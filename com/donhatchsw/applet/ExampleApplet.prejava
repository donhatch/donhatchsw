/**
* Example applet to use as a starting point.
* I usually copy this file and make changes.
*
* XXX haha, getting carried away with the debugClearOnResize thing right now... hope I succeed
*/

package com.donhatchsw.applet; // APP-SPECIFIC: remove or change this as desired



#include "macros.h"

public class ExampleApplet
    extends java.applet.Applet
{
    //
    // Note, all public fields are settable as params
    // from the web page (e.g. <PARAM NAME='eventVerbose' VALUE='4'>)
    // or command line (e.g. "eventVerbose=4")
    //
    public int eventVerbose = 0;
            // eventVerbose values:
            //     0: nothing
            //     1: applet ctor/create/destroy/start/stop/resize stuff
            //     2: and key and mouse press/release/click   XXX should separate into a simple key one with minimum of fluff, I think
            //     3: and mouse drags
            //     4: and update/paint
            //     5: and enter/exit (can be obnoxious)
            //     6: and mouse motion (can be obnoxious)
            //     7: and stack trace of every paint
    public boolean debugClearOnResize = false;
    public boolean doDoubleBuffer = true;


    private boolean controlIsDown = false;
    private boolean button1IsDown = false;
    private boolean button2IsDown = false;
    private boolean button3IsDown = false;


    // APP-SPECIFIC: begin
    /**
     * The Model contains all the objects in the simulation--
     * image, velocity field, pressure field.
     */
    private class Model
    {
        private int width = 256;
        private int height = 256;
        private int depth = 1;
        private double v[][][][] = new double[depth][height][width][3]; // velocity field
        private double p[][][] = new double[depth][height][width]; // pressure field

    } // private class Model

    /**
     * Viewing parameters.
     */
    private class View
    {
        private double velocityArrowsScale = 1.;
    } // View

    /**
     * Stuff that can be done to a model.
     * Static methods for now, but may make it an object
     * if there is state that needs to persist.
     */
    private class Simulation
    {
    } // Simulation
    // APP-SPECIFIC: end


    // XXX debugging... trying to catch the bad clear that happens during resize!
    public void setBounds(int a, int b, int c, int d)
    {
        if (debugClearOnResize)
        {
            System.out.println("====================================");
            System.out.println("in ExampleApplet.setBounds("+a+","+b+","+c+","+d+"");
            //try {Thread.sleep(250);} catch (InterruptedException e) {}
            PRINT(getPeer());
            System.out.println("    calling super's");
        }
        // this is IT baby! right HERE is the evil call
        // that clears when resizing!!!
        // but how can I make it not do that,
        // but still do something needed???
        super.setBounds(a,b,c,d);
        if (debugClearOnResize)
        {
            System.out.println("    returned from super's");
            //try {Thread.sleep(250);} catch (InterruptedException e) {}
            System.out.println("out ExampleApplet.setBounds");
            System.out.println("====================================");
        }
    }
    public void update(java.awt.Graphics g)
    {
        if (debugClearOnResize)
        {
            System.out.println("====================================");
            System.out.println("in ExampleApplet.update");
            //try {Thread.sleep(250);} catch (InterruptedException e) {}
            System.out.println("    calling super's");
        }
        super.update(g);
        if (debugClearOnResize)
        {
            System.out.println("    returned from super's");
            //try {Thread.sleep(250);} catch (InterruptedException e) {}
            System.out.println("out ExampleApplet.update");
            System.out.println("====================================");
        }
    }
    public void paint(java.awt.Graphics g)
    {
setBackground(java.awt.Color.red); // XXX debugging who's clearing... applet is red
((java.awt.Graphics2D)g).setBackground(java.awt.Color.red); // XXX debugging who's clearing
((java.awt.Graphics2D)g).setColor(java.awt.Color.red); // XXX debugging who's clearing
        if (debugClearOnResize)
        {
            System.out.println("        ====================================");
            System.out.println("        in ExampleApplet.paint");
            //try {Thread.sleep(250);} catch (InterruptedException e) {}
            System.out.println("            calling super's");
        }
        super.paint(g);
        if (debugClearOnResize)
        {
            System.out.println("            returned from super's");
            //try {Thread.sleep(250);} catch (InterruptedException e) {}
            System.out.println("        out ExampleApplet.paint");
            System.out.println("        ====================================");
        }
    }



    /**
     * Constructor
     */
    public ExampleApplet()
    {
        if (eventVerbose >= 1) System.out.println("in ctor"); // note this is before eventVerbose is fetched

        final java.awt.Component canvas = new DoubleBufferedCanvas() {
            //
            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            // The state of things seems to be:
            //      - Buttons and TextFields are apparently "focus traversable"
            //        by default.  Canvases and Applets aren't,
            //        implying (not obvious) that you need to click to type
            //        when the app starts,
            //        which is almost never the desired behavior.
            //        You can change this by overriding isFocusTraversable(),
            //        which we do below.
            //      - Other approaches using requestFocus():
            //        A Canvas calling requestFocus() doesn't seem to do
            //        anything.  An Applet calling requestFocus() doesn't
            //        do anything during init(), but I think it works
            //        if you put it in the mouseEntered handler or something,
            //        though this can lead to various unpredictabilities.
            //        The isFocusTraversable() fix is better in any case.
            //
            public boolean isFocusTraversable()
            {
                return true;
            }

            public void validate()
            {
                // XXX tracking down that bogus clear!!!
                // the clear happened BEFORE I got here
                System.out.println("HEY!!!!!!!!!!!!!!!!!!!!!");
                    //try {Thread.sleep(250);} catch (InterruptedException e) {}
                System.out.println("HO!!!!!!!!!!!!!!!!!!!!!");
            }

//int foo = 0; // XXX
            // override to not clear...
            public void update(java.awt.Graphics g)
            {
//ExampleApplet.this.setBounds(5 + (foo++%5),28,100,100); // XXX total hack... and THIS is where the bogus clear is.  how can I do it without the clear?
                if (eventVerbose >= 4 || debugClearOnResize) System.out.println("in update");
                paint(g);
                if (eventVerbose >= 4 || debugClearOnResize) System.out.println("out update");
            }
            // PAINT
            java.awt.Dimension requestedSize = null;
            public void paint(java.awt.Graphics frontBufferGraphics)
            {
                // Increase to the max of parent size and our size...
                // so we never decrease.  This is a hack to minimize flashing.
                // We'll flash at the beginning as they increase,
                // but once we get big we'll never resize again.
                // Increase to parent size... but never decrease.
                // This minimizes flashing.
                {
                    java.awt.Dimension parentSize = getParent().size();
                    java.awt.Dimension mySize = size();
                    java.awt.Dimension requestedSize = new java.awt.Dimension(
                        MAX(mySize.width, parentSize.width-2*0),
                        MAX(mySize.height, parentSize.height-2*0));
                    //setSize(requestedSize);
                    setLocation(0,0); // hmm, I don't know about this... parent might not like it
                }
setBackground(java.awt.Color.yellow); // XXX debugging who's clearing... canvas is yellow
((java.awt.Graphics2D)frontBufferGraphics).setBackground(java.awt.Color.yellow); // XXX debugging who's clearing
((java.awt.Graphics2D)frontBufferGraphics).setColor(java.awt.Color.yellow); // XXX debugging who's clearing
PRINT(frontBufferGraphics);
                if (eventVerbose >= 4 || debugClearOnResize) System.out.println("    in paint");
                if (eventVerbose >= 7 || debugClearOnResize)
                {
                    // Print current stack trace.
                    // Would be nice to try to make it not clear to background
                    // color during resize, but it doesn't look like we
                    // have control over that like we do when called from inside update.
                    // XXX Note if we make an app based on a JPanel, and use paintComponent(),
                    // it doesn't have this problem--
                    // should trace one of those and see what it's doing and if I can emulate it.
                    // The trace when being resized is:
                    /*
                        at ExampleApplet$1.paint(ExampleApplet.java:136)
                        at sun.awt.RepaintArea.paint(RepaintArea.java:177)
                        at sun.awt.motif.MComponentPeer.handleEvent(MComponentPeer.java:405)
                        at java.awt.Component.dispatchEventImpl(Component.java:3678)
                        at java.awt.Component.dispatchEvent(Component.java:3477)
                        at java.awt.EventQueue.dispatchEvent(EventQueue.java:456)
                        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:201)
                        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:151)
                        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:145)
                        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:137)
                        at java.awt.EventDispatchThread.run(EventDispatchThread.java:100)
                    */
                    // The normal trace is:
                    /*
                        Stack trace:java.lang.Throwable
                        at com.donhatchsw.applet.ExampleApplet$1.paint(com/donhatchsw/applet/ExampleApplet.prejava:139)
                        at com.donhatchsw.applet.ExampleApplet$1.update(com/donhatchsw/applet/ExampleApplet.prejava:108)
                        at sun.awt.RepaintArea.paint(RepaintArea.java:169)
                        at sun.awt.motif.MComponentPeer.handleEvent(MComponentPeer.java:405)
                        at java.awt.Component.dispatchEventImpl(Component.java:3678)
                        at java.awt.Component.dispatchEvent(Component.java:3477)
                        at java.awt.EventQueue.dispatchEvent(EventQueue.java:456)
                        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:201)
                        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:151)
                        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:145)
                        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:137)
                        at java.awt.EventDispatchThread.run(EventDispatchThread.java:100)
                    */
                    // So sun.awt.RepaintArea.paint is doing a good thing in one case
                    // (calling update) but doing a bad thing in the other
                    // (calling paint directly).  Should disassemble that
                    // and see what the heck it's thinking.
                    // Oh hmm, it's only in 1.4 that paint sometimes calls update and sometimes paint,
                    // and there's no update method.
                    // In 1.3 there's an update method.
                    // Okay let's get the 1.3 traces...
                    //  The good one:
                    /*
                        at com.donhatchsw.applet.ExampleApplet$1.paint(com/donhatchsw/applet/ExampleApplet.prejava:139)
                        at com.donhatchsw.applet.ExampleApplet$1.update(com/donhatchsw/applet/ExampleApplet.prejava:108)
                        at sun.awt.RepaintArea.update(RepaintArea.java:332)
                        at sun.awt.motif.MComponentPeer.handleEvent(MComponentPeer.java:348)
                        at java.awt.Component.dispatchEventImpl(Component.java:2658)
                        at java.awt.Component.dispatchEvent(Component.java:2492)
                        at java.awt.EventQueue.dispatchEvent(EventQueue.java:334)
                        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:126)
                        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:93)
                        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:88)
                        at java.awt.EventDispatchThread.run(EventDispatchThread.java:80)
                    */
                    // The bad one:
                    /*
                        at com.donhatchsw.applet.ExampleApplet$1.paint(com/donhatchsw/applet/ExampleApplet.prejava:139)
                        at sun.awt.RepaintArea.paint(RepaintArea.java:293)
                        at sun.awt.motif.MComponentPeer.handleEvent(MComponentPeer.java:344)
                        at java.awt.Component.dispatchEventImpl(Component.java:2658)
                        at java.awt.Component.dispatchEvent(Component.java:2492)
                        at java.awt.EventQueue.dispatchEvent(EventQueue.java:334)
                        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:126)
                        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:93)
                        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:88)
                        at java.awt.EventDispatchThread.run(EventDispatchThread.java:80)
                    */

                    // WAITAMINUTE... some parent component's update
                    // must have got called?  SOMEONE did that clearRect...
                    // who was it???


                    //
                    /*
                        In the JPanel based app, in 1.4 the resize one is:
        Stack trace:java.lang.Throwable
        at com.donhatchsw.util.Arrows$MyDemoPanel$MyCanvas.paintComponent(com/donhatchsw/util/Arrows.prejava:905)
        at javax.swing.JComponent.paint(JComponent.java:1003)
        at javax.swing.JComponent.paintChildren(JComponent.java:840)
        at javax.swing.JComponent.paint(JComponent.java:1012)
        at javax.swing.JComponent.paintChildren(JComponent.java:840)
        at javax.swing.JComponent.paint(JComponent.java:1012)
        at javax.swing.JLayeredPane.paint(JLayeredPane.java:559)
        at javax.swing.JComponent.paintChildren(JComponent.java:840)
        at javax.swing.JComponent.paint(JComponent.java:1012)
        at javax.swing.JComponent.paintWithOffscreenBuffer(JComponent.java:4923)
        at javax.swing.JComponent.paintDoubleBuffered(JComponent.java:4876)
        at javax.swing.JComponent._paintImmediately(JComponent.java:4819)
        at javax.swing.JComponent.paintImmediately(JComponent.java:4626)
        at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:451)
        at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:114)
        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:234)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
        Stack trace:java.lang.Throwable
        at com.donhatchsw.util.Arrows$MyDemoPanel$MyCanvas.paintComponent(com/donhatchsw/util/Arrows.prejava:905)
        at javax.swing.JComponent.paint(JComponent.java:1003)
        at javax.swing.JComponent.paintWithOffscreenBuffer(JComponent.java:4923)
        at javax.swing.JComponent.paintDoubleBuffered(JComponent.java:4876)
        at javax.swing.JComponent._paintImmediately(JComponent.java:4819)
        at javax.swing.JComponent.paintImmediately(JComponent.java:4626)
        at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:451)
        at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:114)
        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:234)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)

and a normal one is:
        Stack trace:java.lang.Throwable
        at com.donhatchsw.util.Arrows$MyDemoPanel$MyCanvas.paintComponent(com/donhatchsw/util/Arrows.prejava:905)
        at javax.swing.JComponent.paint(JComponent.java:1003)
        at javax.swing.JComponent.paintWithOffscreenBuffer(JComponent.java:4923)
        at javax.swing.JComponent.paintDoubleBuffered(JComponent.java:4876)
        at javax.swing.JComponent._paintImmediately(JComponent.java:4819)
        at javax.swing.JComponent.paintImmediately(JComponent.java:4626)
        at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:451)
        at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:114)
        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:234)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
        Stack trace:java.lang.Throwable
        at com.donhatchsw.util.Arrows$MyDemoPanel$MyCanvas.paintComponent(com/donhatchsw/util/Arrows.prejava:905)
        at javax.swing.JComponent.paint(JComponent.java:1003)
        at javax.swing.JComponent.paintWithOffscreenBuffer(JComponent.java:4923)
        at javax.swing.JComponent.paintDoubleBuffered(JComponent.java:4876)
        at javax.swing.JComponent._paintImmediately(JComponent.java:4819)
        at javax.swing.JComponent.paintImmediately(JComponent.java:4626)
        at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:451)
        at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:114)
        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:461)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:234)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:163)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:157)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:149)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:110)
*/
                    System.out.print("        Stack trace:");
                    new Throwable().printStackTrace();
                }


                java.awt.Dimension size = getSize();
                double centerX = size.width*.5;
                double centerY = size.height*.5;

                java.awt.Graphics g = frontBufferGraphics;
                java.awt.Image backBuffer = null;
                if (doDoubleBuffer)
                {
                    // from DoubleBufferedCanvas base class...
                    backBuffer = getBackBufferCache(eventVerbose);
                    g = backBuffer.getGraphics();
                }

                //
                // Clear to white...
                //
                g.setColor(java.awt.Color.white);
                BREAKPOINT();
                g.fillRect(0, 0, size.width, size.height);
                BREAKPOINT();

                // APP-SPECIFIC PAINT STUFF HERE
                {
                    // draw an X
                    g.setColor(java.awt.Color.blue);
                    g.drawLine(0,0, size.width, size.height);
                    g.drawLine(0,size.height, size.width, 0);
                }

                if (backBuffer != null)
                {
                    // XXX hmm, not sure about what to do when
                    // XXX the image is not ready... it always
                    // XXX seems to be ready for me,
                    // XXX so I don't know how to test it

                    //frontBufferGraphics.drawImage(backBuffer, 0, 0, this);
                    int mag = 1; // can mess around with different values
                    int x0 = -size.width*(mag-1)/2;
                    int y0 = -size.height*(mag-1)/2;
                    frontBufferGraphics.drawImage(backBuffer,
                                                  x0,
                                                  y0,
                                                  mag*size.width,
                                                  mag*size.height,
                                                  this);
                    if (false) // XXX argh, causes flicker when we do this in the front buffer... we'd need another mag buffer to do this right.
                    if (mag > 1)
                    {
                        frontBufferGraphics.setColor(java.awt.Color.black);
                        FORI (y, size.height+1)
                            frontBufferGraphics.drawLine(0,         y0+mag*y,
                                                         size.width,y0+mag*y);
                        FORI (x, size.width+1)
                            frontBufferGraphics.drawLine(x0+mag*x, 0,
                                                         x0+mag*x, size.height);
                    }
                }

                if (eventVerbose >= 4 || debugClearOnResize)
                {
                    System.out.println("    out paint");
                    //System.out.println();
                    //System.out.println();
                }

            } // paint
        }; // canvas

        this.setLayout(new java.awt.GridBagLayout());

        //
        // THE SECRET to making it not flash on resize--
        // put a ScrollPane inside the Applet,
        // and put everything else under the ScrollPane,
        // This is because components
        // whose peers are sun.awt.motif.MComponentPeer
        // have bad behavior when resized...
        // sun.awt.motif.MComponentPeer.setBounds calls the native pReshape
        // and it all sucks... and it has special voodoo for ScrollPanes...
        // and apparently the scroll pane will increase but never decrease
        // the size of its child-- so we'll get flashing at the beginning
        // but only a bounded amount.
        //

        java.awt.GridBagConstraints fitChildToParent = new java.awt.GridBagConstraints() {
            {
                fill = java.awt.GridBagConstraints.BOTH;
                weightx = 1.;
                weighty = 1.;
            }
        };

        java.awt.Container parent = this;
        if (true)
        {
            java.awt.ScrollPane scrollpane = new java.awt.ScrollPane(java.awt.ScrollPane.SCROLLBARS_NEVER);

            // Make the scrollpane always stretch to the size of the parent
            if (true)
            {
                // Print the defaults
                java.awt.GridBagConstraints constraints = new java.awt.GridBagConstraints();
                PRINT(constraints.gridx);
                PRINT(constraints.gridy);
                PRINT(constraints.gridwidth);
                PRINT(constraints.gridheight);
                PRINT(constraints.weightx);
                PRINT(constraints.weighty);
                PRINT(constraints.anchor);
                PRINT(constraints.fill);
                PRINT(constraints.insets);
                PRINT(constraints.ipadx);
                PRINT(constraints.ipady);
            }

            parent.add(scrollpane, fitChildToParent);
            parent = scrollpane;

            if (true)
            {
                java.awt.Container child = new java.awt.Container();
                child.setLayout(new java.awt.GridBagLayout());
                parent.add(child, fitChildToParent);
                parent = child;
            }
        }

        parent.add(canvas, fitChildToParent);

        makeAndAddTheEventListeners(canvas);

        if (eventVerbose >= 1) System.out.println("out ctor");
    } // ExampleApplet ctor


    //
    // Implementing Applet methods...
    //

        // Constructor-type stuff.
        public void init()
        {
            // Bootstrap eventVerbose-- we need it before
            // we call getParametersIntoPublicFields.
            String paramValueString = getParameter("eventVerbose");
            if (paramValueString != null)
                eventVerbose = AppletUtils.parseInt(paramValueString);

            if (eventVerbose >= 1) System.out.println("in init");
            AppletUtils.getParametersIntoPublicFields(this, eventVerbose);
            if (eventVerbose >= 1) System.out.println("out init");
        }

        // In mozilla, when I go to another web page,
        // I get stop() and destroy().
        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }


    private interface MouseAndMotionListener
        extends java.awt.event.MouseListener,
                java.awt.event.MouseMotionListener
    {
        // so there!
    }

    private void makeAndAddTheEventListeners(java.awt.Component canvas)
    {
        MouseAndMotionListener mouseAndMotionListener = new MouseAndMotionListener() {
            public void mousePressed(java.awt.event.MouseEvent me)
            {
                if (eventVerbose >= 2) System.out.println("in mousePressed (at "+me.getPoint().x+","+me.getPoint().y+")");
                if (eventVerbose >= 2) System.out.println("out mousePressed (at "+me.getPoint().x+","+me.getPoint().y+")");
            }
            public void mouseReleased(java.awt.event.MouseEvent me)
            {
                if (eventVerbose >= 2) System.out.println("in mouseReleased (at "+me.getPoint().x+","+me.getPoint().y+")");
                if (eventVerbose >= 2) System.out.println("out mouseReleased (at "+me.getPoint().x+","+me.getPoint().y+")");
            }
            // NOTE various vms have bugs that make mouseClicked usually
            // not a very good thing to use.
            public void mouseClicked(java.awt.event.MouseEvent me)
            {
                if (eventVerbose >= 2) System.out.println("in mouseClicked (at "+me.getPoint().x+","+me.getPoint().y+")");
                if (eventVerbose >= 2) System.out.println("out mouseClicked (at "+me.getPoint().x+","+me.getPoint().y+")");
            }
            public void mouseDragged(java.awt.event.MouseEvent me)
            {
                if (eventVerbose >= 3) System.out.println("    in mouseDragged (to "+me.getPoint().x+","+me.getPoint().y+")");
                if (eventVerbose >= 3) System.out.println("    out mouseDragged (to "+me.getPoint().x+","+me.getPoint().y+")");
            }
            public void mouseEntered(java.awt.event.MouseEvent me)
            {
                if (eventVerbose >= 5) System.out.println("in mouseEntered (at "+me.getPoint().x+","+me.getPoint().y+")");
                if (eventVerbose >= 5) System.out.println("out mouseEntered (at "+me.getPoint().x+","+me.getPoint().y+")");
            }
            public void mouseExited(java.awt.event.MouseEvent me)
            {
                if (eventVerbose >= 5) System.out.println("in mouseExited (at "+me.getPoint().x+","+me.getPoint().y+")");
                if (eventVerbose >= 5) System.out.println("out mouseExited (at "+me.getPoint().x+","+me.getPoint().y+")");
            }
            public void mouseMoved(java.awt.event.MouseEvent me)
            {
                if (eventVerbose >= 6) System.out.println("    in mouseMoved (to "+me.getPoint().x+","+me.getPoint().y+")");
                if (eventVerbose >= 6) System.out.println("    out mouseMoved (to "+me.getPoint().x+","+me.getPoint().y+")");
            }
        };
        canvas.addMouseListener(mouseAndMotionListener);
        canvas.addMouseMotionListener(mouseAndMotionListener);
        canvas.addKeyListener(new java.awt.event.KeyListener() {
                public void keyPressed(java.awt.event.KeyEvent e)
                {
                    if (eventVerbose >= 2) System.out.println("in keyPressed: "+e);
                    if (eventVerbose >= 2) PRINT((int)e.getKeyChar()+0); // XXX +0 necessary, don't know why
                    if (eventVerbose >= 2) PRINT(e.getModifiers());
                    if ((e.getModifiers() & java.awt.event.InputEvent.CTRL_MASK) != 0)
                        controlIsDown = true;
                    else
                        controlIsDown = false;

                    int keyCode = e.getKeyCode();
                    switch (keyCode)
                    {
                        case java.awt.event.KeyEvent.VK_LEFT:
                            break;
                        case java.awt.event.KeyEvent.VK_RIGHT:
                            break;
                        case java.awt.event.KeyEvent.VK_UP:
                            break;
                        case java.awt.event.KeyEvent.VK_DOWN:
                            break;
                        case java.awt.event.KeyEvent.VK_CONTROL:
                            break;
                        default:
                            break;
                    }
                    if (eventVerbose >= 2) PRINT(e.isControlDown());
                    if (eventVerbose >= 2) PRINT(e.isShiftDown());
                    if (eventVerbose >= 2) System.out.println("out keyPressed: "+e);
                }
                public void keyTyped(java.awt.event.KeyEvent e)
                {
                    if (eventVerbose >= 2) System.out.println("in keyTyped: "+e);
                    if ((e.getModifiers() & java.awt.event.InputEvent.CTRL_MASK) != 0)
                        controlIsDown = true;
                    // but absence of mask is not definitive in keyTyped (java 1.1 netscape)
                    char c = e.getKeyChar();
                    switch (c)
                    {
                        // XXX clean this up
                        case 'V': // cycle event verbosity-- upper-case to minimize possibility of hitting it by accident thus causing subsequent perfomance degradation with no visible reason if Java Console is not visible
                            System.out.print("eventVerbose "+eventVerbose);
                            eventVerbose = (eventVerbose+1) % 8;
                            System.out.println(" -> "+eventVerbose);
                            break;

    #define TOGGLE(var) {var ^= true; System.out.println(#var + " -> " + var); }

                        case ' ': // just repaint
                            e.getComponent().repaint();
                            break;
                        case 'J': // toggle doRandomJitter
                            //TOGGLE(doRandomJitter);
                            e.getComponent().repaint();
                            break;
                        case 'z': case 'Z':
                            break;
#define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a'+1)
                        case CTRL('r'): // reset but same size
                            //reset(false);
                            e.getComponent().repaint();
                            break;
                        default:
                            System.out.println("Unknown key '"+c+"' typed"); // XXX escapify
                            break;
                    } // switch (c)
                if (eventVerbose >= 2) System.out.println("out keyTyped: "+e);
            } // keyTyped

            public void keyReleased(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 2) System.out.println("in keyReleased: "+e);
                switch (e.getKeyCode())
                {
                    case java.awt.event.KeyEvent.VK_CONTROL:
                        controlIsDown = false;
                        return;
                }

                // do this after the switch, so we will properly
                // set it to true in the (unlikely) case
                // that both ctrl keys were down and one was released
                if ((e.getModifiers() & java.awt.event.InputEvent.CTRL_MASK) != 0)
                    controlIsDown = true;
                else
                    controlIsDown = false;

                if (eventVerbose >= 2) System.out.println("out keyReleased: "+e);
            } // keyReleased
        }); //
    } // makeAndAddTheEventListeners

    public static void main(final String[] args)
    {
        System.out.println("in main");

        final ExampleApplet applet = new ExampleApplet();

        final javax.swing.JFrame frame = new javax.swing.JFrame("Example Applet") {
        //final java.awt.Frame frame = new java.awt.Frame("Example Applet") {
            public boolean handleEvent(java.awt.Event event)
            {
                switch(event.id)
                {
                    case java.awt.Event.WINDOW_DESTROY:
                        System.out.println("bye!");
                        // Empirically, either of the following
                        // cause the app to exit-- do both to be safe!
                        // (XXX I've heard rumors that just doing dispose()
                        //  messes up the debugger)
                        // (XXX but doing exit is evil)
                        dispose(); // hide() doesn't delete the windows
                        System.exit(0);
                        return true;
                }
                return super.handleEvent(event);
            }

            // XXX debugging... trying to catch the bad clear that happens during resize!
            // XXX apparently this does call clearRect... but it doesn't seem to be the problem;
            // XXX the problem already happened.
            public void update(java.awt.Graphics g)
            {
                if (true)
                {
                    if (applet.debugClearOnResize)
                    {
                        System.out.println("====================================");
                        System.out.println("in frame.update");
                        //try {Thread.sleep(250);} catch (InterruptedException e) {}
                        System.out.println("    calling super's");
                    }
                    super.update(g);
                    if (applet.debugClearOnResize)
                    {
                        System.out.println("    returned from super's");
                        //try {Thread.sleep(250);} catch (InterruptedException e) {}
                        System.out.println("out frame.update");
                        System.out.println("====================================");
                    }
                }
                else
                    paint(g);
            }

            // can't override dispatchEvent because it's final
            public void dispatchEventImpl(java.awt.AWTEvent g)
            {
                System.out.println("        in frame.dispatchEventImpl");
                System.out.println("        out frame.dispatchEventImpl");
            }

            public void paint(java.awt.Graphics g)
            {
setBackground(java.awt.Color.green); // XXX debugging who's clearing
((java.awt.Graphics2D)g).setBackground(java.awt.Color.green); // XXX debugging who's clearing
((java.awt.Graphics2D)g).setColor(java.awt.Color.green); // XXX debugging who's clearing
                if (applet.debugClearOnResize)
                {
                    BREAKPOINT(); // for debugger
                    System.out.println("        ====================================");
                    System.out.println("        in frame.paint");
                    {
                        // Right HERE is right after the bad clear happened.
                        // It's got to be from inside someone's Component.update()!!!!! whose???
                        System.out.print("        Stack trace:");
                        new Throwable().printStackTrace();
                        // Walk up the component heirarchy...
                        PRINT(this);
                        PRINT(getParent()); // damn! it's null.
                        PRINT(getPeer());
                        /*
        at com.donhatchsw.applet.ExampleApplet$5.paint(com/donhatchsw/applet/ExampleApplet.prejava:634)
        at sun.awt.RepaintArea.paint(RepaintArea.java:293)
        at sun.awt.motif.MComponentPeer.handleEvent(MComponentPeer.java:344)
        at java.awt.Component.dispatchEventImpl(Component.java:2658)
        at java.awt.Container.dispatchEventImpl(Container.java:1208)
        at java.awt.Window.dispatchEventImpl(Window.java:930)
        at java.awt.Component.dispatchEvent(Component.java:2492)    // IS IT AROUND HERE?
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:334)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:126)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:93)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:88)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:80)
    this = com.donhatchsw.applet.ExampleApplet$5[frame0,399,20,803x805,layout=java.awt.BorderLayout,resizable,title=Example Applet]
    getParent() = null
    getPeer() = sun.awt.motif.MFramePeer[com.donhatchsw.applet.ExampleApplet$5[frame0,399,20,803x805,layout=java.awt.BorderLayout,resizable,title=Example Applet]]
                        */
                        // Bleah!  There is a bloody Window
                        // somewhere in the heirarchy above the peer... how to get to it?
                        // Trying jdb...
                        // My graphics is a: sun.awt.motif.X11Graphics
                        // So:
                        /*
                            stop in sun.awt.motif.X11Graphics.clearRect
                            stop in sun.awt.motif.X11Graphics.fillRect
                        */
                        // That doesn't seem to get it...
                        // There is a clearRect that gets called, from frame.update,
                        // but it's after all the damage has been done.
                        // Oh wait there's also a sun.java2d.SunGraphics2D ...
                        /*
                            stop in sun.java2d.SunGraphics2D.clearRect
                            stop in sun.java2d.SunGraphics2D.fillRect

                        */
                        // Bleah, no, the damage has already been done
                        // by the time we get to those too.
                        // (there are two inside createImage
                        // and one inside my canvas paint).
                        // Okay I need to stop it exactly there!
                        /*
                            stop in com.donhatchsw.applet.ExampleApplet.BREAKPOINT
                            stop in sun.awt.motif.X11Graphics.clearRect

    Let's see, what's the earliest I can catch it?
    Got here:
  [1] java.awt.Component.getBackground (Component.java:1030)
  [2] sun.awt.motif.X11Graphics.<init> (X11Graphics.java:125)
  [3] sun.awt.motif.MComponentPeer.getGraphics (MComponentPeer.java:375)
  [4] java.awt.Component.getGraphics (Component.java:1846)
  [5] sun.awt.RepaintArea.paint (RepaintArea.java:252)
  [6] sun.awt.motif.MComponentPeer.handleEvent (MComponentPeer.java:344)
  [7] java.awt.Component.dispatchEventImpl (Component.java:2658)
  [8] java.awt.Container.dispatchEventImpl (Container.java:1208)
  [9] java.awt.Window.dispatchEventImpl (Window.java:930)
  [10] java.awt.Component.dispatchEvent (Component.java:2492)
  [11] java.awt.EventQueue.dispatchEvent (EventQueue.java:334)
  [12] java.awt.EventDispatchThread.pumpOneEventForHierarchy (EventDispatchThread.java:126)
  [13] java.awt.EventDispatchThread.pumpEventsForHierarchy (EventDispatchThread.java:93)
  [14] java.awt.EventDispatchThread.pumpEvents (EventDispatchThread.java:88)
  [15] java.awt.EventDispatchThread.run (EventDispatchThread.java:80)
    stop in sun.awt.RepaintArea.paint
  That got here:
    [1] sun.awt.RepaintArea.paint (RepaintArea.java:252)
    [2] sun.awt.motif.MComponentPeer.handleEvent (MComponentPeer.java:344)
    [3] java.awt.Component.dispatchEventImpl (Component.java:2658)
    [4] java.awt.Container.dispatchEventImpl (Container.java:1208)
    [5] java.awt.Window.dispatchEventImpl (Window.java:930)
    [6] java.awt.Component.dispatchEvent (Component.java:2492)
    [7] java.awt.EventQueue.dispatchEvent (EventQueue.java:334)
    [8] java.awt.EventDispatchThread.pumpOneEventForHierarchy (EventDispatchThread.java:126)
    [9] java.awt.EventDispatchThread.pumpEventsForHierarchy (EventDispatchThread.java:93)
    [10] java.awt.EventDispatchThread.pumpEvents (EventDispatchThread.java:88)
    [11] java.awt.EventDispatchThread.run (EventDispatchThread.java:80)

    stop in sun.awt.motif.MComponentPeer.handleEvent
 That gives too much.
 The stack trace of the call right before,
 and of right after, it happens, is here:
  [1] sun.awt.motif.MComponentPeer.handleEvent (MComponentPeer.java:339)
  [2] java.awt.Component.dispatchEventImpl (Component.java:2658)
  [3] java.awt.Container.dispatchEventImpl (Container.java:1208)
  [4] java.awt.Window.dispatchEventImpl (Window.java:930)
  [5] java.awt.Component.dispatchEvent (Component.java:2492)
  [6] java.awt.EventQueue.dispatchEvent (EventQueue.java:334)
  [7] java.awt.EventDispatchThread.pumpOneEventForHierarchy (EventDispatchThread.java:126)
  [8] java.awt.EventDispatchThread.pumpEventsForHierarchy (EventDispatchThread.java:93)
  [9] java.awt.EventDispatchThread.pumpEvents (EventDispatchThread.java:88)
  [10] java.awt.EventDispatchThread.run (EventDispatchThread.java:80)
 So,
        run
        stop in sun.awt.motif.MComponentPeer.handleEvent
    (resize the window manually)
        cont
        cont
        cont
        step up
            Step completed: AWT-EventQueue-0[1] thread="AWT-EventQueue-0", java.awt.Component.dispatchEventImpl(), line=2660, bci=509
        step up
            Step completed: thread="AWT-EventQueue-0", java.awt.Container.dispatchEventImpl(), line=1210, bci=45
        step up
            Step completed: thread="AWT-EventQueue-0", java.awt.Window.dispatchEventImpl(), line=931, bci=109
        step up
            Step completed: thread="AWT-EventQueue-0", java.awt.Component.dispatchEvent(), line=2493, bci=5
        step up
            Step completed: thread="AWT-EventQueue-0", java.awt.EventQueue.dispatchEvent(), line=334, bci=39
        step up
            Step completed: thread="AWT-EventQueue-0", java.awt.EventDispatchThread.pumpOneEventForHierarchy(), line=127, bci=75
        step up
            Step completed: thread="AWT-EventQueue-0", java.awt.EventDispatchThread.pumpEventsForHierarchy(), line=93, bci=15
    (if I step up again it goes too far)
        stop in java.awt.Component.dispatchEvent
        cont
    (if I step up from here it goes too far)
        stop in java.awt.Window.dispatchEventImpl
 Okay, easier session:
        run
        cont
    (make it the desired start size)
        stop in java.awt.Window.dispatchEventImpl
    (resize the window manually)
        cont
        cont
        cont
        cont
    (now if I step up it goes too far...)
    (and even if I stop in java.awt.Container.dispatchEventImpl
    or java.awt.Component.dispatchEventImpl it goes too far)
    Okay, it looks like it must be in this block of code inside java.awt.Window.dispatchEventImpl:
        switch(awt.getID())
            ...
            case 101:
                invalidate();
                validate();
                repaint();
                break;
            ...
        }
        java.awt.Container.dispatchEventImpl(awtevent);

        stop in java.awt.Component.repaint
        cont
    okay it's bad before it hits it!!!
        stop in java.awt.Container.invalidate
        stop in java.awt.Container.validate
        stop in java.awt.Component.invalidate
        stop in java.awt.Component.validate


        it got to:
            Container.invalidate
               which called Component.invalidate
            Container.validate
                which calls a child's invalidate

    so the last thing I got that I couldn't step out of (or even to the next Container.invalidate)
    is a Container.validate.

    Okay another session:
        run
        cont
    (make it the desired start size)
        stop in java.awt.Container.validate
    (resize the window manually)
    (now it hits the breakpoint and can't step up... it's somewhere inside!)
    (in fact it's inside an inner one...)
        stop in java.awt.Container.validateTree
    (yep, it's inside there)
    okay it's in a trace that looks like this:
        java.awt.Container.validateTree
            java.awt.Container.validateTree
                SOMETHING.validate or SOMETHING.doLayout?
                (and it gets called before my canvas validate I think!)
    it's strange though... if I break there and step up, it says
    it hits another BEFORE it turns yellow...
    but if I break there and cont, it turns yellow before it hits there.
    That is REALLY strange.

        stop in java.awt.Container.layout
    all right, it's inside layout!!!!!
    which means it's in some frickin layoutmanager's layoutContainer()!
    okay I need to figure out how to tell jdb to step into something.
    "step into" sure is not working.  this sucks.

    Okay another session:
        run
        cont
    (make it the desired start size)
        stop in java.awt.Container.layout

    Okay I don't know what kind of layout is the offender,
    so I'll just have to stop in all known ones:

    stop in java.awt.GridLayout.layoutContainer
    stop in java.awt.FlowLayout.layoutContainer
    stop in javax.swing.ViewportLayout.layoutContainer
    stop in javax.swing.ScrollPaneLayout.layoutContainer
    stop in javax.swing.plaf.basic.BasicOptionPaneUI.ButtonAreaLayout.layoutContainer
    stop in javax.swing.plaf.basic.BasicTabbedPaneUI.TabbedPaneLayout.layoutContainer
    stop in javax.swing.plaf.basic.BasicInternalFrameTitlePane.TitlePaneLayout.layoutContainer
    stop in javax.swing.plaf.basic.BasicScrollBarUI.layoutContainer
    stop in javax.swing.plaf.basic.BasicInternalFrameUI.InternalFrameLayout.layoutContainer
    stop in javax.swing.plaf.basic.BasicComboBoxUI.ComboBoxLayoutManager.layoutContainer
    stop in javax.swing.plaf.basic.BasicSplitPaneDivider.DividerLayout.layoutContainer

    stop in java.awt.CardLayout.layoutContainer
    stop in java.awt.BorderLayout.layoutContainer
    stop in java.awt.GridBagLayout.layoutContainer
    stop in javax.swing.BoxLayout.layoutContainer
    stop in javax.swing.OverlayLayout.layoutContainer
    stop in javax.swing.JRootPane.RootLayout.layoutContainer
    stop in javax.swing.plaf.basic.BasicSplitPaneUI.BasicHorizontalLayoutManager.layoutContainer

`   GOT IT!!!!! It's inside a friggin BorderLayout!!!!!!
    This breakpoint got it:
        stop in java.awt.BorderLayout.layoutContainer
    oh shoot maybe didn't get it after all.
    Okay this is not making sense...
    If I stop in the borderLayout and then cont,
    it goes yellow before hitting another layoutContainer.
    But if I stop there and step up, it steps up into the parent
    which is Container.layout...  oh wait it went yellow before
    it got there.
    when contracting, step up makes it turn yellow.
    when expanding, it does NOT!
    No, it's just random :-(
    So it definitely does it from inside the BorderLayout.layoutContainer
    SOMETIMES.
    Okay, looking at that source, it looks like
    it's doing its stuff inside:
        stop in java.awt.Component.setBounds(int,int,int,int)
    ARGH!!!! it's actually inside a container.invalidate()
        that's inside it!!!
        stop in java.awt.Container.invalidate
    except sometimes it's BEFORE that invalidate!
    Oh I bet the reason it's sometimes before and sometimes after
    is that there is no X synchronization.  I wonder if there's
    a way to get it to force to be synced.
    I think the work might be getting done down inside peer.setBounds?  Not sure.
        stop in sun.awt.motif.MComponentPeer.setBounds
    YES that's it...  it only happens sometimes due to sync but it's definitely there.
    And unfortunately since it's a peer I don't think I can override anything...
    BAD BAD BAD MComponentPeer!
    And I think it's calling the native pReshape... and that's all she wrote.
    Okay I need to use something whose peer does NOT derive from MComponentPeer I guess!
    Okay googled MComponentPeer pReshape and people have been here before, in 1998, java 1.1...
        http://archives.java.sun.com/cgi-bin/wa?A2=ind9805&L=java2d-interest&P=2144


   











                        */
                    }

                    //try {Thread.sleep(250);} catch (InterruptedException e) {}
                    System.out.println("            calling super's");
                }
                super.paint(g);
                if (applet.debugClearOnResize)
                {
                    System.out.println("            returned from super's");
                    //try {Thread.sleep(250);} catch (InterruptedException e) {}
                    System.out.println("        out frame.paint");
                    System.out.println("        ====================================");
                }
            }

        };
        // The above handleEvent no longer seems to work as of java 1.5.
        // So we have to use a listener.
        // XXX not sure how far back this exists, may need to use reflection to get it
        {
            frame.addWindowListener(new java.awt.event.WindowAdapter() {
                public void windowClosing(java.awt.event.WindowEvent we) {
                    System.out.println("ciao!");
                    frame.dispose(); // hide() doesn't delete the windows
                    System.exit(0);
                }
            });
        }

        // The following seems to be necessary, or getParameter() will crash, at least in 1.4.
        // And we need it anyway, to send params from the command line.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height) 
             {
                /* should resize frame, but an ExampleApplet never asks to be resized */
                // XXX for now, print this... not sure when this gets called, if ever
                System.out.println("in appletResize(width="+width+", height="+height+")");
             }
             public java.applet.AppletContext getAppletContext() { return null;}
             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 // search backwards from end, so later ones take precedence...
                 for (int i = args.length-1; i >= 0; --i)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             // XXX what's this mean?
             public boolean isActive() { return true; }
        });

        //frame.add(applet); // if it's a Frame
        frame.getContentPane().add(applet); // if it's a JFrame

        applet.init();
        applet.start();

        //frame.pack();
        //frame.move(20,20);
        frame.move(400,20);

        // XXX needs to be a command line param
        //frame.resize(512, 512);
        frame.resize(800, 800);
        //frame.resize(1100, 1100);

        frame.show();

        System.out.println("out main");
    } // main

    // XXX for debugger
    public static void BREAKPOINT()
    {
        System.out.println("BREAKPOINT");
    }

} // ExampleApplet
