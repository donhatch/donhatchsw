/* vim: set filetype=java: */
// Author: Don Hatch (hatch@hadron.org)
#include "macros.h"

package com.donhatchsw.util;

/**
*
* Robust implementations of hyperbolic and inverse hyperbolic trig functions,
* and expm1 and log1p,
* and hypot; all stuff that should be in the standard math library.
* <br>
* For explanations of some of the robust algorithms used, see:
* <a href="http://plunk.org/~hatch/rightway.php">http://plunk.org/~hatch/rightway.php</a>
*/

public class MyMath
{
    private MyMath() {} // non-instantiatable

    /**
    * exp(x)-1, accurate even when x is small.
    */
   /* This was found in:
    * <a href="http://www.cs.berkeley.edu/~wkahan/Math128/Sumnfp.pdf">
    * http://www.cs.berkeley.edu/~wkahan/Math128/Sumnfp.pdf</a>
    * <br>
    * Achieves "nearly full working relative accuracy despite cancellation
    * no matter how tiny x may be".
    */
    public static double
    expm1(double x)
    {
        double u = Math.exp(x);
        if (u == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        if (u == 1.)
            return x;
        if (u-1. == -1.)
            return -1.;
        return (u-1.)*x/Math.log(u);
    }

    /**
    * (exp(x)-1)/x, accurate even when x is small.
    */
    public static double
    expm1_over_x(double x)
    {
        double u = Math.exp(x);
        if (u == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        if (u == 1.)
            return 1.;
        if (u-1. == -1.)
            return -1./x;
        return (u-1.)/Math.log(u);
    }

    /**
    *  log(1+x), accurate even when x is small.
    */
    /*
    *  Found in gsl (gnu scientific library),
    *  distributed under GPL version 2,
    *  but I'm sure it's from Kahan too.
    */
    public static double
    log1p(double x)
    {
        if (x == -1.)
            return Double.NEGATIVE_INFINITY; // grr special case since apparently -inf + nan == nan (I'd prefer -inf)
        if (x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        double u = 1.+x;
        if (u == Double.POSITIVE_INFINITY) // grr, special case for max double
            return Math.log(x);
        return Math.log(u) - ((u-1.)-x)/u; // cancels errors with IEEE arithmetic
    }

    /* 
        XXX the following might be preferable...
 from http://www.hursley.ibm.com/majordomo/JSR-DECIMAL/archives/jsr-decimal.archive.0102/Author/article-6.html:

It is not unheard of for math libraries to deliberately add quantities
that might have very different magnitudes to see what sort of roundoff
occurs.  For example, take Kahan's log1p implementation (log1p is the
result of ln(1 + x) -- because of roundoff in a given precision,
having a separate function is more accurate than the obvious way to
compute this function):

log1p(x) {
  if ( (1.0 + x ) == 1.0)
    return x;
  else
    return log(1.0 +x)*x/(1.0 +x);     XXX that doesn't look right to me... should be dividing by something close to x, not close to 1+x. good thing I'm not using this.
}

The ( (1.0 + x ) == 1.0) expression computes the sum of x and 1.0
simply to see of x gets rounded away.  In this case, computing the
exact value of (1.0 + x) could seriously effect the performance of
this function when it should be very fast.
    XXX and this, from
        http://kristopherjohnson.net/twiki/pub/Main/MathLibFunctions/alg.html

 * Note: Assuming log() return accurate answer, the following
 *       algorithm can be used to compute log1p(x) to within a few ULP:
 *
 *              u = 1+x;
 *              if(u==1.0) return x ; else
 *                         return log(u)*(x/(u-1.0));
 *
 *       See HP-15C Advanced Functions Handbook, p.193.
 *

    XXX whoa, and lots of other good stuff at:
http://kristopherjohnson.net/twiki/pub/Main/MathLibFunctions/alg.html
    */

    /**
    *  log(1+x)/x, accurate even when x is small.
    */
    public static double
    log1p_over_x(double x)
    {
        double u = 1. + x;
        if (u == 1.)
            return 1.;
        return Math.log(u)/(u-1.);
    }


    /** hyperbolic sine function */
    public static double
    sinh(double x)
    {
        // sinh(x) = (e^x - e^-x) / 2
        //         = (e^x - 1)(e^x + 1) / e^x / 2;
        //         = expm1(x) * (expm1(x)+2) / (expm1(x)+1) / 2
        if (x >= 0.)
        {
            double u = expm1(x);
            if (u == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
            return .5 * u / (u+1) * (u+2); // ordered to avoid overflow when big
        }
        else
        {
            double u = expm1(-x);
            if (u == Double.POSITIVE_INFINITY)
                return Double.NEGATIVE_INFINITY;
            return -.5 * u / (u+1) * (u+2); // ordered to avoid overflow when big
        }
    }

    /** hyperbolic cosine function */
    public static double
    cosh(double x)
    {
        // cosh(x) = (e^x + e^-x) / 2
        // I don't think there are any cancellation issues
        // (though probably coshm1, below, is more useful).
        // We start by taking abs(x), just to make sure we get the exact same
        // result for x and -x.
        double e_x = Math.exp(Math.abs(x));
        return (e_x + 1./e_x) * .5;
    }

    /** cosh(x)-1, accurate even when x is small. */
    public static double
    coshm1(double x)
    {
        if (true)
        {
            // cosh(x) - 1 = (e^x + e^-x) / 2 - 1
            //             = (e^x - 2 + e^-x) / 2
            //             = (e^2x - 2*e^x + 1) / e^x / 2
            //             = (e^x - 1)^2 / e^x / 2
            //             = expm1(x)^2 / (expm1(x)+1) / 2
            double u = expm1(Math.abs(x));
            if (u == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
            return .5 * u / (u+1) * u; // ordered to avoid overflow when big
        }
        else
        {
            // Seemingly more straightforward,
            // but actually more expensive since it takes two different expm1's
            // cosh(x) - 1 = (e^x + e^-x) / 2 - 1
            //             = (e^x - 1 + e^-x - 1) / 2
            //             = (e^x - 1)/2 + (e^-x - 1)/2
            //             = (expm1(x) + expm1(-x)) / 2
            return .5 * (expm1(x) + expm1(-x));
        }
        // TODO: 2*sinh(.5*x)^2 ? yeah I think so.  inverse of what we do with acosh1p below.
    }

    /** acosh(1+x), accurate even when x is small. */
    public static double
    acosh1p(double x)
    {
        return 2 * asinh(Math.sqrt(x/2));
    }


    /** hyperbolic tangent function */
    public static double
    tanh(double x)
    {
        // tanh(x) = sinh(x) / cosh(x)
        //         = (e^x - e^-x) / (e^x + e^-x)
        //         = (e^2x - 1) / (e^2x + 1)
        //         = expm1(2*x) / (expm1(2*x) + 2)
        // That works great but overflows prematurely, so do it
        // this way instead:
        // tanh(x) = (e^2x - 1) / (e^2x + 1)
        //         = (e^x - 1)(e^x + 1) / ((e^x - 1)(e^x + 1) + 2)
        //         = expm1(x)(expm1(x)+1) / (expm1(x)(expm1(x)+2) + 2)
        double u = expm1(x);
        return u / (u*(u+2.)+2.) * (u+2.); // ordered to avoid overflow when big
        // XXX oops, that doesn't avoid overflow
        // XXX since u*(u+2) can overflow... can we find another formulation?
    }


    /** inverse hyperboiic sine function */
    public static double
    asinh(double x)
    {
        // asinh(x) = log(x + sqrt(x^2 + 1))
        //          = log1p(x + sqrt(x^2 + 1) - 1)
        //          = log1p(x + (sqrt(x^2+1)-1)*(sqrt(x^2+1)+1)/(sqrt(x^2+1)+1))
        //          = log1p(x + (x^2+1 - 1)/(sqrt(x^2+1)+1))
        //          = log1p(x + x^2 / (sqrt(x^2+1)+1))
        //          = log1p(x * (1 + x / (sqrt(x^2+1)+1) ))
        if (x == Double.NEGATIVE_INFINITY)
            return Double.NEGATIVE_INFINITY;
        if (x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        return log1p(x * (1. + x / (Math.sqrt(x*x+1.)+1.)));
    }

    /** inverse hyperbolic cosine function */
    public static double
    acosh(double x)
    {
        // Only defined for x >= 1.

        // acosh(x) = log(x + sqrt(x^2 - 1))
        // Use the formula given by Kahan in
        // "Branch Cuts for Complex Elementary Functions",
        // as quoted by Cleve Moler in:
        // http://www.mathworks.com/company/newsletter/clevescorner/sum98cleve.shtml
        return 2 * Math.log(Math.sqrt((x+1)*.5) + Math.sqrt((x-1)*.5));
    }

    /** inverse hyperbolic tangent function */
    public static double
    atanh(double x)
    {
        // Only defined for x < 1.

        // atanh(x) = log((1+x)/(1-x))/2
        //          = log((1 - x + 2x) / (1-x)) / 2
        //          = log(1 + 2x/(1-x)) / 2
        //          = log1p(2x/(1-x)) / 2
        return .5 * log1p(2.*x/(1.-x));
    }

    /** 1-cos(x), doesn't lose accuracy for small x */
    public static double
    cosf1(double x)
    {
        double sinHalfX = Math.sin(.5*x);
        return 2.*sinHalfX*sinHalfX;
    }
    /** acos(1-x), doesn't lose accuracy for small x */
    public static double
    acos1m(double x)
    {
        return 2.*Math.asin(Math.sqrt(.5*x));
    }

    /** sin(x)/x, but stable when small */
    public static double
    sin_over_x(double x)
    {
        //
        // It's 1 - x^2/3! + x^4/5! - ...
        // so if |x| is so small that 1-x^2/6 is indistinguishable from 1,
        // then the result will be indistinguishable from 1 too.
        //
        if (1. - x*x*(1/6.) == 1.)
        {
            //System.out.println("Ha! sin(x)/x("+x+") returning 1. instead of "+Math.sin(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return 0.;
        else
            return Math.sin(x)/x;
    }

    /** sinh(x)/x, but stable when small */
    public static double
    sinh_over_x(double x)
    {
        //
        // It's 1 + x^2/3! + x^4/5! + ...
        //
        if (1. + x*x*(1/3.) == 1.)
        {
            //System.out.println("Ha! sinh(x)/x("+x+") returning 1. instead of "+Math.sin(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        else
            return sinh(x)/x;
    }

    /** asin(x)/x, but stable when small */
    public static double
    asin_over_x(double x)
    {
        // 1 + 1/6*x^2 + 3/40*x^4 + 5/112*x^6 + 35/1152*x^8 + 63/2816*x^10 + 231/13312*x^12 + ...
        if (1. + x*x*(1/3.) == 1.)
        {
            //System.out.println("Ha! asin(x)/x("+x+") returning 1. instead of "+MyMath.asin(x)+"/"+x);
            return 1.;
        }
        else
            return Math.asin(x)/x;
    }

    /** asinh(x)/x, but stable when small */
    public static double
    asinh_over_x(double x)
    {
        //
        // 1 - 1/6*x^2 + 3/40*x^4 - 5/112*x^6 + ...
        //
        if (1. - x*x*(1/6.) == 1.)
        {
            //System.out.println("Ha! asinh(x)/x("+x+") returning 1. instead of "+MyMath.asinh(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return 0.;
        else
            return sinh(x)/x;
    }

    /** (cosh(x)-1)/x^2, but stable when small */
    public static double
    cosf1_over_xx(double x)
    {
        double temp = sin_over_x(x*.5);
        return .5 * temp * temp;
    }

    /** (cosh(x)-1)/x^2, but stable when small */
    public static double
    coshm1_over_xx(double x)
    {
        double temp = sinh_over_x(x*.5);
        return .5 * temp * temp;
    }

    /** sqrt(x*x + y*y) but overflow/underflow proof. */
    public static double hypot(double x, double y)
    {
        x = Math.abs(x);
        y = Math.abs(y);
        double min, max;
        if (x < y)
        {
            min = x;
            max = y;
        }
        else
        {
            min = y;
            max = x;
        }
        if (min == 0.)
            return max;
        double min_over_max = min/max;
        return max * Math.sqrt(1. + min_over_max*min_over_max);
    }

    /** Lambert W function, that is, functional inverse of x = f(w) = w e^w.
    * http://blogs.mathworks.com/cleve/2013/09/02/the-lambert-w-function/
    * Copyright 2013 The MathWorks, Inc.
    */
    public static double lambertw(double x,
                                  int branch) // 0 means primary or upper, -1 means lower
    {
        if (Double.isNaN(x))
            return Double.NaN;
        double w;
        if (branch == 0)
            w = 1; // start above -1
        else if (branch == -1)
            w = -2; // start below -1
        else
            throw new IllegalArgumentException("MyMath.lambertw called with illegal branch "+branch);

        if (x <= -1./Math.E)
        {
            if (x < -1./Math.E)
                return Double.NaN; // either branch
            else
                return -1.; // so we get this one exact, on either branch; it would be pretty sloppy otherwise
        }
        if (branch == -1)
        {
            if (x > 0.)
                return Double.NaN;
            else if (x == 0.)
                return Double.NEGATIVE_INFINITY;
            // else strictly negative, so has a solution
        }
        else // if branch == 0
        {
            if (x == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
        }

        double v = Double.POSITIVE_INFINITY * w;
        while (Math.abs((w - v)/w) > 1e-8) // XXX do something different here? not sure
        //while (Math.abs((w - v)/w) > 0.) // XXX do something different here I think
        {
            v = w;
            double e = Math.exp(w);
            double f = w*e - x; // Iterate to make this quantity zero
            w -= f/(e*(w+1.) - (w+2.)*f/(2.*w+2.));
        }
        return w;
    }

    // wolframalpha says the inverse function of e^x/x is -W(-1/x)
    // and empirically, it uses the opposite branch from the one we got.
    // Subtle point: if x is 0 or -0 and branch is -1, we return -infinity.
    // (another possibly valid choice would be -0->-infinity, +0->nan)
    public static double inverse_function_of_exp_over_x(double x,
                                                        int branch)
    {
        // This is a subtle decision, but on branch -1,
        // I think we want to return -infinity if x is either 0 or -0.
        if (x == 0.)
            x = -0.;  // so that we call lambertw on infinity rather than -infinity!

        int otherBranch = -1 - branch;
        return -lambertw(-1./x, -1-branch);
    }

    public static void main(String args[])
    {
        System.out.println("    in MyMath.main");
        // TODO: transplant stuff from SmoothlyVaryingViewingParameter.prejava to here
        System.out.println("    out MyMath.main");
    }
} // class MyMath
