/* vim: set filetype=java: */
// Author: Don Hatch (hatch@hadron.org)
#include "macros.h"

package com.donhatchsw.util;

/**
*
* Robust implementations of hyperbolic and inverse hyperbolic trig functions,
* and expm1 and log1p,
* and hypot; all stuff that should be in the standard math library.
* <br>
* For explanations of some of the robust algorithms used, see:
* <a href="http://plunk.org/~hatch/rightway.php">http://plunk.org/~hatch/rightway.php</a>
*/

public class MyMath
{
    private MyMath() {} // non-instantiatable

    /**
    * exp(x)-1, accurate even when x is small.
    */
   /* This was found in:
    * <a href="http://www.cs.berkeley.edu/~wkahan/Math128/Sumnfp.pdf">
    * http://www.cs.berkeley.edu/~wkahan/Math128/Sumnfp.pdf</a>
    * <br>
    * Achieves "nearly full working relative accuracy despite cancellation
    * no matter how tiny x may be".
    */
    public static double
    expm1(double x)
    {
        double u = Math.exp(x);
        if (u == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        if (u == 1.)
            return x;
        if (u-1. == -1.)
            return -1.;
        return (u-1.)*x/Math.log(u);
    }

    /**
    * (exp(x)-1)/x, accurate even when x is small.
    */
    public static double
    expm1_over_x(double x)
    {
        double u = Math.exp(x);
        if (u == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        if (u == 1.)
            return 1.;
        if (u-1. == -1.)
            return -1./x;
        return (u-1.)/Math.log(u);
    }

    /**
    *  log(1+x), accurate even when x is small.
    */
    /*
    *  Found in gsl (gnu scientific library),
    *  distributed under GPL version 2,
    *  but I'm sure it's from Kahan too.
    */
    public static double
    log1p(double x)
    {
        if (x == -1.)
            return Double.NEGATIVE_INFINITY; // grr special case since apparently -inf + nan == nan (I'd prefer -inf)
        if (x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        double u = 1.+x;
        if (u == Double.POSITIVE_INFINITY) // grr, special case for max double
            return Math.log(x);
        return Math.log(u) - ((u-1.)-x)/u; // cancels errors with IEEE arithmetic
    }

    /* 
        XXX the following might be preferable...
 from http://www.hursley.ibm.com/majordomo/JSR-DECIMAL/archives/jsr-decimal.archive.0102/Author/article-6.html:

It is not unheard of for math libraries to deliberately add quantities
that might have very different magnitudes to see what sort of roundoff
occurs.  For example, take Kahan's log1p implementation (log1p is the
result of ln(1 + x) -- because of roundoff in a given precision,
having a separate function is more accurate than the obvious way to
compute this function):

log1p(x) {
  if ( (1.0 + x ) == 1.0)
    return x;
  else
    return log(1.0 +x)*x/(1.0 +x);     XXX that doesn't look right to me... should be dividing by something close to x, not close to 1+x. good thing I'm not using this.
}

The ( (1.0 + x ) == 1.0) expression computes the sum of x and 1.0
simply to see of x gets rounded away.  In this case, computing the
exact value of (1.0 + x) could seriously effect the performance of
this function when it should be very fast.
    XXX and this, from
        http://kristopherjohnson.net/twiki/pub/Main/MathLibFunctions/alg.html

 * Note: Assuming log() return accurate answer, the following
 *       algorithm can be used to compute log1p(x) to within a few ULP:
 *
 *              u = 1+x;
 *              if(u==1.0) return x ; else
 *                         return log(u)*(x/(u-1.0));
 *
 *       See HP-15C Advanced Functions Handbook, p.193.
 *

    XXX whoa, and lots of other good stuff at:
http://kristopherjohnson.net/twiki/pub/Main/MathLibFunctions/alg.html
    */

    /**
    *  log(1+x)/x, accurate even when x is small.
    */
    public static double
    log1p_over_x(double x)
    {
        double u = 1. + x;
        if (u == 1.)
            return 1.;
        return Math.log(u)/(u-1.);
    }


    /** hyperbolic sine function */
    public static double
    sinh(double x)
    {
        // sinh(x) = (e^x - e^-x) / 2
        //         = (e^x - 1)(e^x + 1) / e^x / 2;
        //         = expm1(x) * (expm1(x)+2) / (expm1(x)+1) / 2
        if (x >= 0.)
        {
            double u = expm1(x);
            if (u == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
            return .5 * u / (u+1) * (u+2); // ordered to avoid overflow when big
        }
        else
        {
            double u = expm1(-x);
            if (u == Double.POSITIVE_INFINITY)
                return Double.NEGATIVE_INFINITY;
            return -.5 * u / (u+1) * (u+2); // ordered to avoid overflow when big
        }
    }

    /** hyperbolic cosine function */
    public static double
    cosh(double x)
    {
        // cosh(x) = (e^x + e^-x) / 2
        // I don't think there are any cancellation issues
        // (though probably coshm1, below, is more useful).
        // We start by taking abs(x), just to make sure we get the exact same
        // result for x and -x.
        double e_x = Math.exp(Math.abs(x));
        return (e_x + 1./e_x) * .5;
    }

    /** cosh(x)-1, accurate even when x is small. */
    public static double
    coshm1(double x)
    {
        if (true)
        {
            // cosh(x) - 1 = (e^x + e^-x) / 2 - 1
            //             = (e^x - 2 + e^-x) / 2
            //             = (e^2x - 2*e^x + 1) / e^x / 2
            //             = (e^x - 1)^2 / e^x / 2
            //             = expm1(x)^2 / (expm1(x)+1) / 2
            double u = expm1(Math.abs(x));
            if (u == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
            return .5 * u / (u+1) * u; // ordered to avoid overflow when big
        }
        else
        {
            // Seemingly more straightforward,
            // but actually more expensive since it takes two different expm1's
            // cosh(x) - 1 = (e^x + e^-x) / 2 - 1
            //             = (e^x - 1 + e^-x - 1) / 2
            //             = (e^x - 1)/2 + (e^-x - 1)/2
            //             = (expm1(x) + expm1(-x)) / 2
            return .5 * (expm1(x) + expm1(-x));
        }
        // TODO: 2*sinh(.5*x)^2 ? yeah I think so.  inverse of what we do with acosh1p below.
    }

    /** acosh(1+x), accurate even when x is small. */
    public static double
    acosh1p(double x)
    {
        return 2 * asinh(Math.sqrt(x/2));
    }


    /** hyperbolic tangent function */
    public static double
    tanh(double x)
    {
        // tanh(x) = sinh(x) / cosh(x)
        //         = (e^x - e^-x) / (e^x + e^-x)
        //         = (e^2x - 1) / (e^2x + 1)
        //         = expm1(2*x) / (expm1(2*x) + 2)
        // That works great but overflows prematurely, so do it
        // this way instead:
        // tanh(x) = (e^2x - 1) / (e^2x + 1)
        //         = (e^x - 1)(e^x + 1) / ((e^x - 1)(e^x + 1) + 2)
        //         = expm1(x)(expm1(x)+1) / (expm1(x)(expm1(x)+2) + 2)
        double u = expm1(x);
        return u / (u*(u+2.)+2.) * (u+2.); // ordered to avoid overflow when big
        // XXX oops, that doesn't avoid overflow
        // XXX since u*(u+2) can overflow... can we find another formulation?
    }


    /** inverse hyperboiic sine function */
    public static double
    asinh(double x)
    {
        if (x == Double.NEGATIVE_INFINITY)
            return Double.NEGATIVE_INFINITY;
        if (x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        // To make it better behaved near 0:
        // asinh(x) = log(x + sqrt(x^2 + 1))
        //          = log1p(x + sqrt(x^2 + 1) - 1)
        //          = log1p(x + (sqrt(x^2+1)-1)*(sqrt(x^2+1)+1)/(sqrt(x^2+1)+1))
        //          = log1p(x + (x^2+1 - 1)/(sqrt(x^2+1)+1))
        //          = log1p(x + x^2 / (sqrt(x^2+1)+1))
        //          = log1p(x * (1 + x / (sqrt(x^2+1)+1) ))
        // That fixes it near 0:
        //     gnuplot> plot [-1e-15:1e-15] asinh(x), asinh_smart(x)
        // However, for some reason the formula still isn't symmetric,
        // even though the function is symmetric, and furthermore
        // it behaves rather atrociously for large negative arguments:
        //     gnuplot> plot [-1e9:1e9] asinh(x), asinh_smart(x)
        // Therefore we special case negative arguments.
        // XXX TODO: might want to switch to more naive log-based when args very large-- might be better behaved? not sure
        if (x >= 0)
            return  log1p( x * (1. + x / (hypot(x,1.)+1.)));
        else
            return -log1p(-x * (1. - x / (hypot(x,1.)+1.)));
    }

    /** inverse hyperbolic cosine function */
    public static double
    acosh(double x)
    {
        // Only defined for x >= 1.

        // acosh(x) = log(x + sqrt(x^2 - 1))
        // Use the formula given by Kahan in
        // "Branch Cuts for Complex Elementary Functions",
        // as quoted by Cleve Moler in:
        // http://www.mathworks.com/company/newsletter/clevescorner/sum98cleve.shtml
        return 2 * Math.log(Math.sqrt((x+1)*.5) + Math.sqrt((x-1)*.5));
    }

    /** inverse hyperbolic tangent function */
    public static double
    atanh(double x)
    {
        // Only defined for x < 1.

        // atanh(x) = log((1+x)/(1-x))/2
        //          = log((1 - x + 2x) / (1-x)) / 2
        //          = log(1 + 2x/(1-x)) / 2
        //          = log1p(2x/(1-x)) / 2
        return .5 * log1p(2.*x/(1.-x));
    }

    /** 1-cos(x), doesn't lose accuracy for small x */
    public static double
    cosf1(double x)
    {
        double sinHalfX = Math.sin(.5*x);
        return 2.*sinHalfX*sinHalfX;
    }
    /** acos(1-x), doesn't lose accuracy for small x */
    public static double
    acos1m(double x)
    {
        return 2.*Math.asin(Math.sqrt(.5*x));
    }

    /** sin(x)/x, but stable when small */
    public static double
    sin_over_x(double x)
    {
        //
        // It's 1 - x^2/3! + x^4/5! - ...
        // so if |x| is so small that 1-x^2/6 is indistinguishable from 1,
        // then the result will be indistinguishable from 1 too.
        //
        if (1. - x*x*(1/6.) == 1.)
        {
            //System.out.println("Ha! sin(x)/x("+x+") returning 1. instead of "+Math.sin(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return 0.;
        else
            return Math.sin(x)/x;
    }

    /** sinh(x)/x, but stable when small */
    public static double
    sinh_over_x(double x)
    {
        //
        // It's 1 + x^2/3! + x^4/5! + ...
        //
        if (1. + x*x*(1/3.) == 1.)
        {
            //System.out.println("Ha! sinh(x)/x("+x+") returning 1. instead of "+Math.sin(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return Double.POSITIVE_INFINITY;
        else
            return sinh(x)/x;
    }

    /** asin(x)/x, but stable when small */
    public static double
    asin_over_x(double x)
    {
        // 1 + 1/6*x^2 + 3/40*x^4 + 5/112*x^6 + 35/1152*x^8 + 63/2816*x^10 + 231/13312*x^12 + ...
        if (1. + x*x*(1/3.) == 1.)
        {
            //System.out.println("Ha! asin(x)/x("+x+") returning 1. instead of "+MyMath.asin(x)+"/"+x);
            return 1.;
        }
        else
            return Math.asin(x)/x;
    }

    /** asinh(x)/x, but stable when small */
    public static double
    asinh_over_x(double x)
    {
        //
        // 1 - 1/6*x^2 + 3/40*x^4 - 5/112*x^6 + ...
        //
        if (1. - x*x*(1/6.) == 1.)
        {
            //System.out.println("Ha! asinh(x)/x("+x+") returning 1. instead of "+MyMath.asinh(x)+"/"+x);
            return 1.;
        }
        else if (x == Double.NEGATIVE_INFINITY
              || x == Double.POSITIVE_INFINITY)
            return 0.;
        else
            return sinh(x)/x;
    }

    /** (cosh(x)-1)/x^2, but stable when small */
    public static double
    cosf1_over_xx(double x)
    {
        double temp = sin_over_x(x*.5);
        return .5 * temp * temp;
    }

    /** (cosh(x)-1)/x^2, but stable when small */
    public static double
    coshm1_over_xx(double x)
    {
        double temp = sinh_over_x(x*.5);
        return .5 * temp * temp;
    }

    /** sqrt(x*x + y*y) but overflow/underflow proof. */
    public static double hypot(double x, double y)
    {
        x = Math.abs(x);
        y = Math.abs(y);
        double min, max;
        if (x < y)
        {
            min = x;
            max = y;
        }
        else
        {
            min = y;
            max = x;
        }
        if (min == 0.)
            return max;
        double min_over_max = min/max;
        return max * Math.sqrt(1. + min_over_max*min_over_max);
    }

    /** Lambert W function, that is, functional inverse of x = f(w) = w e^w.
    * http://blogs.mathworks.com/cleve/2013/09/02/the-lambert-w-function/
    * Copyright 2013 The MathWorks, Inc.
    */
    public static double lambertw(double x,
                                  int branch) // 0 means primary or upper, -1 means lower
    {
        if (Double.isNaN(x))
            return Double.NaN;
        double w;
        if (branch == 0)
            w = 1; // start above -1
        else if (branch == -1)
            w = -2; // start below -1
        else
            throw new IllegalArgumentException("MyMath.lambertw called with illegal branch "+branch);

        if (x <= -1./Math.E)
        {
            if (x < -1./Math.E)
                return Double.NaN; // either branch
            else
                return -1.; // so we get this one exact, on either branch; it would be pretty sloppy otherwise
        }
        if (branch == -1)
        {
            if (x > 0.)
                return Double.NaN;
            else if (x == 0.)
                return Double.NEGATIVE_INFINITY;
            // else strictly negative, so has a solution
        }
        else // if branch == 0
        {
            if (x == Double.POSITIVE_INFINITY)
                return Double.POSITIVE_INFINITY;
        }

        double v = Double.POSITIVE_INFINITY * w;
        while (Math.abs((w - v)/w) > 1e-8) // XXX do something different here? not sure
        //while (Math.abs((w - v)/w) > 0.) // XXX do something different here I think
        {
            v = w;
            double e = Math.exp(w);
            double f = w*e - x; // Iterate to make this quantity zero
            w -= f/(e*(w+1.) - (w+2.)*f/(2.*w+2.));
        }
        return w;
    }

    /**
    * Functional inverse of e^x/x.
    * http://www1.american.edu/cas/mathstat/People/kalman/pdffiles/glog.pdf
    * Wolfram Alpha says this -W(-1/x)
    * and empirically, it uses the opposite branch from the one we got.
    * Subtle point: if x is 0 or -0 and branch is -1, we return -infinity.
    * (another possibly valid choice would be -0->-infinity, +0->nan)
    */
    public static double glog(double x,
                              int branch)
    {
        // This is a subtle decision, but on branch -1,
        // I think we want to return -infinity if x is either 0 or -0.
        if (x == 0.)
            x = -0.;  // so that we call lambertw on infinity rather than -infinity!

        int otherBranch = -1 - branch;
        return -lambertw(-1./x, -1-branch);
    }

    public static void main(String args[])
    {
        System.out.println("    in MyMath.main");

        assert_nan(Math.log(Double.NEGATIVE_INFINITY));
        assert_eq(MyMath.expm1(Double.NEGATIVE_INFINITY), -1.);
        assert_eq(MyMath.sinh(Double.NEGATIVE_INFINITY), Double.NEGATIVE_INFINITY);
        assert_eq(MyMath.cosh(Double.NEGATIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.coshm1(Double.NEGATIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_nan(MyMath.log1p(Double.NEGATIVE_INFINITY));
        assert_eq(MyMath.asinh(Double.NEGATIVE_INFINITY), Double.NEGATIVE_INFINITY);
        assert_nan(MyMath.acosh1p(Double.NEGATIVE_INFINITY));

        assert_eq(Math.exp(Double.NEGATIVE_INFINITY), 0.);
        assert_eq(Math.exp(-1.), 1./Math.E);
        assert_eq(Math.exp(0.), 1.);
        assert_eq(Math.exp(1.), Math.E);
        assert_eq(Math.log(0.), Double.NEGATIVE_INFINITY);
        assert_eq(Math.log(1./Math.E), -1.);
        assert_eq(Math.log(1.), 0.);
        assert_eq(Math.log(Math.E), 1.);
        assert_eq(MyMath.expm1(0.), 0.);
        assert_eq(MyMath.sinh(0.), 0.);
        assert_eq(MyMath.cosh(0.), 1.);
        assert_eq(MyMath.coshm1(0.), 0.);
        assert_eq(MyMath.log1p(-1.), Double.NEGATIVE_INFINITY);
        assert_eq(MyMath.log1p(0.), 0.);
        assert_eq(MyMath.asinh(0.), 0.);
        assert_eq(MyMath.acosh1p(0.), 0.);

        assert_eq(Math.exp(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(Math.log(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.expm1(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.sinh(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.cosh(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.coshm1(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.log1p(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.asinh(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_eq(MyMath.acosh1p(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);

        assert_eq(MyMath.sin_over_x(Double.NEGATIVE_INFINITY), 0.);
        assert_eq(MyMath.sinh_over_x(Double.NEGATIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_nan(MyMath.asin_over_x(Double.NEGATIVE_INFINITY));
        assert_eq(MyMath.asinh_over_x(Double.NEGATIVE_INFINITY), 0.);
        assert_eq(MyMath.cosf1_over_xx(Double.NEGATIVE_INFINITY), 0.);
        assert_eq(MyMath.coshm1_over_xx(Double.NEGATIVE_INFINITY), Double.POSITIVE_INFINITY);

        assert_eq(MyMath.sin_over_x(0.), 1.);
        assert_eq(MyMath.sinh_over_x(0.), 1.);
        assert_eq(MyMath.asin_over_x(0.), 1.);
        assert_eq(MyMath.asinh_over_x(0.), 1.);
        assert_eq(MyMath.cosf1_over_xx(0.), .5);
        assert_eq(MyMath.coshm1_over_xx(0.), .5);

        assert_eq(MyMath.sin_over_x(Double.POSITIVE_INFINITY), 0.);
        assert_eq(MyMath.sinh_over_x(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);
        assert_nan(MyMath.asin_over_x(Double.POSITIVE_INFINITY));
        assert_eq(MyMath.asinh_over_x(Double.POSITIVE_INFINITY), 0.);
        assert_eq(MyMath.cosf1_over_xx(Double.POSITIVE_INFINITY), 0.);
        assert_eq(MyMath.coshm1_over_xx(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);

        // TODO: all of the following is missing testing of all the *_over_x functions
        // TODO: all of the following is missing testing of asinh, probably others

        // first and last entries are big enough to overflow all the exp and hyperbolic trig functions
        double xs[] = {-1000, -100, -10, -1, -.1, 0, .1, 1, 10, 100, 1000};
        for (int i = 0; i < xs.length; ++i)
        {
            double x = xs[i];

            System.out.println("    exp("+x+") = "+Math.exp(x)+"");
            System.out.println("    expm1("+x+") = "+MyMath.expm1(x)+"");
            System.out.println("    sinh("+x+") = "+MyMath.sinh(x)+"");
            System.out.println("    cosh("+x+") = "+MyMath.cosh(x)+"");
            System.out.println("    coshm1("+x+") = "+MyMath.coshm1(x)+"");

            assert_eq(MyMath.expm1(x) + 1., Math.exp(x) - 1. + 1.);
            assert_eq(MyMath.expm1(x) + 1. - 1., Math.exp(x) - 1.);

            if (x > -1.)
            {
                System.out.println("    log1p("+x+") = "+MyMath.log1p(x)+"");
                // TODO: come up with something more sensible I think? I'm a bit confused.
                assert_eq((float)MyMath.log1p(x), (float)Math.log(1.+x));
            }

            if (x >= 0.)
            {
                System.out.println("    acosh1p("+x+") = "+MyMath.acosh1p(x)+"");
                // TODO: come up with something more sensible I think? I'm a bit confused.
                assert_eq((float)MyMath.acosh1p(x), (float)MyMath.acosh(1.+x));
            }

            if (false)
            {
                // hmm, not quite exact, apparently
                PRINT(MyMath.coshm1(x) + 1.);
                PRINT(MyMath.cosh(x) - 1. + 1.);
                assert_eq(MyMath.coshm1(x) + 1., MyMath.cosh(x) - 1. + 1.);
                PRINT(MyMath.coshm1(x) + 1. - 1.);
                PRINT(MyMath.cosh(x) - 1.);
                assert_eq(MyMath.coshm1(x) + 1. - 1., MyMath.cosh(x) - 1.);
            }
            else
            {
                // TODO: come up with something more sensible I think? I'm confused
                assert_eq((float)MyMath.coshm1(x), (float)(MyMath.cosh(x) - 1.));
            }

            if (x >= 0.)
            {
                assert_eq(MyMath.sinh(-x), -MyMath.sinh(x));
                assert_eq(MyMath.asinh(-x), -MyMath.asinh(x));
                assert_eq(MyMath.cosh(-x), MyMath.cosh(x));
            }

            if (i == 0)
            {
                assert_eq(Math.exp(x), 0.);
                assert_eq(MyMath.expm1(x), -1.);
                assert_eq(MyMath.sinh(x), Double.NEGATIVE_INFINITY);
                assert_eq(MyMath.cosh(x), Double.POSITIVE_INFINITY);
            }
            if (i == xs.length-1)
            {
                assert_eq(Math.exp(x), Double.POSITIVE_INFINITY);
                assert_eq(MyMath.expm1(x), Double.POSITIVE_INFINITY);
                assert_eq(MyMath.sinh(x), Double.POSITIVE_INFINITY);
                assert_eq(MyMath.cosh(x), Double.POSITIVE_INFINITY);
            }

            if (i > 0.)
            {
                assert(Math.exp(xs[i-1]) < Math.exp(xs[i]));
                assert(MyMath.expm1(xs[i-1]) <= MyMath.expm1(xs[i])); // not strict < for some
                assert(MyMath.sinh(xs[i-1]) < MyMath.sinh(xs[i]));
                if (ABS(xs[i-1]) < ABS(xs[i]))
                {
                    assert(MyMath.cosh(xs[i-1]) < MyMath.cosh(xs[i]));
                    assert(MyMath.coshm1(xs[i-1]) < MyMath.coshm1(xs[i]));
                }
                else
                {
                    assert(MyMath.cosh(xs[i-1]) > MyMath.cosh(xs[i]));
                    assert(MyMath.coshm1(xs[i-1]) > MyMath.coshm1(xs[i]));
                }
            }
        }

        if (true)
        {
            // lambertw tests
            for (double i = -714.; i <= 696.; ++i) // empirically, works to this range
            {
                if (i <= -1.)
                {
                    if (i >= -10 && i <= 10) System.out.println("    lambertw(e^"+i+"*"+i+", -1) = "+MyMath.lambertw(Math.exp(i)*i,-1));
                    assert_eq(MyMath.lambertw(Math.exp(i)*i,-1), i); // seems to be exact
                }
                if (i >= -1.)
                {
                    if (i >= -10 && i <= 10) System.out.println("    lambertw(e^"+i+"*"+i+", 0) = "+MyMath.lambertw(Math.exp(i)*i,0));
                    assert_eq(MyMath.lambertw(Math.exp(i)*i,0), i); // seems to be exact
                }
            }
            assert_eq(MyMath.lambertw(Double.POSITIVE_INFINITY, 0), Double.POSITIVE_INFINITY);
            assert_nan(MyMath.lambertw(Double.POSITIVE_INFINITY, -1));

            // wolframalpha says the inverse function of e^x/x is -W(-1/x)
            // and we have to figure out which branch it is.
            // then:
            //     x = -W(-1/y)
            // and empirically, it's the lower branch. Hmm.  (wolframalpha didn't indicate that)
            // XXX hmm, -14 and -13 (not as much) are slow! interesting! should investigate!
            // that's
            //     -14: lambert(-5.9394908507397704E-8)
            //     -13: -1.7387149284469648E-7
            //     -12: -5.120176961106842E-7
            //     -11: -1.5183364354768781E-6
            OUT("========");
            for (double i = -100.; i <= 100.; ++i)
            {
                int branch = i<1 ? -1 : 0;
                if (i >= -20 && i <= 20) System.out.println("    MyMath.glog(Math.exp("+i+")/"+i+"="+(Math.exp(i)/i)+","+branch+") = "+MyMath.glog(Math.exp(i)/i,branch));
                assert_eq(MyMath.glog(Math.exp(i)/i,branch), i);

                if (i < 0.)
                {
                    assert(MyMath.glog(i, -1) < 0.);
                    assert_nan(MyMath.glog(i, 0));
                }
                else if (i == 0)
                {
                    // subtle: it's implemented so that both -0 and 0 produce NEGATIVE_INFINITY on branch -1.
                    assert_eq(MyMath.glog(i, -1), Double.NEGATIVE_INFINITY);
                    assert_eq(MyMath.glog(-i, -1), Double.NEGATIVE_INFINITY);
                    assert_nan(MyMath.glog(i, 0));
                    assert_nan(MyMath.glog(-i, 0));
                }
                else if (i < Math.E)
                {
                    assert_nan(MyMath.glog(i, -1));
                    assert_nan(MyMath.glog(i, 0));
                }
                else if (i == Math.E)
                {
                    assert_eq(MyMath.glog(i, -1), 1.);
                    assert_eq(MyMath.glog(i, 0), 1.);
                }
                else if (i > Math.E)
                {
                    assert(MyMath.glog(i, -1) < 1.);
                    assert(MyMath.glog(i, 0) > 1.);
                }
            }
        }

        System.out.println("      MyMath functions all good!");
        System.out.println("    out MyMath.main");
    }
} // class MyMath
