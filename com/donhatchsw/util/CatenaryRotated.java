// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// 102 # 1 "com/donhatchsw/util/CatenaryRotated.prejava"
// 103 # 1 "<built-in>"
// 104 # 1 "<command-line>"
// 105 # 1 "com/donhatchsw/util/CatenaryRotated.prejava"
/* vim: set filetype=java: */
package com.donhatchsw.util;
// 108 # 1 "com/donhatchsw/util/macros.h" 1
//
// macros.h
//
// 112 # 14 "com/donhatchsw/util/macros.h"
// NOTE: this causes a,b to be evaluated twice on failure, so is not ideal. might be better to do a block... ?
// 114 # 30 "com/donhatchsw/util/macros.h"
// Note: the additional "(a)==(b)||" is to make it work correctly for infinities...
// and causes the args to be evaluated twice.
// 117 # 67 "com/donhatchsw/util/macros.h"
// XXX ... what a mess
// 119 # 4 "com/donhatchsw/util/CatenaryRotated.prejava" 2


/* WORK IN PROGRESS */
// TODO: make histograms of timings using newton and binary search, see if there's really a bottleneck
// TODO: implement all cases properly in binary search
// TODO: need to scale problem, I think, in order to make tolerances sensible
// TODO: make fitFromMoment take momentOffset=moment-momentIfTaut instead of moment, would allow better stability I think
// TODO: investigate possibility of decreasing bounds implying decreasing angle variance which decreases the trouble area
// TODO: investigate possibility of hybrid:
//    - one binary step, one newton step?
//    - newton as long as it lands strictly within known bounds (how much within?), otherwise binary?
//    - newton clamped to strictly within known bounds?
//    - newton but pull back to land strictly within known bounds?
public class CatenaryRotated extends Catenary.FlippedMaybe
{
    public static boolean XXX_ALLOW_FITFROMMOMENT_FAILURE = false; // hack hook so SmoothlyVaryingViewingParameter demo3 can proceed with manageable amount of noise

    public double cosRotation;
    public double sinRotation;

    @Override public void assertValid()
    {
        super.assertValid();
        double error = MyMath.hypot(cosRotation, sinRotation) - 1.;
        do { if (!((((error)*(error)) + 1. - 1.)==(0.))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+28 +"): (" + "((error)*(error)) + 1. - 1." + ")" + "==" + "(" + "0." + ") ("+(((error)*(error)) + 1. - 1.)+" vs. "+(0.)+")"); } while (false); // implicit tolerance
    }

    // Unit-length derivative at time t.
    @Override public void differentiate(double t,
                                       double answer[/*2*/])
    {
        super.differentiate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
    }

    // Position at time t.
    @Override public void evaluate(double t,
                                  double answer[/*2*/])
    {
        super.evaluate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
    }
    // Arc length integral from focus to t.
    @Override public void integrate(double t,
                                   double answer[/*2*/])
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("                            in CatenaryRotated.integrate(t="+t+")");
        super.integrate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
        if (verboseLevel >= 1) System.out.println("                            out CatenaryRotated.integrate(t="+t+"), returning answer="+VecMath.toString(answer));
    }

        // XXX experimental at the moment... alternative to newton, see how it behaves
        private static void solveUsingMinimizer(double x[],
                                 double y[], // const
                                 NewtonSolver.Fun nfun,
                                 int minIterations, // seem to need this, or it thinks it stopped improving after 1 iteration in some sticky situations.  I think actually the termination condition should be that it didn't improve in some number of iterations? hmm. actually should make it smart and adaptive I think.
                                 int maxIterations,
                                 boolean adaptiveFlagUnused)
        {
            final double yFinal[] = y;
            final NewtonSolver.Fun nfunFinal = nfun;
            final double fx[] = new double[y.length];
            Minimizer.VectorFunction mfun = new Minimizer.VectorFunction() {
                @Override public double apply(double x[])
                {
                    nfunFinal.f(x, fx);
                    // Which?
                    // Empirically dist gives larger errors-- needed error tolerance of 1e-4 or so,
                    // whereas 1e-6 works (barely) for distsqrd
                    //return VecMath.dist(fx, yFinal);
                    return VecMath.distsqrd(fx, yFinal);
                }
            };
            double initialGuess[] = x;
            double initialDelta = 1e-3; // somewhat arbitrary
            String paramNames[] = null;
            double answer[] = Minimizer.minimize(mfun,
                               initialGuess,
                               initialDelta,
                               maxIterations,
                               false, // returnNullOnMaxCallsReached
                               paramNames);
            do { if (!(answer != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+88 +"): " + "answer != null" + ""); } while (false);
            VecMath.copyvec(x, answer);
        } // solveUsingMinimizer

    public static java.io.PrintWriter goodAndBadOut = null; // apps can set this to debug

    // x0=0 y0=0 x1=x1 y1=0 yMoment>=0
    private void fitFromMomentByBinarySearchCanonicalCase(double x1,
                                                          double xMoment, double yMoment,
                                                          int verboseLevel, // 0: nothing, 1: in/out, 2: nice binary search progress all on one line, 3: very explicit
                                                          double xKnownSolution, double yKnownSolution)
    {
        int fitVerboseLevel = 0; // XXX should be a param? not sure, often it is separate

        do { if (!(x1 >= 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+102 +"): " + "x1 >= 0." + ""); } while (false);
        do { if (!(x1 <= 1.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+103 +"): " + "x1 <= 1." + ""); } while (false);
        do { if (!(x1 == 1.)) throw new Error("Assumption failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+104 +"): " + "x1 == 1." + ""); } while (false); // XXX IMPLEMENT OTHER!

        do { if (!(yMoment >= 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+106 +"): " + "yMoment >= 0." + ""); } while (false);

        double tol = 1e-6; // XXX ?
        //double tol = 1e-5; // XXX ? I'd really like to be able to use something really small

        double x0 = 0.;
        double y0 = 0.;
        double y1 = 0.;

        // some of this is more general than it needs to be
        double dist = MyMath.hypot(y1-y0, x1-x0);
        double desiredMoment[] = {xMoment, yMoment};
        double xMomentIfTaut = (x0+x1)*.5 * dist;
        double yMomentIfTaut = (y0+y1)*.5 * dist;

        double rKnownSolution = Double.NaN;
        double angleKnownSolution = Double.NaN;
        boolean solutionIsKnown = !Double.isNaN(xKnownSolution);
        if (solutionIsKnown)
        {
            rKnownSolution = Math.hypot(xKnownSolution, yKnownSolution);
            angleKnownSolution = Math.atan2(yKnownSolution, xKnownSolution);
            while (angleKnownSolution >= 2*Math.PI) angleKnownSolution -= 2*Math.PI;
            while (angleKnownSolution < 0.) angleKnownSolution += 2*Math.PI;
        }

        // Lower and upper bounds
        double rLo = 0.;
        double rHiStart = Math.max(1.,
                                   10.*Math.sqrt(MyMath.hypot(xMoment-xMomentIfTaut, yMoment-yMomentIfTaut)));
        double rHi = rHiStart;

        double angleLo = 0.;
        double angleHi = Math.PI;

        if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+141 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
        if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+142 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);

        double gotMoment[] = new double[2];
        double gotMomentOther[] = new double[2];

        // First figure out which quadrant the answer is in,
        // by figuring out which side of the image of the +y axis it's on.
        boolean isObviouslyInSecondQuadrant = desiredMoment[0] <= xMomentIfTaut;
        if (isObviouslyInSecondQuadrant)
        {
            if (verboseLevel >= 2) System.out.println("                  easy to see it's in second quadrant.");
            //CHECK(false); // coverage
            angleLo = Math.PI/2.;
        }
        // TODO: actually there's some magic constant angle we can use... figure it out
        // If lower than 45 degree line, then it's obviously in first quadrant
        boolean isObviouslyInFirstQuadrant = desiredMoment[0]-xMomentIfTaut >= desiredMoment[1];
        if (isObviouslyInFirstQuadrant)
        {
            if (verboseLevel >= 2) System.out.println("                  easy to see it's in first quadrant.");
            //CHECK(false); // coverage
            angleHi = Math.PI/2.;
        }

        if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+166 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
        if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+167 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);

        if (!isObviouslyInFirstQuadrant && !isObviouslyInSecondQuadrant)
        {
            if (verboseLevel >= 2) System.out.println("                  figuring out which quadrant since it wasn't obvious...");
            //CHECK(false); // coverage
            double slackPlus1 = xMoment / xMomentIfTaut; // XXX I think this assumes dist is 1?
            double X = Catenary.asinhc(slackPlus1);
            double Y = MyMath.cosh(X);
            // XXX the following is proved elsewhere
            double yMomentOfXMoment = (slackPlus1 * Y - 1.) / (4. * X);
            if (verboseLevel >= 2) System.out.println("                      slackPlus1 = "+slackPlus1);
            if (verboseLevel >= 2) System.out.println("                      X = "+X);
            if (verboseLevel >= 2) System.out.println("                      Y = "+Y);
            if (verboseLevel >= 2) System.out.println("                      yMomentOfXMoment = "+yMomentOfXMoment);
            if (verboseLevel >= 2) System.out.println("                      yMoment = "+yMoment);
            if (yMoment <= yMomentOfXMoment)
            {
                if (verboseLevel >= 2) System.out.println("                    first quadrant.");
                //CHECK(false); // coverage
                angleHi = Math.PI/2.;
            }
            if (yMoment >= yMomentOfXMoment)
            {
                if (verboseLevel >= 2) System.out.println("                    second quadrant.");
                //CHECK(false); // coverage
                angleLo = Math.PI/2.;
            }
            if (angleLo == Math.PI/2. && angleHi == Math.PI/2.)
            {
                // actually we have the answer in this case
                //CHECK(false); // coverage
                rLo = rHi = slackPlus1 - 1.;
            }
        }

        //PRINT(RTOD(angleLo)); // XXX TODO: ARGH! this is printing things like "((angleLo)*(180./Math.PI)) = 123.7499999999999" instead of "RTOD(angleLo) = 123.7499999999999"
        if (verboseLevel >= 2)
        {
            System.out.println("                  initial bounds:");
            System.out.println("                      rLo="+rLo);
            System.out.println("                      rHi="+rHi);
            System.out.println("                      angleLo="+((angleLo)*(180./Math.PI))+"deg");
            System.out.println("                      angleHi="+((angleHi)*(180./Math.PI))+"deg");
            System.out.println("                      desiredMoment="+VecMath.toString(desiredMoment));
            if (solutionIsKnown)
            {
                System.out.println("                      rKnownSolution="+rKnownSolution);
                System.out.println("                      angleKnownSolution="+angleKnownSolution);
            }
        }

        if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+219 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
        if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+220 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);

        if (angleHi <= Math.PI/2.)
        {
            // First quadrant-- easy
            //CHECK(false); // coverage
            if (verboseLevel >= 3) System.out.println("                    first quadrant loop:");
            if (verboseLevel == 2) System.out.print("                    ");
            while (true)
            {
                if (verboseLevel >= 3) System.out.println("                      top of loop");
                if (verboseLevel >= 3) System.out.println("                          rLo="+rLo);
                if (verboseLevel >= 3) System.out.println("                          rKnownSolution="+rKnownSolution);
                if (verboseLevel >= 3) System.out.println("                          rHi="+rHi);
                if (verboseLevel >= 3) System.out.println("                          angleLo="+((angleLo)*(180./Math.PI))+"deg");
                if (verboseLevel >= 3) System.out.println("                          angleKnownSolution="+((angleKnownSolution)*(180./Math.PI))+"deg");
                if (verboseLevel >= 3) System.out.println("                          angleHi="+((angleHi)*(180./Math.PI))+"deg");
                if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+237 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
                if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+238 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);
                double r = (rLo + rHi) * .5;
                double angle = (angleLo + angleHi) * .5;
                double c = Math.cos(angle);
                double s = Math.sin(angle);
                this.fitFromPolarCoords(x0,y0, x1,y1, r, c, s, fitVerboseLevel);
                this.integrate(this.t0, this.t1, gotMoment);
                double xDir = desiredMoment[0] - gotMoment[0];
                double yDir = desiredMoment[1] - gotMoment[1];

                if (verboseLevel >= 3) System.out.println("                          desiredMoment="+VecMath.toString(desiredMoment));
                if (verboseLevel >= 3) System.out.println("                          gotMoment="+VecMath.toString(gotMoment));
                if (verboseLevel >= 3) System.out.println("                          dir="+VecMath.toString(new double[]{xDir,yDir}));

                boolean categorized = false;
                boolean madeProgress = false;

                double angleDotDir = c*xDir + s*yDir;
                if (angleDotDir >= 0)
                {
                    // desired moment is outside tangent line of ellipse.
                    // r is too small (or just right).
                    if (verboseLevel >= 3) System.out.println("                        NEish");
                    if (verboseLevel == 2) System.out.print(" NEish");
                    categorized = true;
                    if (rLo != r)
                    {
                        madeProgress = true;
                        rLo = r;
                    }
                }
                if (xDir <= 0.)
                {
                    // need to go W
                    if (yDir <= 0.)
                    {
                        // need to go SW
                        if (verboseLevel >= 3) System.out.println("                        SW");
                        if (verboseLevel == 2) System.out.print(" SW");
                        categorized = true;
                        if (rHi != r)
                        {
                            madeProgress = true;
                            rHi = r;
                        }
                    }
                    if (yDir >= 0.)
                    {
                        // need to go NW
                        if (verboseLevel >= 3) System.out.println("                        NW");
                        if (verboseLevel == 2) System.out.print(" NW");
                        categorized = true;
                        if (angleLo != angle)
                        {
                            madeProgress = true;
                            angleLo = angle;
                        }
                    }
                }
                if (xDir >= 0.)
                {
                    // need to go E
                    if (yDir <= 0.)
                    {
                        //need to go SE
                        if (verboseLevel >= 3) System.out.println("                        SE");
                        if (verboseLevel == 2) System.out.print(" SE");
                        categorized = true;
                        if (angleHi != angle)
                        {
                            madeProgress = true;
                            angleHi = angle;
                        }
                    }
                    // don't need to test the NE case; we already did that and more above
                }
                do { if (!(categorized)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+314 +"): " + "categorized" + ""); } while (false);
                if (!madeProgress)
                    break;
            }
            if (verboseLevel >= 2) System.out.println("!");
        } // first quadrant

        if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+321 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
        if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+322 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);

        if (angleLo >= Math.PI/2.)
        {
            // Second quadrant-- harder (unless in the "obviously in second quadrant" part of it)
            //CHECK(false); // coverage
            if (verboseLevel >= 3) System.out.println("                    second quadrant loop:");
            if (verboseLevel == 2) System.out.print("                    ");
            while (true)
            {
                if (verboseLevel >= 3) System.out.println("                      top of loop");
                if (verboseLevel >= 3) System.out.println("                          rLo="+rLo);
                if (verboseLevel >= 3) System.out.println("                          rKnownSolution="+rKnownSolution);
                if (verboseLevel >= 3) System.out.println("                          rHi="+rHi);
                if (verboseLevel >= 3) System.out.println("                          angleLo="+((angleLo)*(180./Math.PI))+"deg");
                if (verboseLevel >= 3) System.out.println("                          angleKnownSolution="+((angleKnownSolution)*(180./Math.PI))+"deg");
                if (verboseLevel >= 3) System.out.println("                          angleHi="+((angleHi)*(180./Math.PI))+"deg");
                if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+339 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
                if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+340 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);
                double r = (rLo + rHi) * .5;
                double angle = (angleLo + angleHi) * .5;
                double c = Math.cos(angle);
                double s = Math.sin(angle);
                this.fitFromPolarCoords(x0,y0, x1,y1, r, c, s, fitVerboseLevel);
                this.integrate(this.t0, this.t1, gotMoment);
                double xDir = desiredMoment[0] - gotMoment[0];
                double yDir = desiredMoment[1] - gotMoment[1];

                if (verboseLevel >= 3) System.out.println("                          desiredMoment="+VecMath.toString(desiredMoment));
                if (verboseLevel >= 3) System.out.println("                          gotMoment="+VecMath.toString(gotMoment));
                if (verboseLevel >= 3) System.out.println("                          dir="+VecMath.toString(new double[]{xDir,yDir}));
                if (verboseLevel >= 3) System.out.println("                          angle="+VecMath.toString(new double[]{c,s}));

                boolean categorized = false;
                boolean madeProgress = false;

                double angleDotDir = c*xDir + s*yDir;
                double angleCrossDir = c*yDir - s*xDir;

                if (angleDotDir >= 0.)
                {
                    // desired moment is outside tangent line of ellipse.
                    // r is too small (or just right).
                    if (verboseLevel >= 3) System.out.println("                        NWish");
                    if (verboseLevel == 2) System.out.print(" NWish");
                    categorized = true;
                    if (rLo != r)
                    {
                        madeProgress = true;
                        rLo = r;
                    }

                    // The condition for increasing angle's lower bound
                    // is a test for dir being inside the quadrant [angle, angle+pi/2].
                    // This happens to be strictly stronger than the condition for increasing
                    // r's lower bound, which is that dir is in the half-space [angle-pi/2, angle+pi/2].
                    if (angleCrossDir >= 0.)
                    {
                        if (verboseLevel >= 3) System.out.println("                        (WSWish and increasing angleLo)");
                        if (verboseLevel == 2) System.out.print(" (WSWish and increasing angleLo)");
                        if (angleLo != angle)
                        {
                            madeProgress = true;
                            angleLo = angle;
                        }
                    }
                }
                if (angleDotDir <= 0. && angleCrossDir <= 0.)
                {
                    // Condition for decreasing angle's upper bound
                    // is a test for dir being in the quadrant opposite
                    // the one used for increasing angle's lower bound.
                    if (verboseLevel >= 3) System.out.println("                        (ENEish and decreasing angleHi)");
                    if (verboseLevel == 2) System.out.print(" (ENEish and decreasing angleHi)");
                    categorized = true;
                    if (angleHi != angle)
                    {
                        madeProgress = true;
                        angleHi = angle;
                    }
                }
                if (xDir >= 0. && yDir <= 0.)
                {
                    // need to go SE
                    if (verboseLevel >= 3) System.out.println("                        SE");
                    if (verboseLevel == 2) System.out.print(" SE");
                    categorized = true;
                    if (rHi != r)
                    {
                        madeProgress = true;
                        rHi = r;
                    }
                }
                if (isObviouslyInSecondQuadrant)
                {
                    // In this case we have monotonicity that we don't
                    // normally have in the second quadrant;
                    // therefore if we need to go SW we can increase angleLo.
                    if (xDir <= 0. && yDir <= 0.)
                    {
                        // need to go SW
                        if (verboseLevel >= 3) System.out.println("                        SW");
                        if (verboseLevel == 2) System.out.print(" SW");
                        categorized = true;
                        if (angleLo != angle)
                        {
                            madeProgress = true;
                            angleLo = angle;
                        }
                    }
                }
                if (!categorized)
                {
                    if (verboseLevel >= 3) System.out.println("                        ouch! !categorized");
                    // This is the tricky case.  It's definitely strictly SW;
                    // otherwise it would have already been categorized...
                    if (verboseLevel == 2) System.out.print(" ouch");
                    do { if (!(!isObviouslyInSecondQuadrant)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+439 +"): " + "!isObviouslyInSecondQuadrant" + ""); } while (false);

                    // Logically it's *strictly* in SW quadrant,
                    // but that can fail, e.g. if angle is 89.9999999999999999 degrees or so,
                    // so make the test inexact
                    //CHECK(xDir < 0. && yDir < 0.);
                    do { if (!((((0.)-(xDir)) > (1e-12)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+445 +"): " + "LT(xDir, 0., 1e-12)" + ""); } while (false);
                    do { if (!((((0.)-(yDir)) > (1e-12)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+446 +"): " + "LT(yDir, 0., 1e-12)" + ""); } while (false);

                    boolean tryLastDitchAttemptFlag = false; // XXX TODO: should be able to do this I think!  but there's some logic error
                    if (tryLastDitchAttemptFlag)
                    {
                        // Make a last-ditch attempt to decrease rHi
                        // using more exact and inclusive criteria than just the SE quadrant
                        // XXX think about whether I also want a similar last-ditch inside each iteration of the forcing loop below
                        this.fitFromPolarCoords(x0,y0, x1,y1, r, Math.cos(angleHi), Math.sin(angleHi), fitVerboseLevel);
                        this.integrate(this.t0, this.t1, gotMomentOther);
                        double otherMomentMinusMoment_cross_dir = (gotMomentOther[0]-gotMoment[0]) * yDir
                                                                - (gotMomentOther[1]-gotMoment[1]) * xDir;
                        if (otherMomentMinusMoment_cross_dir >= 0.)
                        {
                            if (verboseLevel >= 3) System.out.println("                        but SE'ish!");
                            if (verboseLevel == 2) System.out.print(" but SE'ish!");
                            categorized = true;
                            if (rHi != r)
                            {
                                madeProgress = true;
                                rHi = r;
                            }
                        }
                    }
                    if (!categorized)
                    {
                        // Force a single refinement of r,
                        // by doing a 1d binary search with r constant,
                        // looking for a point on the ellipse
                        // such that the target is NW or SE of it;
                        // call this a "vantage point".
                        // The angle bounds are not the same ones used globally.
                        double vantageAngleLo = angleLo; // empirically, this is ok (i.e. don't need to start over at Math.PI/2 each time). haven't proved it.
                        double vantageAngleHi = Math.PI; // does NOT work to use angleHi ... sometimes a vantage point higher than angleHi is needed, to look at something lower than angleHi!

                        while (true)
                        {
                            if (verboseLevel >= 3) System.out.println("                          top of inner loop");
                            if (verboseLevel >= 3) System.out.println("                              rLo="+rLo);
                            if (verboseLevel >= 3) System.out.println("                              rKnownSolution="+rKnownSolution);
                            if (verboseLevel >= 3) System.out.println("                              rHi="+rHi);
                            if (verboseLevel >= 3) System.out.println("                              vantageAngleLo="+((vantageAngleLo)*(180./Math.PI))+"deg");
                            if (verboseLevel >= 3) System.out.println("                              angleKnownSolution="+((angleKnownSolution)*(180./Math.PI))+"deg");
                            if (verboseLevel >= 3) System.out.println("                              vantageAngleHi="+((vantageAngleHi)*(180./Math.PI))+"deg");
                            if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+490 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
                            if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+491 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);

                            double vantageAngle = (vantageAngleLo+vantageAngleHi) * .5;
                            double cVantageAngle = Math.cos(vantageAngle);
                            double sVantageAngle = Math.sin(vantageAngle);
                            this.fitFromPolarCoords(x0,y0, x1,y1, r, cVantageAngle, sVantageAngle, fitVerboseLevel);
                            this.integrate(this.t0, this.t1, gotMoment);
                            xDir = desiredMoment[0] - gotMoment[0];
                            yDir = desiredMoment[1] - gotMoment[1];

                            if (verboseLevel >= 3) System.out.println("                              desiredMoment="+VecMath.toString(desiredMoment));
                            if (verboseLevel >= 3) System.out.println("                              gotMoment="+VecMath.toString(gotMoment));
                            if (verboseLevel >= 3) System.out.println("                              dir="+VecMath.toString(new double[]{xDir,yDir}));

                            boolean categorizedVantage = false;
                            boolean madeProgressVantage = false;
                            if (xDir <= 0.)
                            {
                                // need to go w
                                if (yDir <= 0.)
                                {
                                    // need to go sw
                                    if (verboseLevel >= 3) System.out.println("                            sw");
                                    if (verboseLevel == 2) System.out.print(" sw");
                                    categorizedVantage = true;
                                    if (vantageAngleLo != vantageAngle)
                                    {
                                        madeProgressVantage = true;
                                        vantageAngleLo = vantageAngle;
                                    }
                                }
                                //if (yDir >= 0.)
                                double vantageAngleDotDir = cVantageAngle*xDir + sVantageAngle*yDir;
                                if (vantageAngleDotDir >= 0.)
                                {
                                    // need to go nw
                                    if (verboseLevel >= 3) System.out.println("                            nwish!");
                                    if (verboseLevel == 2) System.out.print(" nwish!");
                                    categorizedVantage = true;
                                    if (rLo != r)
                                    {
                                        //CHECK(false); // coverage
                                        madeProgress = true; // not just local!
                                        rLo = r;
                                        break; // out of the local try-extra-hard loop
                                    }
                                }
                            }
                            if (xDir >= 0.)
                            {
                                // need to go e
                                if (yDir <= 0.)
                                {
                                    // need to go se
                                    if (verboseLevel >= 3) System.out.println("                            se!");
                                    if (verboseLevel == 2) System.out.print(" se!");
                                    categorizedVantage = true;
                                    if (rHi != r)
                                    {
                                        //CHECK(false); // coverage
                                        madeProgress = true; // not just local!
                                        rHi = r;
                                        break; // out of the local try-extra-hard loop
                                    }
                                }
                                if (yDir >= 0.)
                                {
                                    // need to go ne
                                    if (verboseLevel >= 3) System.out.println("                            ne");
                                    if (verboseLevel == 2) System.out.print(" ne");
                                    categorizedVantage = true;
                                    if (vantageAngleHi != vantageAngle)
                                    {
                                        madeProgressVantage = true;
                                        vantageAngleHi = vantageAngle;
                                    }
                                }
                            }
                            do { if (!(categorizedVantage)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+569 +"): " + "categorizedVantage" + ""); } while (false);
                            if (!madeProgressVantage)
                            {
                                // prevent endless loop.
                                // But if we get here, we actually found the answer.
                                // XXX think about this
                                angleLo = vantageAngleLo;
                                angleHi = vantageAngleHi;
                                break;
                            }
                        }

                        //angleLo = vantageAngleLo; // this is NOT ok (TODO: come up with clear argument/example)
                        //angleHi = vantageAngleHi; // this is NOT ok (TODO: come up with clear argument/example)
                    }
                }

                if (!madeProgress)
                {
                    if (verboseLevel >= 3) System.out.println("no progress happened! done I guess");
                    break;
                }
            }
            if (verboseLevel >= 2) System.out.println("!");
        } // second quadrant


        if (verboseLevel >= 2)
        {
            System.out.println("                  final bounds:");
            System.out.println("                      rLo="+rLo);
            if (solutionIsKnown) System.out.println("                      rKnownSolution="+rKnownSolution);
            System.out.println("                      rHi="+rHi);
            System.out.println("                      angleLo="+((angleLo)*(180./Math.PI))+"deg");
            if (solutionIsKnown) System.out.println("                      angleKnownSolution="+((angleKnownSolution)*(180./Math.PI))+"deg");
            System.out.println("                      angleHi="+((angleHi)*(180./Math.PI))+"deg");
            System.out.println("                      desiredMoment="+VecMath.toString(desiredMoment));
            System.out.println("                      gotMoment="+VecMath.toString(gotMoment));
            if (solutionIsKnown)
            {
                System.out.println("                      rKnownSolution="+rKnownSolution);
                System.out.println("                      angleKnownSolution="+angleKnownSolution);
            }
        }
        if (solutionIsKnown) do { if (!((rLo)-(rKnownSolution)<=(tol)) || !((rKnownSolution)-(rHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+613 +"): " +"(" + "rLo" + ")<=(" + "rKnownSolution" + ")<=(" + "rHi" + ")+-" + "tol" + "" +" ("+(rLo)+" vs. "+(rKnownSolution)+" vs. "+(rHi)+" +- "+(tol)+")" +" (error = "+((rLo)-(rKnownSolution))+", "+((rKnownSolution)-(rHi))+")" ); } while (false);
        if (solutionIsKnown) do { if (!((angleLo)-(angleKnownSolution)<=(tol)) || !((angleKnownSolution)-(angleHi)<=(tol))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+614 +"): " +"(" + "angleLo" + ")<=(" + "angleKnownSolution" + ")<=(" + "angleHi" + ")+-" + "tol" + "" +" ("+(angleLo)+" vs. "+(angleKnownSolution)+" vs. "+(angleHi)+" +- "+(tol)+")" +" (error = "+((angleLo)-(angleKnownSolution))+", "+((angleKnownSolution)-(angleHi))+")" ); } while (false);
    } // fitFromMomentByBinarySearchCanonicalCase

    // experimental at the moment
    private void fitFromMomentByBinarySearch(double x0, double y0,
                                             double x1, double y1,
                                             double xMoment, double yMoment,
                                             com.donhatchsw.compat.ArrayList newtonPathOut,
                                             int verboseLevel, // 0: nothing, 1: in/out, 2: nice binary search progress all on one line, 3: very explicit
                                             double xKnownSolution, double yKnownSolution) // XXX debug params-- figure out what I want here
    {
        int fitVerboseLevel = 0; // XXX should be a param? not sure, often it is separate
        if (verboseLevel >= 1) System.out.println("                in CatenaryRotated.fitFromMomentByBinarySearch(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+(Double.isNaN(xKnownSolution)?"":", xKnownSolution="+xKnownSolution+", yKnownSolution="+yKnownSolution)+")");

        try
        {
            if (((((x0)-(-1.)) <= (1e-12)) && (((-1.)-(x0)) <= (1e-12)))
             && ((((y0)-(0.)) <= (1e-12)) && (((0.)-(y0)) <= (1e-12)))
             && x1 == 0.
             && y1 == 0.
             && yMoment <= 1e-12)
            {
                // Flip from lower to upper half plane,
                // and the sample point from negative x axis to positive x axis.
                // I.e. flip the problem in both x and y.

                double xMomentInCanonicalSpace = -xMoment;
                double yMomentInCanonicalSpace = -yMoment;
                double xKnownSolutionInCanonicalSpace = -xKnownSolution;
                double yKnownSolutionInCanonicalSpace = -yKnownSolution;

                yMomentInCanonicalSpace = ((yMomentInCanonicalSpace)>=(0.)?(yMomentInCanonicalSpace):(0.));
                fitFromMomentByBinarySearchCanonicalCase(1., xMomentInCanonicalSpace, yMomentInCanonicalSpace,
                                                         verboseLevel,
                                                         xKnownSolutionInCanonicalSpace, yKnownSolutionInCanonicalSpace);

                // Convert back to original space: both x and y flipped.
                // This is just rotating the rotation of the CatenaryRotated.
                this.cosRotation *= -1.;
                this.sinRotation *= -1.;
            }
            else
            {
                // TODO: implement more cases!
                do {if (true) throw new Error("Unimplemented at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+658 +")"); } while (false);
                if (verboseLevel >= 1) System.out.println("                out CatenaryRotated.fitFromMomentByBinarySearch(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+(Double.isNaN(xKnownSolution)?"":", xKnownSolution="+xKnownSolution+", yKnownSolution="+yKnownSolution)+") (unimplemented)");
                return;
            }

            double desiredMoment[] = {xMoment, yMoment};
            double gotMoment[] = new double[2];

            this.integrate(this.t0, this.t1, gotMoment);

            if (verboseLevel >= 1) System.out.println("                  answer this="+this);
            if (verboseLevel >= 1) System.out.println("                  desiredMoment="+VecMath.toString(desiredMoment));
            if (verboseLevel >= 1) System.out.println("                  gotMoment="+VecMath.toString(gotMoment));

            do { if (!((VecMath.dist(desiredMoment,gotMoment))<=(1e-6))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+672 +"): (" + "VecMath.dist(desiredMoment,gotMoment)" + ")" + "<=" + "(" + "1e-6" + ") ("+(VecMath.dist(desiredMoment,gotMoment))+" vs. "+(1e-6)+")"); } while (false); // TODO: make this relative to problem scale? not sure
            //CHECK_LE(VecMath.dist(desiredMoment,gotMoment), 1e-5); // TODO: make this relative to problem scale? not sure
            //CHECK_LE(VecMath.dist(desiredMoment,gotMoment), 1e-4); // TODO: make this relative to problem scale? not sure
            //CHECK_LE(VecMath.dist(desiredMoment,gotMoment), 1e-1); // TODO: ok this is ridiculous
            if (goodAndBadOut != null || verboseLevel >= 1)
            {
                String message = "    INTERNAL GOOD: CatenaryRotated.fitFromMomentByBinarySearch(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+(Double.isNaN(xKnownSolution)?"":", xKnownSolution="+xKnownSolution+", yKnownSolution="+yKnownSolution)+") succeeded: got moment "+VecMath.toString(gotMoment)+", error="+VecMath.dist(desiredMoment,gotMoment);
                if (goodAndBadOut != null)
                {
                    goodAndBadOut.println(message);
                    goodAndBadOut.flush();
                }
                if (verboseLevel >= 1)
                    System.out.println(message);
            }
        }
        catch (Error e)
        {
            // more descriptive error
            e = new Error("    INTERNAL ERROR: CatenaryRotated.fitFromMomentByBinarySearch(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+(Double.isNaN(xKnownSolution)?"":", xKnownSolution="+xKnownSolution+", yKnownSolution="+yKnownSolution)+") failed: "+e.getMessage());
            if (goodAndBadOut != null)
            {
                goodAndBadOut.println(e.getMessage());
                goodAndBadOut.flush();
            }
            if (XXX_ALLOW_FITFROMMOMENT_FAILURE)
            {
                System.err.println(e.getMessage());
                // but proceed
            }
            else
                throw e;
        }


        if (verboseLevel >= 1) System.out.println("                out CatenaryRotated.fitFromMomentByBinarySearch(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+(Double.isNaN(xKnownSolution)?"":", xKnownSolution="+xKnownSolution+", yKnownSolution="+yKnownSolution)+"), returning this="+this);
    } // fitFromMomentByBinarySearch

    /**
    * Set members to be the parameters of the catenary
    * passing through points (x0,y0),(x1,y1)
    * with given moment (i.e. integral with respect to arc length).
    * Caveat: this is done numerically.
    * In general there may be 1, 3, or 2 solutions;
    * if there are more than 1 solutions, this function may find one of them,
    * or it may fail to converge.
    * If the function is not 1-to-1 in a neighborhood of the solution,
    * it will fail to converge.
    * If it fails to converge, [XXX what?] is thrown.
    * XXX use current contents as initial guess?
    */
    public void fitFromMoment(double x0, double y0,
                              double x1, double y1,
                              double xMoment, double yMoment,
                              com.donhatchsw.compat.ArrayList newtonPathOut,
                              int verboseLevel)
    {
        fitFromMomentInternal(x0,y0, x1,y1, xMoment,yMoment, newtonPathOut, verboseLevel,
                              Double.NaN, Double.NaN);

    }
    private void fitFromMomentInternal(double x0, double y0,
                                       double x1, double y1,
                                       double xMoment, double yMoment,
                                       com.donhatchsw.compat.ArrayList newtonPathOut,
                                       int verboseLevel,
                                       double xKnownSolution, double yKnownSolution) // XXX debug params-- figure out what I want here
    {
        int fitVerboseLevel = 0; // XXX and this too?
        if (verboseLevel >= 1) System.out.println("            in CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+")");

        // XXX eventually it should handle all cases, but for now, don't try it in cases where we know it's unnecessary and unimplemented, to reduce noise
        // XXX or, actually... well it's slower, so should try newton where it succeeds... ?
        //boolean tryBinarySearch = true;
        boolean tryBinarySearch = ((((x0)-(-1.)) <= (1e-12)) && (((-1.)-(x0)) <= (1e-12)));
        //boolean tryBinarySearch = false;
        if (tryBinarySearch)
        {
            fitFromMomentByBinarySearch(x0,y0, x1,y1, xMoment,yMoment, newtonPathOut, verboseLevel, xKnownSolution, yKnownSolution);
            if (verboseLevel >= 1) System.out.println("            out CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+") (via binary search)");
            return;
        }

        double dist = MyMath.hypot(y1-y0, x1-x0);
        double desiredMoment[] = {xMoment, yMoment};

        // Represent a solution by polar coords slack,downAngle,
        // converted to rectangular coords x,y:
        //  x = slack * cos(downAngle)
        //  y = slack * sin(downAngle)
        // We will do a numeric solve for x,y.
        final int verboseLevelFinal = verboseLevel;
        final int fitVerboseLevelFinal = fitVerboseLevel;
        final com.donhatchsw.compat.ArrayList newtonPathOutFinal = newtonPathOut;
        final boolean inJ[] = {false};
        final double x0final = x0;
        final double y0final = y0;
        final double x1final = x1;
        final double y1final = y1;

        NewtonSolver.Fun fun = new NewtonSolver.Fun(2) {
            @Override public void f(double xy[], double answerIntegral[])
            {
                if (verboseLevelFinal >= 2) System.out.println("                in f(xy = "+Arrays.toStringCompact(xy)+")");

                // use self as scratch catenary
                CatenaryRotated self = CatenaryRotated.this;
                self.fitFromRectangularCoords(x0final,y0final, x1final,y1final, xy[0], xy[1], fitVerboseLevelFinal);

                self.integrate(self.t0, self.t1, answerIntegral);

                if (!inJ[0] && newtonPathOutFinal != null)
                {
                    newtonPathOutFinal.add(new double[][] {VecMath.copyvec(xy), VecMath.copyvec(answerIntegral)});
                }
                if (verboseLevelFinal >= 2) System.out.println("                out f(xy = "+Arrays.toStringCompact(xy)+"), returning answerIntegral="+Arrays.toStringCompact(answerIntegral));
            }
            @Override public void J(double xy[], double fxy[], double answerJacobian[][])
            {
                if (verboseLevelFinal >= 2) System.out.println("            in J");
                inJ[0] = true;
                try
                {
                    super.J(xy, fxy, answerJacobian);
                }
                finally
                {
                    inJ[0] = false; // executed even on the way out of a throw
                }
                if (verboseLevelFinal >= 2)
                {
                    System.out.println("        " + "answerJacobian" + " =\n" + VecMath.toString(answerJacobian));
                    {System.out.print("        "); System.out.println("VecMath.conditionNumber(answerJacobian)" + " = " + (VecMath.conditionNumber(answerJacobian)));};
                    System.out.println("        " + "VecMath.singularValues(answerJacobian)" + " = " + VecMath.toString(VecMath.singularValues(answerJacobian)));
                }
                if (verboseLevelFinal >= 2) System.out.println("            out J");
            }
            @Override public double tol()
            {
                // Somewhat dog science:
                // When using adaptive flag,
                // 1e-4 makes it freak out and confidence test fail currently (evaluation functions not stabilized).
                // 1e-6 fixes it but makes it slow down when past the switch (which is the numerically challenging part)
                // But I think 1e-6 is probably better in general anyway...
                // assuming problem has been scaled to unit size.
                return 1e-6;
            }
        };

        // Make an initial guess-- this gets it in the correct upper or lower
        // half-plane, but is otherwise very rough.
        double xMomentIfTaut = (x0+x1)*.5 * dist;
        double yMomentIfTaut = (y0+y1)*.5 * dist;
        double xInitialGuess = xMoment - xMomentIfTaut;
        double yInitialGuess = yMoment - yMomentIfTaut;
        double xyAnswer[] = {xInitialGuess, yInitialGuess};
        boolean adaptiveFlag = false; // setting this to true makes the TRY_TO_DO_IT_RIGHT plan paths look much better in demo3 (since evaluation functions not stable yet)... but it makes it horribly slow instead of just freaking out!  so, leaving this false; need to fix the problem instead.
        boolean amoebaFlag = false; // XXX make this configurable?
        if (amoebaFlag)
        {
            int maxIterations = 1000;
            solveUsingMinimizer(xyAnswer,
                               desiredMoment,
                               fun,
                               10,
                               maxIterations,
                               adaptiveFlag);
        }
        else
            NewtonSolver.solve(xyAnswer,
                               desiredMoment,
                               fun,
                               10,
                               1000,
                               adaptiveFlag);

        if (newtonPathOut != null)
            newtonPathOut.add(new double[][]{null, desiredMoment}); // special entry for the target

        this.fitFromRectangularCoords(x0,y0, x1,y1, xyAnswer[0], xyAnswer[1], fitVerboseLevelFinal);
        double gotMoment[] = new double[2];
        this.integrate(this.t0, this.t1, gotMoment);
        if (verboseLevel >= 1) System.out.println("              answer this="+this);
        if (verboseLevel >= 1) System.out.println("              desiredMoment="+VecMath.toString(desiredMoment));
        if (verboseLevel >= 1) System.out.println("              gotMoment="+VecMath.toString(gotMoment));

        try
        {
            do { if (!((VecMath.dist(desiredMoment,gotMoment))<=(1e-6))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+860 +"): (" + "VecMath.dist(desiredMoment,gotMoment)" + ")" + "<=" + "(" + "1e-6" + ") ("+(VecMath.dist(desiredMoment,gotMoment))+" vs. "+(1e-6)+")"); } while (false); // TODO: make this relative to problem scale? not sure
            if (goodAndBadOut != null || verboseLevel >= 1)
            {
                String message = "    INTERNAL GOOD: CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+") succeeded: got moment "+VecMath.toString(gotMoment)+", error="+VecMath.dist(desiredMoment,gotMoment);
                if (goodAndBadOut != null)
                {
                    goodAndBadOut.println(message);
                    goodAndBadOut.flush();
                }
                if (verboseLevel >= 1)
                    System.out.println(message);
            }
        }
        catch (Error e)
        {
            // more descriptive error
            e = new Error("    INTERNAL ERROR: CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+") failed: got moment "+VecMath.toString(gotMoment)+", error="+VecMath.dist(desiredMoment,gotMoment));
            if (goodAndBadOut != null)
            {
                goodAndBadOut.println(e.getMessage());
                goodAndBadOut.flush();
            }
            if (XXX_ALLOW_FITFROMMOMENT_FAILURE)
            {
                System.err.println(e.getMessage());
                // but proceed
            }
            else
                throw e;
        }
        if (verboseLevel >= 1) System.out.println("            out CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+"), returning this="+this);
    } // fitFromMoment


    private void fitFromRectangularCoords(double x0, double y0,
                                          double x1, double y1,
                                          double x, double y, // slack,downAngle in rectangular coords
                                          int verboseLevel)
    {
        if (verboseLevel >= 1) System.out.println("                in CatenaryRotated.fitFromRectangularCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", x="+x+" y="+y+")");
        double slack = MyMath.hypot(x, y);
        do { if (!(slack >= 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+901 +"): " + "slack >= 0." + ""); } while (false); // XXX I've seen this fail, in demo3, but I guess that must mean there's nans coming in? at least I think it's here that is failing
        double downAngle = Math.atan2(y, x);
        double cosDownAngle = Math.cos(downAngle);
        double sinDownAngle = Math.sin(downAngle);
        // note cosDownAngle,sinDownAngle are just x,y normalized, robustly.
        // if I had a robust normalization function that I trusted, I'd use that instead.
        this.fitFromPolarCoords(x0,y0, x1,y1, slack, cosDownAngle, sinDownAngle, verboseLevel);
        if (verboseLevel >= 1) System.out.println("                out CatenaryRotated.fitFromRectangularCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", x="+x+" y="+y+")");
    } // fitFromRectangularCoords

    private void fitFromPolarCoords(double x0, double y0,
                                    double x1, double y1,
                                    double slack,
                                    double cosDownAngle,
                                    double sinDownAngle,
                                    int verboseLevel)
    {
        if (verboseLevel >= 1) System.out.println("                    in CatenaryRotated.fitFromPolarCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+" c="+cosDownAngle+" s="+sinDownAngle+")");
        // rotation = downAngle - (-pi/2)
        this.cosRotation = -sinDownAngle;
        this.sinRotation = cosDownAngle;
        double x0Unrotated = xPartOfUnrotated(this.cosRotation, this.sinRotation, x0, y0);
        double y0Unrotated = yPartOfUnrotated(this.cosRotation, this.sinRotation, x0, y0);
        double x1Unrotated = xPartOfUnrotated(this.cosRotation, this.sinRotation, x1, y1);
        double y1Unrotated = yPartOfUnrotated(this.cosRotation, this.sinRotation, x1, y1);
        // Note that when fit is done it will call our isValid() (which is admittedly odd)
        // so our cosRotation and sinRotation, as well as the FlippedMaybe members,
        // had better be valid.
        super.fit(x0Unrotated, y0Unrotated,
                  x1Unrotated, y1Unrotated,
                  slack,
                  verboseLevel);
        if (verboseLevel >= 1) System.out.println("                    out CatenaryRotated.fitFromPolarCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+" c="+cosDownAngle+" s="+sinDownAngle+")");
    } // fitFromPolarCoords

    private static final double xPartOfRotated(double cosRotation, double sinRotation, double x, double y)
    {
        return cosRotation * x - sinRotation * y;
    }
    private static final double yPartOfRotated(double cosRotation, double sinRotation, double x, double y)
    {
        return sinRotation * x + cosRotation * y;
    }
    private static final double xPartOfUnrotated(double cosRotation, double sinRotation, double x, double y)
    {
        return cosRotation * x + sinRotation * y;
    }
    private static final double yPartOfUnrotated(double cosRotation, double sinRotation, double x, double y)
    {
        return -sinRotation * x + cosRotation * y;
    }
    private static final void rotate(double cosRotation, double sinRotation, double x, double y, double answer[/*2*/])
    {
        answer[0] = xPartOfRotated(cosRotation, sinRotation, x, y);
        answer[1] = yPartOfRotated(cosRotation, sinRotation, x, y);
    }
    private static final void unRotate(double cosRotation, double sinRotation, double x, double y, double answer[/*2*/])
    {
        answer[0] = xPartOfUnrotated(cosRotation, sinRotation, x, y);
        answer[1] = yPartOfUnrotated(cosRotation, sinRotation, x, y);
    }

    // XXX phase this out, moving to pure catenary routines... I think? confidence test still uses it at the moment.
    // A catenary is a scaled rotated translated cosh.
    // Path-length integrate from v0 to either v1, or to a length of maxLengthToIntegrate,
    // which ever comes first.
    // Answer gets put into answer. The function return value is the arc length.
    // vFinal is the point that the integral went to (either v1, or the point at distance maxLengthToIntegrate along the curve).
    private static double integralOfCatenaryWithEndpointsRectangular(double v0[/*2*/],
                                                                     double v1[/*2*/],
                                                                     double x, double y, // slack,downAngle in rectangular coords
                                                                     double maxLengthToIntegrate,
                                                                     double answer[/*2*/],
                                                                     double vFinal[/*2*/],
                                                                     double aFinal[/*2*/],
                                                                     CatenaryRotated scratchCatenaryRotated,
                                                                     int debugLevel) // 0: nothing, 1: in/out, 2: a bit more
    {
        int fitVerboseLevel = debugLevel;
        if (debugLevel >= 1) System.out.println("            in integralOfCatenaryWithEndpointsRectangular");
        if (debugLevel >= 2) System.out.println("              v0 = "+VecMath.toString(v0));
        if (debugLevel >= 2) System.out.println("              v1 = "+VecMath.toString(v1));
        if (debugLevel >= 2) System.out.println("              x = "+x+" y = "+y);
        if (debugLevel >= 2) System.out.println("              maxLengthToIntegrate = "+maxLengthToIntegrate);

        scratchCatenaryRotated.fitFromRectangularCoords(v0[0], v0[1], v1[0], v1[1], x, y, fitVerboseLevel);
        double t0 = scratchCatenaryRotated.t0;
        double t1 = scratchCatenaryRotated.t1;
        double arcLength = t1 - t0;
        if (maxLengthToIntegrate < arcLength)
        {
            if (debugLevel >= 2) System.out.println("              clamping arcLength from "+arcLength+" to "+maxLengthToIntegrate);
            arcLength = maxLengthToIntegrate;
            t1 = t0 + maxLengthToIntegrate;
        }
        if (debugLevel >= 1) System.out.println("                scratchCatenaryRotated.{cos,sin}Rotation = "+scratchCatenaryRotated.cosRotation+", "+scratchCatenaryRotated.sinRotation);
        scratchCatenaryRotated.integrate(t0, t1, answer);
        if (debugLevel >= 1) System.out.println("              integral answer = "+VecMath.toString(answer));
        if (vFinal != null)
        {
            scratchCatenaryRotated.evaluate(t1, vFinal);
            if (debugLevel >= 1) System.out.println("              vFinal = "+VecMath.toString(vFinal));
        }
        if (aFinal != null)
        {
            scratchCatenaryRotated.differentiate(t1, aFinal);
            if (debugLevel >= 1) System.out.println("              aFinal = "+VecMath.toString(aFinal));
        }
        if (debugLevel >= 1) System.out.println("            out integralOfCatenaryWithEndpointsRectangular, returning arcLength="+arcLength);
        return arcLength;
    } // integralOfCatenaryWithEndpointsRectangular

    public String toString()
    {
       StringBuffer sb = new StringBuffer();
       sb.append("{cos=");
       sb.append(this.cosRotation);
       sb.append(", sin=");
       sb.append(this.sinRotation);
       sb.append(", ");
       sb.append(super.toString());
       sb.append("}");
       return sb.toString();
    }

    public static void confidenceTests()
    {
        System.out.println("    in confidenceTests");

        int testVerboseLevel = 2; // 0 = nothing, 1 = basic outer flow, 2 = dots at loop iterations, 3 = trace all loop iterations

        if (true)
        {
            System.out.println("        testing fitFromMomentByBinarySearch...");
            // Test fitFromMomentByBinarySearch.
            // Strategy: start with an xy, apply the function forward to get an xMoment,yMoment,
            // then call fitFromMomentByBinarySearch with xy passed in as secret debug params.
            // It should find xy, while checking that all its refinements
            // on the way to finding xy are correct.
            CatenaryRotated scratchCatenaryRotated = new CatenaryRotated();
            //int nXsteps = 1000;
            //int nYsteps = 1000;
            int nXsteps = 500;
            int nYsteps = 500;
            //int nXsteps = 200;
            //int nYsteps = 200;
            //int nXsteps = 100;
            //int nYsteps = 100;
            //int nXsteps = 50;
            //int nYsteps = 50;
            //int nXsteps = 10;
            //int nYsteps = 10;
            for (int iY = 0; iY < nYsteps+1; ++iY)
            {
                double y = ((1-(iY/(double)nYsteps))*(-1.) + (iY/(double)nYsteps)*(1.));
                if (y > 0.)
                {
                    System.out.println("            not doing positive y!");
                    continue;
                }
                System.out.println("            y = "+y);
                for (int iX = 0; iX < nXsteps+1; ++iX)
                {
                    double x = ((1-(iX/(double)nXsteps))*(-1.) + (iX/(double)nXsteps)*(1.));

                    System.out.println("              xy = "+x+","+y);
                    double moment[] = new double[2];
                    if (x == 0 && y == 0)
                    {
                        System.out.println("I AM SO CONFUSED!");
                        continue;
                    }
                    scratchCatenaryRotated.fitFromRectangularCoords(-1.,0., 0.,0., x,y, 0);
                    scratchCatenaryRotated.integrate(scratchCatenaryRotated.t0, scratchCatenaryRotated.t1, moment);

                    if (((0. <(moment[1]))&&((moment[1])< 1e-15))) moment[1] = 0.; // XXX HACK to make it use the currently implemented code path, for now

                    int implementationVerboseLevel = 0;
                    scratchCatenaryRotated.fitFromMomentInternal(-1.,0., 0.,0., moment[0],moment[1], null, implementationVerboseLevel, x,y);
                }
            }
            System.out.println("        done testing fitFromMomentByBinarySearch");
            if (true)
            {
                System.out.println("WARNING: Exiting prematurely!");
                System.exit(1);
            }
        }
        else
        {
            System.out.println("WARNING: fitFromMomentByBinarySearch tests disabled");
        }


        if (false)
        {
            CatenaryRotated scratchCatenaryRotated = new CatenaryRotated();

            double downAngles[] = {-Math.PI/2., -Math.PI/4, 0., Math.PI/2, Math.PI};
            double invScales[] = {1., .5, 2., 0.};
            double xTranslates[] = {0., 2., -2.};
            double yTranslates[] = {0., 2., -2.};
            double x0s[] = {0.,-1.,-2.,1.,2.};
            //double x1s[] = {1.,2.,0.,-1.,-2.};
            double x1s[] = x0s; // XXX get rid

            for (int ix0 = 0; ix0 < x0s.length; ++ix0)
            for (int ix1 = 0; ix1 < x1s.length; ++ix1)
            {
                double x0 = x0s[ix0];
                double x1 = x1s[ix1];

                if (x1 < x0)
                {
                    // In constructing the example, we always go left to right.
                    // Don't fret, we'll rotate to all sorts of orientations.
                    continue;
                }

                if (testVerboseLevel >= 1) System.out.println("      ===============================================================");
                if (testVerboseLevel >= 1) System.out.println("      x0 = "+x0);
                if (testVerboseLevel >= 1) System.out.println("      x1 = "+x1);

                double sinhx0 = MyMath.sinh(x0);
                double sinhx1 = MyMath.sinh(x1);
                double coshx0 = MyMath.cosh(x0);
                double coshx1 = MyMath.cosh(x1);
                double v0[] = {x0, coshx0};
                double v1[] = {x1, coshx1};
                if (testVerboseLevel >= 1) System.out.println("      v0 = "+VecMath.toString(v0));
                if (testVerboseLevel >= 1) System.out.println("      v1 = "+VecMath.toString(v1));

                // Parametrizing cosh by arc length between those endpoints,
                // this part of the cosh curve is:
                //      <asinh(t), sqrt(1+t^2)> for x in [x0,x1]
                //                              i.e. for t in [sinh(x0),sinh(x1)]
                // The arc length of that part is sinh(x1) - sinh(x0).
                // The integral of that part is:
                //      {-sqrt(1+t^2) + t*asinh(t),
                //       (t*sqrt(1+t^2) + asinh(t))/2}
                // =    {-cosh(x) + sinh(x)*x,
                //       (sinh(x)*cosh(x) + x) / 2}
                double expectedArcLength = sinhx1 - sinhx0;
                double expectedIntegral[] = {
                    (sinhx1*x1-coshx1)-(sinhx0*x0-coshx0),
                    ((sinhx1*coshx1+x1)-(sinhx0*coshx0+x0))*.5,
                };
                double integral[] = new double[2]; // scratch

                double slack = Math.abs(expectedArcLength) - VecMath.dist(v0,v1);

                if (true)
                {
                    // s=1
                    System.out.println(""+"        s=1 case");
                    double x = 0.;
                    double y = -slack;
                    double arcLength = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integral, null, null, scratchCatenaryRotated, 0);
                    if (testVerboseLevel >= 1) {System.out.print("        "); System.out.println("arcLength" + " = " + (arcLength));};
                    if (testVerboseLevel >= 1) {System.out.print("        "); System.out.println("expectedArcLength" + " = " + (expectedArcLength));};
                    do { if (!((arcLength)==(expectedArcLength)||Math.abs((arcLength)-(expectedArcLength))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1161 +"): " +"(" + "arcLength" + ")==(" + "expectedArcLength" + ")+-" + "1e-6" + "" +" ("+(arcLength)+" vs. "+(expectedArcLength)+" +- "+(1e-6)+")" +" (error = "+((arcLength)-(expectedArcLength))+")" ); } while (false);
                    if (testVerboseLevel >= 1) System.out.println("        " + "integral" + " = " + VecMath.toString(integral));
                    if (testVerboseLevel >= 1) System.out.println("        " + "expectedIntegral" + " = " + VecMath.toString(expectedIntegral));
                    do { if (!(VecMath.dist(integral, expectedIntegral) < 1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1164 +"): " + "VecMath.dist(integral, expectedIntegral) < 1e-6" + ""); } while (false);
                }


                double halfLength = VecMath.dist(v0,v1)*.5;
                double expectedIntegralOfSegment[] = VecMath.vxs(VecMath.vpv(v0,v1),halfLength); // length times average
                double expectedArcLengthOfSegment = VecMath.dist(v0,v1);

                // in degenerate test, slack is 1
                // and gravity is from v1 towards v0 (or arbitrary direction if they are the same)
                double slackForDegenerate = 1.; // somewhat arbitrary XXX should try others
                double expectedArcLengthOfDegenerate = expectedArcLengthOfSegment + slackForDegenerate;
                double gravityForDegenerate[] = VecMath.normalize(VecMath.vmv(v0, v1));
                double expectedIntegralOfDegenerate[] = VecMath.vpv(expectedIntegralOfSegment,
                                                                    VecMath.vxs(VecMath.vpsxv(v0,slackForDegenerate/4.,gravityForDegenerate),
                                                                                slackForDegenerate));

                if (true)
                {
                    // s=infinity
                    System.out.println(""+"        s=infinity case");
                    double x = 0.;
                    double y = 0.;
                    double integralOfSegment[] = new double[2];
                    double arcLengthOfSegment = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integralOfSegment, null, null, scratchCatenaryRotated, 0);
                    if (testVerboseLevel >= 1) {System.out.print("        "); System.out.println("arcLengthOfSegment" + " = " + (arcLengthOfSegment));};
                    if (testVerboseLevel >= 1) {System.out.print("        "); System.out.println("expectedArcLengthOfSegment" + " = " + (expectedArcLengthOfSegment));};
                    do { if (!((arcLengthOfSegment)==(expectedArcLengthOfSegment)||Math.abs((arcLengthOfSegment)-(expectedArcLengthOfSegment))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1191 +"): " +"(" + "arcLengthOfSegment" + ")==(" + "expectedArcLengthOfSegment" + ")+-" + "1e-6" + "" +" ("+(arcLengthOfSegment)+" vs. "+(expectedArcLengthOfSegment)+" +- "+(1e-6)+")" +" (error = "+((arcLengthOfSegment)-(expectedArcLengthOfSegment))+")" ); } while (false);
                    if (testVerboseLevel >= 1) System.out.println("        " + "integralOfSegment" + " = " + VecMath.toString(integralOfSegment));
                    if (testVerboseLevel >= 1) System.out.println("        " + "expectedIntegralOfSegment" + " = " + VecMath.toString(expectedIntegralOfSegment));
                    do { if (!(VecMath.dist(integralOfSegment, expectedIntegralOfSegment) < 1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1194 +"): " + "VecMath.dist(integralOfSegment, expectedIntegralOfSegment) < 1e-6" + ""); } while (false);
                }

                if (true)
                {
                    // s=0, gravity from v1 towards v0 (or arbitrary dir if v0=v1)
                    System.out.println(""+"        s=0 case");
                    System.out.println("        " + "gravityForDegenerate" + " = " + VecMath.toString(gravityForDegenerate));
                    System.out.println("        " + "v0" + " = " + VecMath.toString(v0));
                    System.out.println("        " + "v1" + " = " + VecMath.toString(v1));
                    double x = slackForDegenerate * gravityForDegenerate[0];
                    double y = slackForDegenerate * gravityForDegenerate[1];
                    double integralOfDegenerate[] = new double[2];
                    double arcLengthOfDegenerate = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integralOfDegenerate, null, null, scratchCatenaryRotated, 0);
                    if (testVerboseLevel >= 1) {System.out.print("        "); System.out.println("arcLengthOfDegenerate" + " = " + (arcLengthOfDegenerate));};
                    if (testVerboseLevel >= 1) {System.out.print("        "); System.out.println("expectedArcLengthOfDegenerate" + " = " + (expectedArcLengthOfDegenerate));};
                    do { if (!((arcLengthOfDegenerate)==(expectedArcLengthOfDegenerate)||Math.abs((arcLengthOfDegenerate)-(expectedArcLengthOfDegenerate))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1210 +"): " +"(" + "arcLengthOfDegenerate" + ")==(" + "expectedArcLengthOfDegenerate" + ")+-" + "1e-6" + "" +" ("+(arcLengthOfDegenerate)+" vs. "+(expectedArcLengthOfDegenerate)+" +- "+(1e-6)+")" +" (error = "+((arcLengthOfDegenerate)-(expectedArcLengthOfDegenerate))+")" ); } while (false);
                    if (testVerboseLevel >= 1) System.out.println("        " + "integralOfDegenerate" + " = " + VecMath.toString(integralOfDegenerate));
                    if (testVerboseLevel >= 1) System.out.println("        " + "expectedIntegralOfDegenerate" + " = " + VecMath.toString(expectedIntegralOfDegenerate));
                    do { if (!(VecMath.dist(integralOfDegenerate, expectedIntegralOfDegenerate) < 1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1213 +"): " + "VecMath.dist(integralOfDegenerate, expectedIntegralOfDegenerate) < 1e-6" + ""); } while (false);
                }

                if (testVerboseLevel == 2) System.out.print("        "); // indent for dots

                for (int iDownAngle = 0; iDownAngle < downAngles.length; ++iDownAngle)
                for (int iInvScale = 0; iInvScale < invScales.length; ++iInvScale)
                for (int iXTranslate = 0; iXTranslate < xTranslates.length; ++iXTranslate)
                for (int iYTranslate = 0; iYTranslate < yTranslates.length; ++iYTranslate)
                {
                    double downAngle = downAngles[iDownAngle];
                    double invScale = invScales[iInvScale];
                    double translate[] = {xTranslates[iXTranslate], yTranslates[iYTranslate]};

                    if (testVerboseLevel >= 3) System.out.println("            ---------------------------------------------------------------");
                    if (testVerboseLevel >= 3) System.out.println("            downAngle="+((downAngle)*(180./Math.PI))+"deg invScale="+invScale+" translate="+VecMath.toString(translate));


                    // we're really doing two fundamentally different tests,
                    // depending on whether invScale is 0 or not.
                    // I think it ends up exercising everything though.
                    // XXX except near-0 and near-infinity, which we need to exercise too

                    double rotateDownAngleToMinusYAxis = -Math.PI/2 - downAngle;
                    double c = Math.cos(rotateDownAngleToMinusYAxis);
                    double s = Math.sin(rotateDownAngleToMinusYAxis);
                    double rotateDownAngleToMinusYAxisMatrix[][] = { // row oriented
                       { c,s},
                       {-s,c},
                    };
                    // rotate minus Y axis to down angle
                    double v0Transformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, v0); // by inverse of matrix
                    if (invScale != 0.)
                        VecMath.vxs(v0Transformed, v0Transformed, 1./invScale);
                    VecMath.vpv(v0Transformed, v0Transformed, translate);
                    double v1Transformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, v1); // by inverse of matrix
                    if (invScale != 0.)
                        VecMath.vxs(v1Transformed, v1Transformed, 1./invScale);
                    VecMath.vpv(v1Transformed, v1Transformed, translate);

                    double expectedIntegralTransformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix,
                                                                       invScale==0. ? expectedIntegralOfSegment : expectedIntegral);
                    if (invScale != 0.)
                        VecMath.vxs(expectedIntegralTransformed, expectedIntegralTransformed, 1./(invScale*invScale));
                    VecMath.vpsxv(expectedIntegralTransformed, expectedIntegralTransformed,
                                  invScale==0. ? VecMath.dist(v0,v1) : expectedArcLength/invScale,
                                  translate);
                    double expectedArcLengthTransformed = invScale==0. ? expectedArcLengthOfSegment : expectedArcLength/invScale;

                    if (true)
                    {
                        double integralTransformed[] = new double[2];
                        // 0,-slack/invScale rotated by rotation that takes YAxis to downAngle

                        // keep in mind the invScale=0 test is really a different test, don't expect it to be totally analogous
                        double xy[] = {0, invScale==0. ? 0. : -slack/invScale};
                        xy = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, xy); // by inverse of matrix
                        double x = xy[0];
                        double y = xy[1];
                        double arcLengthTransformed = integralOfCatenaryWithEndpointsRectangular(v0Transformed, v1Transformed, x, y, Double.POSITIVE_INFINITY, integralTransformed, null, null, scratchCatenaryRotated, 0);
                        if (testVerboseLevel >= 3) System.out.println("                arcLengthTransformed = "+arcLengthTransformed);
                        if (testVerboseLevel >= 3) System.out.println("                expectedArcLengthTransformed = "+expectedArcLengthTransformed);
                        do { if (!((arcLengthTransformed)==(expectedArcLengthTransformed)||Math.abs((arcLengthTransformed)-(expectedArcLengthTransformed))<=1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1275 +"): " +"(" + "arcLengthTransformed" + ")==(" + "expectedArcLengthTransformed" + ")+-" + "1e-6" + "" +" ("+(arcLengthTransformed)+" vs. "+(expectedArcLengthTransformed)+" +- "+(1e-6)+")" +" (error = "+((arcLengthTransformed)-(expectedArcLengthTransformed))+")" ); } while (false);
                        if (testVerboseLevel >= 3) System.out.println("                integralTransformed = "+VecMath.toString(integralTransformed));
                        if (testVerboseLevel >= 3) System.out.println("                expectedIntegralTransformed = "+VecMath.toString(expectedIntegralTransformed));
                        do { if (!(VecMath.dist(integralTransformed, expectedIntegralTransformed) < 1e-6)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1278 +"): " + "VecMath.dist(integralTransformed, expectedIntegralTransformed) < 1e-6" + ""); } while (false);
                    }

                    if (testVerboseLevel == 2) System.out.print(".");
                    if (testVerboseLevel >= 3) System.out.println("            ---------------------------------------------------------------");
                }
                if (testVerboseLevel == 2) System.out.println(); // newline after dots
                if (testVerboseLevel >= 1) System.out.println("      ===============================================================");
            } // for x0,x1
        }
        else
        {
            System.out.println("WARNING: general tests disabled");
        }

        if (true)
        {
            System.out.println("      testing some fitFromMoment cases that have been problematic");
            String testCases[] = {

                // one of zillion failures when inverseFunctionFlag is true, wtf?
                "x0=0.0, y0=0.0, x1=1.0, y1=0.0, xMoment=0.5586369584951553, yMoment=-0.021632316067343338",
                null,

                // doesn't fail, but seems to be one of the ones contributing to taking a long time
                "x0=-1.0, y0=5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.523593452221171, yMoment=-0.1740891838517301",
                null,

                // binary search fail using overhauled algorithm (early try)
                "x0=-1.0, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.603074224821478, yMoment=-0.3471447106867807",
                "x0=-1.0, y0=1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000009124973, yMoment=-2.0541303119347987E-5",
                "x0=-1.0, y0=1.6653345369377348E-16, x1=0.0, y1=0.0, xMoment=-0.5000000007967902, yMoment=-1.953474507895847E-5",
                "x0=-1.0, y0=2.220446049250313E-16, x1=0.0, y1=0.0, xMoment=-0.5000000017031035, yMoment=-2.8018482983005466E-5",
                "x0=-1.0, y0=2.7755575615628914E-16, x1=0.0, y1=0.0, xMoment=-0.5000000016481783, yMoment=-2.736321024068844E-5",


                // rare current demo3 failure of binary search,
                // found by going backwards in time
                "x0=-1.0, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.5000000000000049, yMoment=-4.491159324992999E-8",
                // another now-rare failure from demo3
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.500000001368664, yMoment=-2.465423788210186E-5",
                // yet another now-rare failure from demo3 (problem went away)
                "x0=-1.0000000000000002, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.5000000024486341, yMoment=-3.2242666413592747E-5",
                // (this one seems to work now)
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.7689396962750554, yMoment=-0.8971405863140336",
                // more rare failures from demo3
                "x0=-1.0, y0=1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000026027122, yMoment=-2.3513905908628674E-5",
                "x0=-1.0, y0=1.0842021724855044E-19, x1=0.0, y1=0.0, xMoment=-0.5000000004383723, yMoment=-1.537956412758383E-5",
                "x0=-1.0, y0=6.938893903907228E-18, x1=0.0, y1=0.0, xMoment=-0.5000000004667464, yMoment=-1.6308912242527646E-5",
                "x0=-0.9999999999999999, y0=-3.469446951953614E-18, x1=0.0, y1=0.0, xMoment=-0.5000000026937884, yMoment=-2.354314053128366E-5",
                "x0=-1.0, y0=-5.204170427930421E-18, x1=0.0, y1=0.0, xMoment=-0.5000000024450638, yMoment=-2.3640368814984748E-5",
                "x0=-1.0, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.5000000012589669, yMoment=-2.3984103306118332E-5",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.500000000815029, yMoment=-2.045622020535598E-5",
                "x0=-0.9999999999999999, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000010278508, yMoment=-2.1717435486762193E-5",
                "x0=-1.0, y0=-2.7755575615628914E-17, x1=0.0, y1=0.0, xMoment=-0.50000000067818, yMoment=-1.8103085655765683E-5",
                "x0=-1.0, y0=-3.885780586188048E-16, x1=0.0, y1=0.0, xMoment=-0.5000000010799698, yMoment=-2.1836648062212305E-5",
                "x0=-0.9999999999999999, y0=1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000000917821, yMoment=-8.031659965962445E-6",
                "x0=-1.0, y0=5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.5000000002294929, yMoment=-4.664810677346143E-6",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.5000000011091066, yMoment=-2.2134440393506427E-5",
                "x0=-1.0, y0=-3.885780586188048E-16, x1=0.0, y1=0.0, xMoment=-0.5000000027731453, yMoment=-2.359706603083378E-5",
                "x0=-1.0000000000000002, y0=3.122502256758253E-16, x1=0.0, y1=0.0, xMoment=-0.5000000003953019, yMoment=-1.4292770150282907E-5",
                "x0=-0.9999999999999999, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.500000000948514, yMoment=-2.1283840896585415E-5",
                "x0=-1.0, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000014466168, yMoment=-2.515280803053188E-5",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.5000000010894938, yMoment=-2.200969287505239E-5",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.5000000012437, yMoment=-2.3594793053360874E-5",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.500000000218578, yMoment=-4.453486824623548E-6",

                // case where binary search special case criteria screwed up (fixed)
                "x0=-0.9999999999999999, y0=2.7755575615628914E-16, x1=0.0, y1=0.0, xMoment=-0.5000000000000001, yMoment=2.7755575615628914E-17",

                // current binary search fail as of this writing (not any more)
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.946, yMoment=-0.8031013757681627, xKnownSolution=0.0, yKnownSolution=-0.892",

                // current binary search fail as of this writing (not any more)
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.8436336645308535, yMoment=-0.881820491280086, xKnownSolution=0.24, yKnownSolution=-0.96",

                // binary search fail in first quadrant! (fixed)
                "x0=-0.9999999999999999, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.49999999999999994, yMoment=-1.8932633238932794E-12",
                // binary search fail in first quadrant! (fixed)
                "x0=-1.0, y0=2.7755575615628914E-16, x1=0.0, y1=0.0, xMoment=-0.5000000002805953, yMoment=-4.618879364315376E-6",

                // binary search fail using old quadrant determination
                "x0=-0.9999999999999998, y0=1.6653345369377348E-16, x1=0.0, y1=0.0, xMoment=-0.49999999999999983, yMoment=-5.281938775247852E-11",
                "x0=-0.9999999999999998, y0=1.6653345369377348E-16, x1=0.0, y1=0.0, xMoment=-0.49999999999999994, yMoment=-4.567457523307894E-13",
                "x0=-0.9999999999999998, y0=-6.106226635438361E-16, x1=0.0, y1=0.0, xMoment=-0.4999999999999999, yMoment=-3.716194019176555E-13",

                // binary search fail... and moment isn't even near momentIfTaut, shouldn't be problematic!
                "x0=-1.0, y0=1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.6843006919963104, yMoment=-0.5234607164665921",
                "x0=-1.0000000000000002, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.676447513441035, yMoment=-0.6023753364873917",

                // binary search was failing with 1e-6, required 1e-5 (but fixed)
                "x0=-0.9999999999999998, y0=1.0755285551056204E-16, x1=0.0, y1=0.0, xMoment=-0.49999999999999983, yMoment=-2.498712573656414E-10",
                // binary search bigger fails even with 1e-5
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.006350760623254819, yMoment=-0.0026522100650424284",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.008020400401857962, yMoment=-0.002739893281585962",
                "x0=-1.0, y0=2.220446049250313E-16, x1=0.0, y1=0.0, xMoment=-0.680019195378992, yMoment=-0.511426670862883",
                "x0=-0.9999999999999998, y0=-8.153200337090993E-17, x1=0.0, y1=0.0, xMoment=-0.6091718977961643, yMoment=-0.3417508555717841",
                "x0=-1.0000000000000002, y0=2.7755575615628914E-16, x1=0.0, y1=0.0, xMoment=-0.610018286447814, yMoment=-0.34229908659263464",
                "x0=-0.9999999999999999, y0=1.249000902703301E-16, x1=0.0, y1=0.0, xMoment=-0.6214686214641667, yMoment=-0.34730213006279237",
                "x0=-1.0, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.645753911494539, yMoment=-0.3290585535800697",
                "x0=-0.9999999999999999, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.6458994422138906, yMoment=-0.3276891721641374",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.6460373269290829, yMoment=-0.3262968427253347",
                "x0=-0.9999999999999999, y0=-2.220446049250313E-16, x1=0.0, y1=0.0, xMoment=-0.6461672397380385, yMoment=-0.32488113795395424",
                "x0=-0.9999999999999999, y0=1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.6463178131763557, yMoment=-0.3218921006233052",
                "x0=-1.0, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.6464029351055457, yMoment=-0.3203858421390253",

                // even with 1e-4
                "x0=-1.0000000000000002, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.5000000000000002, yMoment=-2.1163126806555965E-11",
                "x0=-1.0000000000000002, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.5000000000000002, yMoment=-2.120698061602866E-11",
                "x0=-0.9999999999999998, y0=2.220446049250313E-16, x1=0.0, y1=0.0, xMoment=-0.4999999999999999, yMoment=-2.355921013830198E-12",
                "x0=-1.0000000000000002, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000000000001, yMoment=-9.2148511043888E-15",
                "x0=-1.0000000000000002, y0=1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000000000001, yMoment=-1.4994230856935076E-10",
                "x0=-1.0000000000000002, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.5000000000000001, yMoment=-3.635147738378919E-13",
                "x0=-0.9999999999999997, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.4999999999999999, yMoment=-3.914840673857611E-12",



                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.5036269106706781, yMoment=-0.027290553371898757",
                "x0=-1.0, y0=0.0, x1=0.0, y1=0.0, xMoment=-0.5019665247911539, yMoment=-0.020949377300023747",
                "x0=-1.0, y0=2.220446049250313E-16, x1=0.0, y1=0.0, xMoment=-0.5011288865208755, yMoment=-0.016410201253350465",
                "x0=-0.9999999999999999, y0=2.7755575615628914E-17, x1=0.0, y1=0.0, xMoment=-0.5006712775428778, yMoment=-0.013005663996619649",
                "x0=-1.0, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.5004068444282271, yMoment=-0.01036098511128418",
                "x0=-1.0, y0=-5.551115123125783E-17, x1=0.0, y1=0.0, xMoment=-0.8320025520166806, yMoment=-0.06050328101277758",
                "x0=-1.0, y0=-1.1102230246251565E-16, x1=0.0, y1=0.0, xMoment=-0.4835907692577395, yMoment=-0.010211074002742182",
                "x0=-1.0, y0=2.7755575615628914E-16, x1=0.0, y1=0.0, xMoment=-0.4880273204300428, yMoment=-0.008470672745238716",

            };

            for (int iTestCase = 0; iTestCase < testCases.length; ++iTestCase)
            {
                System.out.println("      fitFromMoment test case "+iTestCase+"/"+testCases.length+":");
                String testCase = testCases[iTestCase];
                if (testCase == null)
                {
                    System.out.println("BREAKING EARLY because of null");
                    System.out.println("WARNING: Exiting prematurely!");
                    System.exit(1);
                }

                String tokens[] = testCase.split(", "); // since java 1.4; okay whatever
                do { if (!(tokens.length == 6 || tokens.length == 8)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1418 +"): " + "tokens.length == 6 || tokens.length == 8" + ""); } while (false);
                double x0 = Double.parseDouble(tokens[0].substring(3));
                double y0 = Double.parseDouble(tokens[1].substring(3));
                double x1 = Double.parseDouble(tokens[2].substring(3));
                double y1 = Double.parseDouble(tokens[3].substring(3));
                double xMoment = Double.parseDouble(tokens[4].substring(8));
                double yMoment = Double.parseDouble(tokens[5].substring(8));
                double xKnownSolution = Double.NaN;
                double yKnownSolution = Double.NaN;
                if (tokens.length == 6)
                {
                    //System.out.println(testCases[iTestCase]);
                    //System.out.println("x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment);
                    do { if (!(("x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment).equals(testCases[iTestCase]))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1431 +"): " + "(\"x0=\"+x0+\", y0=\"+y0+\", x1=\"+x1+\", y1=\"+y1+\", xMoment=\"+xMoment+\", yMoment=\"+yMoment).equals(testCases[iTestCase])" + ""); } while (false);
                }
                else
                {
                    xKnownSolution = Double.parseDouble(tokens[6].substring(15));
                    yKnownSolution = Double.parseDouble(tokens[7].substring(15));
                    do { if (!(("x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+", yMoment="+yMoment+", xKnownSolution="+xKnownSolution+", yKnownSolution="+yKnownSolution).equals(testCases[iTestCase]))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1437 +"): " + "(\"x0=\"+x0+\", y0=\"+y0+\", x1=\"+x1+\", y1=\"+y1+\", xMoment=\"+xMoment+\", yMoment=\"+yMoment+\", xKnownSolution=\"+xKnownSolution+\", yKnownSolution=\"+yKnownSolution).equals(testCases[iTestCase])" + ""); } while (false);
                }

                {System.out.print("        "); System.out.println("x0" + " = " + (x0));};
                {System.out.print("        "); System.out.println("y0" + " = " + (y0));};
                {System.out.print("        "); System.out.println("x1" + " = " + (x1));};
                {System.out.print("        "); System.out.println("y1" + " = " + (y1));};
                {System.out.print("        "); System.out.println("xMoment" + " = " + (xMoment));};
                {System.out.print("        "); System.out.println("yMoment" + " = " + (yMoment));};

                XXX_ALLOW_FITFROMMOMENT_FAILURE = true;
                CatenaryRotated catenaryRotated = new CatenaryRotated();
                com.donhatchsw.compat.ArrayList newtonPath = new com.donhatchsw.compat.ArrayList();
                int implementationVerboseLevel = 2;
                catenaryRotated.fitFromMomentInternal(x0,y0, x1,y1, xMoment,yMoment, newtonPath, implementationVerboseLevel, xKnownSolution, yKnownSolution);
                {System.out.print("        "); System.out.println("catenaryRotated" + " = " + (catenaryRotated));};

                System.out.println("        " + "newtonPath.toArray()" + " = " + Arrays.toStringCompact(newtonPath.toArray()));
                if (true)
                {
                    newtonPath.add(new double[][] {{Double.NaN,Double.NaN},{Double.NaN,Double.NaN}}); // expedience
                    for (int i = 0; (i) < (newtonPath.size()); ++i)
                    {
                        double entry[][] = (double[][])newtonPath.get(i);
                        if (entry[0] == null)
                            entry[0] = new double[] {Double.NaN,Double.NaN}; // expedience
                        // apparently gnuplot likes inf but not nan :-(
                        System.out.println("    NEWTON PATH: "
                                +(Double.isNaN(entry[0][0])?"inf":""+entry[0][0])+" "
                                +(Double.isNaN(entry[0][1])?"inf":""+entry[0][1])+"  "
                                +(Double.isNaN(entry[1][0])?"inf":""+entry[1][0])+" "
                                +(Double.isNaN(entry[1][1])?"inf":""+entry[1][1]));
                    }
                }

                double momentActual[] = new double[2];
                double x0y0Actual[] = new double[2];
                double x1y1Actual[] = new double[2];
                double a0Actual[] = new double[2];
                double a1Actual[] = new double[2];
                catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, momentActual);
                catenaryRotated.evaluate(catenaryRotated.t0, x0y0Actual);
                catenaryRotated.evaluate(catenaryRotated.t1, x1y1Actual);
                catenaryRotated.differentiate(catenaryRotated.t0, a0Actual);
                catenaryRotated.differentiate(catenaryRotated.t1, a1Actual);
                System.out.println("        " + "momentActual" + " = " + VecMath.toString(momentActual));
                // TODO: what's the right tolerance?
                //double tol = 1e-12;
                double tol = 1e-6;
                //double tol = 1e-5;
                //double tol = 1e-4; // lets ByBinarySearch succeed most of the time currently, but maybe should make it better instead
                //double tol = 1e-3; // lets ByBinarySearch succeed currently, but maybe should make it better instead
                //double tol = 1e-1; // ok this is ridiculous
                do { if (!((momentActual[0])==(xMoment)||Math.abs((momentActual[0])-(xMoment))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1490 +"): " +"(" + "momentActual[0]" + ")==(" + "xMoment" + ")+-" + "tol" + "" +" ("+(momentActual[0])+" vs. "+(xMoment)+" +- "+(tol)+")" +" (error = "+((momentActual[0])-(xMoment))+")" ); } while (false);
                do { if (!((momentActual[1])==(yMoment)||Math.abs((momentActual[1])-(yMoment))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1491 +"): " +"(" + "momentActual[1]" + ")==(" + "yMoment" + ")+-" + "tol" + "" +" ("+(momentActual[1])+" vs. "+(yMoment)+" +- "+(tol)+")" +" (error = "+((momentActual[1])-(yMoment))+")" ); } while (false);
                do { if (!((x0y0Actual[0])==(x0)||Math.abs((x0y0Actual[0])-(x0))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1492 +"): " +"(" + "x0y0Actual[0]" + ")==(" + "x0" + ")+-" + "tol" + "" +" ("+(x0y0Actual[0])+" vs. "+(x0)+" +- "+(tol)+")" +" (error = "+((x0y0Actual[0])-(x0))+")" ); } while (false);
                do { if (!((x0y0Actual[1])==(y0)||Math.abs((x0y0Actual[1])-(y0))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1493 +"): " +"(" + "x0y0Actual[1]" + ")==(" + "y0" + ")+-" + "tol" + "" +" ("+(x0y0Actual[1])+" vs. "+(y0)+" +- "+(tol)+")" +" (error = "+((x0y0Actual[1])-(y0))+")" ); } while (false);
                do { if (!((x1y1Actual[0])==(x1)||Math.abs((x1y1Actual[0])-(x1))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1494 +"): " +"(" + "x1y1Actual[0]" + ")==(" + "x1" + ")+-" + "tol" + "" +" ("+(x1y1Actual[0])+" vs. "+(x1)+" +- "+(tol)+")" +" (error = "+((x1y1Actual[0])-(x1))+")" ); } while (false);
                do { if (!((x1y1Actual[1])==(y1)||Math.abs((x1y1Actual[1])-(y1))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1495 +"): " +"(" + "x1y1Actual[1]" + ")==(" + "y1" + ")+-" + "tol" + "" +" ("+(x1y1Actual[1])+" vs. "+(y1)+" +- "+(tol)+")" +" (error = "+((x1y1Actual[1])-(y1))+")" ); } while (false);
                do { if (!((VecMath.norm(a0Actual))==(1.)||Math.abs((VecMath.norm(a0Actual))-(1.))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1496 +"): " +"(" + "VecMath.norm(a0Actual)" + ")==(" + "1." + ")+-" + "tol" + "" +" ("+(VecMath.norm(a0Actual))+" vs. "+(1.)+" +- "+(tol)+")" +" (error = "+((VecMath.norm(a0Actual))-(1.))+")" ); } while (false);
                do { if (!((VecMath.norm(a1Actual))==(1.)||Math.abs((VecMath.norm(a1Actual))-(1.))<=tol)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1497 +"): " +"(" + "VecMath.norm(a1Actual)" + ")==(" + "1." + ")+-" + "tol" + "" +" ("+(VecMath.norm(a1Actual))+" vs. "+(1.)+" +- "+(tol)+")" +" (error = "+((VecMath.norm(a1Actual))-(1.))+")" ); } while (false);
                System.out.println("        seems good!");
            }
            if (false)
            {
                System.out.println("WARNING: Exiting prematurely!");
                System.exit(1);
            }
        }
        else
        {
            System.out.println("WARNING: specific case tests disabled");
        }

        System.out.println("    out confidenceTests");
    } // confidenceTests

    private abstract static class RectangularFunction
    {
        public abstract void apply(double x, double y, double answer[]);
    }

    public static void interactiveDemo1()
    {
        final int eventVerbose = 0; // set to something else to debug
        @SuppressWarnings("serial")
        java.awt.Canvas canvas = new java.awt.Canvas() {

            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            // (For more info on inferior approaches, see ExampleApplet.prejava)
            @Override public boolean isFocusable()
            {
                return true;
            }

            class Model
            {
                double v0[] = {0.,0.};
                double v1[] = {1.,0.};


                class Sample {
                    boolean bad;
                    boolean byBinarySearch;
                    double x0;
                    double x1;
                    double y0;
                    double y1;
                    double xMoment;
                    double yMoment;

                    double xMomentNormalized;
                    double yMomentNormalized;
                    Sample(boolean bad, boolean byBinarySearch, double x0, double y0, double x1, double y1, double xMoment, double yMoment, double xMomentNormalized, double yMomentNormalized)
                    {
                        this.bad = bad;
                        this.byBinarySearch = byBinarySearch;
                        this.x0 = x0;
                        this.x1 = x1;
                        this.y0 = y0;
                        this.y1 = y1;
                        this.yMoment = yMoment;
                        this.yMoment = yMoment;
                        this.xMomentNormalized = xMomentNormalized;
                        this.yMomentNormalized = yMomentNormalized;
                    }
                };
                Sample samples[] = null;

                Model()
                {
                    String goodAndBadInFileName = "GOOD_AND_BAD_IN";
                    java.io.BufferedReader in = null;
                    try
                    {
                        in = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(goodAndBadInFileName)));
                    }
                    catch (java.io.FileNotFoundException e)
                    {
                        System.err.println("Error trying to open file "+goodAndBadInFileName+" for reading: "+e);
                    }
                    if (in != null)
                    {
                       String line = null;
                       com.donhatchsw.compat.regex.Pattern pattern = com.donhatchsw.compat.regex.Pattern.compile(" *INTERNAL (GOOD|ERROR): CatenaryRotated.fitFromMoment((ByBinarySearch)?)\\(x0=([^,]*), y0=([^,]*), x1=([^,]*), y1=([^,]*), xMoment=([^,]*), yMoment=([^),]*)\\).*");
                       System.out.print("Reading samples from "+goodAndBadInFileName+" ... ");
                       System.out.flush();
                       try {
                           com.donhatchsw.compat.ArrayList samplesArrayList = new com.donhatchsw.compat.ArrayList();
                           while ((line = in.readLine()) != null)
                           {
                               //System.out.println("got line: "+line);
                               com.donhatchsw.compat.regex.Matcher matcher = pattern.matcher(line);
                               //PRINT(matcher.matches());
                               do { if (!(matcher.matches())) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1592 +"): " + "matcher.matches()" + ""); } while (false);
                               /*
                               PRINT(matcher.group(1));
                               PRINT(matcher.group(2));
                               PRINT(matcher.group(3));
                               PRINT(matcher.group(4));
                               PRINT(matcher.group(5));
                               PRINT(matcher.group(6));
                               PRINT(matcher.group(7));
                               */
                               String goodOrError = matcher.group(1);
                               String byBinarySearchOrNothing = matcher.group(2);
                               double x0 = Double.parseDouble(matcher.group(4));
                               double y0 = Double.parseDouble(matcher.group(5));
                               double x1 = Double.parseDouble(matcher.group(6));
                               double y1 = Double.parseDouble(matcher.group(7));
                               double xMoment = Double.parseDouble(matcher.group(8));
                               double yMoment = Double.parseDouble(matcher.group(9));
                               //PRINT(goodOrError);
                               //PRINT(x0);
                               //PRINT(y0);
                               //PRINT(x1);
                               //PRINT(y1);
                               //PRINT(xMoment);
                               //PRINT(yMoment);
                               do { if (!(((((x1)-(0.)) <= (1e-12)) && (((0.)-(x1)) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1617 +"): " + "EQ(x1,0.,1e-12)" + ""); } while (false);
                               do { if (!(((((y1)-(0.)) <= (1e-12)) && (((0.)-(y1)) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1618 +"): " + "EQ(y1,0.,1e-12)" + ""); } while (false);
                               do { if (!(((((y0)-(0.)) <= (1e-12)) && (((0.)-(y0)) <= (1e-12))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1619 +"): " + "EQ(y0,0.,1e-12)" + ""); } while (false);
                               do { if (!(((-1.0001 <=(x0))&&((x0)<= 0.)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1620 +"): " + "INRANGE(-1.0001 <=, x0, <= 0.)" + ""); } while (false);
                               if (x0 == 0.)
                               {
                                   // can't normalize-- but we don't get errors on this case anyway
                                   do { if (!(goodOrError.equals("GOOD"))) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1624 +"): " + "goodOrError.equals(\"GOOD\")" + ""); } while (false);
                                   continue;
                               }
                               do { if (!(x0 < 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1627 +"): " + "x0 < 0." + ""); } while (false);
                               // normize to space in which x0,y0 = 0,0  x1,y1=1,0
                               double size = -x0;
                               do { if (!(size > 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/CatenaryRotated.prejava"+"("+1630 +"): " + "size > 0." + ""); } while (false);
                               double xMomentNormalized = -xMoment / ((size)*(size));
                               double yMomentNormalized = yMoment / ((size)*(size));
                               /*
                               PRINT(xMomentNormalized);
                               PRINT(yMomentNormalized);
                               */
                               samplesArrayList.add(new Sample(goodOrError.equals("ERROR"), byBinarySearchOrNothing.equals("ByBinarySearch"), x0,y0, x1,y1, xMoment,yMoment, xMomentNormalized,yMomentNormalized));
                           }
                           System.out.println("done.");
                           samples = (Sample[])samplesArrayList.toArray(new Sample[samplesArrayList.size()]);
                       }
                       catch (java.io.IOException e)
                       {
                            System.err.println("Error reading from file "+goodAndBadInFileName+": "+e);
                       }
                       finally {
                           try {
                               in.close();
                           }
                           catch (java.io.IOException e)
                           {
                                System.err.println("Error trying to close input file "+goodAndBadInFileName+": "+e);
                           }
                       }
                    }
                }

            } // class Model
            class View
            {
                // Really viewing params (could separate into ViewParams and ViewState)...
                boolean antialiasFlag = true; // toggle with 'A'
                boolean showPointsFlag = false; // toggle with 'p'
                boolean showPolarGridFlag = true;
                boolean showRectangularGridFlag = false; // toggle with 'g'
                boolean inverseFunctionFlag = false; // toggle with 'i'

                boolean colorByGoodnessFlag = false; // XXX TODO: provide way to control this. note, turning it on greatly increases amount of stuff drawn so it's slow

                double focus[] = {.5, 0.}; // move with UP/DOWN/LEFT/RIGHT (along with model.v0,v1)
                double logRadius = 1.;
                double radius = Math.pow(2., logRadius);
                double gridRotDegrees = 0.;

                double debugCullFrustumShrink = 1.;

                int nPaintsDone = 0;
            }
            class Controller
            {
            }
            private Model model = new Model();
            private View view = new View();
            private Controller controller = new Controller();
            private com.donhatchsw.awt.MyGraphics mostRecentGraphics = null;


            // SIZE (demo1)
            @Override public java.awt.Dimension getPreferredSize()
            {
                //return new java.awt.Dimension(850,850);
                return new java.awt.Dimension(400,400);
                //return new java.awt.Dimension(200,200);
            }


            // http://stackoverflow.com/questions/1953530/why-does-java-prohibit-static-fields-in-inner-classes
            // interesting!  so we can get around it usually by making the inner class static...
            // but in this case it's anonymous, so it can't be static??  why not?
            // Can I make a case that anonymous subclasses should *always* be static?
            // Think about this.
            private int getQuadrant(double x, double y)
            {
                if (x > 0 && y >= 0) return 1;
                if (y > 0 && x <= 0) return 2;
                if (x < 0 && y <= 0) return 3;
                if (y < 0 && x <= 0) return 4;
                return 0;
            }


            private java.awt.Image backBuffer = null;
            private java.awt.Dimension backBufferSize = null;

            @Override public void update(java.awt.Graphics g) { paint(g); } // don't flash
            // PAINT (demo1)
            @Override public void paint(java.awt.Graphics frontBufferGraphics)
            {
                if (eventVerbose >= 2) System.out.println("    in paint");

                java.awt.Dimension size = this.getSize();
                int w = size.width, h = size.height;
                if (backBuffer == null
                 || !size.equals(backBufferSize))
                {
                    System.out.println("    creating back buffer of size "+w+"x"+h+"");
                    backBuffer = this.createImage(w, h);
                    backBufferSize = size;
                }
                java.awt.Graphics g = backBuffer.getGraphics();
                if (false)
                    g = frontBufferGraphics; // make it single buffered

                if (view.antialiasFlag)
                    ((java.awt.Graphics2D)g).setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                                                              java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
                else
                    ((java.awt.Graphics2D)g).setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                                                              java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);

                int minSize = Math.min(w,h);
                int maxSize = Math.max(w,h);
                double xMinView = view.focus[0] -view.radius*w/minSize;
                double xMaxView = view.focus[0] + view.radius*w/minSize;
                double yMinView = view.focus[1] -view.radius*h/minSize;
                double yMaxView = view.focus[1] + view.radius*h/minSize;
                double xMinCull = view.focus[0] -view.radius*w/minSize * view.debugCullFrustumShrink;
                double xMaxCull = view.focus[0] + view.radius*w/minSize * view.debugCullFrustumShrink;
                double yMinCull = view.focus[1] -view.radius*h/minSize * view.debugCullFrustumShrink;
                double yMaxCull = view.focus[1] + view.radius*h/minSize * view.debugCullFrustumShrink;
                com.donhatchsw.awt.MyGraphics mg = new com.donhatchsw.awt.MyGraphics(g, this.getSize(),
                                               xMinView, xMaxView,
                                               yMinView, yMaxView);

                // Clear to black
                if (g != frontBufferGraphics) // if not single buffered
                {
                    mg.setColor(java.awt.Color.BLACK);
                    mg.fillWindow();
                }


                //
                // Evolve.
                //

                // ...

                //
                // Draw.
                //

                final double xMomentIfTaut = (model.v0[0]+model.v1[0])*.5;
                final double yMomentIfTaut = (model.v0[1]+model.v1[1])*.5;


                // culling frustum
                mg.setColor(java.awt.Color.BLUE);
                mg.drawLine(xMinCull,yMinCull, xMaxCull,yMinCull);
                mg.drawLine(xMaxCull,yMinCull, xMaxCull,yMaxCull);
                mg.drawLine(xMaxCull,yMaxCull, xMinCull,yMaxCull);
                mg.drawLine(xMinCull,yMaxCull, xMinCull,yMinCull);


                if (view.inverseFunctionFlag)
                {
                    // hack to get axes at the right place
                    mg.setColor(new java.awt.Color(64,64,64));
                    mg.drawLine(view.focus[0] + -1., 0., view.focus[0] + 1., 0.);
                    mg.drawLine(view.focus[0] + 0., -1., view.focus[0] + 0., 1.);
                }
                if (!view.inverseFunctionFlag)
                {
                    // axes
                    mg.setColor(new java.awt.Color(64,64,64));
                    mg.drawLine(-1.,0., 1., 0.);
                    mg.drawLine(0.,-1., 0., 1.);

                    // show catenary endpoints
                    mg.setColor(new java.awt.Color(128,128,128));
                    mg.drawPoint(model.v0[0],model.v0[1], 5);
                    mg.drawPoint(model.v1[0],model.v1[1], 5);
                }

                final CatenaryRotated catenaryRotated = new CatenaryRotated(); // scratch
                final double moment[] = new double[2]; // scratch

                // Figure out largest and smallest mag level of interest
                int magLevel0 = 20; // XXX be more scientific
                while (true)
                {
                    double r = Math.pow(2., magLevel0);
                    double cosAndSin[][] = {{1,0},{0,1},{-1,0},{0,-1}};
                    double xMin = Double.POSITIVE_INFINITY;
                    double yMin = Double.POSITIVE_INFINITY;
                    double xMax = Double.NEGATIVE_INFINITY;
                    double yMax = Double.NEGATIVE_INFINITY;
                    for (int i = 0; i < cosAndSin.length; ++i)
                    {
                        double cosAngle = cosAndSin[i][0];
                        double sinAngle = cosAndSin[i][1];
                        catenaryRotated.fitFromPolarCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], r, cosAngle, sinAngle, 0);
                        catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, moment);
                        xMin = ((xMin)<=(moment[0])?(xMin):(moment[0]));
                        xMax = ((xMax)>=(moment[0])?(xMax):(moment[0]));
                        yMin = ((yMin)<=(moment[1])?(yMin):(moment[1]));
                        yMax = ((yMax)>=(moment[1])?(yMax):(moment[1]));
                    }
                    if (((xMax-xMin)>=(yMax-yMin)?(xMax-xMin):(yMax-yMin)) < view.radius / 100.) // XXX be more scientific
                    {
                        // magLevel0 is too small to be seen at all, but is used for things
                        // that connect to it.
                        break;
                    }
                    magLevel0--;
                }

                int magLevel1 = -10; // XXX be more scientific
                while (true)
                {
                    double r = Math.pow(2., magLevel1);
                    double cosAndSin[][] = {{1,0},{0,1},{-1,0},{0,-1}};
                    double xMin = Double.POSITIVE_INFINITY;
                    double yMin = Double.POSITIVE_INFINITY;
                    double xMax = Double.NEGATIVE_INFINITY;
                    double yMax = Double.NEGATIVE_INFINITY;
                    for (int i = 0; i < cosAndSin.length; ++i)
                    {
                        double cosAngle = cosAndSin[i][0];
                        double sinAngle = cosAndSin[i][1];
                        catenaryRotated.fitFromPolarCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], r, cosAngle, sinAngle, 0);
                        catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, moment);
                        xMin = ((xMin)<=(moment[0])?(xMin):(moment[0]));
                        xMax = ((xMax)>=(moment[0])?(xMax):(moment[0]));
                        yMin = ((yMin)<=(moment[1])?(yMin):(moment[1]));
                        yMax = ((yMax)>=(moment[1])?(yMax):(moment[1]));
                    }

                    // what's a criterion for figuring out
                    // if the window is safely inside the ellipse?
                    // It's if the view's bounding circle
                    // is contained in the ellipse's inscribed circle.
                    double xCenterEllipse = (xMin+xMax)/2.;
                    double yCenterEllipse = (yMin+yMax)/2.;
                    double ellipseInRadius = (xMax-xMin)/2.;
                    double cullCircumRadius = .5 * Math.hypot(xMaxCull-xMinCull, yMaxCull-yMinCull);
                    // test whether dist between centers plus view circumradius < ellipseInRadius
                    if (Math.hypot(view.focus[0]-xCenterEllipse,
                                   view.focus[1]-yCenterEllipse) + cullCircumRadius < ellipseInRadius)

                    {
                        // magLevel1 is too big to be seen at all, but is used for things
                        // that connect to it.
                        break;
                    }
                    magLevel1++;
                }

                RectangularFunction f = new RectangularFunction() {
                    @Override public void apply(double x, double y, double answer[/*2*/])
                    {
                        catenaryRotated.fitFromRectangularCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], x, y, 0);
                        catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, answer);
                    }
                };
                if (view.inverseFunctionFlag)
                    f = new RectangularFunction() {
                        @Override public void apply(double xMomentOffset, double yMomentOffset, double xy[/*2*/])
                        {
                            boolean saved = XXX_ALLOW_FITFROMMOMENT_FAILURE;
                            try
                            {
                                XXX_ALLOW_FITFROMMOMENT_FAILURE = true;
                                catenaryRotated.fitFromMoment(model.v0[0],model.v0[1],model.v1[0],model.v1[1], xMomentIfTaut+xMomentOffset, yMomentIfTaut+yMomentOffset, null, 0);
                                double slack = catenaryRotated.t1 - catenaryRotated.t0 - MyMath.hypot(model.v1[0]-model.v0[0], model.v1[1]-model.v0[1]);
                                // down angle is rotation rotated by -90 degrees
                                double x = slack * catenaryRotated.sinRotation;
                                double y = slack * -catenaryRotated.cosRotation;
                                xy[0] = x;
                                xy[1] = y;

                                // fudge, to put it at the window center
                                xy[0] += view.focus[0];
                                xy[1] += view.focus[1];
                            }
                            finally
                            {
                                XXX_ALLOW_FITFROMMOMENT_FAILURE = saved;
                            }
                        }
                    };

                if (view.showPolarGridFlag)
                {
                    // Draw polar grid

                    int nMagsMajorPerMagLevel = 1;

                    int nAnglesMajor = 16; // divide 360 into this many parts
                    int nMagsMinorPerMajor = 10;
                    int nAnglesMinorPerMajor = 10;
                    if (view.colorByGoodnessFlag)
                    {
                        nAnglesMajor *= 8;
                        nMagsMinorPerMajor *= 2;
                    }

                    // derived quantities
                    int nAnglesMinor = nAnglesMajor * nAnglesMinorPerMajor;
                    int nMagStepsMajor = (magLevel1-magLevel0) * nMagsMajorPerMagLevel;
                    int nMagStepsMinor = nMagStepsMajor * nMagsMinorPerMajor;

                    for (int iPass = 0; iPass < 2; ++iPass)
                    {

                        // draw radial contours of constant angle
                        if (iPass == 0)
                        {
                            //mg.setColor(java.awt.Color.WHITE);
                            mg.setColor(new java.awt.Color(128, 128, 128)); // good for low contrast against rectangular
                        }
                        else
                        {
                            //mg.setColor(java.awt.Color.RED);
                            mg.setColor(new java.awt.Color(128, 128, 255));
                        }
                        for (int iAngle = 0; iAngle < nAnglesMajor; ++iAngle)
                        {
                            // yes, show the major contours in blue even if view.inverseFunctionFlag
                            int passOfThisAngle = ((4*iAngle % nAnglesMajor == 0) ? 1 : 0);
                            if (iPass != passOfThisAngle)
                                continue;

                            double angle = 2*Math.PI/nAnglesMajor * iAngle;
                            double cosAngle = Math.cos(angle);
                            double sinAngle = Math.sin(angle);
                            double xMomentPrev = Double.NaN;
                            double yMomentPrev = Double.NaN;
                            for (int iMag = 0; iMag < nMagStepsMinor+1; ++iMag)
                            {
                                double r = Math.pow(2., ((1-((double)iMag/(double)nMagStepsMinor))*(magLevel0) + ((double)iMag/(double)nMagStepsMinor)*(magLevel1)));
                                f.apply(r*cosAngle, r*sinAngle, moment);
                                if (iMag > 0)
                                {
                                    // is the slope in the expected quadrant?
                                    int expectedQuadrant = getQuadrant(cosAngle, sinAngle);
                                    int gotQuadrant = getQuadrant(moment[0]-xMomentPrev, moment[1]-yMomentPrev);

                                    if (view.colorByGoodnessFlag)
                                    {
                                        if (gotQuadrant == expectedQuadrant)
                                            mg.setColor(java.awt.Color.GREEN);
                                        else
                                            mg.setColor(java.awt.Color.RED);
                                    }

                                    mg.drawLine(xMomentPrev,yMomentPrev,
                                                moment[0], moment[1]);
                                }
                                if (view.showPointsFlag)
                                    mg.drawPoint(moment[0], moment[1], 3);
                                xMomentPrev = moment[0];
                                yMomentPrev = moment[1];
                            }
                        }

                        // draw circular contours of constant magnitude.
                        // skip largest, since it's outside view.
                        if (iPass == 0)
                        {
                            //mg.setColor(java.awt.Color.WHITE);
                            mg.setColor(new java.awt.Color(128, 128, 128)); // good for low contrast against rectangular
                        }
                        else
                            mg.setColor(new java.awt.Color(128, 128, 255)); // slightly washed out blue
                        for (int iMagMajor = 0; iMagMajor < nMagStepsMajor; ++iMagMajor)
                        {
                            // yes, show the 1 contour in blue even if view.inverseFunctionFlag
                            int passOfThisMag = iMagMajor == (0-magLevel0)*nMagsMajorPerMagLevel ? 1 : 0;
                            if (iPass != passOfThisMag)
                                continue;
                            double r = Math.pow(2., ((1-((double)iMagMajor/(double)nMagStepsMajor))*(magLevel0) + ((double)iMagMajor/(double)nMagStepsMajor)*(magLevel1)));
                            double xMomentPrev = Double.NaN;
                            double yMomentPrev = Double.NaN;
                            for (int iAngle = 0; iAngle < nAnglesMinor+1; ++iAngle)
                            {
                                double angle = 2*Math.PI/nAnglesMinor * iAngle;
                                double cosAngle = Math.cos(angle);
                                double sinAngle = Math.sin(angle);
                                f.apply(r*cosAngle, r*sinAngle, moment);
                                if (iAngle > 0)
                                    mg.drawLine(xMomentPrev,yMomentPrev,
                                                moment[0], moment[1]);
                                if (view.showPointsFlag)
                                    mg.drawPoint(moment[0], moment[1], 3);
                                xMomentPrev = moment[0];
                                yMomentPrev = moment[1];
                            }
                        }

                    }
                } // polar grid


                if (view.showRectangularGridFlag)
                {
                    // Draw rectangular grid
                    //double r = 1.;
                    //double r = .5;
                    double r = .25;
                    double x0 = -r;
                    double x1 = r;
                    double y0 = -r;
                    double y1 = r;
                    int nXStepsMajor = 64;
                    int nXStepsMinorPerMajor = 6;
                    int nYStepsMajor = 64;
                    int nYStepsMinorPerMajor = 6;
                    int nXStepsMinor = nXStepsMajor * nXStepsMinorPerMajor;
                    int nYStepsMinor = nYStepsMajor * nYStepsMinorPerMajor;
                    double sqrtHalf = Math.sqrt(.5);
                    double c = Math.cos(((view.gridRotDegrees)*(Math.PI/180.)));
                    double s = Math.sin(((view.gridRotDegrees)*(Math.PI/180.)));

                    // vertical lines
                    mg.setColor(java.awt.Color.GREEN);
                    for (int iX = 0; iX < nXStepsMajor+1; ++iX)
                    {
                        double x = ((1-(iX/(double)nXStepsMajor))*(x0) + (iX/(double)nXStepsMajor)*(x1));
                        double xMomentPrev = Double.NaN;
                        double yMomentPrev = Double.NaN;
                        for (int iY = 0; iY < nYStepsMinor+1; ++iY)
                        {
                            double y = ((1-(iY/(double)nYStepsMinor))*(y0) + (iY/(double)nYStepsMinor)*(y1));
                            double X = c*x - s*y;
                            double Y = s*x + c*y;
                            f.apply(X, Y, moment);
                            if (iY > 0)
                            {
                                mg.drawLine(xMomentPrev,yMomentPrev,
                                            moment[0], moment[1]);
                            }
                            if (view.showPointsFlag)
                                mg.drawPoint(moment[0], moment[1], 3);
                            xMomentPrev = moment[0];
                            yMomentPrev = moment[1];
                        }
                    }
                    // horizontal lines
                    mg.setColor(java.awt.Color.RED);
                    for (int iY = 0; iY < nYStepsMajor+1; ++iY)
                    {
                        double y = ((1-(iY/(double)nYStepsMajor))*(y0) + (iY/(double)nYStepsMajor)*(y1));
                        double xMomentPrev = Double.NaN;
                        double yMomentPrev = Double.NaN;
                        for (int iX = 0; iX < nXStepsMinor+1; ++iX)
                        {
                            double x = ((1-(iX/(double)nXStepsMinor))*(x0) + (iX/(double)nXStepsMinor)*(x1));
                            double X = c*x - s*y;
                            double Y = s*x + c*y;
                            f.apply(X, Y, moment);
                            if (iX > 0)
                            {
                                mg.drawLine(xMomentPrev,yMomentPrev,
                                            moment[0], moment[1]);
                            }
                            if (view.showPointsFlag)
                                mg.drawPoint(moment[0], moment[1], 3);
                            xMomentPrev = moment[0];
                            yMomentPrev = moment[1];
                        }
                    }
                } // rectangular grid

                if (false)
                {
                    // Draw analytic form of the function where we know it,
                    // namely on the axes
                    double slack0 = 0.;
                    double slack1 = 1.;
                    int nSlackSteps = 20;
                    for (int iSlack = 0; iSlack < nSlackSteps+1; ++iSlack)
                    {
                        double slack = ((1-(iSlack/(double)nSlackSteps))*(slack0) + (iSlack/(double)nSlackSteps)*(slack1));
                        double x = 0.;
                        double y = slack;
                        if (false)
                        {
                            f.apply(x, y, moment);
                            mg.setColor(java.awt.Color.GREEN);
                            mg.drawPoint(moment[0], moment[1], 5);
                        }

                        // What's the formula, given x=0, y=slack?
                        // Well the x component is easy:
                        //      xMoment = .5 * (1+slack)  (actually xMomentIfTaut * (1+slack))
                        // The y component is harder.
                        // Let X,Y,T be the max relevant coordinates
                        // on the canonical (unscaled) catenary.
                        // First solve for s = catenary scale:
                        //      2*s*T = 1+slack
                        //      2*s*X = 1
                        // Divide first equation by second:
                        //      T/X = 1+slack
                        //      T/asinh(T) = 1+slack
                        //      sinh(X)/X = 1+slack
                        //      sinhc(X) = 1+slack
                        // So,
                        //      X = asinhc(1+slack)
                        //      s = 1/(2*X)
                        //        = 1/(2*asinhc(1+slack))
                        //      T = sinh(X)
                        //        = sinh(asinhc(1+slack))
                        //      Y = cosh(X)
                        //        = cosh(asinhc(1+slack))
                        // Then:
                        //      yMoment = (1-frac)*s*(Y-1) * (1+slack)
                        // where frac is the fraction of a canonical catenary
                        // where its center-of-mass lies in y:
                        //      frac = (integral[0..T] (sqrt(t^2+1)-1) dt)/T / (Y-1)
                        //           = .5*(T*(sqrt(T*T+1)-2) + asinh(T)) / T / (Y-1)
                        //           = .5*(T*(Y-2) + X) / T / (Y-1)
                        //           = .5*(Y - 2 + X/T) / (Y-1)
                        // So, yMoment = (1-(.5*(Y - 2 + X/T) / (Y-1)))*s*(Y-1)*(1+slack)
                        // Okay, that's correct; now let's try to simplify it.
                        //             = ((Y-1)-(.5*(Y - 2 + X/T)))*s*(1+slack)
                        // XXX TODO: transfer the simplifications below to here
                        //             = (Y*(1+slack)-1) * s / 2;
                        //
                        // So we have:
                        //      xMoment = xMomentIfTaut * (1+slack)
                        //      yMoment = (Y*(1.+slack) - 1.) * s / 2

                        // Wait a minute, can we simplify something...
                        //      Y = cosh(X)
                        //      Y = cosh(asinhc(1+slack))
                        //   acosh(Y) = asinhc(1+slack)
                        //   sinhc(acosh(Y)) = 1+slack
                        //   sinh(acosh(Y))/acosh(Y) = 1+slack
                        //      sqrt(Y^2-1)/acosh(Y) = 1+slack
                        //                       T/X = 1+slack   oh but we knew that.
                        //                 sinh(X)/X = 1+slack
                        //                T/asinh(T) = 1+slack

                        // [Idea: If we started with s, or X, instead of slack, then wouldn't need to do any asinhc's ...]
                        // Okay start with xMoment:
                        //      1+slack = xMoment/xMomentIfTaut
                        //      X = asinhc(1+slack)
                        //      s = 1/(2*X)
                        //      Y = cosh(X)
                        //

                        double X = Catenary.asinhc(1.+slack);
                        double Y = MyMath.cosh(X);
                        double T = MyMath.sinh(X);
                        double s = 1./(2.*X);
                        double frac = .5*(Y - 2. + X/T) / (Y-1.);
                        //double yMoment = (1-(.5*(Y - 2 + X/T) / (Y-1)))*s*(Y-1)*(1+slack);
                        //double yMoment = ((Y-1)-(.5*(Y - 2 + X/T)))*s*(1+slack);
                        //double yMoment = (.5*Y-1-(.5*(- 2 + X/T)))*s*(1+slack);
                        //double yMoment = (.5*Y-1-((-1 + .5*X/T)))*s*(1+slack);
                        //double yMoment = (.5*Y - .5*X/T)*s*(1+slack);
                        //double yMoment = .5*(Y - X/T)*s*(1+slack);
                        // use X = 1/(2s)
                        //double yMoment = .5*(s*Y - (1/2.)/T)*(1+slack);
                        //double yMoment = .5*(s*Y - .5/T)*(1+slack);
                        // Oh WAIT a minute: T/X is 1+slack.
                        // back to this:
                        //double yMoment = .5*(Y - X/T)*s*(1+slack);
                        //double yMoment = .5*(Y - 1./(1.+slack))*s*(1+slack);
                        double yMoment = .5*(Y*(1.+slack) - 1.)*s;

                        double xMoment = xMomentIfTaut * (1.+slack);
                        mg.setColor(java.awt.Color.RED);
                        mg.drawPoint(xMoment, yMoment, 3);

                        // and the -y one
                        mg.drawPoint(xMoment, -yMoment, 3);

                        // and the +x one
                        xMoment = xMomentIfTaut + ((slack+2.)*(slack+2.))*.25-1.;
                        mg.drawPoint(xMoment, 0., 3);

                        // and the -x one
                        xMoment = xMomentIfTaut - slack*slack*.25;
                        mg.drawPoint(xMoment, 0., 3);

                        // OKAY starting with xMoment,yMoment, how do you determine if is in first quadrant?
                        //      double angleMin = 0.;
                        //      double angleMax = Math.PI;
                        //      {
                        //          double slackPlus1 = xMoment / xMomentIfTaut;
                        //          double X = asinhc(slackPlus1);
                        //          double Y = cosh(X);
                        //          XXX the following is proved elsewhere
                        //          double yMomentOfXMoment = (slackPlus1 * Y - 1.) / (4. * X);
                        //          if (yMoment < yMomentOfXMoment)
                        //              angleMax = Math.PI/2.; // first quadrant (or +y axis)
                        //          else if (yMoment > yMomentOfXMoment)
                        //              angleMin = Math.PI/2.; // second quadrant (or +y axis)
                        //          else
                        //              return [slackPlus1-1., Math.PI/2.]
                        //      }
                    }
                    mg.setColor(java.awt.Color.YELLOW);
                    for (double xxxMoment = xMomentIfTaut; xxxMoment <= xMomentIfTaut+1.; xxxMoment += .01)
                    {
                        double slackPlus1 = xxxMoment / xMomentIfTaut;
                        double XXX = Catenary.asinhc(slackPlus1);
                        double YYY = MyMath.cosh(XXX);
                        double yMomentOfXMoment = (slackPlus1 * YYY - 1.) / (4. * XXX);
                        if (xxxMoment != xMomentIfTaut)
                            mg.drawPoint(xxxMoment, yMomentOfXMoment, 3);
                    }
                }

                if (!view.inverseFunctionFlag)
                {
                    if (false) // researchy, maybe not for general interest
                    {
                        mg.setColor(java.awt.Color.RED);
                        mg.drawLine(xMomentIfTaut,0., xMomentIfTaut+Math.sqrt(.5), Math.sqrt(.5));

                        // Figure out the magic angle at which we can say we are "obviously in first quadrant", i.e. the angle of the min slope of the image of the y axis.
                        if (true)
                        {
                            GoldenSectionSearch.Fun fun = new GoldenSectionSearch.Fun() {
                                @Override public double apply(double slack)
                                {
                                    double x = 0.;
                                    double y = slack;
                                    catenaryRotated.fitFromRectangularCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], x,y, 0);
                                    catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, moment);
                                    double xMomentPrev = moment[0];
                                    double yMomentPrev = moment[1];
                                    y = slack + 1e-4;
                                    catenaryRotated.fitFromRectangularCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], x,y, 0);
                                    catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, moment);

                                    double angleOfPosition = Math.atan2(moment[1]-yMomentPrev, moment[0]-xMomentPrev);
                                    return xMomentIfTaut < 0. ? -angleOfPosition : angleOfPosition;
                                }
                            };
                            // it's not clear what the upper bound should be, so compute one
                            double lo = 0.;
                            double hi = 2.;
                            while (fun.apply(2.*hi) < fun.apply(hi))
                                hi *= 2.;
                            double slackAtMinAngle = GoldenSectionSearch.findMin(fun, 0., hi)
                                                                     * (xMomentIfTaut < 0. ? -1. : 1.);
                            double minAngle = fun.apply(slackAtMinAngle);
                            if (false)
                            {
                                {System.out.print("        "); System.out.println("slackAtMinAngle" + " = " + (slackAtMinAngle));};
                                {System.out.print("        "); System.out.println("minAngle" + " = " + (minAngle));};
                                {System.out.print("        "); System.out.println("((minAngle)*(180./Math.PI))" + " = " + (((minAngle)*(180./Math.PI))));};
                            }

                            catenaryRotated.fitFromRectangularCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], 0.,slackAtMinAngle, 0);
                            catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, moment);
                            double xMomentAtMinAngle = moment[0];
                            double yMomentAtMinAngle = moment[1];

                            mg.setColor(java.awt.Color.GREEN);
                            mg.drawPoint(xMomentAtMinAngle, yMomentAtMinAngle, 5);
                            mg.drawLine(xMomentIfTaut,0., xMomentIfTaut+Math.cos(minAngle), Math.sin(minAngle));
                        }
                        // Actually, thinking about it more, it's simpler than that...
                        // just find the point whose *position* is at the minimum angle from the origin.
                        // Although, in this case, may need to add some fudge?
                        // However, could compute this offline by binary search, once and for all.
                        // Oh, convenient! It's about 60.710775733211186 degrees,
                        // so can use 60!
                        if (true)
                        {
                            GoldenSectionSearch.Fun fun = new GoldenSectionSearch.Fun() {
                                @Override public double apply(double slack)
                                {
                                    double x = 0.;
                                    double y = slack;
                                    catenaryRotated.fitFromRectangularCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], x,y, 0);
                                    catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, moment);
                                    double angleOfPosition = Math.atan2(moment[1], moment[0]-xMomentIfTaut);
                                    return xMomentIfTaut < 0. ? -angleOfPosition : angleOfPosition;
                                }
                            };
                            // it's not clear what the upper bound should be, so compute one
                            double lo = 0.;
                            double hi = 2.;
                            while (fun.apply(2.*hi) < fun.apply(hi))
                                hi *= 2.;
                            double slackAtMinAngleOfPosition = GoldenSectionSearch.findMin(fun, 0., hi)
                                                                     * (xMomentIfTaut < 0. ? -1. : 1.);
                            double minAngleOfPosition = fun.apply(slackAtMinAngleOfPosition);
                            if (false)
                            {
                                {System.out.print("        "); System.out.println("slackAtMinAngleOfPosition" + " = " + (slackAtMinAngleOfPosition));};
                                {System.out.print("        "); System.out.println("minAngleOfPosition" + " = " + (minAngleOfPosition));};
                                {System.out.print("        "); System.out.println("((minAngleOfPosition)*(180./Math.PI))" + " = " + (((minAngleOfPosition)*(180./Math.PI))));};
                            }

                            catenaryRotated.fitFromRectangularCoords(model.v0[0],model.v0[1],model.v1[0],model.v1[1], 0.,slackAtMinAngleOfPosition, 0);
                            catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, moment);
                            double xMomentAtMinAngleOfPosition = moment[0];
                            double yMomentAtMinAngleOfPosition = moment[1];

                            mg.setColor(java.awt.Color.BLUE);
                            mg.drawPoint(xMomentAtMinAngleOfPosition, yMomentAtMinAngleOfPosition, 5);
                            mg.drawLine(xMomentIfTaut,0., xMomentIfTaut+Math.cos(minAngleOfPosition), Math.sin(minAngleOfPosition));
                        }

                    }
                }

                // Draw good and bad samples
                if (model.samples != null)
                {
                    for (int i = 0; i < model.samples.length; ++i)
                    {
                        Model.Sample sample = model.samples[i];
                        double xMoment = sample.xMomentNormalized;
                        double yMoment = sample.yMomentNormalized;
                        if (((xMinCull <=(xMoment))&&((xMoment)<= xMaxCull))
                         && ((yMinCull <=(yMoment))&&((yMoment)<= yMaxCull)))
                        {
                            mg.setColor(sample.bad ? java.awt.Color.RED : java.awt.Color.GREEN);
                            int pointSize;
                            if (((((sample.x0)-(-1.)) <= (1e-12)) && (((-1.)-(sample.x0)) <= (1e-12)))) // i.e. if endpoints were originally bigger than moment
                                pointSize = 1;
                            else // i.e. if moment was originally bigger than endpoints
                                pointSize = 2;
                            if (sample.byBinarySearch)
                            {
                                //CHECK(false); // coverage
                                //pointSize += 4;
                                mg.setColor(sample.bad ? java.awt.Color.YELLOW : java.awt.Color.CYAN);
                                if (sample.bad)
                                    pointSize += 4;
                            }
                            mg.drawPoint(xMoment, yMoment, pointSize);
                        }
                    }
                }

                if (false)
                {
                    // Just visualize a single point I was having trouble with
                    mg.setColor(java.awt.Color.YELLOW);
                    //mg.drawPoint(0.4880273204300428, 0.008470672745238716, 1);
                    //mg.drawPoint(0.603074224821478, 0.3471447106867807, 3);
                    mg.drawPoint(0.9162910793298915, 0.9150576416554741, 3);
                }

                //
                // If anything's still moving, make paint get called again
                //

                // ...

                view.nPaintsDone++;
                //if (viewParams.showNumPaintsDone.get())
                {
                    g.setColor(java.awt.Color.WHITE);
                    java.awt.Dimension viewSize = getSize(); // getWidth,getHeight don't exist in 1.1
                    int W = viewSize.width;
                    int H = viewSize.height;
                    int Y = 2;
                    com.donhatchsw.awt.MyGraphics mgTemp = new com.donhatchsw.awt.MyGraphics(g, viewSize, 0,W,H,0);
                    mgTemp.drawString("("+view.nPaintsDone+" paint"+(view.nPaintsDone==1?"":"s")+")", W-2, Y, 1, -1.);
                    Y += 18;
                    mgTemp.drawString("mag levels ["+magLevel0+" .. "+magLevel1+")", W-2, Y, 1, -1.);
                    Y += 18;
                }

                if (g != frontBufferGraphics)
                    frontBufferGraphics.drawImage(backBuffer, 0, 0, this);
                mostRecentGraphics = mg;


                if (eventVerbose >= 2) System.out.println("    out paint");
            } // paint
            {
                addKeyListener(new java.awt.event.KeyAdapter() {
                    public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        boolean controlIsDown = e.isControlDown();
                        int keyCode = e.getKeyCode();
                        char c = e.getKeyChar();
                        if (eventVerbose >= 1) System.out.println("    in keyPressed, keyEvent = "+e+" keyChar = (char)"+(int)c+"");

                        if (false) {}
                        else if (keyCode == java.awt.event.KeyEvent.VK_LEFT)
                        {
                            double dx = -1./8;
                            model.v0[0] += dx;
                            model.v1[0] += dx;
                            VecMath.lerp(view.focus, model.v0, model.v1, .5);
                            repaint();
                        }
                        else if (keyCode == java.awt.event.KeyEvent.VK_RIGHT)
                        {
                            double dx = 1./8;
                            model.v0[0] += dx;
                            model.v1[0] += dx;
                            VecMath.lerp(view.focus, model.v0, model.v1, .5);
                            repaint();
                        }
                        else if (keyCode == java.awt.event.KeyEvent.VK_UP)
                        {
                            double dy = 1./8;
                            model.v0[1] += dy;
                            model.v1[1] += dy;
                            VecMath.lerp(view.focus, model.v0, model.v1, .5);
                            repaint();
                        }
                        else if (keyCode == java.awt.event.KeyEvent.VK_DOWN)
                        {
                            double dy = -1./8;
                            model.v0[1] += dy;
                            model.v1[1] += dy;
                            VecMath.lerp(view.focus, model.v0, model.v1, .5);
                            repaint();
                        }
                        else if (c == '-' || c == '+' || c == '=')
                        {
                            double stepSize = .25;
                            double increment = c=='-' ? -stepSize : stepSize;
                            view.logRadius -= increment; // view.radius is inverse of scale
                            view.radius = Math.pow(2., view.logRadius);

                            {System.out.print("        "); System.out.println("view.logRadius" + " = " + (view.logRadius));};
                            {System.out.print("        "); System.out.println("view.radius" + " = " + (view.radius));};
                            repaint();
                        }
                        else if (c == 'g')
                        {
                            view.showRectangularGridFlag ^= true;
                            {System.out.print("        "); System.out.println("view.showRectangularGridFlag" + " = " + (view.showRectangularGridFlag));};
                            repaint();
                        }
                        else if (c == 'p')
                        {
                            view.showPointsFlag ^= true;
                            {System.out.print("        "); System.out.println("view.showPointsFlag" + " = " + (view.showPointsFlag));};
                            repaint();
                        }
                        else if (c == 'i')
                        {
                            view.inverseFunctionFlag ^= true;
                            {System.out.print("        "); System.out.println("view.inverseFunctionFlag" + " = " + (view.inverseFunctionFlag));};
                            repaint();
                        }
                        else if (c == java.awt.event.KeyEvent.CHAR_UNDEFINED)
                        {
                            // This is the case for things like arrow keys
                            //System.out.println("CHAR_UNDEFINED");
                        }

                        else if (c == java.awt.event.KeyEvent.VK_ESCAPE
                              || c == (('c')-'a'+1)) // XXX do I want this? should be control panel I think, if I ever make one for this demo1
                        {
                            System.out.println("ciao!");
                            System.exit(0); // asinine way of doing things
                        }
                        else if (c == (('f')-'a'+1))
                        {
                            view.debugCullFrustumShrink = (view.debugCullFrustumShrink!=1. ? 1. : .5);
                            {System.out.print("        "); System.out.println("view.debugCullFrustumShrink" + " = " + (view.debugCullFrustumShrink));};
                            repaint();
                        }
                        else if (c == ' ')
                        {
                            repaint();
                        }
                        else if (c == 'A')
                        {
                            view.antialiasFlag ^= true;
                            {System.out.print("        "); System.out.println("view.antialiasFlag" + " = " + (view.antialiasFlag));};
                            repaint();
                        }
                        else if (c == 'r')
                        {
                            view.gridRotDegrees += 5;
                            {System.out.print("        "); System.out.println("view.gridRotDegrees" + " = " + (view.gridRotDegrees));};
                            repaint();
                        }
                        else if (c == 'R')
                        {
                            view.gridRotDegrees -= 5;
                            {System.out.print("        "); System.out.println("view.gridRotDegrees" + " = " + (view.gridRotDegrees));};
                            repaint();
                        }
                        else if (c == 'h')
                        {
                            System.out.println("The following keys do things:");
                            System.out.println("         -/+/= - zoom out/in");
                            System.out.println("             i - toggle function / inverse function");
                            System.out.println("    arrow keys - move catenary endpoints");
                            System.out.println("             g - toggle rectangular grid");
                            System.out.println("           r/R - rotate rectangular grid CCW/CW");
                            System.out.println("             p - toggle points used to draw curves");
                            System.out.println("        ctrl-f - shrink/unshrink view cull frustum");
                            System.out.println("       shift-A - toggle antialiasing");
                            System.out.println("             h - show this help message");
                            System.out.println("           Esc - quit");
                        }
                        else
                        {
                            System.out.println("Huh?");
                        }
                    }
                });
                addMouseListener(new java.awt.event.MouseListener() {
                    public void mouseClicked(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseClicked at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseClicked");
                    }
                    public void mousePressed(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mousePressed at "+e.getX()+","+e.getY()+"");
                        // XXX dup code
                        if (mostRecentGraphics != null)
                        {
                            double thisPoint[] = new double[2];
                            mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                            if (eventVerbose >= 1) System.out.println("        thisPoint = "+Arrays.toStringCompact(thisPoint));
                            // do something with it
                            repaint();
                        }
                        if (eventVerbose >= 1) System.out.println("    out mousePressed");
                    }
                    public void mouseReleased(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseReleased at "+e.getX()+","+e.getY()+"");

                        if (eventVerbose >= 1) System.out.println("    out mouseReleased");
                    }
                    public void mouseEntered(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseEntered at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseEntered");
                    }
                    public void mouseExited(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseExited at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseExited");
                    }
                });
                addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                    public void mouseMoved(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 3) System.out.println("    in mouseMoved to "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 3) System.out.println("    out mouseMoved");
                    }
                    public void mouseDragged(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseDragged to "+e.getX()+","+e.getY()+"");
                        if (mostRecentGraphics != null)
                        {
                            double thisPoint[] = new double[2];
                            mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                            // do something with it
                        }
                        if (eventVerbose >= 1) System.out.println("    out mouseDragged");
                    }
                });
            }
        }; // canvas
        canvas.requestFocus(); // seems to be needed initially XXX see whether this is true

        final java.awt.Frame frame = new java.awt.Frame("Optimal Trajectories");
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            @Override public void windowClosing(java.awt.event.WindowEvent we)
            {
                frame.dispose();
                System.out.println("ciao!");
                System.exit(0); // asinine way of doing things
            }
        });
        frame.setForeground(java.awt.Color.WHITE);
        frame.setBackground(java.awt.Color.BLACK);
        frame.add(canvas);
        frame.pack();
        frame.setVisible(true); // available in java 1.5, replaces deprecated show()
    } // interactiveDemo1

    public static void main(String args[])
    {
        System.out.println("in main");
        if (args.length == 1 && args[0].equals("demo1"))
            interactiveDemo1();
        else if (args.length == 1 && args[0].equals("confidenceTests"))
            confidenceTests();
        else
        {
            System.err.println("Usage: CatenaryRotated [demo1|confidenceTests]\n");
            System.exit(1);
        }

        System.out.println("out main");
    }

} // CatenaryRotated
