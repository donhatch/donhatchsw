/*
    TODO:
        - smoothing-- for now, would be fine to just do the post-time-to-space thing, thought it would be nicer to do it down in the velocity of the undo tree view so it can do smooth direction changes... that would be AWESOME
        - speed slider
        - ctrl-up, ctrl-down should put it on a fractional place
        - clicking on a node should make it current
            (and ctrl-clicking should let it land on a fractional place)

        - button panel
        - zoom, pan... mode to keep the current node in the center
        - JTree to show model/view/viewer relationship
        -               model/view/followingview/viewer relationship
        - should have prune methods--
                PruneCurrentAndBelow
                PruneAboveCurrent
          OOH!  and all parts of the tree should be ref counted and should
                automatically go away when no one can ever see them again!!!
        - make the model/view thing explicit instead of this half-assed implicit joint ownership thing!
        - should remember current depth when moving more shallowly, like vim does
        - optimize the tree rendering so bushy parts can stack up if possible
*/
package com.donhatchsw.util;

import com.donhatchsw.compat.regex;

#include "macros.h"

/**
* Graphical Viewer for an UndoTree.
* This class is Component-agnostic, at least to the extent
* that you can hook it up to either a Canvas or a JPanel, for example.
*
* <pre>
*              key,mouse                       undo,redo      +--------------+
* +----------+  events   +---------------+     requests       |Application   |
* |Component |---------->|UndoTreeViewer |------------------->|              |
* |          |           |               |                    | Do,undo,redo |
* |-  -  -  -| repaint() |               | somethingChanged() | +---------+  |
* |          |<----------|<--------------|<---------------------|UndoTree |  |
* |          |---------->|               |           +----------|         |  |
* +----------+  paint()  +---------------+           |        | |         |  |
*                                                    |        | +---------+  |
*                                                    v        +--------------+
*                                         +----------------+        ^
*                                         |UndoTreeViewer2 |        |
*                                      ...|                |--------+
* </pre>
* All of the above connections are established via listener callbacks,
* except for the repaint and paint calls which are done directly;
* the Component should call the UndoTreeViewer's paint() method
* from inside its own paint() or paintComponent() method.
* <p>
* Actually the controlling Component (the one sending key and mouse events)
* can be different from the displaying Component (that's the reason
* for the dotted line across the Component in the above diagram),
* although I don't know why you'd want that.
*/
// XXX would it make more sense for the UndoTreeViewer to call undo/redo etc. on the UntoTree directly, and have the Application be set up to intercept those somehow?  Think about that...
public class UndoTreeViewer
{
    /**
    * Anyone can set this at any time to debug the viewer's activity;
    * possible values are as follows.
    * <pre>
    *      0: nothing (default)
    *      1: key and mouse press/release/click
    *      2: and mouse drags
    *      3: and update/paint
    *      4: and enter/exit (can be obnoxious)
    *      5: and mouse motion (can be obnoxious)
    *</pre>
    */
    public int eventVerboseLevel = 0; // XXX need a key to cycle this


    private ItemColorizer colorizer; // set in ctor

    //
    // Viewing parameters that always change SMOOTHLY
    // so I don't have an anxiety attack.
    //
        SmoothlyVaryingViewingParameter stretchOutAlongTimeLine = new SmoothlyVaryingViewingParameter(0.f);
        SmoothlyVaryingViewingParameter centerCurrentNode = new SmoothlyVaryingViewingParameter(0.f);


    //
    // Things I listen to...
    //
    private UndoTree undoTree = null;
    private UndoTree.Listener undoTreeListener = null;
    private java.awt.Component component;
    private java.awt.event.KeyListener componentKeyListener = null;
    private java.awt.event.MouseListener componentMouseListener = null;
    private java.awt.event.MouseMotionListener componentMouseMotionListener = null;
    //
    // And things that listen to me.
    //
    private com.donhatchsw.compat.ArrayList/*<Applistener>*/ appListeners = new com.donhatchsw.compat.ArrayList();

    /** Install one of these if you want the UndoTree to be able to request app actions in response to the user manipulating the UndoTreeViewer window. */
    public interface AppListener
    {
        public void requestUndo();
        public void requestRedo();
        public void requestPreferOlderChild();
        public void requestPpreferYoungerChild();
    }

    /** Installs a listener that will send requests from the UndoTreeViewer window to an application. */
    public void addAppListener(AppListener appListener)
    {
        appListeners.remove(appListener); // XXX should throw IllegalArgument instead
        appListeners.add(appListener);
    } // addAppListener
    /** Removes a listener that was previously installed with addAppListener. */
    public void removeAppListener(AppListener appListener)
    {
        appListeners.remove(appListener);
    } // removeAppListener

    /** Callback used to decide the appearance (color and length) of each edge in the UndoTree. You give one of these to the UndoTreeViewer constructor. */
    public interface ItemColorizer
    {
        /**
        * The color in which given edge should be drawn.
        */
        java.awt.Color color(Object item);
        /**
        * The length the given edge should be; use 1 for an average edge.
        */
        double length(Object item);
    }

    /** Attaches to the given UndoTree. It is an error to try to attach to more than one UndoTree at a given time. */
    public void attachToUndoTree(UndoTree undoTree)
    {
        if (undoTreeListener != null)
            throw new IllegalArgumentException("UndoTreeViewer.attachToUndoTree: already attached to someone"); // XXX should be illegal state or something instead?
        this.undoTree = undoTree;
        undoTree.addListener(this.undoTreeListener = new UndoTree.Listener() {
            public void somethingChanged()
            {
                if (component != null)
                    component.repaint();
            }
        });

        // And just do it, since something did change...
        if (component != null)
            component.repaint();

    } // attachToUndoTree
    /** Detaches from the UndoTree that was previously attached using attachToUndoTree. */
    public void detachFromUndoTree()
    {
        if (undoTreeListener == null)
            throw new IllegalArgumentException("UndoTreeViewer.detachFromUndoTree: not attached to any UndoTree"); // XXX should be illegal state or something instead?
        undoTree.removeListener(undoTreeListener);
        undoTreeListener = null;
        undoTree = null;

        // And just do it, since something did change...
        if (component != null)
            component.repaint();
    } // detachFromUndoTree
    /** Installs event listeners on the given Component, which can be a Canvas or a JPanel or whatever. It is an error to try to attach to more than one Component at a given time. */
    public void attachToComponent(final java.awt.Component component)
    {
        if (this.component != null)
            throw new IllegalArgumentException("UndoTreeViewer.attachToComponent: already attached to someone"); // XXX should be illegal state or something instead?
        this.component = component;
        component.addKeyListener(componentKeyListener = new java.awt.event.KeyListener() {

            public void keyPressed(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyPressed "+ke);
                if (eventVerboseLevel >= 1) System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
                int keyChar = ke.getKeyChar();
                String keyText = java.awt.event.KeyEvent.getKeyText(keyCode);

                boolean horizontal = false; // only vertical is supported, I think, unless I want to do diagonal flips some day or something

                if (false)
                {
                    // XXX bleah! get rid of this when I stop needing to look at it and be weirded out
                    PRINT(keyCode);
                    PRINT(keyChar);
                    PRINT(keyText);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD0);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD1);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD2);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD3);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD4);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD5);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD6);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD7);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD8);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD9);
                }

                // holy shit!
                int x = 0, y = 0;
                if (false) {}
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD1
                      || keyText.equals("End"))
                    { x = -1; y = 1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_DOWN
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD2
                      || keyText.equals("Down"))
                    { x = 0; y = 1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD3
                      || keyText.equals("Page Down"))
                    { x = 1; y = 1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_LEFT
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD4
                      || keyText.equals("Left"))
                    { x = -1; y = 0; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD5
                      || keyText.equals("Begin"))
                    { x = 0; y = 0; }
                else if (keyCode == java.awt.event.KeyEvent.VK_RIGHT
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD6
                      || keyText.equals("Right"))
                    { x = 1; y = 0; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD7
                      || keyText.equals("Home"))
                    { x = -1; y = -1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_UP
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD8
                      || keyText.equals("Up"))
                    { x = 0; y = -1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD9
                      || keyText.equals("Page Up"))
                    { x = 1; y = -1; }
                else
                {
                    // nothin
                }

                if (horizontal)
                {
                    int temp = x;
                    x = y;
                    y = temp;
                }

                if (false) {}
                else if (y==-1 && x==-1)
                    requestOlderBranch();
                else if (y==-1 && x==0)
                    requestUndo();
                else if (y==-1 && x==1)
                    requestYoungerBranch();
                else if (y==0 && x==-1)
                    requestOlder();
                else if (y==0 && x==1)
                    requestYounger();
                else if (y==1 && x==-1)
                    requestOlderLeaf();
                else if (y==1 && x==0)
                    requestRedo();
                else if (y==1 && x==1)
                    requestYoungerLeaf();

                else if (keyCode == java.awt.event.KeyEvent.VK_A)
                {
                    asciiDump(undoTree, stretchOutAlongTimeLine.get());
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_S)
                {
                    undoTree.setSharedLabel("this_is_a_shared_label"); // XXX get rid of the underscores when I make the parsing smarter
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_P)
                {
                    undoTree.setPrivateLabel("this_is_a_private_label"); // XXX get rid of the underscores when I make the parsing smarter
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_T)
                {
                    float newStretch = 1.f - stretchOutAlongTimeLine.getTarget();
                    if (eventVerboseLevel >= 1) System.out.println("stretchOutAlongTimeLine "+stretchOutAlongTimeLine.get()+" -> "+newStretch);
                    boolean justUseLerp = (ke.isShiftDown()); // XXX lame, this should be in a keyTyped, not keyPressed
                    stretchOutAlongTimeLine.set(newStretch, 1000, justUseLerp); // XXX not sure should hard code?
                    if (component != null)
                        component.repaint();
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_J)
                {
                    jitterRadius = (jitterRadius + 1) % 2; // just on or off for now
                    // XXX um... and why am I not seeing it repaint immediately? OH FOR FUCKS SAKE I HAVE TO POINT TO CLICK AFTER I ENTER THE WINDOW! but only sometimes!! when will I get this monkey off my back?
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_C)
                {
                    undoTree.Clear();
                }
                component.repaint();
            }
            public void keyReleased(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyReleased "+ke);
                if (eventVerboseLevel >= 1) System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
            }
            public void keyTyped(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyTyped");
                char c = ke.getKeyChar();
                //System.out.println("key listener got key '"+c+"'("+(int)c+")"); // XXX escapify!
            }
        }); // key listener
        component.addMouseListener(componentMouseListener = new java.awt.event.MouseListener() {
            public void mouseClicked(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mouseClicked on a "+component.getClass().getSuperclass().getName());
            } // mouseClicked
            public void mousePressed(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mousePressed on a "+component.getClass().getSuperclass().getName());
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mouseReleased on a "+component.getClass().getSuperclass().getName());
            } // mouseReleased
            public void mouseEntered(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 4) System.out.println("mouseExited on a "+component.getClass().getSuperclass().getName());
            } // mouseEntered
            public void mouseExited(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 4) System.out.println("mouseExited on a "+component.getClass().getSuperclass().getName());
            } // mouseExited
        }); // mouse listener
        component.addMouseMotionListener(componentMouseMotionListener = new java.awt.event.MouseMotionListener() {
            private long time0 = System.currentTimeMillis();
            public void mouseDragged(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("    mouseDragged on a "+component.getClass().getSuperclass().getName()+", time = "+(me.getWhen()-time0)/1000.);
            } // mouseDragged
            public void mouseMoved(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 5) System.out.println("        mouseMoved on a "+component.getClass().getSuperclass().getName());
            } // mouseMoved
        }); // mouse motion listener
    } // attachToComponent

        //
        // Private convenience stuff...
        // XXX actually might be useful for public use, think about it
        //

            private void requestYoungerBranch() // 7 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request younger branch");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferYoungerChild())
                    {
                        undoTree.redo();
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestUndo()        // 8 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request undo");
                String undoneItem = (String)undoTree.undo();
                if (eventVerboseLevel >= 1) System.out.println("undid "+undoneItem);
            }
            private void requestOlderBranch()   // 9 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request older branch");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferOlderChild())
                    {
                        undoTree.redo();
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestOlder()       // 4 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request older at same depth");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferOlderChild())
                    {
                        // Try to go back to same level as before,
                        // sticking to the young side
                        while (nUndosDone-- > 0)
                        {
                            undoTree.redo(); // okay if fails
                            if (nUndosDone > 0)
                            {
                                while (undoTree.preferYoungerChild())
                                    ;
                            }
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            // App is expected to handle the 5 key and do a Do, maybe
            private void requestYounger()     // 6 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request younger at same depth");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferYoungerChild())
                    {
                        // Try to go back to same level as before,
                        // sticking to the old side
                        while (nUndosDone-- > 0)
                        {
                            undoTree.redo(); // okay if fails
                            if (nUndosDone > 0)
                            {
                                while (undoTree.preferOlderChild())
                                    ;
                            }
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestOlderLeaf()   // 7 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request older leaf");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferOlderChild())
                    {
                        // Go as deep as possible,
                        // sticking to the young side
                        while (undoTree.redo() != null)
                        {
                            while (undoTree.preferYoungerChild())
                                ;
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestRedo()        // 8 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request redo");
                String redoneItem = (String)undoTree.redo();
                if (eventVerboseLevel >= 1) System.out.println("redid "+redoneItem);
            }
            private void requestYoungerLeaf() // 9 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request younger leaf");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferYoungerChild())
                    {
                        // Go as deep as possible,
                        // sticking to the old side
                        while (undoTree.redo() != null)
                        {
                            while (undoTree.preferOlderChild())
                                ;
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }


    /** Detaches from the given component, which must have been previously attached by attachToComponent(). */
    public void detachFromComponent(java.awt.Component component)
    {
        if (this.component == null)
            throw new IllegalArgumentException("UndoTreeViewer.detachFromComponent: not attached to any component"); // XXX should be illegal state or something instead?
        component.removeKeyListener(componentKeyListener);
        component.removeMouseListener(componentMouseListener);
        component.removeMouseMotionListener(componentMouseMotionListener);
        componentKeyListener = null;
        componentMouseListener = null;
        componentMouseMotionListener = null;
        component = null;
    } // detachFromComponent

    private UndoTree.Snapshot snapshot = new UndoTree.Snapshot(); // scratch to reuse each time  // XXX put this up top somewhere, and should probably clear it if the tree is cleared

    // XXX figure out where to put this, if anywhere
    private java.util.Random jitterGenerator = new java.util.Random();
    private int jitterRadius = 0; // j key toggles

    /** Paint callback to be called from inside your Component's paint() or paintComponent() method. The caller is responsible for clearing the window and/or double-buffering. XXX although it might make sense to draw single-buffered sometimes, when only a couple of pixels are changing... need to think about this */
    // PAINT (the UndoTreeViewer)
    public void paint(java.awt.Component component, java.awt.Graphics g)
    {
        if (eventVerboseLevel >= 3) System.out.println("            UndoTreeViewer painting on a "+component.getClass().getSuperclass().getName());

        // Evolve any params that are moving towards a target...
        {
            stretchOutAlongTimeLine.evolveOneFrame();
            if (stretchOutAlongTimeLine.isMoving())
                component.repaint();
            centerCurrentNode.evolveOneFrame();
            if (centerCurrentNode.isMoving())
                component.repaint();
        }

        undoTree.takeSnapshot(snapshot);
        int nNodes = snapshot.nNodes;
        java.awt.Color edgeColors[] = new java.awt.Color[nNodes];
        double edgeLengths[] = new double[nNodes];

        // Determine the color and length the edge above each node.
        // Start at node 1, since node 0 doesn't have an edge above it.
        for (int iNode = 1; iNode < nNodes; ++iNode) // start at 1
        {
            edgeColors[iNode] = colorizer.color(snapshot.edgeItems[iNode]);
            edgeLengths[iNode] = colorizer.length(snapshot.edgeItems[iNode]);
        }
        double x[] = new double[nNodes];
        double y[] = new double[nNodes];
        UndoTree.chooseNodePositions(snapshot.nNodes, snapshot.parents, snapshot.preferredChildIndices, edgeLengths, snapshot.currentNode, snapshot.currentNodeFraction, stretchOutAlongTimeLine.get(), x, y);
        double xmin = Double.POSITIVE_INFINITY;
        double ymin = Double.POSITIVE_INFINITY;
        double xmax = Double.NEGATIVE_INFINITY;
        double ymax = Double.NEGATIVE_INFINITY;
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            xmin = Math.min(xmin, x[iNode]);
            ymin = Math.min(ymin, y[iNode]);
            xmax = Math.max(xmax, x[iNode]);
            ymax = Math.max(ymax, y[iNode]);
        }


        //System.out.println("                model bounds ["+xmin+".."+xmax+"]x["+ymin+"x"+ymax+"]");
        //
        // Fit to the window...
        // We know the initial scale of the model is such that
        // things occur at granularity around 1, so a border of .5 is good.
        // So, map xmin-.5..xmax+.5 to 0..getWidth and same for y.
        // XXX I'm sure this is not the final way I'll do this
        //
        int w = component.getWidth();
        int h = component.getHeight();
        xmin -= .5;
        ymin -= .5;
        xmax += .5;
        ymax += .5;
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            double xFrac = (x[iNode]-xmin)/(xmax-xmin); // XXX redundant division
            double yFrac = (y[iNode]-ymin)/(ymax-ymin); // XXX redundant division
            x[iNode] = LERP(0, w, xFrac);
            y[iNode] = LERP(0, h, yFrac);
        }

        if (jitterRadius > 0)
        {
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                x[iNode] += (jitterGenerator.nextInt(2*jitterRadius+1)-jitterRadius);
                y[iNode] += (jitterGenerator.nextInt(2*jitterRadius+1)-jitterRadius);
            }
        }


        // Actual drawing starts here
        {
            //
            // Draw the edges first, so the nodes can go on top if they collide
            //
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                if (snapshot.parents[iNode] != -1)
                {
                    g.setColor(edgeColors[iNode]);
                    g.drawLine((int)x[snapshot.parents[iNode]],
                               (int)y[snapshot.parents[iNode]],
                               (int)x[iNode],
                               (int)y[iNode]);
                }
            }

            //
            // Now draw the nodes
            //
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                if (snapshot.parents[iNode] != -1)
                    g.setColor(edgeColors[iNode]);
                else
                    g.setColor(java.awt.Color.white);
                int radius = 2;
                g.drawRect((int)x[iNode]-radius,(int)y[iNode]-radius,
                           2*radius,2*radius);
            }

            //
            // Put a ring around the current node
            //
            {
                int parentNode = snapshot.parents[snapshot.currentNode]==-1 ? snapshot.currentNode : snapshot.parents[snapshot.currentNode];
                double currentNodeTimeFraction = snapshot.currentNodeFraction;
                double currentNodeSpaceFraction = SMOOTH(currentNodeTimeFraction);

                double currentNodeX = LERP(x[parentNode], x[snapshot.currentNode], currentNodeSpaceFraction);
                double currentNodeY = LERP(y[parentNode], y[snapshot.currentNode], currentNodeSpaceFraction);
                g.setColor(java.awt.Color.white);
                int radius = 4;
                g.drawRect((int)currentNodeX-radius,
                           (int)currentNodeY-radius,
                           2*radius,2*radius);
            }

        }
    } // paint

    /** Creates an UndoTreeViewer.  Attach it to a Component using attachToComponent and to an UndoTree using attachToUndoTree. */
    public UndoTreeViewer(ItemColorizer colorizer)
    {
        this.colorizer = colorizer;
    } // UndoTreeViewer ctor

    private static void asciiDump(UndoTree undoTree, float stretchOutAlongTimeLine)
    {
        //PRINT(__LINE__);
        //PRINT(undoTree);
        UndoTree.ItemToString itemToString = new UndoTree.ItemToString(){
            public String regex()
            {
                //return "-?\\d+"; // ints
                //return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public String itemToString(Object obj)
            {
                // is this method necessary? could just take the regex
                //return obj.toString(); // ints
                return obj.toString(); // identifiers too
            }
        };
        UndoTree.ItemFromString itemFromString = new UndoTree.ItemFromString(){
            public String regex()
            {
                // return "-?\\d+"; // ints
                //return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public Object itemFromString(String s)
            {
                //return Integer.valueOf(s); // ints
                return s; // identifiers
            }
        };
        //String indentSpaces = "    ";
        //String separatorSpaces = System.getProperty("line.separator");
        String indentSpaces = "";
        String separatorSpaces = " ";

        if (undoTree != null)
        {
            UndoTree t0 = undoTree;
            String s1 = t0.toString(itemToString, indentSpaces, separatorSpaces);
            System.out.println(s1);

            if (true)
            {
                UndoTree t2 = UndoTree.fromString(s1, itemFromString);
                String s3 = t2.toString(itemToString, indentSpaces, separatorSpaces);
                if (!s3.equals(s1))
                {
                    System.out.println(s1);
                    System.out.println(s3);
                    System.out.println("WARNING: they aren't equal!"); // XXX currently goes off because I had to comment out something in the other file, can put this back soon
                    //assert(false);
                }
            }
            System.out.println("===================================");
            System.out.println(undoTree.toStringVisualCool(stretchOutAlongTimeLine >= .5f));
        }
        else
        {
            System.out.println("No undo tree attached.");
        }
    } // asciiDump




    // Graphical viewer for an undo tree, for the example main program
    // XXX shouldn't use swing for this... or maybe I should, I don't know
    private static void makeExampleUndoTreeViewer(final UndoTree undoTree,
                                           final UndoTree otherViewThatThisViewShouldFollowAround,
                                           final int x, final int y, final int w, final int h,
                                           final int nThingsDoneEver[],
                                           final int nViewersAlive[],
                                           final int nModelsEverMade[],
                                           final int nViewsEverMade[],
                                           final int nViewersEverMade[])
    {
        UndoTreeViewer.ItemColorizer colorizer = new UndoTreeViewer.ItemColorizer() {
            private java.util.Random random = new java.util.Random();
            public java.awt.Color color(Object item)
            {
                //
                // Pick a random color that is a function
                // of item's hash code.
                //
                int fudge = 1234; // I didn't like the colors initially
                random.setSeed(item.hashCode()+fudge);
                return new java.awt.Color(random.nextFloat(),
                                          random.nextFloat(),
                                          random.nextFloat());
            }
            public double length(Object item)
            {
                return 1.;
            }
        };
        final UndoTreeViewer undoTreeViewer = new UndoTreeViewer(colorizer);


        nViewersAlive[0]++;
        final javax.swing.JPanel jpanel = new javax.swing.JPanel() {
            // PAINT (the surrounding example)
            public void paintComponent(java.awt.Graphics g)
            {
                int w = getWidth(), h = getHeight();
                if (undoTreeViewer.eventVerboseLevel >= 3) System.out.println("    in paintComponent");

                if (otherViewThatThisViewShouldFollowAround != null)
                {
                    //System.out.println("        kibbles and bits!");
                    double timeIncrement = 1./500; // XXX figure out a scheme that makes sense... currently it just does linear interpolation and we smooth it out in a post-process, which means we do NOT get smooth direction changes, which we'd get if we used the velocity model
                    boolean actuallyDidSomething = undoTree.incrementViewTowardsOtherView(otherViewThatThisViewShouldFollowAround, timeIncrement);
                    //PRINT(actuallyDidSomething);
                }

                g.setColor(java.awt.Color.black);
                g.fillRect(0,0,w,h);
                undoTreeViewer.paint(this, g);

                // XXX should use the font height instead of hard coding 20
                int y = h - 9*20 - 20;
                g.drawString("Enter to Do", 10, y+=20);
                g.drawString("Up to undo", 10, y+=20);
                g.drawString("Down to redo", 10, y+=20);
                g.drawString("Left for older", 10, y+=20);
                g.drawString("Right for younger", 10, y+=20);
                g.drawString("c to clear", 10, y+=20);
                g.drawString("t to toggle stretch-along-time-line display mode", 10, y+=20);
                g.drawString("n for new view window of same tree", 10, y+=20);
                g.drawString("ctrl-n for new view that follows this view around like a dog", 10, y+=20);
                assert(y+20 == h);
                if (undoTreeViewer.eventVerboseLevel >= 3) System.out.println("    out paintComponent");
            }
        };
        // should work in either order...
        undoTreeViewer.attachToComponent(jpanel);
        undoTreeViewer.attachToUndoTree(undoTree);


        // XXX hmm, I think I have listener memory leaks everywhere...
        // XXX this one in particular, no one is keeping track of it at all.
        // XXX in fact I don't think anyone ever calls detachFromUndoTree or detachFromComponent yet!
        {
            UndoTree.Listener otherViewThatThisViewShouldFollowAroundListener = null;
            final java.awt.Component component = jpanel;
            if (otherViewThatThisViewShouldFollowAround != null)
            {
                otherViewThatThisViewShouldFollowAround.addListener(otherViewThatThisViewShouldFollowAroundListener = new UndoTree.Listener() {
                    public void somethingChanged()
                    {
                        //System.out.println("    woof!");
                        // just repaint-- we will progress (and call repaint again)
                        // each time we paint
                        if (component != null)
                            component.repaint();
                    }
                });
            }
            // XXX the following is the corresponding detach code--- put it somewhere appropriate when I get those variables somewhere appropriate
            if (false)
            {
                if (otherViewThatThisViewShouldFollowAround != null)
                {
                    otherViewThatThisViewShouldFollowAround.removeListener(otherViewThatThisViewShouldFollowAroundListener);
                    otherViewThatThisViewShouldFollowAroundListener = null;
                    //otherViewThatThisViewShouldFollowAround = null; // uncomment this when it's real; compiler doesn't like it now because it's final
                }
            }

        }


        final javax.swing.JFrame jframe = new javax.swing.JFrame("Undo Tree View");
        jframe.setForeground(java.awt.Color.white);
        jframe.setForeground(java.awt.Color.black);
        jframe.setContentPane(jpanel);
        jframe.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent event)
            {
                if (--nViewersAlive[0] == 0)
                {
                    System.out.println("Chow!");
                    System.exit(0); // asinine way of doing things
                }
                else
                {
                    System.out.println("ciao!");
                }
            }
        });
        jpanel.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent ke)
            {
                //System.out.println("keyPressed "+ke);
                //System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
                String keyText = java.awt.event.KeyEvent.getKeyText(keyCode);

                if (keyCode == java.awt.event.KeyEvent.VK_ENTER
                 || keyText.equals("Enter")
                 // screw it, I don't like it! it mixes up changes with navigation
                 //|| keyCode == java.awt.event.KeyEvent.VK_NUMPAD5
                 //|| keyText.equals("Begin") // this is what's needed to detect the numeric keypad 5 on my linux machine
                 )
                {
                    int n = nThingsDoneEver[0]++;
                    String doneItem = ""+(char)('A'+n%26);
                    n /= 26;
                    while (n != 0)
                    {
                        doneItem = ""+(char)('A'+n%27-1) + doneItem; // XXX haha lame, it messes up after AA... figure out the right way to to it, you doofus
                        n /= 27;
                    }

                    undoTree.Do(doneItem);
                    if (undoTreeViewer.eventVerboseLevel >= 1) System.out.println("Did "+doneItem);
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_N)
                {
                    makeExampleUndoTreeViewer(new UndoTree(undoTree), // different view, same model
                                              ke.isControlDown() ? undoTree : null, // ctrl-n means the new one should follow me around
                                              x+20, y+20, jframe.getWidth(), jframe.getHeight(), nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade);
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_C // I keep hitting ctrl-c so let's do it baby
                      && ke.isControlDown())
                {
                    System.exit(0);
                }
                jpanel.repaint();
            }
        });

        //jframe.pack();
        jframe.setSize(w,h);
        jframe.setLocation(x,y);
        // I think just-created stuff is safe until the components are
        // "realized"... so put the realization stuff in an invokeLater
        // to be done in an event dispatch thread, where gui creation stuff
        // is supposed to be done.
        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run()
            {
                jframe.setVisible(true);
                jpanel.requestFocus(); // seems to be needed initially, if running in <=1.2 on linux, anyway.  weird!
            }
        });

        /*
        TODO:
            Should make the following buttons:
                older branch  undo  younger branch
                older          Do   younger
                older leaf    redo  younger leaf
        */

    } // makeUndoTreeViewer


    /** Test/example program. */
    // XXX TODO: replace this with a smaller clearer one that just does the littler examples that I gave above.  The viewer stuff is good but is best left to a separate viewer program.
    public static void main(String args[])
    {
        System.out.println("in main");
        UndoTree tree = new UndoTree();
        if (false) // nah, cooler to start with nothing
        {
            // Seed it with something mildly interesting
            tree.Do("A");
            tree.Do("B");
            tree.setPrivateLabel("private_before_fork");
            tree.undo();
            tree.undo();
            tree.Do("C");
            tree.setPrivateLabel("shared_before_fork");
            tree.undo();
            tree.preferYoungerChild();
            tree.redo();
            tree.Do("D");
            tree.Do("E");
        }

        int nThingsDoneEver[] = {0};
        int nViewersAlive[] = {0};
        int nModelsEverMade[] = {0};
        int nViewsEverMade[] = {0};
        int nViewersEverMade[] = {0};
        int x = 50;
        int w = 400;
        makeExampleUndoTreeViewer(tree, null, x, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade);
        // The following two lines are very different!
        if (false)
        {
            // Doing it this way, both viewers will share
            // undos and redos (as well as changes in the tree structure).
            // Each can have its own display style though.
            makeExampleUndoTreeViewer(tree, null, x+=w, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade);
        }
        if (true)
        {
            // Doing it this way, both viewers see tree changes
            // but they can explore the tree independently;
            // one viewer's undos and redos will not affect the other.
            makeExampleUndoTreeViewer(tree = new UndoTree(tree), null, x+=w, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade);
        }
        if (true)
        {
            // Doing it this way, the new one will follow the previous one
            // around!
            makeExampleUndoTreeViewer(new UndoTree(tree), tree, x+=w, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade);
        }

        //
        // Okay I think a good way to manage the models, views, and viewers
        // is with a JTree.
        // A typical setup is:
        //      model I
        //          view A
        //              viewer 0
        //              viewer 1
        //              viewer 2
        //          view B
        //              viewer 3
        //          view C
        //      model II
        //          view D
        //              viewer 4
        // XXX Bleah, I know this is going to totally obscure the simplicity
        // of this example program
        //          


        System.out.println("out main");
    } // main
} // class UndoTreeViewer
