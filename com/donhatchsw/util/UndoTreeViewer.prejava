package com.donhatchsw.util;

import com.donhatchsw.compat.regex;

#include "macros.h"

/**
* Graphical Viewer for an UndoTree.
* This class is Component-agnostic, at least to the extent
* that you can hook it up to either a Canvas or a JPanel, for example.
*
* <pre>
*              key,mouse                       undo,redo      +--------------+
* +----------+  events   +---------------+     requests       |Application   |
* |Component |---------->|UndoTreeViewer |------------------->|              |
* |          |           |               |                    | Do,undo,redo |
* |-  -  -  -| repaint() |               | somethingChanged() | +---------+  |
* |          |<----------|<--------------|<---------------------|UndoTree |  |
* |          |---------->|               |           +----------|         |  |
* +----------+  paint()  +---------------+           |        | |         |  |
*                                                    |        | +---------+  |
*                                                    v        +--------------+
*                                         +----------------+        ^
*                                         |UndoTreeViewer2 |        |
*                                      ...|                |--------+
* </pre>
* All of the above connections are established via listener callbacks,
* except for the repaint and paint calls which are done directly;
* the Component should call the UndoTreeViewer's paint() method
* from inside its own paint() or paintComponent() method.
* <p>
* Actually the controlling Component (the one sending key and mouse events)
* can be different from the displaying Component (that's the reason
* for the dotted line across the Component in the above diagram),
* although I don't know why you'd want that.
*/
// XXX would it make more sense for the UndoTreeViewer to call undo/redo etc. on the UntoTree directly, and have the Application be set up to intercept those somehow?  Think about that...
public class UndoTreeViewer
{
    /**
    * Anyone can set this at any time to debug the viewer's activity;
    * possible values are as follows.
    * <pre>
    *      0: nothing (default)
    *      1: key and mouse press/release/click
    *      2: and mouse drags
    *      3: and update/paint
    *      4: and enter/exit (can be obnoxious)
    *      5: and mouse motion (can be obnoxious)
    *</pre>
    */
    public int eventVerboseLevel = 0;


    private ItemColorizer colorizer; // set in ctor

    //
    // Things I listen to...
    //
    private UndoTree undoTree = null;
    private UndoTree.Listener undoTreeListener = null;
    private java.awt.Component component;
    private java.awt.event.KeyListener componentKeyListener = null;
    private java.awt.event.MouseListener componentMouseListener = null;
    private java.awt.event.MouseMotionListener componentMouseMotionListener = null;
    //
    // And things that listen to me.
    //
    private com.donhatchsw.compat.ArrayList/*<Applistener>*/ appListeners = new com.donhatchsw.compat.ArrayList();

    /** Install one of these if you want the UndoTree to be able to request app actions in response to the user manipulating the UndoTreeViewer window. */
    public interface AppListener
    {
        public void requestUndo();
        public void requestRedo();
        public void requestPreferOlderChild();
        public void requestPpreferYoungerChild();
    }

    /** Installs a listener that will send requests from the UndoTreeViewer window to an application. */
    public void addAppListener(AppListener appListener)
    {
        appListeners.remove(appListener); // XXX should throw IllegalArgument instead
        appListeners.add(appListener);
    } // addAppListener
    /** Removes a listener that was previously installed with addAppListener. */
    public void removeAppListener(AppListener appListener)
    {
        appListeners.remove(appListener);
    } // removeAppListener

    /** Callback used to decide the appearance (color and length) of each edge in the UndoTree. You give one of these to the UndoTreeViewer constructor. */
    public interface ItemColorizer
    {
        /**
        * The color in which given edge should be drawn.
        */
        java.awt.Color color(Object item);
        /**
        * The length the given edge should be; use 1 for an average edge.
        */
        double length(Object item);
    }

    /** Attaches to the given UndoTree. It is an error to try to attach to more than one UndoTree at a given time. */
    public void attachToUndoTree(UndoTree undoTree)
    {
        if (undoTreeListener != null)
            throw new IllegalArgumentException("UndoTreeViewer.attachToUndoTree: already attached to someone"); // XXX should be illegal state or something instead?
        this.undoTree = undoTree;
        undoTree.addListener(this.undoTreeListener = new UndoTree.Listener() {
            public void somethingChanged()
            {
                if (component != null)
                    component.repaint();
            }
        });
    } // attachToUndoTree
    /** Detaches from the UndoTree that was previously attached using attachToUndoTree. */
    public void detachFromUndoTree()
    {
        if (undoTreeListener == null)
            throw new IllegalArgumentException("UndoTreeViewer.detachFromUndoTree: not attached to any UndoTree"); // XXX should be illegal state or something instead?
        undoTree.removeListener(undoTreeListener);
        undoTreeListener = null;
        undoTree = null;
    } // detachFromUndoTree
    /** Installs event listeners on the given Component, which can be a Canvas or a JPanel or whatever. It is an error to try to attach to more than one Component at a given time. */
    public void attachToComponent(final java.awt.Component component)
    {
        if (component != null)
            throw new IllegalArgumentException("UndoTreeViewer.attachToComponent: already attached to someone"); // XXX should be illegal state or something instead?
        this.component = component;
        component.addKeyListener(componentKeyListener = new java.awt.event.KeyListener() {
            public void keyPressed(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyPressed "+ke);
                if (eventVerboseLevel >= 1) System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
            }
            public void keyReleased(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyReleased "+ke);
                if (eventVerboseLevel >= 1) System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
            }
            public void keyTyped(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyTyped");
                char c = ke.getKeyChar();
                //System.out.println("key listener got key '"+c+"'("+(int)c+")"); // XXX escapify!
            }
        }); // key listener
        component.addMouseListener(componentMouseListener = new java.awt.event.MouseListener() {
            public void mouseClicked(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mouseClicked on a "+component.getClass().getSuperclass().getName());
            } // mouseClicked
            public void mousePressed(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mousePressed on a "+component.getClass().getSuperclass().getName());
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mouseReleased on a "+component.getClass().getSuperclass().getName());
            } // mouseReleased
            public void mouseEntered(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 4) System.out.println("mouseExited on a "+component.getClass().getSuperclass().getName());
            } // mouseEntered
            public void mouseExited(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 4) System.out.println("mouseExited on a "+component.getClass().getSuperclass().getName());
            } // mouseExited
        }); // mouse listener
        component.addMouseMotionListener(componentMouseMotionListener = new java.awt.event.MouseMotionListener() {
            public void mouseDragged(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mouseDragged on a "+component.getClass().getSuperclass().getName()+", time = "+me.getWhen());
            } // mouseDragged
            public void mouseMoved(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 5) System.out.println("        mouseMoved on a "+component.getClass().getSuperclass().getName());
            } // mouseMoved
        }); // mouse motion listener
    } // attachToComponent

    /** Detaches from the given component, which must have been previously attached by attachToComponent(). */
    public void detachFromComponent(java.awt.Component component)
    {
        if (component == null)
            throw new IllegalArgumentException("UndoTreeViewer.detachFromComponent: not attached to any component"); // XXX should be illegal state or something instead?
        component.removeKeyListener(componentKeyListener);
        component.removeMouseListener(componentMouseListener);
        component.removeMouseMotionListener(componentMouseMotionListener);
        componentKeyListener = null;
        componentMouseListener = null;
        componentMouseMotionListener = null;
        component = null;
    } // detachFromComponent

    /** Paint callback to be called from inside your Component's paint() or paintComponent() method. The caller is responsible for clearing the window and/or double-buffering. XXX although it might make sense to draw single-buffered sometimes, when only a couple of pixels are changing... need to think about this */
    // PAINT
    public void paint(java.awt.Component component, java.awt.Graphics graphics)
    {
        if (eventVerboseLevel >= 3) System.out.println("            painting on a "+component.getClass().getSuperclass().getName());

    } // paint

    /** Creates an UndoTreeViewer.  Attach it to a Component using attachToComponent and to an UndoTree using attachToUndoTree. */
    public UndoTreeViewer(ItemColorizer colorizer)
    {
        this.colorizer = colorizer;
    } // UndoTreeViewer ctor


    // Graphical viewer for an undo tree, for the example main program
    // XXX shouldn't use swing for this... or maybe I should, I don't know
    private static void makeUndoTreeViewer(final UndoTree undoTree,
                                           final int x, final int y, final int w, final int h,
                                           final int nThingsDoneEver[],
                                           final int nViewsAlive[])
    {
        nViewsAlive[0]++;
        final boolean stretchOutAlongTimeLine[] = {false};
        final javax.swing.JPanel jpanel = new javax.swing.JPanel() {
            // PAINT
            public void paintComponent(java.awt.Graphics g)
            {
                System.out.println("    in paintComponent");
                UndoTree.ItemToString itemToString = new UndoTree.ItemToString(){
                    public String regex()
                    {
                        //return "-?\\d+"; // ints
                        //return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                        return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
                    }
                    public String itemToString(Object obj)
                    {
                        // is this method necessary? could just take the regex
                        //return obj.toString(); // ints
                        return obj.toString(); // identifiers too
                    }
                };
                UndoTree.ItemFromString itemFromString = new UndoTree.ItemFromString(){
                    public String regex()
                    {
                        // return "-?\\d+"; // ints
                        //return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                        return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
                    }
                    public Object itemFromString(String s)
                    {
                        //return Integer.valueOf(s); // ints
                        return s; // identifiers
                    }
                };
                //String indentSpaces = "    ";
                //String separatorSpaces = System.getProperty("line.separator");
                String indentSpaces = "";
                String separatorSpaces = " ";

                UndoTree t0 = undoTree;
                String s1 = t0.toString(itemToString, indentSpaces, separatorSpaces);
                System.out.println(s1);

                if (true)
                {
                    UndoTree t2 = UndoTree.fromString(s1, itemFromString);
                    String s3 = t2.toString(itemToString, indentSpaces, separatorSpaces);
                    if (!s3.equals(s1))
                    {
                        System.out.println(s3);
                        assert(false);
                    }
                }
                System.out.println("===================================");
                System.out.println(undoTree.toStringVisualCool(stretchOutAlongTimeLine[0]));
                System.out.println("    out paintComponent");
            }
        };

        final javax.swing.JFrame jframe = new javax.swing.JFrame("Undo Tree View");
        jframe.setForeground(java.awt.Color.white);
        jframe.setForeground(java.awt.Color.black);
        jframe.setContentPane(jpanel);
        jframe.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent event)
            {
                if (--nViewsAlive[0] == 0)
                {
                    System.out.println("Chow!");
                    System.exit(0); // asinine way of doing things
                }
                else
                {
                    System.out.println("ciao!");
                }
            }
        });

        //jframe.pack();
        jframe.setSize(w,h);
        jframe.setLocation(x,y);
        jframe.setVisible(true);
        jpanel.requestFocus(); // seems to be needed initially, if running in <=1.2 on linux, anyway.  weird!

        jpanel.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent ke)
            {
                boolean horizontal = false; // set to true when concentrating on the uncool ascii tree

                //System.out.println("in keyPressed: "+ke);
                int keyCode = ke.getKeyCode();
                if (keyCode == java.awt.event.KeyEvent.VK_ENTER)
                {
                    //Integer doneItem = new Integer(nThingsDoneEver[0]++);
                    int n = nThingsDoneEver[0]++;
                    String doneItem = ""+(char)('A'+n%26);
                    n /= 26;
                    while (n != 0)
                    {
                        doneItem = ""+(char)('A'+n%27-1) + doneItem; // XXX haha lame, it messes up after AA... figure out the right way to to it, you doofus
                        n /= 27;
                    }

                    undoTree.Do(doneItem);
                    System.out.println("Did "+doneItem);
                }
                else if (keyCode == (horizontal ? java.awt.event.KeyEvent.VK_LEFT : java.awt.event.KeyEvent.VK_UP))
                {
                    //Integer undoneItem = (Integer)undoTree.undo();
                    String undoneItem = (String)undoTree.undo();
                    System.out.println("undid "+undoneItem);
                }
                else if (keyCode == (horizontal ? java.awt.event.KeyEvent.VK_RIGHT : java.awt.event.KeyEvent.VK_DOWN))
                {
                    //Integer redoneItem = (Integer)undoTree.redo();
                    String redoneItem = (String)undoTree.redo();
                    System.out.println("redid "+redoneItem);
                }
                else if (keyCode == (horizontal ? java.awt.event.KeyEvent.VK_UP : java.awt.event.KeyEvent.VK_LEFT))
                {
                    System.out.println("going younger, if you're lucky");
                    // XXX clunky
                    if (undoTree.undo() != null)
                    {
                        undoTree.preferYoungerChild();
                        undoTree.redo();
                    }
                }
                else if (keyCode == (horizontal ? java.awt.event.KeyEvent.VK_DOWN : java.awt.event.KeyEvent.VK_RIGHT))
                {
                    System.out.println("going older, if you're lucky");
                    // XXX clunky
                    if (undoTree.undo() != null)
                    {
                        undoTree.preferOlderChild();
                        undoTree.redo();
                    }
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_S)
                {
                    undoTree.setSharedLabel("this_is_a_shared_label"); // XXX get rid of the underscores when I make the parsing smarter
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_P)
                {
                    undoTree.setPrivateLabel("this_is_a_private_label"); // XXX get rid of the underscores when I make the parsing smarter
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_N)
                {
                    makeUndoTreeViewer(new UndoTree(undoTree), x+20, y+20, jframe.getWidth(), jframe.getHeight(), nThingsDoneEver, nViewsAlive);
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_T)
                {
                    stretchOutAlongTimeLine[0] ^= true;
                    System.out.println("stretchOutAlongTimeLine "+!stretchOutAlongTimeLine[0]+" -> "+stretchOutAlongTimeLine[0]);
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_C // I keep hitting ctrl-c so let's do it baby
                      && ke.isControlDown())
                {
                    System.exit(0);
                }
                jpanel.repaint();
            }
        });
    } // makeUndoTreeViewer


    /** Test/example program. */
    // XXX TODO: replace this with a smaller clearer one that just does the littler examples that I gave above.  The viewer stuff is good but is best left to a separate viewer program.
    public static void main(String args[])
    {
        System.out.println("in main");
        UndoTree undoTree0 = new UndoTree(null);
        UndoTree undoTree1 = new UndoTree(undoTree0);
        int nThingsDoneEver[] = new int[]{0};
        int nViewsAlive[] = new int[]{0};
        // XXX argh, I guess I need to do the invokeLater thing?  bleah, why must everything be so difficult in swing :-(
        makeUndoTreeViewer(undoTree0, 500, 20, 300, 300, nThingsDoneEver, nViewsAlive);
        System.out.println("out main");
    } // main
} // class UndoTreeViewer
