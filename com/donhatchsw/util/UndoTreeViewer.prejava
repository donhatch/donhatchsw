/*
    TODO:
        - example app could be a simple editor... each letter typed
            or deleted is a Do.  Oh cool!
            What sort of games could we do?
                - multiplayer typing following?
        - show animation and controller both in same window, optionally
            (I think all that's really needed from the animation
            window is its current position)

        - need a way to disable undo/redo for the mc4d animation view
            since otherwise they will mess it up bad!
        - hmm, never stops moving... who's calling repaint when they shouldn't?
        - smoothing-- for now, would be fine to just do the post-time-to-space thing, thought it would be nicer to do it down in the velocity of the undo tree view so it can do smooth direction changes... that would be AWESOME
        - speed slider
        - ctrl-up, ctrl-down should put it on a fractional place
        - clicking on a node should make it current
            (and ctrl-clicking should let it land on a fractional place)

        - button panel
        - should be able to drag view around with middle mouse
        - JTree to show model/view/viewer relationship
                        model/view/followingview/viewer relationship
                and moving stuff around in there
                are exactly the supported operations
                for connecting and reconnecting stuff
                to each other.

        - should have prune methods--
                PruneCurrentAndBelow
                PruneAboveCurrent
          OOH!  and all parts of the tree should be ref counted and should
                automatically go away when no one can ever see them again!!!
                ha!
        - make the model/view thing explicit instead of this half-assed implicit joint ownership thing!
        - should remember current depth when moving more shallowly, like vim does
        - optimize the tree rendering so bushy parts can stack up if possible
        - don't continuously fit, should just have a fit button
        - clipping-- especially when label drawing
        - option to not slow down at edge transitions
        - all listeners should have names in case we want to turn debugging on
        - don't-stop-at-stop-signs mode?
          possible names:
            stop at stop signs
            stop at intersections
            stop at crossroads
            stop at railroad tracks
            rolling stops
        - ooh we can make the double-click go smooth now!!!
        - mode in which they manipulate the puzzle face like a trackball?

    List of pie-in-the-sky features that just got easy:
        Ctrl key required for spin dragging
            - the drinking game
        Undo tree
            - no need for separate animation queue or buffer--
              twists, undos, redos take effect in the undo tree immediately.
              The animation and controller just see two different
              current positions in the tree (the controller's position
              in the tree gets updated instantaneously in response
              to Do/undo/redos, while the animation's position lags behind
              at the selected speed).
            - user can undo/redo while a twist is in progress
                (this was problematic before since,
                for example, a quick undo-undo-undo-redo
                would destroy the history, making it impossible
                for the animation to recover)
            - can automatically vary the twist speed throughout a solve
              so it's really fast in the middle (optionally)
            - user can change from undo to redo and back
              in the middle of a twist, it will smoothly change direction
              in mid-twist-- there are never any velocity impulses,
              it's effectively force based so it will always react smoothly
              to anything you do.
            - you can make it overshoot, by suddenly slowing it down
              (which actually means weakening it, since it's all force based)
              in the middle of a twist.
              When this happens it will not have the necessary strength
              to decelerate to a smooth landing at the planned time,
              so it will overshoot and recover, smoothly, instead.
            - optional overshoot/oscillation (bounce) when converging
              on the end each twist
            - you can drag back and forth along the undo/redo timeline,
              stopping in the middle of a twist if you want
              (it will smoothly complete the twist when you let go)
            - When you double-click to do a double-twist,
              the two twists are combined smoothly into one,
              giving exactly the same animation
              as if you had asked for it with a single mouse or key event.
              (Similarly if you triple-click!)
              The reason this works is that the motion paths
              of a single twist and a smooth double-twist (or triple-click)
              are identical up to the halfway point
              of the single twist (i.e. up to the point
              where the single twist would stop accelerating
              and start decelerating).  So as long as you get the second
              click in before the halfway point of the single twist,
              they can be combined and it will look exactly like
              one longer twist.
              Note that even if you wait until after that halfway point
              to do the second click, the change of plans will
              be handled smoothly... it will simply accelerate
              again as necessary and head for the farther target
              at which it will land smoothly.
            - Likewise if you hit undo in the middle of the twist,
              it will smoothly switch direction in mid-flight.
              All trajectory plans are recalculated from scratch each frame
              based on the target and current velocity,
              so when you change the target it always reacts smoothly.

*/
package com.donhatchsw.util;

import com.donhatchsw.compat.regex;

#include "macros.h"

/**
* Graphical Viewer for an UndoTree.
* This class is Component-agnostic, at least to the extent
* that you can hook it up to either a Canvas or a JPanel, for example.
*
* <pre>
*              key,mouse                       undo,redo      +--------------+
* +----------+  events   +---------------+     requests       |Application   |
* |Component |---------->|UndoTreeViewer |------------------->|              |
* |          |           |               |                    | Do,undo,redo |
* |-  -  -  -| repaint() |               | somethingChanged() | +---------+  |
* |          |<----------|<--------------|<---------------------|UndoTree |  |
* |          |---------->|               |           +----------|         |  |
* |          |  paint()  |               |           |        | |         |  |
* |          |           |               |           |        | +---------+  |
* |          |<--------- +---------------+           v        +--------------+
* +----------+   actual drawing           +----------------+        ^
*                inside paint()           |UndoTreeViewer2 |        |
*                                      ...|                |--------+
* </pre>
* All of the above connections are established via listener callbacks,
* except for the repaint and paint calls which are done directly;
* the Component should call the UndoTreeViewer's paint() method
* from inside its own paint() or paintComponent() method.
* <p>
* Actually the controlling Component (the one sending key and mouse events)
* can be different from the displaying Component (that's the reason
* for the dotted line across the Component in the above diagram),
* although I don't know why you'd want that.
*/
// XXX would it make more sense for the UndoTreeViewer to call undo/redo etc. on the UntoTree directly, and have the Application be set up to intercept those somehow?  Think about that...
public class UndoTreeViewer
{
    /**
    * Anyone can set this at any time to debug the viewer's activity;
    * possible values are as follows.
    * <pre>
    *      0: nothing (default)
    *      1: key and mouse press/release/click
    *      2: and mouse drags
    *      3: and update/paint
    *      4: and enter/exit (can be obnoxious)
    *      5: and mouse motion (can be obnoxious)
    *</pre>
    */
    public int eventVerboseLevel = 0; // XXX need a key to cycle this


    private ItemColorizer colorizer; // set in ctor
    private UndoTree.ItemLengthizer lengthizer; // set in ctor

    //
    // Viewing parameters that always change SMOOTHLY
    // so I don't have an anxiety attack.
    //
        private SmoothlyVaryingViewingParameter stretchOutAlongTimeLine = new SmoothlyVaryingViewingParameter(0.);
        public SmoothlyVaryingViewingParameter centerCurrentNode = new SmoothlyVaryingViewingParameter(0.);
        private SmoothlyVaryingViewingParameter log2ViewScale = new SmoothlyVaryingViewingParameter(0.);
        private double paramFadeFrames = 1000.;
        private double paramCriticalDampingFraction = .9;

        //public double nFramesPerEdgeWhenFollowing = 300.; // XXX this is a misnomer, it's per average edge
        public double nFramesPerEdgeWhenFollowing = 50.;

        // XXX WEIRD! the number of frames it takes to converge doesn't
        // XXX increase monotonically as the damping decrease... it has a sweet spot!
        // XXX this is with nFramesPerEdgeWhenFollowing=300, on a 360 edge.
        // XXX might be a numerical artifact of the dt?
        //private double followerCriticalDampingFraction = .05; // 5421
        //private double followerCriticalDampingFraction = .06; // 5580
        //private double followerCriticalDampingFraction = .062; // 5590
        //private double followerCriticalDampingFraction = .063; // 5594
        //private double followerCriticalDampingFraction = .065; // 5595
        //private double followerCriticalDampingFraction = .066; // 5596 <<< !
        //private double followerCriticalDampingFraction = .067; // 5595
        //private double followerCriticalDampingFraction = .068; // 5594
        //private double followerCriticalDampingFraction = .069; // 5591
        //private double followerCriticalDampingFraction = .07; // 5586
        //private double followerCriticalDampingFraction = .071; // 5583
        //private double followerCriticalDampingFraction = .08; // 5504
        //private double followerCriticalDampingFraction = .75; // 1024
        private double followerCriticalDampingFraction = .9; // 799   (just detectable if you're paying attention)
        //private double followerCriticalDampingFraction = .95; // 726
        //private double followerCriticalDampingFraction = 1; // 604 yep, critical damping is the fastest converging!
        //private double followerCriticalDampingFraction = 1.1; // 618
        //private double followerCriticalDampingFraction = 1.5; // 675
        //private double followerCriticalDampingFraction = 2; // 764
        //private double followerCriticalDampingFraction = 3; // 1124
        //private double followerCriticalDampingFraction = 4; // infinity whoa, never converges! hmm, probably hanging out near the floating point epsilon.  XXX can we detect stall?
        //private double followerCriticalDampingFraction = 5; // 1039
        //private double followerCriticalDampingFraction = 10; // infinity
        //private double followerCriticalDampingFraction = 20; // infinity


        public boolean showLabels = false; // XXX need a toggle for this



    //
    // Things I listen to...
    //
    private UndoTree undoTree = null;
    private UndoTree.Listener undoTreeListener = null;
    private java.awt.Component component;
    private java.awt.event.KeyListener componentKeyListener = null;
    private java.awt.event.MouseListener componentMouseListener = null;
    private java.awt.event.MouseMotionListener componentMouseMotionListener = null;
    //
    // And things that listen to me.
    //
    private com.donhatchsw.compat.ArrayList/*<Applistener>*/ appListeners = new com.donhatchsw.compat.ArrayList();

    /** Install one of these if you want the UndoTree to be able to request app actions in response to the user manipulating the UndoTreeViewer window. */
    // XXX I'm not sure this is functional?  revisit this
    public interface AppListener
    {
        public void requestUndo();
        public void requestRedo();
        public void requestPreferOlderChild();
        public void requestPpreferYoungerChild();
    }

    /** Installs a listener that will send requests from the UndoTreeViewer window to an application. */
    public void addAppListener(AppListener appListener)
    {
        appListeners.remove(appListener); // XXX should throw IllegalArgument instead
        appListeners.add(appListener);
    } // addAppListener
    /** Removes a listener that was previously installed with addAppListener. */
    public void removeAppListener(AppListener appListener)
    {
        appListeners.remove(appListener);
    } // removeAppListener

    /** Callback used to decide the appearance (color and length) of each edge in the UndoTree. You give one of these to the UndoTreeViewer constructor. */
    public interface ItemColorizer
    {
        /**
        * The color in which given edge should be drawn.
        */
        java.awt.Color color(Object item);
        /**
        * Labels to put on the left and right of the given edge.
        */
        String leftLabel(Object item);
        String rightLabel(Object item);
    }

    /** Attaches to the given UndoTree. It is an error to try to attach to more than one UndoTree at a given time. */
    public void attachToUndoTree(UndoTree undoTree)
    {
        if (undoTreeListener != null)
            throw new IllegalArgumentException("UndoTreeViewer.attachToUndoTree: already attached to someone"); // XXX should be illegal state or something instead?
        this.undoTree = undoTree;
        undoTree.addListener(this.undoTreeListener = new UndoTree.Listener() {
            public void somethingChanged()
            {
                if (component != null)
                    component.repaint();
            }
        });

        // And just do it, since something did change...
        if (component != null)
            component.repaint();

    } // attachToUndoTree
    /** Detaches from the UndoTree that was previously attached using attachToUndoTree. */
    public void detachFromUndoTree()
    {
        if (undoTreeListener == null)
            throw new IllegalArgumentException("UndoTreeViewer.detachFromUndoTree: not attached to any UndoTree"); // XXX should be illegal state or something instead?
        undoTree.removeListener(undoTreeListener);
        undoTreeListener = null;
        undoTree = null;

        // And just do it, since something did change...
        if (component != null)
            component.repaint();
    } // detachFromUndoTree
    /** Installs event listeners on the given Component, which can be a Canvas or a JPanel or whatever. It is an error to try to attach to more than one Component at a given time. */
    public void attachToComponent(final java.awt.Component component)
    {
        if (this.component != null)
            throw new IllegalArgumentException("UndoTreeViewer.attachToComponent: already attached to someone"); // XXX should be illegal state or something instead?
        this.component = component;
        component.addKeyListener(componentKeyListener = new java.awt.event.KeyListener() {

            public void keyPressed(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyPressed "+ke);
                if (eventVerboseLevel >= 1) System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
                int keyChar = ke.getKeyChar();
                String keyText = java.awt.event.KeyEvent.getKeyText(keyCode);

                boolean horizontal = false; // only vertical is supported, I think, unless I want to do diagonal flips some day or something

                if (false)
                {
                    // XXX bleah! get rid of this when I stop needing to look at it and be weirded out
                    PRINT(keyCode);
                    PRINT(keyChar);
                    PRINT(keyText);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD0);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD1);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD2);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD3);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD4);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD5);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD6);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD7);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD8);
                    PRINT(java.awt.event.KeyEvent.VK_NUMPAD9);
                }

                // holy shit!
                int x = 0, y = 0;
                if (false) {}
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD1
                      || keyText.equals("End"))
                    { x = -1; y = 1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_DOWN
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD2
                      || keyText.equals("Down"))
                    { x = 0; y = 1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD3
                      || keyText.equals("Page Down"))
                    { x = 1; y = 1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_LEFT
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD4
                      || keyText.equals("Left"))
                    { x = -1; y = 0; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD5
                      || keyText.equals("Begin"))
                    { x = 0; y = 0; }
                else if (keyCode == java.awt.event.KeyEvent.VK_RIGHT
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD6
                      || keyText.equals("Right"))
                    { x = 1; y = 0; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD7
                      || keyText.equals("Home"))
                    { x = -1; y = -1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_UP
                      || keyCode == java.awt.event.KeyEvent.VK_NUMPAD8
                      || keyText.equals("Up"))
                    { x = 0; y = -1; }
                else if (keyCode == java.awt.event.KeyEvent.VK_NUMPAD9
                      || keyText.equals("Page Up"))
                    { x = 1; y = -1; }
                else
                {
                    // nothin
                }

                if (horizontal)
                {
                    int temp = x;
                    x = y;
                    y = temp;
                }

                if (false) {}
                else if (y==-1 && x==-1)
                    requestOlderBranch();
                else if (y==-1 && x==0)
                    requestUndo(ke.isControlDown() ? .1 : 1.);
                else if (y==-1 && x==1)
                    requestYoungerBranch();
                else if (y==0 && x==-1)
                    requestOlder();
                else if (y==0 && x==1)
                    requestYounger();
                else if (y==1 && x==-1)
                    requestOlderLeaf();
                else if (y==1 && x==0)
                    requestRedo(ke.isControlDown() ? .1 : 1.);
                else if (y==1 && x==1)
                    requestYoungerLeaf();

                if (component != null)
                    component.repaint();
            }
            public void keyReleased(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyReleased "+ke);
                if (eventVerboseLevel >= 1) System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
            }
            public void keyTyped(java.awt.event.KeyEvent ke)
            {
                if (eventVerboseLevel >= 1) System.out.println("keyTyped");
                char c = ke.getKeyChar();
                //System.out.println("key listener got key '"+c+"'("+(int)c+")"); // XXX escapify!
                if (c == '0') // toggle center current node
                {
                    boolean justUseLerp = (ke.isShiftDown());
                    centerCurrentNode.set(1.-centerCurrentNode.getTarget());
                }
                else if (c == '+' || c == '=') // zoom in
                {
                    boolean justUseLerp = (ke.isShiftDown());
                    log2ViewScale.set(log2ViewScale.getTarget() + .5f);
                }
                else if (c == '-') // zoom out
                {
                    boolean justUseLerp = (ke.isShiftDown());
                    log2ViewScale.set(log2ViewScale.getTarget() - .5f);
                }
                else if (c == 't') // stretch out along time line
                {
                    boolean justUseLerp = (ke.isShiftDown());
                    stretchOutAlongTimeLine.set(1.-stretchOutAlongTimeLine.getTarget());
                }
                else if (c == 'a') // ascii dump
                {
                    asciiDump(undoTree, stretchOutAlongTimeLine.get());
                }
                else if (c == 'S')
                {
                    nFramesPerEdgeWhenFollowing *= Math.sqrt(2);
                }
                else if (c == 's')
                {
                    nFramesPerEdgeWhenFollowing *= Math.sqrt(.5);
                }
                else if (c == 'l')
                {
                    showLabels = !showLabels;
                }
                // XXX yes I want the following but there is no visual indication of it yet so let me use the keys for other things
                /*
                else if (c == 's') // set shared label
                {
                    undoTree.setSharedLabel("this_is_a_shared_label"); // XXX get rid of the underscores when I make the parsing smarter
                }
                else if (c == 'p') // set private label
                {
                    undoTree.setPrivateLabel("this_is_a_private_label"); // XXX get rid of the underscores when I make the parsing smarter
                }
                */
                else if (c == 'j') // toggle jitter
                {
                    jitterRadius = (jitterRadius + 1) % 2; // just on or off seems to be all that's needed
                    // XXX um... and why am I not seeing it repaint immediately? OH FOR FUCKS SAKE I HAVE TO POINT TO CLICK AFTER I ENTER THE WINDOW! but only sometimes!! when will I get this monkey off my back?
                }
                if (component != null)
                    component.repaint();
            } // keyTyped
        }); // key listener
        component.addMouseListener(componentMouseListener = new java.awt.event.MouseListener() {
            public void mouseClicked(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mouseClicked on a "+component.getClass().getSuperclass().getName());

            } // mouseClicked
            public void mousePressed(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mousePressed on a "+component.getClass().getSuperclass().getName());
                setCurrentToClosestToMouse(frameForPicking, me.getX(), me.getY(), undoTree);
                // no repaint necessary from us... it notifies everyone who's drawing it
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("mouseReleased on a "+component.getClass().getSuperclass().getName());
            } // mouseReleased
            public void mouseEntered(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 4) System.out.println("mouseExited on a "+component.getClass().getSuperclass().getName());
            } // mouseEntered
            public void mouseExited(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 4) System.out.println("mouseExited on a "+component.getClass().getSuperclass().getName());
            } // mouseExited
        }); // mouse listener
        component.addMouseMotionListener(componentMouseMotionListener = new java.awt.event.MouseMotionListener() {
            private long time0 = System.currentTimeMillis();
            public void mouseDragged(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 1) System.out.println("    mouseDragged on a "+component.getClass().getSuperclass().getName()+", time = "+(me.getWhen()-time0)/1000.);
                if (centerCurrentNode.get() != 0.)
                {
                    // Continuously moving the node under the mouse to center
                    // has the effect of warping to the edge of the world,
                    // which is not friendly, so we don't do anything on drag
                    // when in that mode.
                    // XXX there might be other things we could do... think about it
                }
                else
                    setCurrentToClosestToMouse(frameForPicking, me.getX(), me.getY(), undoTree);
                // no repaint necessary from us... it notifies everyone who's drawing it
            } // mouseDragged
            public void mouseMoved(java.awt.event.MouseEvent me)
            {
                if (eventVerboseLevel >= 5) System.out.println("        mouseMoved on a "+component.getClass().getSuperclass().getName());
            } // mouseMoved
        }); // mouse motion listener
    } // attachToComponent

        //
        // Private convenience stuff...
        // XXX actually might be useful for public use, think about it
        //

            private void requestYoungerBranch() // 7 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request younger branch");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferYoungerChild())
                    {
                        undoTree.redo();
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestUndo(double amount)        // 8 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request undo");
                assert(amount >= 0);

                double originalFraction = undoTree.getCurrentNodeFraction();
                double targetFraction = originalFraction-amount;
                //
                // If it would go from strictly after a node
                // to strictly before it (or even at it), then clamp.
                //
                if (originalFraction > 0.
                 && targetFraction <= 0.)
                {
                    Object undoneItem = undoTree.undo();
                    if (eventVerboseLevel >= 1) System.out.println("undid "+(String)undoneItem);
                    undoTree.setCurrentNodeFraction(1.);
                }
                else
                {
                    undoTree.setCurrentNodeFraction(targetFraction);
                }
            }
            private void requestOlderBranch()   // 9 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request older branch");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferOlderChild())
                    {
                        undoTree.redo();
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestOlder()       // 4 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request older at same depth");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferOlderChild())
                    {
                        // Try to go back to same level as before,
                        // sticking to the young side
                        while (nUndosDone-- > 0)
                        {
                            undoTree.redo(); // okay if fails
                            if (nUndosDone > 0)
                            {
                                while (undoTree.preferYoungerChild())
                                    ;
                            }
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            // App is expected to handle the 5 key and do a Do, maybe
            private void requestYounger()     // 6 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request younger at same depth");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferYoungerChild())
                    {
                        // Try to go back to same level as before,
                        // sticking to the old side
                        while (nUndosDone-- > 0)
                        {
                            undoTree.redo(); // okay if fails
                            if (nUndosDone > 0)
                            {
                                while (undoTree.preferOlderChild())
                                    ;
                            }
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestOlderLeaf()   // 7 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request older leaf");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferOlderChild())
                    {
                        // Go as deep as possible,
                        // sticking to the young side
                        while (undoTree.redo() != null)
                        {
                            while (undoTree.preferYoungerChild())
                                ;
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }
            private void requestRedo(double amount)        // 8 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request redo");
                assert(amount >= 0);

                //
                // If it would go from strictly before a node
                // to strictly after it, then clamp.
                //
                double originalFraction = undoTree.getCurrentNodeFraction();
                double targetFraction = originalFraction+amount;

                double eps = 1e-3;
                if (LT(originalFraction, 1., eps)
                 && GT(targetFraction, 1., eps))
                {
                    targetFraction = 1.;
                }
                else if (EQ(originalFraction, 1., eps)
                      && GT(targetFraction, 1., eps))
                {
                    Object redoneItem = undoTree.redo();
                    if (eventVerboseLevel >= 1) System.out.println("redid "+(String)redoneItem);
                    if (redoneItem == null)
                        targetFraction = 1.; // the redo failed-- it's a leaf, don't go past it
                    else
                        targetFraction -= 1.;
                }
                undoTree.setCurrentNodeFraction(targetFraction);
            }
            private void requestYoungerLeaf() // 9 key on numeric keypad
            {
                if (eventVerboseLevel >= 1) System.out.println("request younger leaf");
                int nUndosDone = 0;
                while (undoTree.undo() != null)
                {
                    nUndosDone++;
                    if (undoTree.preferYoungerChild())
                    {
                        // Go as deep as possible,
                        // sticking to the old side
                        while (undoTree.redo() != null)
                        {
                            while (undoTree.preferOlderChild())
                                ;
                        }
                        return;
                    }
                }
                // oops, hit the top. unroll
                while (nUndosDone-- > 0)
                    undoTree.redo();
            }

            private static void setCurrentToClosestToMouse(double frameForPicking[][], int mouseX, int mouseY, UndoTree undoTree)
            {
                if (frameForPicking != null)
                {
                    double closestDistSqrd = Double.POSITIVE_INFINITY;
                    int closestNode = -1;
                    for (int iNode = 0; iNode < frameForPicking[0].length; ++iNode)
                    {
                        double thisDistSqrd = SQR(mouseX-frameForPicking[0][iNode])
                                            + SQR(mouseY-frameForPicking[1][iNode]);
                        if (thisDistSqrd < closestDistSqrd)
                        {
                            closestNode = iNode;
                            closestDistSqrd = thisDistSqrd;
                        }
                    }
                    undoTree.setCurrentNodeIndex(closestNode);
                }
            } // setCurrentToClosestToMouse


    /** Detaches from the given component, which must have been previously attached by attachToComponent(). */
    public void detachFromComponent(java.awt.Component component)
    {
        if (this.component == null)
            throw new IllegalArgumentException("UndoTreeViewer.detachFromComponent: not attached to any component"); // XXX should be illegal state or something instead?
        component.removeKeyListener(componentKeyListener);
        component.removeMouseListener(componentMouseListener);
        component.removeMouseMotionListener(componentMouseMotionListener);
        componentKeyListener = null;
        componentMouseListener = null;
        componentMouseMotionListener = null;
        component = null;
    } // detachFromComponent

    private UndoTree.Snapshot snapshot = new UndoTree.Snapshot(); // scratch to reuse each time  // XXX put this up top somewhere, and should probably clear it if the tree is cleared
    private double frameForPicking[][] = null;

    // XXX figure out where to put this, if anywhere
    private java.util.Random jitterGenerator = new java.util.Random();
    private int jitterRadius = 0; // j key toggles

    /** Paint callback to be called from inside your Component's paint() or paintComponent() method. The caller is responsible for clearing the window and/or double-buffering. XXX although it might make sense to draw single-buffered sometimes, when only a couple of pixels are changing... need to think about this */
    // PAINT (the UndoTreeViewer)
    public void paint(java.awt.Component component, java.awt.Graphics g)
    {
        if (eventVerboseLevel >= 3) System.out.println("            UndoTreeViewer painting on a "+component.getClass().getSuperclass().getName());

        boolean showLabelsThisTime = this.showLabels;
        // Evolve any params that are moving towards a target...
        {
            stretchOutAlongTimeLine.evolve(1, paramFadeFrames, 1, paramCriticalDampingFraction);
            if (stretchOutAlongTimeLine.isMoving())
            {
                //System.out.println("repaint because stretchOutAlongTimeLine moving");
                showLabelsThisTime = false; // slight hack
                component.repaint();
            }
            centerCurrentNode.evolve(1, paramFadeFrames, 1, paramCriticalDampingFraction);
            if (centerCurrentNode.isMoving())
            {
                //System.out.println("repaint because centerCurrentNode moving");
                showLabelsThisTime = false; // slight hack
                component.repaint();
            }
            log2ViewScale.evolve(1, paramFadeFrames, 1, paramCriticalDampingFraction);
            if (log2ViewScale.isMoving())
            {
                //System.out.println("repaint because view scale moving");
                showLabelsThisTime = false; // slight hack
                component.repaint();
            }
        }

        undoTree.takeSnapshot(snapshot);
        int nNodes = snapshot.nNodes;
        int parentNode = snapshot.parents[snapshot.currentNode]==-1 ? snapshot.currentNode : snapshot.parents[snapshot.currentNode];
        double currentNodeTimeFraction = snapshot.currentNodeFraction;

        //double currentNodeSpaceFraction = SMOOTH(currentNodeTimeFraction); // smooth in addition to what the follower logic already does
        double currentNodeSpaceFraction = currentNodeTimeFraction; // don't smooth in addition to what the follower logic already does

        java.awt.Color edgeColors[] = new java.awt.Color[nNodes];
        double edgeLengths[] = new double[nNodes];

        String leftLabels[] = showLabelsThisTime ? new String[nNodes] : null;
        String rightLabels[] = showLabelsThisTime ? new String[nNodes] : null;

        // Determine the color and length the edge above each node.
        // Start at node 1, since node 0 doesn't have an edge above it.
        for (int iNode = 1; iNode < nNodes; ++iNode) // start at 1
        {
            edgeColors[iNode] = colorizer.color(snapshot.edgeItems[iNode]);
            edgeLengths[iNode] = lengthizer.length(snapshot.edgeItems[iNode]);
            if (showLabelsThisTime)
            {
                leftLabels[iNode] = colorizer.leftLabel(snapshot.edgeItems[iNode]);
                rightLabels[iNode] = colorizer.rightLabel(snapshot.edgeItems[iNode]);
            }
        }
        double x[] = new double[nNodes];
        double y[] = new double[nNodes];
        UndoTree.chooseNodePositions(snapshot.nNodes,
                                     snapshot.parents,
                                     snapshot.preferredChild,
                                     edgeLengths,
                                     snapshot.currentNode,
                                     snapshot.currentNodeFraction,
                                     stretchOutAlongTimeLine.get(),
                                     x, y);
        double xmin = Double.POSITIVE_INFINITY;
        double ymin = Double.POSITIVE_INFINITY;
        double xmax = Double.NEGATIVE_INFINITY;
        double ymax = Double.NEGATIVE_INFINITY;
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            xmin = Math.min(xmin, x[iNode]);
            ymin = Math.min(ymin, y[iNode]);
            xmax = Math.max(xmax, x[iNode]);
            ymax = Math.max(ymax, y[iNode]);
        }


        //System.out.println("                model bounds ["+xmin+".."+xmax+"]x["+ymin+"x"+ymax+"]");
        //
        // Fit to the window...
        // We know the initial scale of the model is such that
        // things occur at granularity around 1, so a border of .5 is good.
        // So, map xmin-.5..xmax+.5 to 0..getWidth and same for y.
        // XXX I'm sure this is not the final way I'll do this
        //
        int w = component.getWidth();
        int h = component.getHeight();
        xmin -= .5;
        ymin -= .5;
        xmax += .5;
        ymax += .5;
        {
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                double xFrac = (x[iNode]-xmin)/(xmax-xmin); // XXX redundant division
                double yFrac = (y[iNode]-ymin)/(ymax-ymin); // XXX redundant division
                x[iNode] = LERP(0, w, xFrac);
                y[iNode] = LERP(20, h, yFrac); // XXX hack- leave margin at top
            }
        }

        {
            // XXX lame arithmetic, should combine
            double currentNodeX = LERP(x[parentNode], x[snapshot.currentNode], currentNodeSpaceFraction);
            double currentNodeY = LERP(y[parentNode], y[snapshot.currentNode], currentNodeSpaceFraction);
            double translateX = LERP(0, w/2.-currentNodeX, centerCurrentNode.get());
            double translateY = LERP(0, h/2.-currentNodeY, centerCurrentNode.get());
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                x[iNode] += translateX;
                y[iNode] += translateY;
            }
            double scale = Math.pow(2.,
                                    log2ViewScale.get()
                                    // - centerCurrentNode.get() // XXX I thought this would be cool but apparently not
                                    );
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                x[iNode] = (x[iNode]-w*.5)*scale + w*.5;
                y[iNode] = (y[iNode]-h*.5)*scale + h*.5;
            }
        }

        if (jitterRadius > 0)
        {
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                x[iNode] += (jitterGenerator.nextInt(2*jitterRadius+1)-jitterRadius);
                y[iNode] += (jitterGenerator.nextInt(2*jitterRadius+1)-jitterRadius);
            }
        }


        // Actual drawing starts here
        {
            //
            // Draw the edges first, so the nodes can go on top if they collide
            //
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                if (snapshot.parents[iNode] != -1)
                {
                    g.setColor(edgeColors[iNode]);
                    g.drawLine((int)x[snapshot.parents[iNode]],
                               (int)y[snapshot.parents[iNode]],
                               (int)x[iNode],
                               (int)y[iNode]);
                }
            }

            //
            // Now draw the nodes
            //
            for (int iNode = 0; iNode < nNodes; ++iNode)
            {
                if (snapshot.parents[iNode] != -1)
                    g.setColor(edgeColors[iNode]);
                else
                    g.setColor(java.awt.Color.white);
                int radius = 2;
                g.drawRect((int)x[iNode]-radius,(int)y[iNode]-radius,
                           2*radius,2*radius);
            }

            //
            // Then the edge labels
            //
            if (showLabelsThisTime)
            {
                for (int iNode = 0; iNode < nNodes; ++iNode)
                {
                    if (snapshot.parents[iNode] != -1)
                    {
                        double edgeCenterX = (x[snapshot.parents[iNode]]+x[iNode])*.5;
                        double edgeCenterY = (y[snapshot.parents[iNode]]+y[iNode])*.5;
                        // Clip, since drawing out of bounds labels
                        // can take FOREVER
                        // XXX in fact should clip everything
                        {
                            double slop = 50; // so there's no popping, assuming labels don't get longer than this
                            //double slop = 0.; // so I can see what it's doing
                            if (edgeCenterX < -slop
                            || edgeCenterX > w+slop
                            || edgeCenterY < -slop
                            || edgeCenterY > h+slop)
                            {
                                //System.out.println("Throwing label "+leftLabels[iNode]+","+rightLabels[iNode]+" in the trash");
                                continue; // clip-- drawing out of bounds labels can take FOREVER (XXX should clip other stuff too!)
                            }
                        }

                        g.setColor(edgeColors[iNode]);
                        if (leftLabels[iNode] != null
                         && !leftLabels[iNode].equals(""))
                        {
                            com.donhatchsw.util.Arrows.drawString(
                                (java.awt.Graphics2D)g, // XXX !? is this necessary??
                                leftLabels[iNode],
                                edgeCenterX,
                                edgeCenterY,
                                1., // right justify
                                0.);
                        }
                        if (rightLabels[iNode] != null
                         && !rightLabels[iNode].equals(""))
                        {
                            com.donhatchsw.util.Arrows.drawString(
                                (java.awt.Graphics2D)g, // XXX !? is this necessary??
                                rightLabels[iNode],
                                edgeCenterX+2, // fudge
                                edgeCenterY,
                                -1., // left justify
                                0.);
                        }
                    }
                }
            }


            //
            // Put a ring around the current node
            //
            {

                double currentNodeX = LERP(x[parentNode], x[snapshot.currentNode], currentNodeSpaceFraction);
                double currentNodeY = LERP(y[parentNode], y[snapshot.currentNode], currentNodeSpaceFraction);
                g.setColor(java.awt.Color.white);
                int radius = 4;
                g.drawRect((int)currentNodeX-radius,
                           (int)currentNodeY-radius,
                           2*radius,2*radius);
            }

            frameForPicking = new double[][]{x,y};

            ++nPaintsDone;
            com.donhatchsw.util.Arrows.drawString((java.awt.Graphics2D)g, "("+nPaintsDone+" paint"+(nPaintsDone==1?"":"s")+")", w-2, 2, 1, -1.);
        }
    } // paint
    private int nPaintsDone = 0;

    /** Creates an UndoTreeViewer.  Attach it to a Component using attachToComponent and to an UndoTree using attachToUndoTree. */
    public UndoTreeViewer(ItemColorizer colorizer,
                          UndoTree.ItemLengthizer lengthizer)
    {
        this.colorizer = colorizer;
        this.lengthizer = lengthizer;
    } // UndoTreeViewer ctor

    private static void asciiDump(UndoTree undoTree, double stretchOutAlongTimeLine)
    {
        //PRINT(__LINE__);
        //PRINT(undoTree);
        UndoTree.ItemToString itemToString = new UndoTree.ItemToString(){
            public String regex()
            {
                //return "-?\\d+"; // ints
                //return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public String itemToString(Object obj)
            {
                // is this method necessary? could just take the regex
                //return obj.toString(); // ints
                return obj.toString(); // identifiers too
            }
        };
        UndoTree.ItemFromString itemFromString = new UndoTree.ItemFromString(){
            public String regex()
            {
                // return "-?\\d+"; // ints
                //return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public Object itemFromString(String s)
            {
                //return Integer.valueOf(s); // ints
                return s; // identifiers
            }
        };
        //String indentSpaces = "    ";
        //String separatorSpaces = System.getProperty("line.separator");
        String indentSpaces = "";
        String separatorSpaces = " ";

        if (undoTree != null)
        {
            UndoTree t0 = undoTree;
            String s1 = t0.toString(itemToString, indentSpaces, separatorSpaces);
            System.out.println(s1);

            if (true)
            {
                UndoTree t2 = UndoTree.fromString(s1, itemFromString);
                String s3 = t2.toString(itemToString, indentSpaces, separatorSpaces);
                if (!s3.equals(s1))
                {
                    System.out.println(s1);
                    System.out.println(s3);
                    System.out.println("WARNING: they aren't equal!"); // XXX currently goes off because I had to comment out something in the other file, can put this back soon
                    //assert(false);
                }
            }
            System.out.println("===================================");
            System.out.println(undoTree.toStringVisualCool(stretchOutAlongTimeLine >= .5f));
        }
        else
        {
            System.out.println("No undo tree attached.");
        }
    } // asciiDump




    // Graphical viewer for an undo tree, for the example main program
    // XXX shouldn't use swing for this... or maybe I should, I don't know
    public static UndoTreeViewer makeExampleUndoTreeViewer(
                                           final String name,
                                           final UndoTree undoTree,
                                           final String nameOfOtherViewThatThisViewShouldFollowAround,
                                           final UndoTree otherViewThatThisViewShouldFollowAround,
                                           final int x, final int y, final int w, final int h,
                                           final int nThingsDoneEver[],
                                           final int nViewersAlive[],
                                           final int nModelsEverMade[],
                                           final int nViewsEverMade[],
                                           final int nViewersEverMade[],
                                           final boolean allowDo,
                                           final boolean allowUndoRedo,
                                           final UndoTree.ItemLengthizer lengthizer,
                                           final UndoTreeViewer.ItemColorizer colorizer)
    {
        final UndoTreeViewer undoTreeViewer = new UndoTreeViewer(colorizer,
                                                                 lengthizer);


        nViewersAlive[0]++;
        final javax.swing.JPanel jpanel = new javax.swing.JPanel() {
            // PAINT (the surrounding example)
            public void paintComponent(java.awt.Graphics g)
            {
                int w = getWidth(), h = getHeight();
                if (undoTreeViewer.eventVerboseLevel >= 3) System.out.println("    in paintComponent");

                boolean isAFollower = otherViewThatThisViewShouldFollowAround != null;
                if (isAFollower)
                {
                    //System.out.println("        kibbles and bits!");
                    UndoTree.ReturnValueOfIncrementViewTowardsOtherView stateChange = undoTree.incrementViewTowardsOtherView(
                        otherViewThatThisViewShouldFollowAround,
                        1., // ref trip dist = one unit of edge length
                        undoTreeViewer.nFramesPerEdgeWhenFollowing, // ref trip time = that many frames
                        1., // dt = one frame
                        undoTreeViewer.followerCriticalDampingFraction,
                        lengthizer);
                    if (stateChange != null
                     && stateChange.dir != 0)
                    {
                        // apply the integer state change here... if there was any
                    }
                }

                g.setColor(java.awt.Color.black);
                g.fillRect(0,0,w,h);
                undoTreeViewer.paint(this, g);

                // XXX should use the font height instead of hard coding 20
                int y = h - (isAFollower ? 7 : allowUndoRedo ? allowDo ? 12 : 11 : 6)*20 - 20; // XXX holy hell!
                if (!isAFollower)
                {
                    if (allowUndoRedo)
                    {
                        if (allowDo)
                            g.drawString("Enter to Do", 10, y+=20);
                        g.drawString("  Up to undo", 10, y+=20);
                        g.drawString("  Down to redo", 10, y+=20);
                        g.drawString("  Left for older", 10, y+=20);
                        g.drawString("  Right for younger", 10, y+=20);
                        g.drawString("c to Clear", 10, y+=20);
                    }
                }
                else
                    g.drawString("S/s to follow Slower/faster", 10, y+=20);
                //g.drawString("  (or just click and drag around and hit enter a lot)", 10, y+=20);
                g.drawString("+/-/= to zoom in/out", 10, y+=20);
                g.drawString("0 to toggle keep-current-node-in-center mode", 10, y+=20);
                g.drawString("t to toggle stretch-out-along-time-line display mode", 10, y+=20);
                g.drawString("l to toggle labels", 10, y+=20);
                g.drawString("n for new view window of same tree", 10, y+=20);
                g.drawString("ctrl-n for new view that follows this view around like a dog", 10, y+=20);
                //PRINT((h - (y+20)) / 20);
                assert(y+20 == h);
                if (undoTreeViewer.eventVerboseLevel >= 3) System.out.println("    out paintComponent");
            }
        };
        // should work in either order...
        undoTreeViewer.attachToComponent(jpanel);
        undoTreeViewer.attachToUndoTree(undoTree);


        // XXX hmm, I think I have listener memory leaks everywhere...
        // XXX this one in particular, no one is keeping track of it at all.
        // XXX in fact I don't think anyone ever calls detachFromUndoTree or detachFromComponent yet!
        {
            UndoTree.Listener otherViewThatThisViewShouldFollowAroundListener = null;
            final java.awt.Component component = jpanel;
            if (otherViewThatThisViewShouldFollowAround != null)
            {
                otherViewThatThisViewShouldFollowAround.addListener(otherViewThatThisViewShouldFollowAroundListener = new UndoTree.Listener() {
                    public void somethingChanged()
                    {
                        //System.out.println("    woof!");
                        // just repaint-- we will progress (and call repaint again)
                        // each time we paint
                        if (component != null)
                            component.repaint();
                    }
                });
            }
            // XXX the following is the corresponding detach code--- put it somewhere appropriate when I get those variables somewhere appropriate
            if (false)
            {
                if (otherViewThatThisViewShouldFollowAround != null)
                {
                    otherViewThatThisViewShouldFollowAround.removeListener(otherViewThatThisViewShouldFollowAroundListener);
                    otherViewThatThisViewShouldFollowAroundListener = null;
                    //otherViewThatThisViewShouldFollowAround = null; // uncomment this when it's real; compiler doesn't like it now because it's final
                }
            }

        }

        String title = name;
        if (title.startsWith("View"))
            title = "Undo Tree " + title; // XXX hack, to make it nice for this program and the other program that uses it that doesn't want this
        if (nameOfOtherViewThatThisViewShouldFollowAround != null)
            title += " (FOLLOWER of "+nameOfOtherViewThatThisViewShouldFollowAround+")";

        final javax.swing.JFrame jframe = new javax.swing.JFrame(title);
        jframe.setForeground(java.awt.Color.white);
        jframe.setForeground(java.awt.Color.black);
        jframe.setContentPane(jpanel);
        jframe.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent event)
            {
                if (--nViewersAlive[0] == 0)
                {
                    System.out.println("Chow!");
                    System.exit(0); // asinine way of doing things
                }
                else
                {
                    System.out.println("ciao!");
                }
            }
        });
        jpanel.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent ke)
            {
                //System.out.println("keyPressed "+ke);
                //System.out.println("    isShiftDown = "+ke.isShiftDown());
                int keyCode = ke.getKeyCode();
                String keyText = java.awt.event.KeyEvent.getKeyText(keyCode);

                if (allowDo && (keyCode == java.awt.event.KeyEvent.VK_ENTER
                             || keyText.equals("Enter")))
                {
                    int n = nThingsDoneEver[0]++;
                    String doneItem = ""+(char)('A'+n%26);
                    n /= 26;
                    while (n != 0)
                    {
                        doneItem = ""+(char)('A'+n%27-1) + doneItem; // XXX haha lame, it messes up after AA... figure out the right way to to it, you doofus
                        n /= 27;
                    }

                    undoTree.Do(doneItem);
                    if (undoTreeViewer.eventVerboseLevel >= 1) System.out.println("Did "+doneItem);
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_N)
                {
                    makeExampleUndoTreeViewer("View "+(nViewsEverMade[0]++),
                                              new UndoTree(undoTree), // different view, same model
                                              ke.isControlDown() ? name : null, // ctrl-n means the new one should follow me around
                                              ke.isControlDown() ? undoTree : null, // ctrl-n means the new one should follow me around
                                              x+20, y+20, jframe.getWidth(), jframe.getHeight(), nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade, allowDo, allowUndoRedo, lengthizer, colorizer);
                }
                else if (keyCode == java.awt.event.KeyEvent.VK_C // I keep hitting ctrl-c so let's do it baby
                      && ke.isControlDown())
                {
                    System.exit(0);
                }
                jpanel.repaint();
            } // keyPressed
            public void keyTyped(java.awt.event.KeyEvent ke)
            {
                char c = ke.getKeyChar();
                //System.out.println("key listener got key '"+c+"'("+(int)c+")"); // XXX escapify!
                if (false) {}
                else if (c == 'c') // toggle center current node
                {
                    undoTree.Clear();
                    nThingsDoneEver[0] = 0;
                }
            }
        });

        //jframe.pack();
        jframe.setSize(w,h);
        jframe.setLocation(x,y);
        // I think just-created stuff is safe until the components are
        // "realized"... so put the realization stuff in an invokeLater
        // to be done in an event dispatch thread, where gui creation stuff
        // is supposed to be done.
        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run()
            {
                jframe.setVisible(true);
                jpanel.requestFocus(); // seems to be needed initially, if running in <=1.2 on linux, anyway.  weird!
            }
        });

        /*
        TODO:
            Should make the following buttons:
                older branch  undo  younger branch
                older          Do   younger
                older leaf    redo  younger leaf
        */

        return undoTreeViewer;
    } // makeUndoTreeViewer


    /** Test/example program. */
    // XXX TODO: replace this with a smaller clearer one that just does the littler examples that I gave above.  The viewer stuff is good but is best left to a separate viewer program.
    public static void main(String args[])
    {
        System.out.println("in main");
        UndoTree tree = new UndoTree();
        if (false) // nah, cooler to start with nothing
        {
            // Seed it with something mildly interesting
            tree.Do("A");
            tree.Do("B");
            tree.setPrivateLabel("private_before_fork");
            tree.undo();
            tree.undo();
            tree.Do("C");
            tree.setPrivateLabel("shared_before_fork");
            tree.undo();
            tree.preferYoungerChild();
            tree.redo();
            tree.Do("D");
            tree.Do("E");
        }


        // Somewhat arbitrary frequencies for edge lengths...
        // Think of a puzzle where the moves are rotations,
        // 90 degree rotations being the most common...
        final double possibleLengths[] = com.donhatchsw.util.VecMath.flatten(new double[][]{
            com.donhatchsw.util.VecMath.fillvec(50, 90/90.),
            com.donhatchsw.util.VecMath.fillvec(30, 120/90.),
            com.donhatchsw.util.VecMath.fillvec(20, 180/90.),
            com.donhatchsw.util.VecMath.fillvec(10, 360/90.),
            com.donhatchsw.util.VecMath.fillvec(1, 2*360/90.),
            com.donhatchsw.util.VecMath.fillvec(5, 4./5), // 72
            com.donhatchsw.util.VecMath.fillvec(2, 4./6), // 60
            com.donhatchsw.util.VecMath.fillvec(1, 4./7),
            com.donhatchsw.util.VecMath.fillvec(2, 4./8),
        });

        //
        // We have to tell it how choose edge lengths
        // and colors.
        // XXX the example really should do this since it's example stuff,
        // XXX but I moved this here so it wouldn't be used in mc4d
        // XXX which at the moment also uses makeExampleViewer.  should make a usable utility version that it can call instead.
        final java.util.Random hashRandomizer = new java.util.Random();
        final UndoTree.ItemLengthizer lengthizer = new UndoTree.ItemLengthizer() {
            public double length(Object item)
            {
                if (true)
                {
                    hashRandomizer.setSeed(item.hashCode());
                    // oh for heaven's sake, that produces an obvious pattern... stir it again to get rid of that
                    hashRandomizer.setSeed(hashRandomizer.nextInt());
                    double length = possibleLengths[hashRandomizer.nextInt(possibleLengths.length)];
                    //PRINT2(item, length);
                    return length;
                }
                else
                    return 1.; // all edges the same length
            }
        };
        final UndoTreeViewer.ItemColorizer colorizer = new UndoTreeViewer.ItemColorizer() {
            public java.awt.Color color(Object item)
            {
                //
                // Pick a random color that is a function
                // of item's hash code.
                //
                int fudge = 1234; // I didn't like the colors initially
                hashRandomizer.setSeed(item.hashCode()+fudge);
                return new java.awt.Color(hashRandomizer.nextFloat(),
                                          hashRandomizer.nextFloat(),
                                          hashRandomizer.nextFloat());
            }
            public String leftLabel(Object item)
            {
                double length = lengthizer.length(item);
                double degrees = (int)Math.round(length*90.);
                // XXX the following is probably a bottleneck
                String degreesString = com.donhatchsw.compat.Format.sprintf("%.3g ", degrees); // "90", "120" or "180"
                return degreesString;
            }
            public String rightLabel(Object item)
            {
                return (String)item;
            }
        };





        int nThingsDoneEver[] = {0};
        int nViewersAlive[] = {0};
        int nModelsEverMade[] = {0};
        int nViewsEverMade[] = {0};
        int nViewersEverMade[] = {0};
        int x = 50;
        int w = 400;
        makeExampleUndoTreeViewer("View "+(nViewsEverMade[0]++), tree, null, null, x, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade, true, true, lengthizer, colorizer);
        // The following two lines are very different!
        if (false)
        {
            // Doing it this way, both viewers will share
            // undos and redos (as well as changes in the tree structure).
            // Each can have its own display style though.
            makeExampleUndoTreeViewer("View "+(nViewsEverMade[0]++), tree, null, null, x+=w, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade, true, true, lengthizer, colorizer);
        }
        if (false)
        {
            // Doing it this way, both viewers see tree changes
            // but they can explore the tree independently;
            // one viewer's undos and redos will not affect the other.
            makeExampleUndoTreeViewer("View "+(nViewsEverMade[0]++), tree = new UndoTree(tree), null, null, x+=w, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade, true, true, lengthizer, colorizer);
        }
        if (true)
        {
            // Doing it this way, the new one will follow the previous one
            // around!
            makeExampleUndoTreeViewer("View "+(nViewsEverMade[0]++), new UndoTree(tree), "View "+(nViewsEverMade[0]-2/*omg this is outa control*/), tree, x+=w, 20, w, 700, nThingsDoneEver, nViewersAlive, nModelsEverMade, nViewsEverMade, nViewersEverMade, true, true, lengthizer, colorizer);
        }

        //
        // Okay I think a good way to manage the models, views, and viewers
        // is with a JTree.
        // A typical setup is:
        //      model I
        //          view A
        //              viewer 0
        //              viewer 1
        //              viewer 2
        //          view B
        //              viewer 3
        //          view C
        //      model II
        //          view D
        //              viewer 4
        // XXX Bleah, I know this is going to totally obscure the simplicity
        // of this example program
        //          


        System.out.println("out main");
    } // main


    /*
     * Shamelessly copied from someone who shamelessly copied it from SwingUtilities.java since that is in JDK 1.3 and we'd like to keep this to 1.2 and below.
     */
    public static boolean isMiddleMouseButton(java.awt.event.MouseEvent anEvent) {
        return ((anEvent.getModifiers() & java.awt.event.InputEvent.BUTTON2_MASK) == java.awt.event.InputEvent.BUTTON2_MASK);
    }
    public static boolean isLeftMouseButton(java.awt.event.MouseEvent anEvent) {
         return ((anEvent.getModifiers() & java.awt.event.InputEvent.BUTTON1_MASK) != 0);
    }
} // class UndoTreeViewer
