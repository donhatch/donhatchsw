/*
* Copyright (c) 2006 Don Hatch Software
*/
//
// LinearProgramming.prejava
//
// Author: Don Hatch (hatch@plunk.org)
// This code may be used for any purpose as long as it is good and not evil.
//

package com.donhatchsw.util;

#include "macros.h" // XXX should try to get rid of this



/*
    Linear programming, straight out of Numerical Recipes in C,
    but with simpler interface function.
*/


public final class LinearProgramming
{
    private LinearProgramming() {} // uninstantiatable

    /** Find x that minimizes ||Ax-b|| in the infinity (max) norm (not implemented yet). */
    public static int invmxvMaxNorm(double x[],
                                    double A[][],
                                    double b[])
    {
        throw new Error("invmxvMaxNorm not implemented yet");
    } // invmxvMaxNorm

    /** Find x that minimizes ||Ax-b|| in the one (sum) norm (not implemented yet). */
    public static int invmxvSumNorm(double x[],
                                    double A[][],
                                    double b[])
    {
        throw new Error("invmxvSumNorm not implemented yet");
    } // invmxvSumNorm

    /**
     * Find x such that the vector Mx has sum 1
     * and maximal minimum element.
     * <p>
     * This is a convenience function
     * that is implemented in terms of maximizeMinimum as follows:
     * <pre>
     *     A = [[1,1,..,1] * M]         (1 x n matrix)
     *     b = [1]
     *     C = M
     *     d = [0,0,...,0]
     *     return maximizeMinimum(x, A, b, C, d);
     * </pre>
     */
    public static int maximizeMinimumAffine(double x[],
                                            double resultSum,
                                            double M[][])
    {
        int n = x.length;
        double A[][] = {VecMath.vxm(VecMath.fillvec(M.length, 1.), M)};
        double b[] = {1.};
        double C[][] = M;
        double d[] = VecMath.fillvec(M.length, 0.);
        return maximizeMinimum(x, A, b, C, d);
    } // maximizeMinimumAffine

    /**
     * Find a solution vector x
     * that satisfies A x == b
     * and maximizes the minimum element of C x - d.
     * <p>
     * This is a convenience function; it is implemented
     * in terms of LPSolve as follows:
     * <pre>
     * We want to maximize the smallest element of:
     *        ((C[0] dot x)   - d[0])
     *        ((C[1] dot x)   - d[1])
     *        ...
     *        ((C[m-1] dot x) - d[m-1])
     *      
     * The trick is to add another variable "smallest"
     * with constraints:
     *      smallest <= ((C[0] dot x)   - d[0])
     *      smallest <= ((C[1] dot x)   - d[1])
     *      ...
     *      smallest <= ((C[m-1] dot x) - d[m-1])
     * i.e.
     *      ((-C[0] dot x)   + smallest <= -d[0])
     *      ((-C[1] dot x)   + smallest <= -d[1])
     *      ...
     *      ((-C[m-1] dot x) + smallest <= -d[m-1])
     * so the new variables are x[0]..x[n-1],smallest
     * and our object is to maximize smallest;
     * this is clearly a linear programming problem now.
     * To express it in the language of our LPSolve function,
     *     A' = A with a colum of 0's added on the right
     *     b' = b
     *     C' = -C with a colum of 1's added on the right
     *     d' = -d
     *     q' = n 0's with a single 1 at the end
     * and we are solving for
     *     x' = x with smallest appended at the end,
     * by calling:
     *     LPSolve(x', y, A', b', c', d')
     *     
     * </pre>
     */
    public static int maximizeMinimum(double x[], // solution
                                      double A[][], double b[], // equalities Ax==b
                                      double C[][], double d[]) // maximize minimum element of Cx - d
    {
        int n = x.length;
        assert(A.length == b.length);
        assert(C.length == d.length);
        // row length assertions will be done below

        double xx[] = new double[n+1];
        double AA[][] = new double[A.length][n+1];
        double bb[] = b;
        double CC[][] = new double[C.length][n+1];
        double dd[] = new double[d.length];
        double qq[] = new double[n+1];

        for (int iA = 0; iA < A.length; ++iA)
        {
            assert(A[iA].length == n);
            for (int i = 0; i < n; ++i)
                AA[iA][i] = A[iA][i];
            AA[iA][n] = 0.;
        }
        for (int iC = 0; iC < C.length; ++iC)
        {
            assert(C[iC].length == n);
            for (int i = 0; i < n; ++i)
                CC[iC][i] = -C[iC][i];
            CC[iC][n] = 1.;
            dd[iC] = -d[iC];
        }
        for (int i = 0; i < n; ++i)
            qq[i] = 0.;
        qq[n] = 1.;

        int ret = LPSolve(xx, null, AA, bb, CC, dd, qq, false);
        if (ret == 0)
            for (int i = 0; i < n; ++i)
                x[i] = x[i];
        return ret;
    } // maximizeMinimum


    /**
     *
     * Solve a linear programming problem.
     * Finds x such that:
     * <pre>
     *         A x == b
     *         C x <= d  componentwise
     *           x >= 0  componentwise  (but only if xMustBeNonNegative is set)
     *     q dot x maximal.
     * </pre>
     * Returns -1 if infeasible (in which case x will be undefined),
     * 1 if unbounded (in which case x will be undefined), or
     * 0 if finite (in which case x is filled in with the answer,
     *              and y, if non-null, is filled in
     *              with the non-negative values <code>d - C x</code>
     *              with exact zeros for those inequalities
     *              that were satisfied as equalities).
     * <p>
     * IMPLEMENTATION NOTE: setting xMustBeNonNegative to true
     * doubles the number of variables solved for internally,
     * so it is more time consuming.
     */
    public static int LPSolve(double x[], // solution
                              double y[], // slack d-Cx at solution
                              double A[][], double b[], // equalities Ax == b
                              double C[][], double d[], // inequalities Cx <= d
                              double q[], // objective: maximize q dot x
                              boolean xMustBeNonNegative)
    {
        int n = x.length;            // number of variables
        int m = A.length + C.length; // number of constraints

        assert(q.length == n);
        assert(A.length == b.length);
        assert(C.length == d.length);
        for (int i = 0; i < A.length; ++i)
            assert(A[i].length == n);
        for (int i = 0; i < C.length; ++i)
            assert(C[i].length == n);

        if (!xMustBeNonNegative)
        {
            //
            // simplx solves using additional constraints x >= 0.
            // To get around this, add n more variables,
            // which will recieve the absolute values of the negative
            // components of the final solution,
            // solve the twice-as-big problem,
            // and then mix the two halves of the final solution together.
            //
            // This is really pretty lame, since we could also do it
            // by solving for x+BIG where BIG is a vector of large
            // positive numbers, and that new system
            // is the same size as the original one,
            // but unfortunately it's impossible
            // to know how big those numbers need to be beforehand
            // (in particular, if it's unbounded in a negative direction,
            // then we can never get it right by doing it that way).
            //
            double xx[] = new double[2*n];
            double AA[][] = new double[A.length][2*n];
            double CC[][] = new double[C.length][2*n];
            double qq[] = new double[2*n];

            for (int i = 0; i < n; ++i)
            {
                qq[n+i] = -(qq[i] = q[i]);
                for (int iA = 0; iA < A.length; ++iA)
                    AA[iA][n+i] = -(AA[iA][i] = A[iA][i]);
                for (int iC = 0; iC < C.length; ++iC)
                    CC[iC][n+i] = -(CC[iC][i] = C[iC][i]);
            }

            int ret = LPSolve(xx, y, AA, b, CC, d, qq, true);

            if (ret == 0)
                for (int i = 0; i < n; ++i)
                    x[i] = xx[i] - xx[n+i];

            return ret;
        }

        if (n == 0)
            return 0; // success; don't bother with simplx since it will bomb in this case XXX I think--- maybe try it and see
        // I think it should work even if m is 0... should always return 1 though (unbounded).

        double M[][] = new double [1+1+m+1][];
        for (int i = 1; i < M.length; ++i) // start at 1, leave row 0 null
        {
            M[i] = new double[1+1+n];
            M[i][0] = Double.NaN;
        }

        // Fill in M...
        int nEQ = 0; // and counting
        int nLE = 0; // and counting
        int nGE = 0; // and counting
        {
            // Objective function row...
            M[1][1+0] = 0.;
            for (int i = 0; i < n; ++i)
                M[1][1+1+i] = q[i];

            for (int iNE = 0; iNE < C.length; ++iNE)
            {
                // simplx requires the constant to be >= 0,
                // so if that's not the case we negate the <= constraint
                // to get a >= constraint.
                int sign = d[iNE] < 0. ? -1 : 1;
                int iRow = 1+1+(sign == -1 ?  (m-1)-(nGE++) : (nLE++) );
                M[iRow][1+0] = sign * d[iNE];
                for (int i = 0; i < n; ++i)
                    M[iRow][1+1+i] = sign * -C[iNE][i];
            }
            for (int iEQ = 0; iEQ < A.length; ++iEQ)
            {
                // simplx requires constant column of input to be >= 0,
                // so if that's not the case we simply negate the equation.
                int sign = b[iEQ] < 0. ? -1 : 1;
                int iRow = 1+1+nLE+nGE+(nEQ++);
                M[iRow][1+0] = sign * b[iEQ];
                for (int i = 0; i < n; ++i)
                    M[iRow][1+1+i] = sign * -A[iEQ][i];
            }
        }


        int izrov[] = new int[1+n]; izrov[0] = -999;
        int iposv[] = new int[1+m]; iposv[0] = -999;
        int icase = simplx(M,
                           m,
                           n,
                           nLE,
                           nGE,
                           nEQ,
                           izrov,
                           iposv);
        assert(M[0] == null);
        for (int i = 1; i < M.length; ++i)
            assert(Double.isNaN(M[i][0]));
        assert(izrov[0] == -999);
        assert(iposv[0] == -999);

        if (icase == 0) // if got a finite result
        {
            for (int i = 0; i < x.length; ++i)
                x[i] = Double.NaN;
            if (y != null)
                for (int i = 0; i < y.length; ++i)
                    y[i] = Double.NaN;

            for (int i = 0; i < m; ++i)
                if (iposv[1+i]-1 < n)
                    x[iposv[1+i]-1] = M[1+1+i][1];
                else if (y != null)
                    y[iposv[1+i]-1 - n] = M[1+1+i][1]; // XXX uh oh this might not be safe-- can it be an artificial variable?
            for (int i = 0; i < n; ++i)
                if (izrov[1+i]-1 < n)
                    x[izrov[1+i]-1] = 0.;
                else if (y != null)
                    y[izrov[1+i]-1 - n] = 0.;         // XXX uh oh this might not be safe-- can it be an artificial variable?

            for (int i = 0; i < x.length; ++i)
                assert(!Double.isNaN(x[i]));
            if (y != null)
                for (int i = 0; i < y.length; ++i)
                    assert(!Double.isNaN(y[i]));
        }

        return icase;
    } // LPsolve

    /** You don't want to know.  If this is <code>>= 1</code>, print out the tableaux at various times during the internal simplx function call. If it's <code>>= 2</code>, print out even more stuff.  See, I told you, you can't handle the truth. */
    public static int debugLevel = 1;

    private final static double EPS = 1e-12;
    // Here EPS is the absolute precision,
    // which should be adjusted to the scale of your variables.
    // XXX do that! the assumption is that the inputs do not differ from unity by too many orders of magnitude.
    // (was 1e-6 in the book which uses float,
    // changing to 1e-12 here since we are using double)
    // Yknow what though, I think it would be more appropriate
    // to simply scale each row in the input problem
    // so that the maximum entry is 1.

    //
    // Utilities used by printing...
    //
        private static String repeat(char s, int n)
        {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < n; ++i)
                sb.append(s);
            return sb.toString();
        }
        private static String ljustify(String s, int width)
        {
            assert(s.length() <= width);
            return s + repeat(' ', width-s.length());
        }
        private static String rjustify(String s, int width)
        {
            assert(s.length() <= width);
            return repeat(' ', width-s.length()) + s;
        }
        private static String lcenter(String s, int width)
        {
            assert(s.length() <= width);
            return repeat(' ', (width-s.length())/2) + s + repeat(' ', (width-s.length()+1)/2);
        }
        private static String rcenter(String s, int width)
        {
            assert(s.length() <= width);
            return repeat(' ', (width-s.length()+1)/2) + s + repeat(' ', (width-s.length())/2);
        }
        private static String justify(double x, int lWidth, int rWidth)
        {
            String s = ""+x;
            int indexOfDecimalPoint = s.indexOf('.');
            assert(indexOfDecimalPoint != -1);
            int nBefore = indexOfDecimalPoint;
            int nAfter = s.length() - (indexOfDecimalPoint+1);
            return repeat(' ', lWidth-nBefore) + s + repeat(' ', rWidth-nAfter);
        }
        static void appendSeparatorRow(StringBuffer sb,
                                       int n,
                                       int colWidths[],
                                       char primaryChar,
                                       String singleCross,
                                       String doubleCross)
        {
            sb.append(repeat(primaryChar, colWidths[0]));
            sb.append(doubleCross);
            for (int iCol = 1; iCol <= n+1; ++iCol)
            {
                sb.append(repeat(primaryChar,colWidths[iCol]));
                sb.append(iCol==n+1 ? doubleCross : singleCross);
            }
            sb.append("\n");
        } // appendSeparatorRow
        static String varLabel(int iVar, int m, int n)
        {
            assert(iVar <= m+n);
            if (iVar <= n)
                return "x"+iVar; // original variable
            else if (iVar <= n+m)
                return "y"+(iVar-n); // slack variable
            else
                return "z" + (iVar-(n+m)); // artificial variable
        }

    private static String TableauToString(double a[/*1+1+m+1*/][/*1+1+n*/],
                                          int m,
                                          int n,
                                          int m1,
                                          int m2,
                                          int izrov[/*1+n*/],
                                          int iposv[/*1+m*/])
    {
        StringBuffer sb = new StringBuffer();

        //
        // Sanity check the arrays...
        //
        assert(a.length == 1+1+m+1);
        assert(a[0] == null);
        assert(a[1].length == 1+1+n);
        for (int iRow = 1; iRow < a.length; ++iRow)
            assert(Double.isNaN(a[iRow][0]));
        assert(izrov[0] == -999);
        assert(iposv[0] == -999);

        //
        // Figure out optimal column widths
        // XXX could concievably overflow if many thousands of variables
        //
        int colWidths[] = new int[1+1+n];
        int maxBeforeDecimal[] = new int[1+1+n];
        int maxAfterDecimal[] = new int[1+1+n];
        for (int iCol = 1; iCol <= n+1; ++iCol)
        {
            maxBeforeDecimal[iCol] = 2; // minimum so colWidth is at least 5
            maxAfterDecimal[iCol] = 2; // minimum so colWidth is at least 5
            for (int iRow = 1; iRow <= m+2; ++iRow)
            {
                String s = ""+a[iRow][iCol];
                int indexOfDecimalPoint = s.indexOf('.');
                assert(indexOfDecimalPoint != -1);
                int nBefore = indexOfDecimalPoint;
                int nAfter = s.length() - (indexOfDecimalPoint+1);
                if (nBefore > maxBeforeDecimal[iCol]) maxBeforeDecimal[iCol] = nBefore;
                if (nAfter > maxAfterDecimal[iCol]) maxAfterDecimal[iCol] = nAfter;
            }
            colWidths[iCol] = maxBeforeDecimal[iCol] + 1 + maxAfterDecimal[iCol];
        }
        colWidths[0] = 4; // width of label column

        //
        // Print top labels
        //
        {
            sb.append(repeat(' ', colWidths[0]));
            sb.append("  ");
            for (int iCol = 1; iCol <= n+1; ++iCol)
            {
                String label;
                if (iCol == 1)
                    label = "";
                else
                    label = varLabel(izrov[iCol-1], m, n);
                label = lcenter(label, colWidths[iCol]);
                sb.append(label);
                sb.append(iCol==n+1 ? "||" : "|");
            }
            sb.append("\n");
        }
        appendSeparatorRow(sb, n, colWidths, '=', "+", "++");
        for (int iRow = 1; iRow <= m+2; ++iRow)
        {
            if (iRow == m+2)
                appendSeparatorRow(sb, n, colWidths, '=', "+", "++");
            String label;
            if (iRow == 1)
                label = "z";
            else if (iRow == m+2)
                label = "z'";
            else
                label = varLabel(iposv[iRow-1], m, n);
            label = ljustify(label.length()==colWidths[0] ? label : " "+label, colWidths[0]);
            sb.append(label);
            sb.append("||");
            for (int iCol = 1; iCol <= n+1; ++iCol)
            {
                sb.append(justify(a[iRow][iCol], maxBeforeDecimal[iCol], maxAfterDecimal[iCol]));
                sb.append(iCol==n+1 ? "||" : "|");
            }
            sb.append("\n");
            if (iRow == 1)
                appendSeparatorRow(sb, n, colWidths, '-', "+", "++");
        }
        appendSeparatorRow(sb, n, colWidths, '-', "+", "++");

        sb.deleteCharAt(sb.length()-1); // delete final newline
        return sb.toString();
    } // printTableau

    #define PRINTTABLEAU(a,m,n,m1,m2,izrov,iposv) System.out.println(#a + " =\n" + TableauToString(a,m,n,m1,m2,izrov,iposv))


    private static void myCheckForFeasibility(double a[/*1+1+m+1*/][/*1+1+n*/],
                                              int m,
                                              int n,
                                              int m1,
                                              int m2,
                                              int izrov[/*1+n*/],
                                              int iposv[/*1+m*/],
                                              boolean useAuxRow)
    {
        double objectiveFunctionRow[] = a[useAuxRow ? m+1 : 1];
    }

    //
    // Simplex method for linear programming.
    //
    // On output, the tableau A
    // is indexed by two returned arrays of integers.
    // iposv[j] contains, for j = 1..m, the number i in 1..m
    // whose original variable x_i is now represented by row j+1 of a.
    // These are thus the left-hand variables in the solution.
    // (The first row if A is of course the z-row.)
    // A value i > N indicates that the variable is a y_i
    // rather than an x_i, x_(N+j) === y_j.  XXX I didn't follow this
    // Likewise, izrov[j] contains, for j = 1...n,
    // the number i in 1..m
    // whose original variable x_i is now a right-hand variable,
    // represented by column j+1 of A.
    // These variables are all zero in the solution.
    // The meaning of i>n is the same as above, except that i>n+m1+m2
    // denotes an artificial or slack variable which was used only internally
    // and should now be entirely ignored.
    //
    // The function returns 0 if a finite solution is found,
    // +1 if the objective function is unbounded,
    // -1 if no solution satisfies the given constraints.
    //
    //
    private static int simplx(double a[/*1+1+m+1*/][/*1+1+n*/], // in/out
                              int m,                      // in
                              int n,                      // in
                              int m1,                     // in: number of <='s
                              int m2,                     // in: number of >='s
                              int m3,                     // in; number of =='s
                              int izrov[/*1+n*/],         // out
                              int iposv[/*1+m*/])         // out
    {
        System.out.println("    In simplx");
        if (m != (m1+m2+m3))
            throw new Error("Bad input constraint counts in simplx");

        // Initialize l1, which is the index list of variable-columns admissible for exchange,
        // and make all original variables initially right-hand.
        int l1[] = new int[1+n]; l1[0] = -999; // note the book allocates 1..n+1 but only 1..n are used so that's what I'm allocating
        int nl1 = n;
        PRINT(n);
        PRINT(m);
        for (int k = 1; k <= n; k++)
            l1[k] = izrov[k] = k;
        for (int  i = 1; i <= m; i++)
        {
            if (a[i+1][1] < 0.)
                throw new Error("Bad input tableau in simplx");
            // Constants b[i] must be nonnegative.
            iposv[i] = n+i;
            // Initial left-hand variables.
            // m1 (<=) type constraints are represented by having their slack
            // variable initially left-hand, with no artificial variable.
            // m2 (>=) type constraints have their slack variable
            // initially left-hand, with a minus sign, and their artificial
            // variable handled implicitly during their first exchange.
            // m3 (==) type constraints have their artificial variables
            // initially left-hand.
        }

        int kpScratch[] = new int[1];
        double bmaxScratch[] = new double[1];
        if (m2+m3 != 0)
        {
            // Origin is not a feasible starting solution: we must do phase one.

            // Initialize l3, which is the list of constraints whose slack variables
            // have never been exchanged out of the initial basis.
            boolean l3[] = new boolean[1+m2]; l3[0] = true; //  note the book allocates 1..m but only 1..m2 are used so that's what I'm allocating
            for (int i = 1; i <= m2; i++)
                l3[i] = true;
            for (int k = 1; k <= n+1; k++)
            {
                // Compute the auxiliary objective function.
                double q1 = 0.;

                // NOTE: In the text,
                // it gives an aux objective function that would be obtained
                // by considering all 4 rows, i.e. starting at i=1.
                // In the code, we skip the two m1-type rows, starting at i=1+m1 instead
                // and only considering the last 2 rows in that example.
                // However if I blindly use 1 instead of 1+m1 here, it returns infeasible.
                // But... is this the cruz of why I don't get the same answer
                // as the book?
                for (int i = 1+m1; i <= m; i++)
                    q1 += a[i+1][k];
                a[m+2][k] = -q1;
            }

            System.out.println("        PHASE ONE");
            if (debugLevel >= 2)
            {
                PRINTMAT(a);
            }
            if (debugLevel >= 1)
            {
                PRINTVEC(izrov);
                PRINTVEC(iposv);
                PRINTTABLEAU(a,m,n,m1,m2,izrov,iposv);
            }

            for (;;)
            {
                boolean goingto_one = false; // simulate goto with bubblegum and string
                int ip = -999; // doesn't really need initializing, but compiler thinks so

                // Find max. coeff. of auxiliary objective fn.
                simp1(a, m+1, l1, nl1, false, kpScratch, bmaxScratch);
                int kp = kpScratch[0];
                double bmax = bmaxScratch[0];
                if (bmax <= EPS && a[m+2][1] < -EPS)
                {
                    // Auxiliary objective function is still negative
                    // and can't be improved, hence no
                    // feasible solution exists.
                    assert(l1[0] == -999);
                    assert(l3[0] == true);
                    System.out.println("    Out simplx (infeasible)");
                    return -1;
                }
                else if (bmax <= EPS && a[m+2][1] <= EPS)
                {
                    // Auxiliary objective function is zero and
                    // can't be improved; we have a feasible starting vector.
                    // Clean out the artificial variables
                    // corresponding to any remaining m3 (equality) constraints
                    // by goto one and then move on to phase two.
                    System.out.println("            WE HAVE A FEASIBLE STARTING VECTOR");
                    for (ip = m1+m2+1; ip <= m; ip++)
                    {
                        if (iposv[ip] == (ip+n))
                        {
                            // Found an artificial variable for an
                            // equality constraint.
                            simp1(a,ip,l1,nl1,true,kpScratch,bmaxScratch);
                            kp = kpScratch[0];
                            bmax = bmaxScratch[0];
                            // Exchange with column corresponding to maximum
                            // pivot element in row ip.
                            if (bmax > EPS)
                            {
                                //goto one;
                                goingto_one = true;
                                System.out.println("                GOING TO ONE");
                                break;
                            }
                        }
                    }
                    if (!goingto_one)
                    {
                        // Change sign of row for any m2 constraints
                        // still present from the initial basis.
                        for (int i = m1+1; i <= m1+m2; i++)
                        {
                            if (l3[i-m1])
                                for (int k = 1; k <= n+1; k++)
                                    a[i+1][k] = -a[i+1][k];
                        }
                        break; // Go to phase two.
                    }
                }
                if (!goingto_one)
                {
                    // Locate a pivot element (phase one).
                    ip = simp2(a,m,n,kp);
                    if (ip == 0)
                    {
                        // Maximum of auxiliary objective function is
                        // unbounded, so no feasible solution exists.
                        assert(l1[0] == -999);
                        assert(l3[0] == true);
                        System.out.println("    Out simplx (infeasible, aux objective function unbounded)");
                        return -1;
                    }
                }
//one:
                goingto_one = false;
                System.out.println("                pivoting row "+ip+" ("+varLabel(iposv[ip],m,n)+") with col "+kp+" ("+varLabel(izrov[kp],m,n)+")");
                pivot(a,m+1,n,ip,kp);
                // Exchange a left- and a right-hand variable (phase one),
                // then update lists.
                if (iposv[ip] >= n+m1+m2+1)
                {
                    // Exchanged out an artificial variable
                    // for an equality constraint.
                    // Make sure it stays out by removing it from the l1 list.
                    int k;
                    for (k = 1; k <= nl1; k++)
                        if (l1[k] == kp)
                            break;
                    --nl1;
                    for (int is = k; is <= nl1; is++)
                        l1[is] = l1[is+1];
                }
                else
                {
                    int kh = iposv[ip]-m1-n;
                    if (kh >= 1 && l3[kh])
                    {
                        // Exchanged out an m2 type constraint
                        // for the first time.
                        // Correct the pivot column for the minus sign
                        // and the implicit artificial variable.
                        l3[kh] = false;
                        ++a[m+2][kp+1];
                        for (int i = 1; i <= m+2; i++)
                        {
                            a[i][kp+1] = -a[i][kp+1];
                        }
                    }
                }

                // Update lists of left-and right-hand variables.
                {
                    // SWAP(izrov[kp], iposv[ip]);
                    int is = izrov[kp]; 
                    izrov[kp] = iposv[ip];
                    iposv[ip] = is;
                }
            } // Still in phase 1, go back to for(;;).
            assert(l3[0] == true);
        } // if (m2+m3 != 0)

        System.out.println("        PHASE TWO");
        if (debugLevel >= 2)
        {
            PRINTMAT(a);
        }
        if (debugLevel >= 1)
        {
            PRINTVEC(izrov);
            PRINTVEC(iposv);
            PRINTTABLEAU(a,m,n,m1,m2,izrov,iposv);
        }

        // End of phase one code for finding an initial feasible solution.
        // Now, in phase two, optimize it.
        for (;;)
        {
            simp1(a,0,l1,nl1,false,kpScratch,bmaxScratch); // Test the z-row for doneness.
            int kp = kpScratch[0];
            double bmax = bmaxScratch[0];
            if (bmax <= EPS)
            {
                // Done.  Solution found.  Return with the good news.
                assert(l1[0] == -999);
                if (debugLevel >= 2)
                {
                    PRINTMAT(a);
                }
                if (debugLevel >= 1)
                {
                    System.out.println("        SOLUTION:");
                    PRINTVEC(izrov);
                    PRINTVEC(iposv);
                    PRINTTABLEAU(a,m,n,m1,m2,izrov,iposv);
                }
                System.out.println("    Out simplx (finite)");
                return 0;
            }
            int ip = simp2(a,m,n,kp); // Locate a pivot element (phase two).
            if (ip == 0)
            {
                // Objective function is unbounded.  Report and return.
                assert(l1[0] == -999);
                System.out.println("    Out simplx (unbounded)");
                return 1;
            }
            System.out.println("                pivoting row "+ip+" ("+varLabel(iposv[ip],m,n)+") with col "+kp+" ("+varLabel(izrov[kp],m,n)+")");
            pivot(a,m,n,ip,kp); // Exchange a left- and right-hand variable (phase two).

            {
                // SWAP(izrov[kp], iposv[ip]);
                int is = izrov[kp]; 
                izrov[kp] = iposv[ip];
                iposv[ip] = is;
            }
        } // and return for another iteration.

    } // simplx

    //
    // Utility functions...
    //

        // Determines the maximum of those elements whose index is contained
        // in the supplied list ll,
        // either with or without taking the absolute value,
        // as flagged by iabf.
        private static void simp1(double a[][],       // in
                                  int mm,             // in
                                  int ll[],           // in
                                  int nll,            // in
                                  boolean iabf,       // in
                                  int kp[/*1*/],      // out
                                  double bmax[/*1*/]) // out
        {
            if (nll <= 0)
                bmax[0] = 0.; // No eligible columns.
            else
            {
                kp[0] = ll[1];
                bmax[0] = a[mm+1][kp[0]+1];
                for (int k = 2; k <= nll; k++)
                {
                    double test =
                        iabf ? Math.abs(a[mm+1][ll[k]+1]) - Math.abs(bmax[0])
                             : a[mm+1][ll[k]+1] - bmax[0];
                    if (test > 0.)
                    {
                        bmax[0] = a[mm+1][ll[k]+1];
                        kp[0] = ll[k];
                    }
                }
            }
        } // simp1

        // Locate a pivot element, taking degeneracy into account.
        private static int simp2(double a[][],
                                 int m,
                                 int n,
                                 int kp)
        {
            int i;
            for (i = 1; i <= m; i++)
                if (a[i+1][kp+1] < -EPS) break; // Any possible pivots?
            if (i > m)
                return 0;
            double q1 = -a[i+1][1]/a[i+1][kp+1];
            int ip = i;
            for (i = ip+1; i <= m; i++)
            {
                if (a[i+1][kp+1] < -EPS)
                {
                    double q = -a[i+1][1]/a[i+1][kp+1];
                    if (q < q1)
                    {
                        ip = i;
                        q1 = q;
                    }
                    else if (q == q1) // We have a degeneracy.
                    {
                        double q0=0., qp=0.; // doesn't really need initializing, assuming n>0 XXX which perhaps should be asserted
                        for (int k = 1; k <= n; k++)
                        {
                            qp = -a[ip+1][k+1]/a[ip+1][kp+1];
                            q0 = -a[i+1][k+1]/a[i+1][kp+1];
                            if (q0 != qp)
                                break;
                        }
                        if (q0 < qp)
                            ip = i;
                    }
                }
            }
            return ip;
        } // simp2

        // Matrix operations to exchange
        // a left-hand (row) and right-hand (column) variable.
        // Pivots row variable ip with column variable kp,
        // i.e. pivots row 1+ip with column 1+kp.
        private static void pivot(double a[][],
                                  int i1, // last row to worry about is 1+i1
                                  int k1, // last col to worry about is 1+k1
                                  int ip,
                                  int kp)
        {
            double piv = 1./a[ip+1][kp+1];
            for (int ii = 1; ii <= i1+1; ii++)
            {
                if (ii-1 != ip)
                {
                    a[ii][kp+1] *= piv;
                    for (int kk = 1; kk <= k1+1; kk++)
                    {
                        if (kk-1 != kp)
                            a[ii][kk] -= a[ip+1][kk]*a[ii][kp+1];
                    }
                }
            }
        } // pivot

    /** Little test program. */
    public static void main(String args[])
    {

        if (false)
        {
            //
            // Example from the book.
            // Dummy first row and column.
            //
            double A[][] = {
                null, // dummy row for 1-based indexing
                // Objective function
                {Double.NaN, 0, 1, 1, 3, -.5},  // maximize z = x1 + x2 + 3*x3 - .5*x4
                // Less-than constraints
                {Double.NaN, 740, -1, 0, -2, 0}, // x1 + 2*x3 <= 740
                {Double.NaN, 0, 0, -2, 0, 7},    // 2*x2 - 7*x4 <= 0
                // Greater-than constraints
                {Double.NaN, .5, 0, -1, 1, -2},  // x2 - x3 + 2*x4 >= .5
                // Equality constraints
                {Double.NaN, 9,-1,-1,-1,-1},     // x1 + x2 + x3 + x4 == 9
                // Algorithm needs extra scratch row for the auxiliary objective function
                {Double.NaN, 0,0,0,0,0},
            };
            double expectedAnswerToTwoDecimals[] = { Double.NaN, 0, 3.33, 4.73, .95 };
            int m = A.length-3;
            int n = A[1].length-2;
            int nLE = 2;
            int nGE = 1;
            int nEQ = 1;
            assert(nLE+nGE+nEQ == m);
            System.out.println("Input:");
            PRINTMAT(A);
            PRINT(m);
            PRINT(n);
            PRINT(nLE);
            PRINT(nGE);
            PRINT(nEQ);

            int izrov[] = new int[n+1]; izrov[0] = -999;
            int iposv[] = new int[m+1]; iposv[0] = -999;

            int icase = simplx(A,
                               nLE+nGE+nEQ,
                               n,
                               nLE, nGE, nEQ,
                               izrov,
                               iposv);
            System.out.println("Output:");
            PRINT(icase);
            if (debugLevel >= 2)
            {
                PRINTMAT(A);
            }
            if (debugLevel >= 1)
            {
                PRINTVEC(izrov);
                PRINTVEC(iposv);
                PRINTTABLEAU(A,m,n,nLE,nGE,izrov,iposv);
            }

            assert(A[0] == null);
            for (int i = 1; i < A.length; ++i)
                assert(Double.isNaN(A[i][0]));
            assert(izrov[0] == -999);
            assert(iposv[0] == -999);
            // XXX assert the answer is right!

        }

        if (true)
        {
            //
            // See if we can locate the dual verts
            // of each regular polyhedron.
            //
            double noVerts[][] = {
            };
            double oneVert[][] = {
                { 1,0,0},
            };
            double segVerts[][] = {
                { 1,0,0},
                {-1,0,0},
            };
            double tetraVerts[][] = {
                {1,1,1},
                {1,-1,-1},
                {-1,1,-1},
                {-1,-1,1},
            };
            double cubeVerts[][] = {
                {-1,-1,-1},
                { 1,-1,-1},
                {-1, 1,-1},
                { 1, 1,-1},
                {-1,-1, 1},
                { 1,-1, 1},
                {-1, 1, 1},
                { 1, 1, 1},
            };
            double octaVerts[][] = {
                {1,0,0},
                {-1,0,0},
                {0,1,0},
                {0,-1,0},
                {0,0,1},
                {0,0,-1},
            };
            double gold = (Math.sqrt(5)+1)/2;
            double icosaVerts[][] = {
                {0,  1,  gold},
                {0, -1,  gold},
                {0,  1, -gold},
                {0, -1, -gold},
                { 1,  gold, 0},
                { 1, -gold, 0},
                {-1,  gold, 0},
                {-1, -gold, 0},
                { gold, 0,  1},
                { gold, 0, -1},
                {-gold, 0,  1},
                {-gold, 0, -1},
            };
            double dodecaVerts[][] = {
                {0,  1/gold,  gold},
                {0, -1/gold,  gold},
                {0,  1/gold, -gold},
                {0, -1/gold, -gold},
                { 1/gold,  gold, 0},
                { 1/gold, -gold, 0},
                {-1/gold,  gold, 0},
                {-1/gold, -gold, 0},
                { gold, 0,  1/gold},
                { gold, 0, -1/gold},
                {-gold, 0,  1/gold},
                {-gold, 0, -1/gold},
                { 1, 1, 1},
                { 1, 1,-1},
                { 1,-1, 1},
                { 1,-1,-1},
                {-1, 1, 1},
                {-1, 1,-1},
                {-1,-1, 1},
                {-1,-1,-1},
            };
            double primalsVerts[][][] = {
                noVerts, // should be unbounded
                oneVert, // should be unbounded
                segVerts, // should be finite
                tetraVerts, // should be finite
                cubeVerts, // should be finite
                octaVerts, // should be finite
                icosaVerts, // should be finite
                dodecaVerts, // should be finite
            };
            for (int iPrimal = 0; iPrimal < primalsVerts.length; ++iPrimal)
            {
                System.out.println("=======================================================");
                System.out.println("iPrimal = "+iPrimal);
                double verts[][] = primalsVerts[iPrimal];
                int nDims = 3;
                int nVerts = verts.length;

                double A[][] = new double[0][nDims]; // XXX maybe should allow null?
                double b[] = new double[0]; // XXX maybe should allow null?
                double C[][] = verts;
                double d[] = new double[nVerts];

                double x[] = new double[nDims]; // solution
                double y[] = new double[nVerts]; // slack at solution

                for (int iVert = 0; iVert < nVerts; ++iVert)
                    d[iVert] = 1; // verts[iVert] dot x <= 1

                for (int iIter = 0; iIter < 1; ++iIter)
                {
                    java.util.Random generator =
                        args.length > 0 ? new java.util.Random(Integer.parseInt(args[0]))
                                        : new java.util.Random();

                    // Random offset...
                    double offset[] = new double[nDims];
                    for (int iDim = 0; iDim < nDims; ++iDim)
                        offset[iDim] = 2*generator.nextDouble() - 1;
                    VecMath.normalize(offset);
                    VecMath.sxv(offset, 1., offset);
                    // So instead of C x < d,
                    // we want C (x - offset) < d
                    // i.e. C x < d + C offset
                    double offset_d[] = VecMath.mxv(C, offset);
                                        VecMath.vpv(offset_d, offset_d, d);

                    // Random objective function...
                    double q[] = new double[nDims];
                    for (int iDim = 0; iDim < nDims; ++iDim)
                        q[iDim] = 2*generator.nextDouble()-1;

                    int result = LPSolve(x,y,A,b,C,offset_d,q, false); // the general problem
                    //int result = LPSolve(x,y,A,b,C,offset_d,q, true); // restrict to positive octant to make it a simpler problem.  This will often be infeasible due to the offset.
                    PRINTVEC(q);
                    PRINTVEC(x);
                    PRINTVEC(y);

                } // for iIter

                System.out.println("=======================================================");
            } // for iPrimal
        }
    } // main

} // class LinearProgramming
