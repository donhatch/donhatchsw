/* vim: set filetype=java: */
package com.donhatchsw.util;
#include "macros.h" 

/**
* WORK IN PROGRESS
* XXX javadocize
* This class encapsulates parameters of a downward-hanging catenary
* in the x,y plane; that is, the graph of the canonical catenary function y=cosh(x)-1,
* possibly scaled and translated.
* Very small or large scales including 0 and infinity are handled robustly.
* However the scale must be nonnegative,
* which means the x coord is nondecreasing.  If you want a class without
* this restriction, use Catenary.FlippedMaybe instead.
*
* The parameters are the scale s and a "focus point" both on the canonical catenary
* and in world space:
*   - scale s
*   - a focus time TFocus yielding focus point XFocus=asinh(TFocus),YFocus=sqrt(TFocus^2+1)-1
*       on the canonical catenary graph Y=cosh(X)-1
*   - the corresponding focus point xFocusInWorld,yFocusInWorld in world space
* The parametrization is then nominally:
*   x(t) = xFocusInWorld + s*asinh(t/s + TFocus)
*   y(t) = yFocusInWorld + s*(sqrt((t/s + TFocus)^2 + 1) - 1)
*        = yFocusInWorld + (sqrt((t + TFocus*s)^2 + s^2) - s)
* Robustness is achieved, in part, by the following techniques:
*   - s is represented as a non-negative numerator and a denominator,
*     either (but not both) of which may be zero, and the max of which is 1.
*   - TFocus,XFocus,YFocus are represented implicitly by "focusDirection" which is the tangent unit
*     direction vector of the function at the focus point (both in canonical catenary space
*     and in world space).
*     Then nominally,
*         TFocus = slope = yFocusDirection/xFocusDirection
*         XFocus = asinh(TFocus)
*         YFocus = sqrt(TFocus^2+1)-1
*     In particular:
*         focusDirection=(0,-1) represents T0=-infinity,X0=-infinity,Y0=infinity
*         focusDirection=(1,0)  represents T0=0,X0=0,Y0=0
*         focusDirection=(0,1)  represents T0=infinity,X0=infinity,Y0=infinity
*   - When fitting to sample points, the focus points are chosen
*     to be close to the sample points to avoid unnecessarily large
*     intermediate values in computations.
*   - When s <= 1, the focus direction is constrained to be (1,0).
* Constraints:
*   sNumerator >= 0
*   sDenominator >= 0
*   max(sNumerator, sDenominator) = 1
*   xFocusDirection >= 0 (no sign restriction on y)
*   xFocusDirection^2 + yFocusDirection^2 = 1
*   when s<=1, focusDirection=(1,0)
*   when s>1, and fitting to two sample points, the focus must be between the two
*              sample points.
*              XXX maybe focusDirection should be from first toward second sample point? not sure
*   XXX when s<=1 can the slope be represented as / replaced by t distance from apex in world space?  and when s>=1 it's the t disance from apex in canon space.  hmm, maybe some elegant formulation hidden in here that I'm not quite getting.
*/
public class Catenary
{
    public boolean XXX_TRY_NONTRIVIAL_FOCUS = false; // doesn't work yet. need to make it work and get rid of this.
    public boolean XXX_USE_SIMPLE_PROTECTION = true;

    // Scale s, in range [0,infinity].
    // sNumerator>=0, sDenominator>=0, max(sNumerator,sDenominator)==1.
    public double sNumerator;
    public double sDenominator;

    // Value at t=0.  Must be finite.
    public double xFocusInWorld;
    public double yFocusInWorld;

    // Unit direction vector of the tangent of the function at the focus point.
    public double xFocusDirection;
    public double yFocusDirection;

    public double t0; // t for which value is x0,y0 if fitting to sample points
    public double t1;  // t for which value is x1,y1 if fitting to sample points

    public Catenary()
    {}

    public void assertValid()
    {
        assert(sNumerator >= 0.);
        assert(sDenominator >= 0.);
        assert(Math.max(sNumerator, sDenominator) == 1.);
        assert(xFocusDirection >= 0); // no restriction on sign of y
        //PRINT(xFocusDirection);
        //PRINT(yFocusDirection);
        //PRINT(MyMath.hypot(xFocusDirection, yFocusDirection));
        double focusDirectionLengthError = MyMath.hypot(xFocusDirection, yFocusDirection) - 1.;
        assert(SQR(focusDirectionLengthError) + 1. - 1. == 0.); // implicit tolerance
        if (sNumerator <= sDenominator)
        {
            assert(xFocusDirection == 1.);
            assert(yFocusDirection == 0.);
        }
        else
        {
            if (XXX_TRY_NONTRIVIAL_FOCUS)
            {
                assert(t0 <= 0.);
                assert(t1 >= 0.);
            }
            else
            {
                if (t0 > 0. || t1 < 0.)
                {
                    //OUT("WARNING: not enforcing nontrivial focus");
                }
            }
        }
        assert(t0 <= t1);
    }

    // Set members to be the parameters of the catenary
    // passing through points (x0,y0),(x1,y1) with given nonnegatie slack.
    // Does no memory allocations.
    // x0 must be <= x1.
    public void fit(double x0, double y0,
                    double x1, double y1,
                    double slack,
                    int verboseLevel) // 0: nothing, 1: in/out, 2: more details
    {
        if (verboseLevel >= 1) System.out.println("                        in Catenary.fit(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+")");
        assert(slack >= 0.); // precondition
        assert(x0 <= x1); // precondition
        double dx = x1 - x0;
        double dy = y1 - y0;
        double tol = 1e-9;
        if (slack == 0.
         || XXX_USE_SIMPLE_PROTECTION && slack <= tol)
        {
            if (verboseLevel >= 1) System.out.println("                          slack=0 s=infinity case"+(slack!=0.?" (CLOSE ENOUGH)":""));
            // s is infinity
            //assert(false); // coverage; remove when hit
            this.sNumerator = 1.;
            this.sDenominator = 0.;
            this.xFocusInWorld = (x0+x1)*.5;
            this.yFocusInWorld = (y0+y1)*.5;

            double L = MyMath.hypot(dx, dy);
            if (L == 0.)
            {
                this.xFocusDirection = 1.;
                this.yFocusDirection = 0.;
            }
            else
            {
                this.xFocusDirection = dx / L;
                this.yFocusDirection = dy / L;
            }
            this.t0 = -L*.5;
            this.t1 = L*.5;
        }
        else if (dx == 0.
             || XXX_USE_SIMPLE_PROTECTION && Math.abs(dx) < tol)
        {
            if (verboseLevel >= 1) System.out.println("                          dx=0 s=0 case"+(dx!=0.?" (CLOSE ENOUGH)":""));
            // s is zero
            //assert(false); // coverage; remove when hit
            this.sNumerator = 0.;
            this.sDenominator = 1.;
            this.xFocusInWorld = (x0+x1)*.5;
            this.yFocusInWorld = Math.min(y0,y1) - slack*.5;
            this.xFocusDirection = 1.;
            this.yFocusDirection = 0.;
            this.t0 = this.yFocusInWorld - y0; // negative
            this.t1 = y1 - this.yFocusInWorld; // positive
        }
        else
        {
            if (verboseLevel >= 1) System.out.println("                          s finite and nonzero case");
            // s is finite and nonzero
            //assert(false); // coverage; remove when hit
            double L = MyMath.hypot(dx, dy) + slack;
            // XXX TODO: make the following totally robust even if s is very large or small
            double s = dx / (2.*asinhc(Math.sqrt(L*L - dy*dy) / dx));
            if (verboseLevel >= 1) System.out.println("                              s = "+s);
            if (s <= 1.)
            {
                if (verboseLevel >= 1) System.out.println("                              s<=1 subcase: focus at apex");
                //assert(false); // coverage; remove when hit
                this.sNumerator = s;
                this.sDenominator = 1.;

                this.xFocusDirection = 1.;
                this.yFocusDirection = 0.;

                double tMid = .5 * dy * Math.sqrt(1. + 4.*(s*s)/(L*L - dy*dy));
                this.t0 = tMid - L/2.;
                this.t1 = t0 + L;
                // If we didn't care about stability:
                //   this.xFocusInWorld = x0 - s*asinh(t0/s)
                // XXX wait a minute, why can't we do that?? I'm confused. why is what I have here any better? it's just computing it at the xMid point instead of x0 I guess?
                this.xFocusInWorld = (x0+x1)/2.
                                   - s*MyMath.asinh(dy/(2.*s*MyMath.sinh(dx/(2.*s))));
                this.yFocusInWorld = y0 - (Math.sqrt(this.t0*this.t0 + s*s) - s);
            }
            else
            {
                if (verboseLevel >= 1) System.out.println("                              s>1 subcase: focus not at apex");
                //assert(false); // coverage; remove when hit
                this.sNumerator = 1.;
                this.sDenominator = 1./s;

                if (true)
                {
                    // For now, start with the canonical focus case and adjust.
                    // XXX eventually need to move to something more stable

                    this.xFocusDirection = 1.;
                    this.yFocusDirection = 0.;

                    double tMid = .5 * dy * Math.sqrt(1. + 4.*(s*s)/(L*L - dy*dy));
                    this.t0 = tMid - L/2.;
                    this.t1 = t0 + L;
                    // If we didn't care about stability:
                    //   this.xFocusInWorld = x0 - s*asinh(t0/s)
                    // XXX wait a minute, why can't we do that?? I'm confused. why is what I have here any better? it's just computing it at the xMid point instead of x0 I guess?
                    this.xFocusInWorld = (x0+x1)/2.
                                       - s*MyMath.asinh(dy/(2.*s*MyMath.sinh(dx/(2.*s))));
                    this.yFocusInWorld = y0 - (Math.sqrt(this.t0*this.t0 + s*s) - s);


                    if (true)
                    {
                        // Adjust to meet validity criteria: t0<=0, t1>=0.

                        // Switch focus from 0 (apex of catenary) to tMid (measured from apex of catenary)

                        double xFocusInWorldOld = this.xFocusInWorld;
                        double yFocusInWorldOld = this.yFocusInWorld;
                        double t0Old = this.t0;
                        double t1Old = this.t1;
                        if (verboseLevel >= 2) PRINT(xFocusInWorldOld);
                        if (verboseLevel >= 2) PRINT(yFocusInWorldOld);
                        if (verboseLevel >= 2) PRINT(t0Old);
                        if (verboseLevel >= 2) PRINT(t1Old);

                        // Anything with T in it, here,
                        // is a measurement from the apex of the canonical catenary.
                        double TFocusOld = 0.;
                        double XFocusOld = 0.;
                        double YFocusOld = 0.;
                        double T0Old = t0Old / s;
                        double T1Old = t1Old / s;

                        double TFocusNew = tMid / s;
                        double XFocusNew = MyMath.asinh(TFocusNew);
                        double YFocusNew = Math.sqrt(SQR(TFocusNew)+1.)-1.;
                        double t0New = (T0Old - TFocusNew) * s;
                        double t1New = (T1Old - TFocusNew) * s;
                        double xFocusInWorldNew = xFocusInWorldOld + (XFocusNew-XFocusOld) * s;
                        double yFocusInWorldNew = yFocusInWorldOld + (YFocusNew-YFocusOld) * s;
                        double focusSlopeNew = TFocusNew;
                        double xFocusDirectionNew = 1.;
                        double yFocusDirectionNew = focusSlopeNew;
                        double temp = Math.hypot(xFocusDirectionNew, yFocusDirectionNew);
                        xFocusDirectionNew /= temp;
                        yFocusDirectionNew /= temp;

                        if (XXX_TRY_NONTRIVIAL_FOCUS)
                        {
                            this.t0 = t0New;
                            this.t1 = t1New;
                            this.xFocusInWorld = xFocusInWorldNew;
                            this.yFocusInWorld = yFocusInWorldNew;
                            this.xFocusDirection = xFocusDirection;
                            this.yFocusDirection = yFocusDirection;
                        }
                        else
                        {
                            //System.out.println("WARNING: not doing nontrivial focus");
                        }
                    }
                }
            }
        }
        if (verboseLevel >= 1)
        {
            System.out.println("                          s= "+this.sNumerator+"/"+this.sDenominator+" = "+(this.sNumerator/this.sDenominator));
            System.out.println("                          focusDirection = "+this.xFocusDirection+" "+this.yFocusDirection);
            System.out.println("                          focusInWorld = "+this.xFocusInWorld+" "+this.yFocusInWorld);
            System.out.println("                          t0 = "+this.t0);
            System.out.println("                          t1 = "+this.t1);

        }

        assertValid();
        if (verboseLevel >= 1) System.out.println("                        out Catenary.fit(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+")");
    } // fit


    // Unit-length derivative at time t. 
    public void differentiate(double t,
                              double answer[/*2*/])
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("                        in Catenary.differentiate(t="+t+")");
        assertValid();

        if (sDenominator == 0.)
        {
            // s is infinity
            if (verboseLevel >= 1) System.out.println("                          slack=0 s=infinity case");
            //assert(false); // coverage; remove when hit.
            answer[0] = xFocusDirection;
            answer[1] = yFocusDirection;
            // guaranteed to be unit length! hooray!
        }
        else if (sNumerator == 0.)
        {
            // s is 0
            if (verboseLevel >= 1) System.out.println("                          dx=0 s=0 case");
            //assert(false); // coverage; remove when hit.
            answer[0] = 0.;
            answer[1] = t>=0. ? 1. : -1.;
        }
        else
        {
            if (verboseLevel >= 1) System.out.println("                          s finite and nonzero case");
            double s = sNumerator / sDenominator; // XXX obviously not robust
            double TFocusNumerator = yFocusDirection;
            double TFocusDenominator = xFocusDirection;
            if (SQR(xFocusDirection) >= .5)
            {
                if (verboseLevel >= 1) System.out.println("                              mostly horizontal");
                // mostly horizontal; Tfocus relatively small (or zero),
                // so we're not subtracting huge numbers.
                // (XXX assuming s not huge... need to think about case s huge)
                //assert(false); // coverage; remove when hit
                double TFocus = TFocusNumerator / TFocusDenominator; // stable
                assert(TFocus == 0.); // XXX won't be true when I fix everything
                double T = TFocus + t/s;
                answer[0] = 1.;
                answer[1] = T;
                VecMath.normalize(answer, answer);
            }
            else
            {
                if (verboseLevel >= 1) System.out.println("                              mostly vertical");
                // mostly vertical.

                assert(false); // coverage; remove when hit
                double invTFocus = TFocusDenominator / TFocusNumerator; // stable
                assert(false); // XXX implement me!
            }
        }

        if (verboseLevel >= 1) PRINT(VecMath.norm(answer));
        double normsqrd = VecMath.normsqrd(answer);
        assert(Math.abs(normsqrd - 1.) < 1e-6); // very rough; just make sure we didn't do anything blatantly wrong
        assert(answer[0] >= 0.);
        if (verboseLevel >= 1) System.out.println("                        out Catenary.differentiate(t="+t+"), returning answer="+VecMath.toString(answer));
    } // differentiate

    // Position at time t.
    public void evaluate(double t,
                         double answer[/*2*/])
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("                        in Catenary.evaluate(t="+t+")");
        assertValid();
        if (sDenominator == 0.)
        {
            // s is infinity
            if (verboseLevel >= 1) System.out.println("                          slack=0 s=infinity case");
            //assert(false); // coverage; remove when hit.
            answer[0] = xFocusInWorld + t * xFocusDirection;
            answer[1] = yFocusInWorld + t * yFocusDirection;
        }
        else if (sNumerator == 0.)
        {
            // s is 0
            if (verboseLevel >= 1) System.out.println("                          dx=0 s=0 case");
            //assert(false); // coverage; remove when hit.
            answer[0] = xFocusInWorld;
            answer[1] = yFocusInWorld + Math.abs(t);
        }
        else
        {
            if (verboseLevel >= 1) System.out.println("                          s finite and nonzero case");
            // keep in mind: when s<1, we know Tfocus=0, so that can simplify things.
            // conversely, when Tfocus!=0 we know s>=1.
            // i.e. it never happens that s<1 and Tfocus!=0.

            // 0 < s < infinity
            //assert(false); // coverage; remove when hit

            //     x(t) = xFocusInWorld + s*(asinh(TFocus + t/s) - asinh(TFocus))
            //     y(t) = yFocusInWorld + s*(sqrt((TFocus + t/s)^2 + 1) - sqrt(TFocus^2 + 1))
            //          = yFocusInWorld + (sqrt((s*TFocus + t)^2 + s^2) - sqrt((s*TFocus)^2 + s^2))
            //          = yFocusInWorld + (((s*TFocus + t)^2 + s^2) - ((s*TFocus)^2 + s^2))
            //                          / (sqrt((s*TFocus + t)^2 + s^2) + sqrt((s*TFocus)^2 + s^2))
            //          = yFocusInWorld + (2*s*TFocus*t + t^2)
            //                          / (sqrt((s*TFocus + t)^2 + s^2) + sqrt((s*TFocus)^2 + s^2))
            // Where TFocus = slope = yFocusDirection/xFocusDirection.
            // XXX you are here
            double s = sNumerator / sDenominator; // XXX obviously not robust

            // This should work no matter whether Tfocus is
            // entirely vertical, mainly vertical, mainly horizontal, or entirely horizontal,
            // as long as s is not too huge or infinity. XXX think about that case
            double TFocusNumerator = yFocusDirection;
            double TFocusDenominator = xFocusDirection;
            answer[0] = xFocusInWorld + s * MyMath.asinh_difference(TFocusNumerator, TFocusDenominator, t/s);

#ifdef NOTYET
            answer[1] = yFocusInWorld + 
#endif

            if (SQR(xFocusDirection) >= .5)
            {
                if (verboseLevel >= 1) System.out.println("                              mostly horizontal");
                // mostly horizontal; Tfocus relatively small (or zero),
                // so we're not subtracting huge numbers.
                // (XXX assuming s not huge... need to think about case s huge)
                //assert(false); // coverage; remove when hit
                double TFocus = TFocusNumerator / TFocusDenominator; // stable
                answer[1] = yFocusInWorld + (Math.sqrt(SQR(TFocus*s + t) + s*s)
                                           - Math.sqrt(SQR(TFocus*s) + s*s));
            }
            else
            {
                if (verboseLevel >= 1) System.out.println("                              mostly vertical");
                // mostly vertical.

                // For the y part:
                // shorthand T=Tfocus
                //     sqrt((T+t/s)^2+1) - sqrt(T^2+1)
                //   = ((T+t/s)^2+1) - (T^2+1)) / (sqrt((T+t/s)^2+1) + sqrt(T^2+1))
                //   = (T+t/s)^2 - T^2) / (sqrt((T+t/s)^2+1) + sqrt(T^2+1))
                //   = (2*T*(t/s)+(t/s)^2) / (sqrt((T+t/s)^2+1) + sqrt(T^2+1))
                //   = (2*(t/s) + (t/s)^2/T) / (sqrt((1+t/s/T)^2+1/T^2) + sqrt(1+1/T^2)
                // so s times that is:
                //   = (2*t + t^2/s/T) / (...)
                //   = t*(2 + t/s/T) / (...)
                // XXX redo this using the second version of y(t) throughout
                assert(false); // coverage; remove when hit
                double invTFocus = TFocusDenominator / TFocusNumerator; // stable
                answer[1] = yFocusInWorld
                          + t*(2+t*invTFocus/s) / (Math.sqrt(SQR(1+t*invTFocus/s)+SQR(invTFocus)) + Math.sqrt(1+SQR(invTFocus)));
            }
        }
        if (verboseLevel >= 1) System.out.println("                        out Catenary.evaluate(t="+t+"), returning answer="+VecMath.toString(answer));
    } // evaluate
    // Arc length integral from focus to t.
    public void integrate(double t,
                          double answer[/*2*/])
    {
        int verboseLevel = 0; // 0: nothing, 1: in/out, 2: more details
        if (verboseLevel >= 1) System.out.println("                                in Catenary.integrate(t="+t+")");

        assertValid();
        if (sDenominator == 0.)
        {
            if (verboseLevel >= 1) System.out.println("                                    slack=0 s=infinity case");
            // s is infinity
            //assert(false); // coverage; remove when hit
            answer[0] = t * (xFocusInWorld + .5*t*xFocusDirection);
            answer[1] = t * (yFocusInWorld + .5*t*yFocusDirection);
        }
        else if (sNumerator == 0.)
        {
            if (verboseLevel >= 1) System.out.println("                                    dx=0 s=0 case");
            // s is 0
            //assert(false); // coverage; remove when hit
            answer[0] = t * xFocusInWorld;
            answer[1] = t * (yFocusInWorld + .5*Math.abs(t));
        }
        else
        {
            if (verboseLevel >= 1) System.out.println("                                    s finite and nonzero case");
            //assert(false); // coverage; remove when hit
            double s = sNumerator / sDenominator; // XXX obviously not robust
            assert(xFocusDirection != 0.);
            double TFocus = yFocusDirection / xFocusDirection; // XXX obviously not robust
            //     x(t) = xFocusInWorld + s*asinh(t/s + TFocus)
            //     y(t) = yFocusInWorld + s*(sqrt((t/s + TFocus)^2 + 1) - 1)   (integrate this one, it's easier)
            //          = yFocusInWorld + sqrt((t + TFocus*s)^2 + s^2) - s
            // Per wolframalpha:
            //     x part of integral = xFocusInWorld*t + s*((s*T+t)*asinh(t/s+T)-s*sqrt(SQR(s*T+t)/(s*s)+1))
            //                        = xFocusInWorld*t + s*((s*T+t)*asinh(t/s+T) - sqrt(SQR(s*T+t) + s*s))
            //     y part of integral = (yFocusInWorld-s)*t + .5*(s*s)*(sqrt(SQR(t/s+T)+1)*(t/s+T) + asinh(t/s+T))
            double T = TFocus;

            if (verboseLevel >= 2) System.out.println("                                        t = "+t);
            if (verboseLevel >= 2) System.out.println("                                        s = "+s);
            if (verboseLevel >= 2) System.out.println("                                        t/s = "+t/s);
            if (verboseLevel >= 2) System.out.println("                                        T = "+T);
            if (verboseLevel >= 2) System.out.println("                                        t/s+T = "+t/s+T);
            if (verboseLevel >= 2) System.out.println("                                        asinh(t/s+T) = "+MyMath.asinh(t/s+T));

            double asinh = MyMath.asinh(t/s+T);

            answer[0] = xFocusInWorld*t + s*((s*T+t)*asinh - Math.sqrt(SQR(s*T+t) + s*s));
            answer[1] = (yFocusInWorld-s)*t + .5*(s*s)*(Math.sqrt(SQR(t/s+T)+1)*(t/s+T) + asinh);

            // XXX maybe use this from previous implementation?
            // XXX it wasn't as general, but it's a very interesting formulation!
            // XXX does it require both t0 and t1 though? Actually I don't think so!
            // Parametrizing cosh by arc length between those endpoints,
            // this part of the cosh curve is:
            //      <asinh(t), sqrt(1+t^2)> for x in [x0,x1]
            //                              i.e. for t in [sinh(x0),sinh(x1)]
            // The integral of that part is:
            //      {-sqrt(1+t^2) + t*asinh(t),
            //       (t*sqrt(1+t^2) + asinh(t))/2}.
            // Evaluating that at the two endpoints, subtracting, and simplifying,
            // we get:
            //      x part = (-sqrt(1+sinh(x1)^2) + sinh(x1)*x1)
            //             - (-sqrt(1+sinh(x0)^2) + sinh(x0)*x0)
            //             = (-cosh(x1) + sinh(x1)*x1)
            //             - (-cosh(x0) + sinh(x0)*x0)
            //
            //      y part = (sinh(x1)*sqrt(1+sinh(x1)^2) + x1)/2
            //             - (sinh(x0)*sqrt(1+sinh(x0)^2) + x0)/2
            //             = (sinh(x1)*cosh(x1) + x1)/2
            //             - (sinh(x0)*cosh(x0) + x0)/2
            // But we also have to add the arc length
            // times the translation taking the cosh curve to v0,v1.
            // The arc length is sinh(x1)-sinh(x0)
            // and the translation is <v0[0]-x0, v0[1]-cosh(x0)>
        }
        if (verboseLevel >= 1) System.out.println("                                out Catenary.integrate(t="+t+"), returning "+VecMath.toString(answer));
    } // integrate

    // subclasses don't need to override this--
    // it's just a convenience function
    // that calls the subclass's integrate() anyway.
    public void integrate(double t0, // not necessarily this.t0
                          double t1, // not necessarily this.t1
                          double answer[/*2*/])
    {
        int verboseLevel = 0; // 0: nothing, 1: in/out, 2: more details
        if (verboseLevel >= 1) System.out.println("                        in Catenary.integrate(t0="+t0+", t1="+t1+")");
        integrate(t0, answer); // note this might be a subclass's integrate
        double answer0x = answer[0];
        double answer0y = answer[1];
        integrate(t1, answer); // note this might be a subclass's integrate
        answer[0] -= answer0x;
        answer[1] -= answer0y;
        if (verboseLevel >= 1) System.out.println("                        out Catenary.integrate(t0="+t0+", t1="+t1+"), returning answer="+VecMath.toString(answer));
    } // integrate

    @Override public String toString()
    {
       StringBuffer sb = new StringBuffer();
       sb.append("{");
       sb.append("s=");
       sb.append(sNumerator);
       sb.append("/");
       sb.append(sDenominator);
       sb.append(", focusInWorld = ");
       sb.append(xFocusInWorld);
       sb.append(",");
       sb.append(yFocusInWorld);
       sb.append(", focusDirection =");
       sb.append(xFocusDirection);
       sb.append(",");
       sb.append(yFocusDirection);
       sb.append(", ");
       sb.append("t0=");
       sb.append(t0);
       sb.append(", ");
       sb.append("t1=");
       sb.append(t1);
       sb.append("}");
       return sb.toString();
    }

    // Catenary always has non-negative scale,
    // and its fit() requires x0<=x1.
    // This class has no such restriction.
    // The catenary still hangs downward but may be left-right flipped.
    public static class FlippedMaybe extends Catenary
    {
        public boolean leftRightFlipped;
        @Override public void fit(double x0, double y0,
                                  double x1, double y1,
                                  double slack,
                                  int verboseLevel)
        {
            if (x1 < x0)
            {
                super.fit(-x0,y0, -x1,y1, slack, verboseLevel);
                this.leftRightFlipped = true;
            }
            else
            {
                super.fit(x0,y0, x1,y1, slack, verboseLevel);
                this.leftRightFlipped = false;
            }
            //PRINT(this.leftRightFlipped);
        }
        @Override public void differentiate(double t,
                                            double answer[/*2*/])
        {
            super.differentiate(t, answer);
            if (this.leftRightFlipped)
                answer[0] *= -1.;
        }
        @Override public void evaluate(double t,
                                       double answer[/*2*/])
        {
            super.evaluate(t, answer);
            if (this.leftRightFlipped)
                answer[0] *= -1.;
        }
        @Override public void integrate(double t,
                                        double answer[/*2*/])
        {
            super.integrate(t, answer);
            if (this.leftRightFlipped)
                answer[0] *= -1.;
        }
        @Override public String toString()
        {
           StringBuffer sb = new StringBuffer();
           sb.append("{");
           sb.append("flipped=");
           sb.append(this.leftRightFlipped);
           sb.append(", ");
           sb.append(super.toString());
           sb.append("}");
           return sb.toString();
        }
    } // class FlippedMaybe





    //======================================================================================
    // XXX move asinhc to MyMath? note it's conceptually very similar to glog and lambertw.
    //
    // The good news is, Newton seems to work well in all cases:
    //   f(x) = sinh(x)/x-y
    //   f'(x) = (x*math.cosh(x)-sinh(x))/x**2
    //   xNext = x - f(x)/f'(x)
    //         = x - (sinh(x)/x-y)/((x*cosh(x)-sinh(x))/x**2)
    // But the bad news is, when done, it seems to get in cycles of 5 so we'd need to retain a lot of values
    // if our stopping criterion is seeing a repeat.
    // But the good news is, after one iteration, we get a value that's definitely too high,
    // after which it's all downhill, so we can stop as soon as it didn't decrease.
    //
    /*
    asinhc_by_newton(y) = y<1. ? crash_in_asinhc_by_newton(1) : y==1. ? 0. : asinhc_by_newton_recurse0(y, Asinh(y))
      // this gets called with an initial guess x that may be (or must be?) too small.
      asinhc_by_newton_recurse0(y, x)   = asinhc_by_newton_recurse1(y, x - (sinh(x)/x-y)/((x*cosh(x)-sinh(x))/x**2))
        // this gets called with x that's definitely bigger than the answer.
        asinhc_by_newton_recurse1(y, x) = asinhc_by_newton_recurse (y, x - (sinh(x)/x-y)/((x*cosh(x)-sinh(x))/x**2), x)
          // this gets called with x<xPrev, unless converged.
          asinhc_by_newton_recurse(y, x, xPrev) = x>=xPrev ? (x+xPrev)/2. : asinhc_by_newton_recurse_helper(y, x, cosh(x), sinh(x))
          asinhc_by_newton_recurse_helper(y, x, cosh_x, sinh_x) = asinhc_by_newton_recurse(y, x - (sinh_x/x-y)/((x*cosh_x-sinh_x)/x**2), x)
          */
    private static double asinhc_by_binary_search(double y)
    {
        if (y <= 1.)
        {
            if (y == 1.)
                return 0.;
            else
                return Double.NaN; // XXX or 0 ? that will correctly handle slight roundoff error in input, but it won't catch blatant errors. in fact, maybe should throw?  not sure
        }
        double lo = 0.;
        double hi = 1e3; // XXX should be more principled, this is plenty for double though
        while (true)
        {
            double mid = (lo + hi) / 2;
            if (mid == lo || mid == hi)
                return mid;
            if (MyMath.sinh(mid)/mid < y) // mid is too low
                lo = mid;
            else
                hi = mid;
        }
    }
    private static double asinhc_by_newton(double y)
    {
        if (y <= 1.)
        {
            if (y == 1.)
                return 0.;
            else
                return Double.NaN; // XXX or 0 ? that will correctly handle slight roundoff error in input, but it won't catch blatant errors. in fact, maybe should throw?  not sure
        }
        // initial guess that may be too small.
        //double x = MyMath.asinh(y); // I think this *must* be too small? not sure
        // very rough eyeball fit:
        // gnuplot> set samples 10000
        // gnuplot> q = 10
        // gnuplot> plot [-q:q] [-q:q] sinh(x)/x, cosh(x/1.5), cosh(x/2.5)**2
        // gnuplot> q = 100
        // gnuplot> replot
        // therefore, roughly:
        //     y = sinhc(x) = cosh(x/2.5)**2
        //     x = 2.5*acosh(sqrt(y))
        // Let's do this in a principled way: using gnuplot's fit function.
        // First dump some samples (somewhat ad-hoc):
        /*
        gnuplot << EOF > DATA.txt  # XXX not right yet, had to paste results manually
sinhc(x) = sinh(x)/x
print 0, 1
print 1, sinhc(1)
print 1.001, sinhc(1.001)
print 1.01, sinhc(1.01)
print 1.1, sinhc(1.1)
print 2, sinhc(2)
print 5, sinhc(5)
EOF
            f(x) = cosh(x/A)**B
            A = 1 # initial guess
            B = 1 #  initial guess
            FIT_LIMIT = 1e-5 # default
            FIT_LIMIT = 1e-13
            #FIT_LIMIT = 1e-14 # The maximum lambda = 1.000000e+20 was exceeded. Fit stopped.
            fit f(x) "DATA.txt" using 1:2 via A,B
            print A, B
            print sprintf("%.17g %.17g", A, B)
            q = 20
            q = 2
            set samples 1001
            plot [-q:q] [-q:q] "DATA.txt" with points, cosh(x/A)**B

        output is:
            2.4536756011708301 1.9812429870098702
        */
        //                    
        double x = 2.4536756011708301 * MyMath.acosh(Math.pow(y, 1./1.9812429870098702));

        // Actually maybe better:
        /*
            f(x) = (cosh(x/A)-1.)**B+1.
            A = 1 # initial guess
            B = 1 #  initial guess
            FIT_LIMIT = 1e-5 # default
            FIT_LIMIT = 1e-8
            #FIT_LIMIT = 1e-9 # "The maximum lambda = 1.000000e+20 was exceeded. Fit stopped."
            fit f(x) "DATA.txt" using 1:2 via A,B
            print A,B
            print sprintf("%.17g %.17g", A, B)
            q = 20
            q = 2
            set samples 1001
            plot [-q:q] [-q:q] "DATA.txt" with points, cosh(x/A)**B
            1.62278016560655 1.14541126805886
        */
        // Hmm actually no, that sucks.  Fooey.  Why??
        // Maybe see: http://stackoverflow.com/questions/11073925/gnuplot-behaves-oddly-in-polynomial-fit-why-is-that


        // iterate once to get something that's definitely bigger than the answer.
        {
            double sinh_x = MyMath.sinh(x);
            x -= (sinh_x/x-y)/((x*MyMath.cosh(x)-sinh_x)/(x*x));
        }
        double xPrev = Double.POSITIVE_INFINITY;
        while (true)
        {
            if (!(x < xPrev))
                return (x+xPrev)*.5;
            xPrev = x;
            double sinh_x = MyMath.sinh(x);
            x -= (sinh_x/x-y)/((x*MyMath.cosh(x)-sinh_x))/(x*x);
        }
    }

    public static double asinhc(double y)
    {
        // XXX TODO: something wrong with newton... ? gives wrong answer on y=3.4081082040601114
        //return asinhc_by_newton(y);
        return asinhc_by_binary_search(y);
    }
    //======================================================================================

} // private static class Catenary
