/* vim: set filetype=java: */
package com.donhatchsw.util;
#include "macros.h" 

//import static java.lang.Math.*; // uncomment for quick messing around to get sqrt etc.

/**
* WORK IN PROGRESS
* XXX javadocize
* This class encapsulates parameters of a downward-hanging catenary
* in the x,y plane; that is, the graph of the canonical catenary function y=cosh(x)-1,
* possibly scaled and translated.
* Very small or large scales including 0 and infinity are handled robustly.
* However the scale must be nonnegative,
* which means the x coord is nondecreasing.  If you want a class without
* this restriction, use Catenary.FlippedMaybe instead.
*
* The parameters are the scale s and a "focus point" both on the canonical catenary
* and in world space:
*   - scale s
*   - a focus time TFocus yielding focus point XFocus=asinh(TFocus),YFocus=sqrt(TFocus^2+1)-1
*       on the canonical catenary graph Y=cosh(X)-1
*   - the corresponding focus point xFocusInWorld,yFocusInWorld in world space
* The parametrization is then nominally:
*   x(t) = xFocusInWorld + s*asinh(t/s + TFocus)
*   y(t) = yFocusInWorld + s*(sqrt((t/s + TFocus)^2 + 1) - 1)
*        = yFocusInWorld + (sqrt((t + TFocus*s)^2 + s^2) - s)
* Robustness is achieved, in part, by the following techniques:
*   - the scale s is represented as a non-negative numerator and a denominator,
*     either (but not both) of which may be zero, and the max of which is 1.
*   - TFocus,XFocus,YFocus are represented implicitly by "focusDirection" which is the tangent unit
*     direction vector of the function at the focus point (both in canonical catenary space
*     and in world space).
*     Then nominally,
*         TFocus = slope = yFocusDirection/xFocusDirection with xFocusDirection >= 0
*         XFocus = asinh(TFocus)
*         YFocus = sqrt(TFocus^2+1)-1
*     In particular:
*         focusDirection=(0,-1) represents T0=-infinity,X0=-infinity,Y0=infinity
*         focusDirection=(1,0)  represents T0=0,X0=0,Y0=0
*         focusDirection=(0,1)  represents T0=infinity,X0=infinity,Y0=infinity
*   - When fitting to two sample points far from the catenary "vertex",
*     the focus point is chosen to be one of the sample points.
*   - If the catenary vertex is between the two sample points,
*     then that is chosen as the focus; i.e. focusDirection=(1,0).
*     This avoids instability and ambiguity if s is close to 0
*     and the catenary piece contains the vertex.
* Constraints:
*   sNumerator >= 0
*   sDenominator >= 0
*   max(sNumerator, sDenominator) = 1
*   xFocusDirection >= 0 (no sign restriction on y)
*   xFocusDirection^2 + yFocusDirection^2 = 1
*   When fitting to two sample points, the focus is the lowest point on the catenary piece.
*     That is, if the catenary vertex lies between the two sample points, the focus point is the vertex;
*     i.e. focusDirection=(1,0).
*     Otherwise the focus is the lower (closer to the vertex) of the two sample points.
*/
public class Catenary
{
    public static boolean XXX_USE_SIMPLE_PROTECTION = false; // actually go through potentially risky computation in all cases!

    // Scale s, in range [0,infinity].
    // sNumerator>=0, sDenominator>=0, max(sNumerator,sDenominator)==1.
    public double sNumerator;
    public double sDenominator;

    // Value at t=0.  Must be finite.
    public double xFocusInWorld;
    public double yFocusInWorld;

    // Unit direction vector of the tangent of the function at the focus point.
    public double xFocusDirection;
    public double yFocusDirection;

    public double t0; // t for which value is x0,y0 if fitting to sample points
    public double t1;  // t for which value is x1,y1 if fitting to sample points

    public Catenary()
    {}

    public void assertValid()
    {
        try
        {
            assert_ge(sNumerator, 0.);
            assert_ge(sDenominator, 0.);
            assert_eq(Math.max(sNumerator, sDenominator), 1.);

            assert_ge(xFocusDirection, 0); // no restriction on sign of y
            //PRINT(xFocusDirection);
            //PRINT(yFocusDirection);
            //PRINT(MyMath.hypot(xFocusDirection, yFocusDirection));
            double focusDirectionLengthError = MyMath.hypot(xFocusDirection, yFocusDirection) - 1.;
            assert_eq(SQR(focusDirectionLengthError) + 1. - 1., 0.); // implicit tolerance

            assert_le(t0, t1);
            assert_le(t0, 0.);
            assert_ge(t1, 0.);

            // If focus is not one of the two sample points,
            // then it must be the catenary vertex
            // (which is strictly between the two sample points).
            if (t0 != 0. && t1 != 0.)
            {
                assert_eq(xFocusDirection, 1.);
                assert_eq(yFocusDirection, 0.);
            }
        }
        catch (Error e)
        {
            // enhance the message with a dump of this catenary
            throw new Error(e.getMessage() + "; this catenary = "+this);
        }
    }

    // Set members to be the parameters of the catenary
    // passing through points (x0,y0),(x1,y1) with given nonnegative slack.
    // Does no memory allocations.
    // x0 must be <= x1.
    public void fit(double x0, double y0,
                    double x1, double y1,
                    double slack,
                    int verboseLevel) // 0: nothing, 1: in/out, 2: more details
    {
        if (verboseLevel >= 1) System.out.println("                        in Catenary.fit(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+")");

        try
        {
            assert(slack >= 0.); // precondition
            assert(x0 <= x1); // precondition
            double dx = x1 - x0;
            double dy = y1 - y0;
            double tol = 1e-9;
            if (slack == 0.
             || XXX_USE_SIMPLE_PROTECTION && slack <= tol)
            {
                if (verboseLevel >= 1) System.out.println("                          slack=0 s=infinity case"+(slack!=0.?" (CLOSE ENOUGH)":""));
                // s is infinity
                //assert(false); // coverage; remove when hit
                this.sNumerator = 1.;
                this.sDenominator = 0.;

                double dist = MyMath.hypot(dx, dy);
                if (dist == 0.)
                {
                    this.xFocusDirection = 1.;
                    this.yFocusDirection = 0.;
                }
                else
                {
                    this.xFocusDirection = dx / dist;
                    this.yFocusDirection = dy / dist;
                }

                // focus is the lower of the two points
                if (y0 <= y1)
                {
                    this.xFocusInWorld = x0;
                    this.yFocusInWorld = y0;
                    this.t0 = 0.;
                    this.t1 = dist;
                }
                else
                {
                    this.xFocusInWorld = x1;
                    this.yFocusInWorld = y1;
                    this.t0 = -dist;
                    this.t1 = 0.;
                }
            }
            else if (dx == 0.
                 || dx*dx*dx == 0. // XXX TODO: this is ad-hoc protection against infinities in the other case when dx is very small such as 1e-155-- but need a real fix!
                 || XXX_USE_SIMPLE_PROTECTION && Math.abs(dx) < tol)
            {
                if (verboseLevel >= 1) System.out.println("                          dx=0 s=0 case"+(dx!=0.?" (CLOSE ENOUGH)":""));
                // s is zero
                //assert(false); // coverage; remove when hit
                this.sNumerator = 0.;
                this.sDenominator = 1.;
                this.xFocusInWorld = (x0+x1)*.5;
                this.yFocusInWorld = Math.min(y0,y1) - slack*.5;
                this.xFocusDirection = 1.;
                this.yFocusDirection = 0.;
                this.t0 = this.yFocusInWorld - y0; // negative
                this.t1 = y1 - this.yFocusInWorld; // positive
            }
            else
            {
                if (verboseLevel >= 1) System.out.println("                          s finite and nonzero case");
                //assert(false); // coverage; remove when hit

                double L = MyMath.hypot(dx, dy) + slack;

                // Mathematically sqrt(L^2-dy^2)/dx >= 1,
                // and it better be since we're about to take asinhc of it...
                // But if we compute it naively, it might not be.
                // For example:
                //     x0=-3.0390817003387307E-16, y0=-0.5345224838248487, x1=0.0, y1=0.0, slack=1.0690449676496974
                // produces:
                //     dx = 0.36774686989671046
                //     dy = -0.9299259323629877
                //     L = 1.
                //     sqrt(L*L-dy*dy) = 0.3677468698967104
                //     sqrt(L*L-dy*dy)/dx = 0.9999999999999999
                // Bad!
                // So, figure out a better expression for sqrt(L^2-dy^2)/dx
                // that is guaranteed to be >= 1.

                // sqrt(L^2-dy^2)/dx = sqrt((hypot(dx,dy)+slack)^2 - dy^2) / dx
                //                   = sqrt(dx^2+dy^2 + 2*slack*hypot(dx,ty) + slack^2 - dy^2) / dx
                //                   = sqrt(dx^2 + 2*slack*hypot(dx,dy) + slack^2) / dx
                //                   = sqrt(1 + 2*slack*hypot(dx,dy)/dx/dx + (slack/dx)^2)
                //                   = sqrt(1 + 2*slack*hypot(1,dy/dx)/dx + (slack/dx)^2)
                // XXX TODO: make completely bulletproof; I think dy/dx can still overflow if dy>1 and dx very small?
                double L2_minus_dy2 = SQR(dx) + slack*(2*MyMath.hypot(dx,dy) + slack);
                assert_almost_eq(L2_minus_dy2, L*L - dy*dy, 1e-6);
                double sqrt_L2minusdy2 = Math.sqrt(L2_minus_dy2); // not used immediately, used farther down
                assert_ge(sqrt_L2minusdy2, dx);

                /*
                PRINT(dy);
                PRINT(dx);
                PRINT(dy/dx);
                PRINT(MyMath.hypot(1.,dy/dx));
                PRINT(MyMath.hypot(1.,dy/dx)/dx);
                PRINT(SQR(slack/dx));
                PRINT(MyMath.hypot(1.,dy/dx)/dx + SQR(slack/dx));
                PRINT(slack);
                PRINT(slack*MyMath.hypot(1.,dy/dx)/dx + SQR(slack/dx));
                PRINT(2.*slack*MyMath.hypot(1.,dy/dx)/dx + SQR(slack/dx));
                PRINT(1. + 2.*slack*MyMath.hypot(1.,dy/dx)/dx + SQR(slack/dx));
                PRINT(Math.sqrt(1. + 2.*slack*MyMath.hypot(1.,dy/dx)/dx + SQR(slack/dx)));
                */

                double sqrt_L2minusdy2__over_dx = Math.sqrt(1. + 2.*slack*MyMath.hypot(1.,dy/dx)/dx + SQR(slack/dx));
                double sqrt_L2minusdy2__over_dx___naive = Math.sqrt(L*L-dy*dy)/dx;
                if (verboseLevel >= 1) System.out.println("                            sqrt_L2minusdy2__over_dx___naive = "+sqrt_L2minusdy2__over_dx___naive);
                if (verboseLevel >= 1) System.out.println("                            sqrt_L2minusdy2__over_dx = "+sqrt_L2minusdy2__over_dx);
                if (verboseLevel >= 1) System.out.println("                            python or wolframalpha this (naive): sqrt(1 + 2*"+slack+"*hypot(1,"+dy+"/"+dx+")/"+dx+"+("+slack+"/"+dx+")**2)");
                if (verboseLevel >= 1) System.out.println("                            python or wolframalpha this (smart): sqrt((sqrt(("+dx+")**2+("+dy+")**2)+"+slack+")**2 - ("+dy+")**2)/"+dx+"");
                // wolframalpha is being weird-- it refuses to offer more digits if I use hypot instead of sqrt,
                // and it *still* doesn't offer more digits unless I pad the .99999999 with at least one zero.

                // The naive answer is just hopelessly wrong in high-tension cases,
                // so only assert something if it's got some non-negligible slack.
                if (slack >= 1e-3)
                {
                    // naive is known to not be very accurate, so use very coarse tolerance to check for blatant errors
                    if (sqrt_L2minusdy2__over_dx___naive < 1.)
                    {
                        // absolute tolerance
                        assert_almost_eq(sqrt_L2minusdy2__over_dx, sqrt_L2minusdy2__over_dx___naive, 1e-3);
                    }
                    else
                    {
                        // relative tolerance
                        // (XXX SVVP demo3 gets values on order of 3e13 here-- maybe that's a problem?)
                        assert_almost_eq(sqrt_L2minusdy2__over_dx/sqrt_L2minusdy2__over_dx___naive, 1., 1e-3);
                    }
                }


                this.sNumerator = dx;
                this.sDenominator = 2.*asinhc(sqrt_L2minusdy2__over_dx);

                if (this.sNumerator <= this.sDenominator)
                {
                    this.sNumerator /= this.sDenominator;
                    this.sDenominator = 1.;
                }
                else
                {
                    this.sDenominator /= this.sNumerator;
                    this.sNumerator = 1.;
                }

                if (sDenominator == 0.)
                {
                    // s is infinite. it's a straight line.
                    // don't descend into further complication.
                    this.xFocusDirection = x1-x0; // we'll normalize below
                    this.yFocusDirection = y1-y0; // we'll normalize below
                    double temp = MyMath.hypot(this.xFocusDirection, this.yFocusDirection);
                    assert_ne(temp, 0.);
                    this.xFocusDirection /= temp;
                    this.yFocusDirection /= temp;
                    if (y0 <= y1)
                    {
                        this.t0 = 0.;
                        this.t1 = L;
                        this.xFocusInWorld = x0;
                        this.yFocusInWorld = y0;
                    }
                    else
                    {
                        this.t0 = -L;
                        this.t1 = 0.;
                        this.xFocusInWorld = x1;
                        this.yFocusInWorld = y1;
                    }
                }
                else
                {
                    double s = this.sNumerator / this.sDenominator; // XXX not robust, and still used in a couple of places

                    // Start with the canonical focus case (at catenary vertex) and adjust.

                    this.xFocusDirection = 1.;
                    this.yFocusDirection = 0.;

                    //double tMid = .5 * dy * Math.sqrt(1. + 4.*(s*s)/(L2_minus_dy2));
                    double tMid = .5 * dy * Math.hypot(1., + 2.*s/sqrt_L2minusdy2);
                    this.t0 = tMid - L/2.;
                    this.t1 = t0 + L;

                    // If we didn't care about stability:
                    //   this.xFocusInWorld = x0 - s*asinh(t0/s)
                    // XXX wait a minute, why can't we do that?? I'm confused. why is what I have here any better? it's just computing it at the xMid point instead of at x0 I guess? so maybe that's preferable because it's more symmetric?
                    // XXX if so, why not do it for y too?
                    this.xFocusInWorld = (x0+x1)/2.
                                       - s*MyMath.asinh(dy/(2.*s*MyMath.sinh(dx/(2.*s))));
                    //this.xFocusInWorld = x0 - s*MyMath.asinh(t0/s);
                    this.yFocusInWorld = y0 - (Math.hypot(this.t0, s) - s);

                    if (this.t0 > 0. || this.t1 < 0.)
                    {
                        if (verboseLevel >= 1) System.out.println("                          t0,t1 were "+t0+","+t1+"");
                        double tFocusWithRespectToVertex;
                        if (this.t0 > 0.)
                        {
                            // Entire interval is to right of the catenary vertex.
                            // Make x0,y0 the focus.
                            if (verboseLevel >= 1) System.out.println("                          clamping focus to x0,y0");
                            //assert(false); // coverage
                            tFocusWithRespectToVertex = this.t0;
                            this.t0 = 0.;
                            this.t1 = L;
                            this.xFocusInWorld = x0;
                            this.yFocusInWorld = y0;
                        }
                        else
                        {
                            // Entire interval is to left of the catenary vertex.
                            // Make x1,y1 the focus.
                            if (verboseLevel >= 1) System.out.println("                          clamping focus to x1,y1");
                            //assert(false); // coverage
                            tFocusWithRespectToVertex = this.t1; // before changing this.t1
                            this.t0 = -L;
                            this.t1 = 0.;
                            this.xFocusInWorld = x1;
                            this.yFocusInWorld = y1;
                        }

                        // slope is tFocusWithRespectToVertex/s = tFocusWithRespectToVertex*sDenominator / sNumerator.
                        this.xFocusDirection = this.sNumerator; // we'll normalize below
                        this.yFocusDirection = this.sDenominator * tFocusWithRespectToVertex; // we'll normalize below
                        double temp = MyMath.hypot(this.xFocusDirection, this.yFocusDirection);
                        assert_ne(temp, 0.);
                        this.xFocusDirection /= temp;
                        this.yFocusDirection /= temp;
                    }
                    else
                    {
                        if (verboseLevel >= 1) System.out.println("                          focus is the catenary vertex");
                    }
                }
            }
            if (verboseLevel >= 1)
            {
                System.out.println("                          s= "+this.sNumerator+"/"+this.sDenominator+" = "+(this.sNumerator/this.sDenominator));
                System.out.println("                          focusDirection = "+this.xFocusDirection+" "+this.yFocusDirection);
                System.out.println("                          focusInWorld = "+this.xFocusInWorld+" "+this.yFocusInWorld);
                System.out.println("                          t0 = "+this.t0);
                System.out.println("                          t1 = "+this.t1);

            }

            // NOTE: this calls the subclass's assertValid() (because I don't know how to just make it call ours,
            // short of having a differently-named private method-- which might actually be a good idea).
            // So if the subclass is fitting us but has old params that are incompatible with us, it will be bad!
            assertValid();
        }
        catch (Error e)
        {
            // annotate the Error (most likely assertion failure) with the params needed to reproduce the problem
            throw new Error(e.getMessage() + "; fit params: (x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+")");
        }
        if (verboseLevel >= 1) System.out.println("                          this = "+this);
        if (verboseLevel >= 1) System.out.println("                        out Catenary.fit(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+")");
    } // fit


    // Unit-length derivative at time t. 
    public void differentiate(double t,
                              double answer[/*2*/])
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("                        in Catenary.differentiate(t="+t+")");
        assertValid();

        // The following works in all cases:
        //   - s can be 0, finite, or infinity,
        //   - TFocus can be 0, finite, or infinite.

        // T = TFocus + t/s
        //   = TFocusN/TFocusD + t*sD/sN
        //   = (TFocusN*sN + t*sD*TFocusD) / (TFocusD*sN)
        double TFocusNumerator = yFocusDirection;
        double TFocusDenominator = xFocusDirection;
        double TNumerator = TFocusNumerator*sNumerator + t*sDenominator*TFocusDenominator;
        double TDenominator = TFocusDenominator*sNumerator;
        answer[0] = TDenominator;
        answer[1] = TNumerator;
        if (answer[0] == 0. && answer[1] == 0.)
        {
            // This happens at the switchback in the s=0 case: s=0/1, TFocus=0/1, t=0.
            // In this case the answer has some freedom,
            // but should not be progressing leftward.
            // We somewhat-arbitrarily choose it to be rightward-pointing.
            assert(false); // coverage; remove when hit.  (it is hit once in a blue moon in SmoothlyVaryingViewingParameter demo3, currently)
            answer[0] = 1.;
        }
        VecMath.normalize(answer, answer);

        assert(answer[0] >= 0.);
        if (verboseLevel >= 1) System.out.println("                        out Catenary.differentiate(t="+t+"), returning answer="+VecMath.toString(answer));
    } // differentiate

    // Position at time t.
    public void evaluate(double t,
                         double answer[/*2*/])
    {
        int verboseLevel = 0; // 0: nothing, 1: debugging
        if (verboseLevel >= 1) System.out.println("                        in Catenary.evaluate(t="+t+")");
        if (verboseLevel >= 1) System.out.println("                            this = "+this);
        assertValid();
        if (sDenominator == 0.)
        {
            // s is infinity
            if (verboseLevel >= 1) System.out.println("                          slack=0 s=infinity case");
            //assert(false); // coverage; remove when hit.
            answer[0] = xFocusInWorld + t * xFocusDirection;
            answer[1] = yFocusInWorld + t * yFocusDirection;
        }
        else if (sNumerator == 0.)
        {
            // s is 0
            if (verboseLevel >= 1) System.out.println("                          dx=0 s=0 case");
            //assert(false); // coverage; remove when hit.
            answer[0] = xFocusInWorld;
            answer[1] = yFocusInWorld + Math.abs(t);
        }
        else
        {
            if (verboseLevel >= 1) System.out.println("                          s finite and nonzero case");
            // keep in mind: when s<1, we know Tfocus=0, so that can simplify things.
            // conversely, when Tfocus!=0 we know s>=1.
            // i.e. it never happens that s<1 and Tfocus!=0.

            // 0 < s < infinity
            //assert(false); // coverage; remove when hit

            //     x(t) = xFocusInWorld + s*(asinh(TFocus + t/s) - asinh(TFocus))
            //     y(t) = yFocusInWorld + s*(sqrt((TFocus + t/s)^2 + 1) - sqrt(TFocus^2 + 1))
            //          = yFocusInWorld + (sqrt((s*TFocus + t)^2 + s^2) - sqrt((s*TFocus)^2 + s^2))
            //          = yFocusInWorld + (((s*TFocus + t)^2 + s^2) - ((s*TFocus)^2 + s^2))
            //                          / (sqrt((s*TFocus + t)^2 + s^2) + sqrt((s*TFocus)^2 + s^2))
            //          = yFocusInWorld + (2*s*TFocus*t + t^2)
            //                          / (sqrt((s*TFocus + t)^2 + s^2) + sqrt((s*TFocus)^2 + s^2))
            // Where TFocus = slope = yFocusDirection/xFocusDirection.

            double s = sNumerator / sDenominator; // XXX obviously not robust, and still used in a couple of places

            // This should work no matter whether Tfocus is
            // entirely vertical, mainly vertical, mainly horizontal, or entirely horizontal,
            // as long as s is not too huge or infinity. XXX think about that case
            double TFocusNumerator = yFocusDirection;
            double TFocusDenominator = xFocusDirection;

            double TFocus_times_s_numerator = sNumerator * TFocusNumerator;
            double TFocus_times_s_denominator = sDenominator * TFocusDenominator;

            answer[0] = xFocusInWorld + s * MyMath.asinh_difference(TFocusNumerator,TFocusDenominator,
                                                                    t*sDenominator/sNumerator); // t/s

            // XXX I'm currently a muddle about whether we want to be testing horizontalness of focusDirection or of TFocus*s, or some combination. I know I'm not doing it quite right yet.
            //if (SQR(TFocusNumerator) <= TFocusDenominator) // XXX?
            if (SQR(TFocus_times_s_numerator) <= SQR(TFocus_times_s_denominator)) // XXX?
            {
                if (verboseLevel >= 1) System.out.println("                              mostly horizontal");
                // mostly horizontal; Tfocus relatively small (or zero),
                // so we're not subtracting huge numbers.
                // (XXX assuming s not huge... need to think about case s huge)
                //assert(false); // coverage; remove when hit
                double TFocus = TFocusNumerator / TFocusDenominator; // stable XXX?
                double TFocus_times_s = TFocus_times_s_numerator / TFocus_times_s_denominator; // stable XXX?
                answer[1] = yFocusInWorld
                          + (MyMath.hypot(TFocus_times_s+t, s)
                           - MyMath.hypot(TFocus_times_s, s)); // XXX use smart different function? not sure
            }
            else
            {
                if (verboseLevel >= 1) System.out.println("                              mostly vertical");
                // mostly vertical.

                // For the y part:
                // shorthand T=Tfocus
                // Look at the main subexpression:
                double TFocus = TFocusNumerator / TFocusDenominator;
                //     sqrt((TF+t/s)^2+1) - sqrt(TF^2+1)
                //   = (((TF+t/s)^2+1) - (TF^2+1)) / (sqrt((TF+t/s)^2+1) + sqrt(TF^2+1))
                //   = ((TF+t/s)^2 - TF^2) / (sqrt((TF+t/s)^2+1) + sqrt(TF^2+1))
                //   = (2*TF*(t/s)+(t/s)^2) / (sqrt((TF+t/s)^2+1) + sqrt(TF^2+1))
                //   = (2*(t/s) + (t/s)^2/TF) / (sqrt((1+t/s/TF)^2+1/TF^2) + sqrt(1+1/TF^2)) * SIGN(TF)
                // so s times that is:
                //   = (2*t + t^2/s/TF) / (...) * SIGN(TF)
                //   = t*(2 + t/s/TF) / (...) * SIGN(TF)
                // XXX redo this using the second version of y(t) throughout, maybe
                //assert(false); // coverage; remove when hit
                double invTFocus = TFocusDenominator / TFocusNumerator; // stable XXX?
                double TFocus_times_s_inverse = TFocus_times_s_denominator / TFocus_times_s_numerator; // stable XXX?
                answer[1] = yFocusInWorld
                          + (t*(2+t*TFocus_times_s_inverse)
                           / (Math.hypot(1+t*TFocus_times_s_inverse, invTFocus) + Math.hypot(1, invTFocus))
                           * SIGN(yFocusDirection));
            }
        }
        if (verboseLevel >= 1) System.out.println("                        out Catenary.evaluate(t="+t+"), returning answer="+VecMath.toString(answer));
    } // evaluate
    // Arc length integral from focus to t.
    public void integrate(double t,
                          double answer[/*2*/])
    {
        int verboseLevel = 0; // 0: nothing, 1: in/out, 2: more details
        if (verboseLevel >= 1) System.out.println("                                in Catenary.integrate(t="+t+")");
        if (verboseLevel >= 1) System.out.println("                                  this = "+this);

        assertValid();
        if (sDenominator == 0.)
        {
            if (verboseLevel >= 1) System.out.println("                                    slack=0 s=infinity case");
            // s is infinity
            //assert(false); // coverage; remove when hit
            answer[0] = t * (xFocusInWorld + .5*t*xFocusDirection);
            answer[1] = t * (yFocusInWorld + .5*t*yFocusDirection);
        }
        else if (sNumerator == 0.)
        {
            if (verboseLevel >= 1) System.out.println("                                    dx=0 s=0 case");
            // s is 0
            //assert(false); // coverage; remove when hit
            answer[0] = t * xFocusInWorld;
            answer[1] = t * (yFocusInWorld + .5*Math.abs(t));
        }
        else
        {
            if (verboseLevel >= 1) System.out.println("                                    s finite and nonzero case");
            //assert(false); // coverage; remove when hit
            double s = sNumerator / sDenominator; // XXX obviously not robust
            assert(xFocusDirection != 0.);
            double TFocus = yFocusDirection / xFocusDirection; // XXX obviously not robust
            // Recall:
            //     x(t) = xFocusInWorld + s*(asinh(TFocus + t/s) - asinh(TFocus))
            //     y(t) = yFocusInWorld + s*(sqrt((TFocus + t/s)^2 + 1) - sqrt(TFocus^2 + 1))
            // Per wolframalpha:
            //    x part of integral = xFocusInWorld*t + s*((s*TF+t)*asinh(t/s+TF) - t*asinh(TF) - sqrt(s*(s*TF*TF+s+2*t*TF)+t*t))
            //    y part of integral = yFocusInWorld*t + s*( .5 * ((s*TF+t)*sqrt((TF+t/s)^2+1) + s*asinh(TF+t/s) - 2*t*sqrt(TF*TF+1)))
            double TF = TFocus;
            answer[0] = xFocusInWorld*t + s*((s*TF+t)*MyMath.asinh(t/s+TF) - t*MyMath.asinh(TF) - Math.sqrt(s*(s*TF*TF+s+2*t*TF)+t*t));
            answer[1] = yFocusInWorld*t + s*( .5 * ((s*TF+t)*Math.hypot(TF+t/s,1) + s*MyMath.asinh(TF+t/s) - 2*t*Math.hypot(TF,1)));
        }
        if (verboseLevel >= 1) System.out.println("                                out Catenary.integrate(t="+t+"), returning "+VecMath.toString(answer));
    } // integrate

    // subclasses don't need to override this--
    // it's just a convenience function
    // that calls the subclass's integrate() anyway.
    public void integrate(double t0, // not necessarily this.t0
                          double t1, // not necessarily this.t1
                          double answer[/*2*/])
    {
        int verboseLevel = 0; // 0: nothing, 1: in/out, 2: more details
        if (verboseLevel >= 1) System.out.println("                        in Catenary.integrate(t0="+t0+", t1="+t1+")");
        integrate(t0, answer); // note this might be a subclass's integrate
        double answer0x = answer[0];
        double answer0y = answer[1];
        integrate(t1, answer); // note this might be a subclass's integrate
        answer[0] -= answer0x;
        answer[1] -= answer0y;
        if (verboseLevel >= 1) System.out.println("                        out Catenary.integrate(t0="+t0+", t1="+t1+"), returning answer="+VecMath.toString(answer));
    } // integrate

    @Override public String toString()
    {
       StringBuffer sb = new StringBuffer();
       sb.append("{");
       sb.append("s=");
       sb.append(sNumerator);
       sb.append("/");
       sb.append(sDenominator);
       sb.append(", focusInWorld = ");
       sb.append(xFocusInWorld);
       sb.append(",");
       sb.append(yFocusInWorld);
       sb.append(", focusDirection =");
       sb.append(xFocusDirection);
       sb.append(",");
       sb.append(yFocusDirection);
       sb.append(", ");
       sb.append("t0=");
       sb.append(t0);
       sb.append(", ");
       sb.append("t1=");
       sb.append(t1);
       sb.append("}");
       return sb.toString();
    }

    // Catenary always has non-negative scale,
    // and its fit() requires x0<=x1.
    // This class has no such restriction on x0,x1.
    // The catenary still hangs downward but may be left-right flipped.
    public static class FlippedMaybe extends Catenary
    {
        public boolean leftRightFlipped;
        @Override public void fit(double x0, double y0,
                                  double x1, double y1,
                                  double slack,
                                  int verboseLevel)
        {
            if (x1 < x0)
            {
                // initialize our members *before* calling fit,
                // in case fit() calls isValid() which actually calls subclass's
                this.leftRightFlipped = true;
                super.fit(-x0,y0, -x1,y1, slack, verboseLevel);
            }
            else
            {
                // initialize our members *before* calling fit,
                // in case fit() calls isValid() which actually calls subclass's
                this.leftRightFlipped = false;
                super.fit(x0,y0, x1,y1, slack, verboseLevel);
            }
            //PRINT(this.leftRightFlipped);
        }
        @Override public void differentiate(double t,
                                            double answer[/*2*/])
        {
            super.differentiate(t, answer);
            if (this.leftRightFlipped)
                answer[0] *= -1.;
        }
        @Override public void evaluate(double t,
                                       double answer[/*2*/])
        {
            super.evaluate(t, answer);
            if (this.leftRightFlipped)
                answer[0] *= -1.;
        }
        @Override public void integrate(double t,
                                        double answer[/*2*/])
        {
            super.integrate(t, answer);
            if (this.leftRightFlipped)
                answer[0] *= -1.;
        }
        @Override public String toString()
        {
           StringBuffer sb = new StringBuffer();
           sb.append("{");
           sb.append("flipped=");
           sb.append(this.leftRightFlipped);
           sb.append(", ");
           sb.append(super.toString());
           sb.append("}");
           return sb.toString();
        }
    } // class FlippedMaybe





    //======================================================================================
    // XXX move asinhc to MyMath? note it's conceptually very similar to glog and lambertw.
    //
    // The good news is, Newton seems to work well in all cases:
    //   f(x) = sinh(x)/x-y
    //   f'(x) = (x*math.cosh(x)-sinh(x))/x**2
    //   xNext = x - f(x)/f'(x)
    //         = x - (sinh(x)/x-y)/((x*cosh(x)-sinh(x))/x**2)
    // But the bad news is, when done, it seems to get in cycles of 5 so we'd need to retain a lot of values
    // if our stopping criterion is seeing a repeat.
    // But the good news is, after one iteration, we get a value that's definitely too high,
    // after which it's all downhill, so we can stop as soon as it didn't decrease.
    //
    /*
    asinhc_by_newton(y) = y<1. ? crash_in_asinhc_by_newton(1) : y==1. ? 0. : asinhc_by_newton_recurse0(y, Asinh(y))
      // this gets called with an initial guess x that may be (or must be?) too small.
      asinhc_by_newton_recurse0(y, x)   = asinhc_by_newton_recurse1(y, x - (sinh(x)/x-y)/((x*cosh(x)-sinh(x))/x**2))
        // this gets called with x that's definitely bigger than the answer.
        asinhc_by_newton_recurse1(y, x) = asinhc_by_newton_recurse (y, x - (sinh(x)/x-y)/((x*cosh(x)-sinh(x))/x**2), x)
          // this gets called with x<xPrev, unless converged.
          asinhc_by_newton_recurse(y, x, xPrev) = x>=xPrev ? (x+xPrev)/2. : asinhc_by_newton_recurse_helper(y, x, cosh(x), sinh(x))
          asinhc_by_newton_recurse_helper(y, x, cosh_x, sinh_x) = asinhc_by_newton_recurse(y, x - (sinh_x/x-y)/((x*cosh_x-sinh_x)/x**2), x)
          */
    private static double asinhc_by_binary_search(double y)
    {
        if (y <= 1.)
        {
            if (y == 1.)
                return 0.;
            else
                return Double.NaN; // XXX or 0 ? that will correctly handle slight roundoff error in input, but it won't catch blatant errors. in fact, maybe should throw?  not sure
        }
        double lo = 0.;
        double hi = 1e3; // XXX should be more principled, this is plenty for double though
        while (true)
        {
            double mid = (lo + hi) / 2;
            if (mid == lo || mid == hi)
                return mid;
            if (MyMath.sinh(mid)/mid < y) // mid is too low
                lo = mid;
            else
                hi = mid;
        }
    }
    private static double asinhc_by_newton(double y)
    {
        if (y <= 1.)
        {
            if (y == 1.)
                return 0.;
            else
                return Double.NaN; // XXX or 0 ? that will correctly handle slight roundoff error in input, but it won't catch blatant errors. in fact, maybe should throw?  not sure
        }
        // initial guess that may be too small.
        //double x = MyMath.asinh(y); // I think this *must* be too small? not sure
        // very rough eyeball fit:
        // gnuplot> set samples 10000
        // gnuplot> q = 10
        // gnuplot> plot [-q:q] [-q:q] sinh(x)/x, cosh(x/1.5), cosh(x/2.5)**2
        // gnuplot> q = 100
        // gnuplot> replot
        // therefore, roughly:
        //     y = sinhc(x) = cosh(x/2.5)**2
        //     x = 2.5*acosh(sqrt(y))
        // Let's do this in a principled way: using gnuplot's fit function.
        // First dump some samples (somewhat ad-hoc):
        /*
        gnuplot << EOF > DATA.txt  # XXX not right yet, had to paste results manually
sinhc(x) = sinh(x)/x
print 0, 1
print 1, sinhc(1)
print 1.001, sinhc(1.001)
print 1.01, sinhc(1.01)
print 1.1, sinhc(1.1)
print 2, sinhc(2)
print 5, sinhc(5)
EOF
            f(x) = cosh(x/A)**B
            A = 1 # initial guess
            B = 1 #  initial guess
            FIT_LIMIT = 1e-5 # default
            FIT_LIMIT = 1e-13
            #FIT_LIMIT = 1e-14 # The maximum lambda = 1.000000e+20 was exceeded. Fit stopped.
            fit f(x) "DATA.txt" using 1:2 via A,B
            print A, B
            print sprintf("%.17g %.17g", A, B)
            q = 20
            q = 2
            set samples 1001
            plot [-q:q] [-q:q] "DATA.txt" with points, cosh(x/A)**B

        output is:
            2.4536756011708301 1.9812429870098702
        */
        //                    
        double x = 2.4536756011708301 * MyMath.acosh(Math.pow(y, 1./1.9812429870098702));

        // Actually maybe better:
        /*
            f(x) = (cosh(x/A)-1.)**B+1.
            A = 1 # initial guess
            B = 1 #  initial guess
            FIT_LIMIT = 1e-5 # default
            FIT_LIMIT = 1e-8
            #FIT_LIMIT = 1e-9 # "The maximum lambda = 1.000000e+20 was exceeded. Fit stopped."
            fit f(x) "DATA.txt" using 1:2 via A,B
            print A,B
            print sprintf("%.17g %.17g", A, B)
            q = 20
            q = 2
            set samples 1001
            plot [-q:q] [-q:q] "DATA.txt" with points, cosh(x/A)**B
            1.62278016560655 1.14541126805886
        */
        // Hmm actually no, that sucks.  Fooey.  Why??
        // Maybe see: http://stackoverflow.com/questions/11073925/gnuplot-behaves-oddly-in-polynomial-fit-why-is-that


        // iterate once to get something that's definitely bigger than the answer.
        {
            double sinh_x = MyMath.sinh(x);
            x -= (sinh_x/x-y)/((x*MyMath.cosh(x)-sinh_x)/(x*x));
        }
        double xPrev = Double.POSITIVE_INFINITY;
        while (true)
        {
            if (!(x < xPrev))
                return (x+xPrev)*.5;
            xPrev = x;
            double sinh_x = MyMath.sinh(x);
            x -= (sinh_x/x-y)/((x*MyMath.cosh(x)-sinh_x))/(x*x);
        }
    }

    public static double asinhc(double y)
    {
        // XXX TODO: something wrong with newton... ? gives wrong answer on y=3.4081082040601114
        //return asinhc_by_newton(y);
        return asinhc_by_binary_search(y);
    }
    //======================================================================================

    public static void confidenceTest()
    {
        System.out.println("        in Catenary.confidenceTest");
        int testVerboseLevel = 2; // 0 = nothing, 1 = basic outer flow, 2 = dots at loop iterations, 3 = trace all loop iterations

        if (true)
        {
            // Some problematic cases dumped from SmoothlyVaryingViewingParameter demo3.
            // (as of this writing, only loudly problematic if XXX_USE_SIMPLE_PROTECTION is false).
            String inputs[] = {
                // s is infinity
                "x0=-0.9999999999999999, y0=0.0, x1=0.0, y1=0.0, slack=9.813077866773593E-17",

                "x0=-1.0, y0=1.7225464241988333E-16, x1=0.0, y1=0.0, slack=8.326672684688674E-17",
                "x0=-3.0390817003387307E-16, y0=-0.5345224838248487, x1=0.0, y1=0.0, slack=1.0690449676496974",
                "x0=-1.0, y0=6.123233995736769E-17, x1=0.0, y1=0.0, slack=4.852917047803606E-17",
                "x0=-0.36774686989671046, y0=0.9299259323629877, x1=0.0, y1=0.0, slack=1.790824923772195E-16",
                "x0=-7.216449660063518E-16, y0=0.9999999999999999, x1=0.0, y1=0.0, slack=2.220446049250313E-16",
                "x0=-2.220446049250313E-16, y0=1.0, x1=0.0, y1=-0.0, slack=1.6653345369377348E-16",
                "x0=-0.9999999999999998, y0=0.0, x1=0.0, y1=0.0, slack=1.1102230246251565E-16",

                // all these are cases of the same: challenging because dx is very small
                "x0=-1.464441778069256E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.060588577029181835",
                "x0=-5.857767112277024E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.2828366550650318",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.1282300476001653",
                "x0=-5.857767112277024E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.2804306804431736",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.12742264756872818",
                "x0=-1.464441778069256E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.06188098582262641",
                "x0=-5.857767112277024E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.30853427961644925",
                "x0=-1.464441778069256E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.02841626318186087",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.12928801415700492",
                "x0=-5.857767112277024E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.2811859219273672",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.1309864079768968",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.1291281594450318",
                "x0=-1.464441778069256E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.02909487324188506",
                "x0=-5.857767112277024E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.28299187284744437",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.13415390937736354",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.13280296022399296",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.12815595714758168",
                "x0=-2.928883556138512E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.13423964743996727",
                "x0=-5.857767112277024E-155, y0=-1.0, x1=0.0, y1=0.0, slack=0.31228142318407365",
                "x0=-1.4644417780692564E-155, y0=-1.0000000000000002, x1=0.0, y1=0.0, slack=0.028910593597643548",
                "x0=-5.8577671122770255E-155, y0=-1.0000000000000002, x1=0.0, y1=0.0, slack=0.2844590234309425",
            };
            for (int iInput = 0; iInput < inputs.length; ++iInput)
            {
                System.out.println("      fit test case "+iInput+"/"+inputs.length+":");
                String tokens[] = inputs[iInput].split(", "); // since java 1.4; okay whatever
                double x0 = Double.parseDouble(tokens[0].substring(3));
                double y0 = Double.parseDouble(tokens[1].substring(3));
                double x1 = Double.parseDouble(tokens[2].substring(3));
                double y1 = Double.parseDouble(tokens[3].substring(3));
                double slack = Double.parseDouble(tokens[4].substring(6));
                assert(("x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack).equals(inputs[iInput]));
                Catenary catenary = new Catenary();
                int fitVerboseLevel = 1;
                XXX_USE_SIMPLE_PROTECTION = false; // so we really exercise this case
                catenary.fit(x0, y0, x1, y1, slack, fitVerboseLevel);
                PRINT(catenary);
            }

            if (false)
            {
                System.out.println("        out Catenary.confidence test (returning prematurely!)");
                return;
            }
        }

        //
        // Do nonzero non-infinite cases first, for simplicity.
        // I grind my gears if I try to think about the degen cases too soon.
        //
        double deltas[][] = {
            {0.,0.},
            {-10., 100.},
        };
        for (int iDelta = 0; iDelta < deltas.length; ++iDelta)
        {
            double delta[] = deltas[iDelta];
            double xDelta = delta[0];
            double yDelta = delta[1];

            //double scales[][] = {{1.,1.}}; // wimpy
            //double scales[][] = {{1.,1.},  {9.,10.}, {11.,10.}}; // wimpy
            double scales[][] = {{1.,1.},  {1.,10.}, {9.,10.}, {11.,10.}, {10.,1.}}; // got this far

            //double intervalSizesOnCanonical[] = {1.}; // wimpy
            double intervalSizesOnCanonical[] = {1.,  .1, .5, .9, 1.1}; // wimpy    got this far
            //double intervalSizesOnCanonical[] = {1.,  .1, .5, .9, 1.1, 2.}; // wimpy (but not robust enough to succeed yet)
            //double intervalSizesOnCanonical[] = {1.,  0., .1, .5, .9, 1.1, 2.}; // wimpy
            //double intervalSizesOnCanonical[] = {1.,  0., .1, .5, .9, 1.1, 2., 5.};

            for (int iScale = 0; iScale < scales.length; ++iScale)
            {
                double sNumerator = scales[iScale][0];
                double sDenominator = scales[iScale][1];
                double s = sNumerator / sDenominator;
                for (int iIntervalSize = 0; iIntervalSize < intervalSizesOnCanonical.length; ++iIntervalSize)
                {
                    double intervalSizeOnCanonical = intervalSizesOnCanonical[iIntervalSize];
                    double incr = MAX(intervalSizeOnCanonical, .1);
                    PRINT(incr);
                    for (double X0 = -5.*incr;
                         X0+intervalSizeOnCanonical <= 5.*incr;
                         X0 += .5*incr)
                    {
                        OUT("==================");
                        double X1 = X0 + intervalSizeOnCanonical;
                        double Y0 = MyMath.cosh(X0);
                        double Y1 = MyMath.cosh(X1);
                        double T0 = MyMath.sinh(X0);
                        double T1 = MyMath.sinh(X1);
                        double T = LERP(T0, T1, 1./3.); // arbitrary sample point 1/3 of the way from start to end
                        double X = MyMath.asinh(T);
                        double Y = MyMath.hypot(T, 1);
                        double SlackNaive = (T1-T0) - MyMath.hypot(X1-X0, Y1-Y0);
                        // Note that slack computed in the above way isn't very accurate, especially when near zero,
                        // since it's the difference of two numbers that are possibly very large and
                        // close to each other compared to their size.
                        // Can we make it accurate??
                        //    Slack = (T1-T0) - sqrt((X1-X0)^2 + (Y1-Y0)^2)
                        //          = (sinh(X1)-sinh(X0)) - sqrt((X1-X0)^2 + (cosh(X1)-cosh(X0))^2)
                        //          = ((sinh(X1)-sinh(X0))^2 - ((X1-X0)^2 + (cosh(X1)-cosh(X0))^2)) / (((sinh(X1)-sinh(X0)) + sqrt((X1-X0)^2 + (cosh(X1)-cosh(X0))^2))
                        //          = (sinh(X1)^2 + sinh(X0)^2 - 2*sinh(X1)*sinh(X0) - (X1-X0)^2 - cosh(X1)^2 - cosh(X0)^2 + 2*cosh(X1)*cosh(X0)) / (((sinh(X1)-sinh(X0)) + sqrt((X1-X0)^2 + (cosh(X1)-cosh(X0))^2))
                        // using cosh-sinh==1:
                        //          = (-2 - 2*sinh(X1)*sinh(X0) - (X1-X0)^2 + 2*cosh(X1)*cosh(X0)) / ((sinh(X1)-sinh(X0)) + sqrt((X1-X0)^2 + (cosh(X1)-cosh(X0))^2))
                        // using cosh(a)cosh(b)-sin(a)cosh(b) = cosh(a-b)
                        //          = (-2 - (X1-X0)^2 + 2*cosh(X1-X0)) / ((sinh(X1)-sinh(X0)) + sqrt((X1-X0)^2 + (cosh(X1)-cosh(X0))^2))
                        //          = (2*coshm1(X1-X0) - (X1-X0)^2) / ((sinh(X1)-sinh(X0)) + sqrt((X1-X0)^2 + (cosh(X1)-cosh(X0))^2))
                        double Slack = ((2*MyMath.coshm1(intervalSizeOnCanonical)
                                       - SQR(intervalSizeOnCanonical)))
                                     / (MyMath.sinh_difference(X0,1., intervalSizeOnCanonical)
                                      + MyMath.hypot(intervalSizeOnCanonical,
                                                     MyMath.cosh_difference(X0,1., intervalSizeOnCanonical)));
                        // TODO: can still do better when intervalSizeOnCanonical is small, I think: the 2*coshm1(x) cancels with x^2 when x is small.
                        // for first test case: in python or wolframalpha: (sinh(5)-sinh(4)) - sqrt((5-4)**2 + (cosh(5)-cosh(4))**2))
                        PRINT(SlackNaive);
                        PRINT(Slack+0000); // pad to line up

                        PRINTVEC(delta);
                        PRINT(s);
                        PRINT(intervalSizeOnCanonical);
                        PRINT(X0);
                        PRINT(X1);
                        PRINT(Y0);
                        PRINT(Y1);
                        PRINT(T0);
                        PRINT(T1);
                        PRINT(Slack);
                        PRINT(T);
                        PRINT(X);
                        PRINT(Y);

                        double x0 = s*X0 + xDelta;
                        double x1 = s*X1 + xDelta;
                        double y0 = s*Y0 + yDelta;
                        double y1 = s*Y1 + yDelta;
                        double x = s*X + xDelta;
                        double y = s*Y + yDelta;
                        double slack = s * Slack;

                        PRINT(x0);
                        PRINT(x1);
                        PRINT(y0);
                        PRINT(y1);
                        PRINT(x);
                        PRINT(y);
                        PRINT(slack);

                        int fitVerboseLevel = 0;
                        Catenary catenary = new Catenary();
                        catenary.fit(x0,y0,
                                     x1,y1,
                                     slack,
                                     fitVerboseLevel);
                        PRINT(catenary);
                        double t = LERP(catenary.t0, catenary.t1, 1./3.);
                        //double tol = 1e-12;
                        double tol = 1e-5; // XXX really big! make this smaller, like 1e-12, when I get things numerically better

                        if (true)
                        {
                            //
                            // Test evaluate
                            //
                            double evaluated[] = new double[2];

                            catenary.evaluate(catenary.t0, evaluated);
                            //PRINTVEC(evaluated);
                            assert_almost_eq(evaluated[0], x0, tol);
                            assert_almost_eq(evaluated[1], y0, tol);

                            catenary.evaluate(catenary.t1, evaluated);
                            //PRINTVEC(evaluated);
                            assert_almost_eq(evaluated[0], x1, tol);
                            assert_almost_eq(evaluated[1], y1, tol);

                            catenary.evaluate(t, evaluated);
                            //PRINTVEC(evaluated);
                            assert_almost_eq(evaluated[0], x, tol);
                            assert_almost_eq(evaluated[1], y, tol);
                        }

                        if (true)
                        {
                            //
                            // Test differentiate.
                            // Derivative of (X,Y)={asinh(T),sqrt(T^2+1)}
                            // is {1/sqrt(T^2+1), T/sqrt(T^2+1)} = {1/Y, t/Y},
                            // which should be unit length.
                            // And it should be exactly that when scaled too,
                            // since we're always parametrizing by arc length.
                            //
                            double derivative[] = new double[2];

                            catenary.differentiate(catenary.t0, derivative);
                            assert_almost_eq(VecMath.norm(derivative), 1., tol);
                            assert_almost_eq(derivative[0], 1./Y0, tol);
                            assert_almost_eq(derivative[1], T0/Y0, tol);

                            catenary.differentiate(catenary.t1, derivative);
                            assert_almost_eq(VecMath.norm(derivative), 1., tol);
                            assert_almost_eq(derivative[0], 1./Y1, tol);
                            assert_almost_eq(derivative[1], T1/Y1, tol);

                            catenary.differentiate(t, derivative);
                            assert_almost_eq(VecMath.norm(derivative), 1., tol);
                            assert_almost_eq(derivative[0], 1./Y, tol);
                            assert_almost_eq(derivative[1], T/Y, tol);
                        }

                        if (true)
                        {
                            //
                            // Test integrate.
                            // Integral of (X,Y)=asinh(T),sqrt(T^2+1)
                            // is {T*asinh(T) - sqrt(T^2+1), (sqrt(T^2+1)*T + asinh(T))/2}
                            //  = {T*X - Y, (T*Y + X)/2}
                            // Integral of (x,y)=(s*asinh(t/s), sqrt(t^2+s^2))
                            // is (s*(t*asinh(t/s)-sqrt(t^2+s^2)), 1/2(t*sqrt(t^2+s^2) + s^2 log(sqrt(t^2+s^2)+t)))
                            //  = (s*(t*X-y),                      1/2(t*y + s^2 log(y+t))
                            // And if we add in xDelta,yDelta,
                            // that adds t*xDelta,t*yDelta to the integral.
                            //
                            // But the above t,x,y are measured from the catenary vertex. I.e. they are just s*T,s*X,s*Y.
                            double integral[] = new double[2];

                            catenary.integrate(catenary.t0, catenary.t0, integral);
                            PRINTVEC(integral);
                            assert_eq(integral[0], 0.);
                            assert_eq(integral[1], 0.);

                            catenary.integrate(catenary.t0, catenary.t1, integral);
                            PRINTVEC(integral);
                            assert_almost_eq(integral[0], s*(s*T1*X1 - s*Y1)
                                                        - s*(s*T0*X0 - s*Y0)
                                                        + (catenary.t1-catenary.t0)*xDelta, tol);
                            assert_almost_eq(integral[1], .5*(s*T1*s*Y1 + s*s*Math.log(s*Y1+s*T1))
                                                        - .5*(s*T0*s*Y0 + s*s*Math.log(s*Y0+s*T0))
                                                        + (catenary.t1-catenary.t0)*yDelta, tol);

                            catenary.integrate(catenary.t0, t, integral);
                            PRINTVEC(integral);
                            assert_almost_eq(integral[0], s*(s*T*X - s*Y)
                                                        - s*(s*T0*X0 - s*Y0)
                                                        + (t-catenary.t0)*xDelta, tol);
                            assert_almost_eq(integral[1], .5*(s*T*s*Y + s*s*Math.log(s*Y+s*T))
                                                        - .5*(s*T0*s*Y0 + s*s*Math.log(s*Y0+s*T0))
                                                        + (t-catenary.t0)*yDelta, tol);
                        }
                        if (false)
                        {
                            System.out.println("        out Catenary.confidence test (returning prematurely!)");
                            return;
                        }
                    } // for X0
                } // for iIntervalSize
            } // for iScale
        } // for iDelta
        System.out.println("        out Catenary.confidenceTest");
    } // confidenceTest

    public static void main(String args[])
    {
        System.out.println("    in Catenary.main");

        confidenceTest();

        System.out.println("    out Catenary.main");
    } // main

} // private static class Catenary
