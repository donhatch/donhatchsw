/* vim: set filetype=java: */
package com.donhatchsw.util;
#include "macros.h" 


/* WORK IN PROGRESS */
public class CatenaryRotated extends Catenary.FlippedMaybe
{
    public double cosRotation;
    public double sinRotation;

    @Override public void assertValid()
    {
        super.assertValid();
        assert(MyMath.hypot(cosRotation, sinRotation) == 1.); // XXX need tolerance... I think?
    }

    // Position at time t.
    @Override public void evaluate(double t,
                                   double answer[/*2*/])
    {
        super.evaluate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
    }
    // Arc length integral from focus to t.
    @Override public void integrate(double t,
                                    double answer[/*2*/])
    {
        super.integrate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
    }
    /**
    * Set members to be the parameters of the catenary
    * passing through points (x0,y0),(x1,y1)
    * with given moment (i.e. integral with respect to arc length).
    * Caveat: this is done numerically.
    * In general there may be 1 or 2 solutions;
    * if there are 2 solutions, this function may find one of them,
    * or it may fail to converge.
    * If the function is not 1-to-1 in a neighborhood of the solution,
    * it will fail to converge.
    * If it fails to converge, [XXX what?] is thrown.
    * XXX use current contents as initial guess?
    */
    public void fitFromMoment(double x0, double y0,
                              double x1, double y1,
                              double xMoment, double yMoment)
    {
        int verboseLevel = 0; // XXX think about what we want here. make this a parameter?
        int fitVerboseLevel = 0;
        com.donhatchsw.compat.ArrayList newtonPath = null; // XXX think about what we want here.  make this a parameter?

        double dist = MyMath.hypot(y1-y0, x1-x0);
        double desiredMoment[] = {xMoment, yMoment};

        // Represent a solution by polar coords slack,downAngle,
        // converted to rectangular coords x,y:
        //  x = slack * cos(downAngle)
        //  y = slack * sin(downAngle)
        // We will do a numeric solve for x,y.
        final int verboseLevelFinal = verboseLevel;
        final int fitVerboseLevelFinal = fitVerboseLevel;
        final com.donhatchsw.compat.ArrayList newtonPathFinal = newtonPath;
        final boolean inJ[] = {false};
        final double x0final = x0;
        final double y0final = y0;
        final double x1final = x1;
        final double y1final = y1;

        NewtonSolver.Fun fun = new NewtonSolver.Fun() {
            @Override public double[] f(double xy[])
            {
                if (verboseLevelFinal >= 2) System.out.println("                in f(xy = "+Arrays.toStringCompact(xy)+")");

                // use self as scratch catenary
                CatenaryRotated self = CatenaryRotated.this;
                self.fitFromRectangularCoords(x0final,y0final, x1final,y1final, xy[0], xy[1], fitVerboseLevelFinal);

                double integral[] = new double[2]; // XXX wtf? change NewtonSolver so it doesn't require allocating a new thing each time
                self.integrate(self.t0, self.t1, integral);

                if (!inJ[0] && newtonPathFinal != null)
                {
                    newtonPathFinal.add(new double[][] {VecMath.copyvec(xy), VecMath.copyvec(integral)});
                }
                if (verboseLevelFinal >= 2) System.out.println("                out f(xy = "+Arrays.toStringCompact(xy)+"), returning integral="+Arrays.toStringCompact(integral));
                return integral;
            }
            @Override public double[][] J(double xy[], double fxy[])
            {
                if (verboseLevelFinal >= 2) System.out.println("            in J");
                double[][] answer = null;
                inJ[0] = true;
                try
                {
                    answer = super.J(xy, fxy);
                }
                finally
                {
                    inJ[0] = false; // executed even on the way out of a throw
                }
                if (verboseLevelFinal >= 2) PRINTMAT(answer);
                if (verboseLevelFinal >= 2) System.out.println("            out J");
                return answer;
            }
        };

        // Make an initial guess-- this gets it in the correct upper or lower
        // half-plane, but is otherwise very rough.
        double xMomentIfZeroSlack = (x0+x1)*.5 * dist;
        double yMomentIfZeroSlack = (y0+y1)*.5 * dist;
        double xInitialGuess = xMoment - xMomentIfZeroSlack;
        double yInitialGuess = yMoment - yMomentIfZeroSlack;
        double xyAnswer[] = {xInitialGuess, yInitialGuess};

        double stepScale = 1.;
        //double stepScale = .1; // smaller stepScale makes it slower but more likely to converge
        NewtonSolver.solve(xyAnswer,
                           desiredMoment,
                           fun,
                           1000,
                           stepScale);

        this.fitFromRectangularCoords(x0,y0, x1,y1, xyAnswer[0], xyAnswer[1], fitVerboseLevelFinal);
    } // fit


    private void fitFromRectangularCoords(double x0, double y0,
                                          double x1, double y1,
                                          double x, double y, // slack,downAngle in rectangular coords
                                          int verboseLevel)
    {
        if (verboseLevel >= 1) System.out.println("                in CatenaryRotated.fitFromRectangularCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", x="+x+" y="+y+")");
        double slack = MyMath.hypot(x, y);
        double downAngle = Math.atan2(y, x);
        double cosDownAngle = Math.cos(downAngle);
        double sinDownAngle = Math.sin(downAngle);
        // note cosDownAngle,sinDownAngle are just x,y normalized, robustly.
        // if I had a robust normalization function that I trusted, I'd use that instead.
        this.fitFromPolarCoords(x0,y0, x1,y1, slack, cosDownAngle, sinDownAngle, verboseLevel);
        if (verboseLevel >= 1) System.out.println("                out CatenaryRotated.fitFromRectangularCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", x="+x+" y="+y+")");
    } // fitFromRectangularCoords

    private void fitFromPolarCoords(double x0, double y0,
                                    double x1, double y1,
                                    double slack,
                                    double cosDownAngle,
                                    double sinDownAngle,
                                    int verboseLevel)
    {
        if (verboseLevel >= 1) System.out.println("                    in CatenaryRotated.fitFromPolarCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+" c="+cosDownAngle+" s="+sinDownAngle+")");
        // rotation = downAngle - (-pi/2)
        this.cosRotation = -sinDownAngle;
        this.sinRotation = cosDownAngle;
        double x0Unrotated = xPartOfUnrotated(this.cosRotation, this.sinRotation, x0, y0);
        double y0Unrotated = yPartOfUnrotated(this.cosRotation, this.sinRotation, x0, y0);
        double x1Unrotated = xPartOfUnrotated(this.cosRotation, this.sinRotation, x1, y1);
        double y1Unrotated = yPartOfUnrotated(this.cosRotation, this.sinRotation, x1, y1);
        super.fit(x0Unrotated, y0Unrotated, 
                  x1Unrotated, y1Unrotated,
                  slack);
        if (verboseLevel >= 1) System.out.println("                    out CatenaryRotated.fitFromPolarCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+" c="+cosDownAngle+" s="+sinDownAngle+")");
    } // fitFromPolarCoords

    private static final double xPartOfRotated(double cosRotation, double sinRotation, double x, double y)
    {
        return cosRotation * x - sinRotation * y;
    }
    private static final double yPartOfRotated(double cosRotation, double sinRotation, double x, double y)
    {
        return sinRotation * x + cosRotation * y;
    }
    private static final double xPartOfUnrotated(double cosRotation, double sinRotation, double x, double y)
    {
        return cosRotation * x + sinRotation * y;
    }
    private static final double yPartOfUnrotated(double cosRotation, double sinRotation, double x, double y)
    {
        return -sinRotation * x + cosRotation * y;
    }
    private static final void rotate(double cosRotation, double sinRotation, double x, double y, double answer[/*2*/])
    {
        answer[0] = xPartOfRotated(cosRotation, sinRotation, x, y);
        answer[1] = yPartOfRotated(cosRotation, sinRotation, x, y);
    }
    private static final void unRotate(double cosRotation, double sinRotation, double x, double y, double answer[/*2*/])
    {
        answer[0] = xPartOfUnrotated(cosRotation, sinRotation, x, y);
        answer[1] = yPartOfUnrotated(cosRotation, sinRotation, x, y);
    }



    // XXX phase this out, moving to pure catenary routines... I think?
    // XXX start by making private so SmoothlyVaryingViewingParameter can't see it
    // A catenary is a scaled rotated translated cosh.
    // Path-length integrate from v0 to either v1, or to a length of maxLengthToIntegrate,
    // which ever comes first.
    // Answer gets put into answer. The function return value is the arc length.
    // vFinal is the point that the integral went to (either v1, or the point at distance maxLengthToIntegrate along the curve).
    public static double integralOfCatenaryWithEndpointsRectangular(double v0[/*2*/],
                                                                     double v1[/*2*/],
                                                                     double x, double y, // slack,downAngle in rectangular coords
                                                                     double maxLengthToIntegrate,
                                                                     double answer[/*2*/],
                                                                     double vFinal[/*2*/])
    {
        int debugLevel = 0; // 0: nothing, 1: in/out, 2: a bit more
        int fitVerboseLevel = 2;
        if (debugLevel >= 1) System.out.println("            in integralOfCatenaryWithEndpointsRectangular");
        if (debugLevel >= 2) System.out.println("              v0 = "+VecMath.toString(v0));
        if (debugLevel >= 2) System.out.println("              v1 = "+VecMath.toString(v1));
        if (debugLevel >= 2) System.out.println("              x = "+x+" y = "+y);
        if (debugLevel >= 2) System.out.println("              maxLengthToIntegrate = "+maxLengthToIntegrate);

        if (true)
        {
            CatenaryRotated catenaryRotated = new CatenaryRotated();
            catenaryRotated.fitFromRectangularCoords(v0[0], v0[1], v1[0], v1[1], x, y, fitVerboseLevel);
            double t0 = catenaryRotated.t0;
            double t1 = catenaryRotated.t1;
            double arcLength = t1 - t0;
            if (maxLengthToIntegrate < arcLength)
            {
                if (debugLevel >= 2) System.out.println("                  clamping! = ");
                arcLength = maxLengthToIntegrate;
                t1 = t0 + maxLengthToIntegrate;
            }
            catenaryRotated.integrate(t0, t1, answer);
            if (vFinal != null)
                catenaryRotated.evaluate(t1, vFinal);
            if (debugLevel >= 1) System.out.println("            out integralOfCatenaryWithEndpointsRectangular, returning arcLength="+arcLength);
            return arcLength;
        }

        if (true)
        {
            double slack = MyMath.hypot(x, y);
            double downAngle = Math.atan2(y, x);

            if (debugLevel >= 2) System.out.println("              slack = "+slack);
            if (debugLevel >= 2) System.out.println("              downAngle = "+downAngle+" = "+RTOD(downAngle)+"deg");

            if (slack*slack == 0.) // XXX rough heuristic
            {
                // It's just a segment; return its integral
                double length = VecMath.dist(v0, v1);
                if (maxLengthToIntegrate < length)
                {
                    double wayPoint[] = VecMath.lerp(v0, v1, maxLengthToIntegrate/length);
                    VecMath.sxvpsxv(answer,
                                    maxLengthToIntegrate*.5, v0,
                                    maxLengthToIntegrate*.5, wayPoint);
                    if (vFinal != null)
                        VecMath.copyvec(vFinal, wayPoint);
                }
                else
                {
                    VecMath.sxvpsxv(answer,
                                    length*.5, v0,
                                    length*.5, v1);
                    if (vFinal != null)
                        VecMath.copyvec(vFinal, v1);
                }
                if (debugLevel >= 1) System.out.println("            out integralOfCatenaryWithEndpointsRectangular, returning length="+length);
                return length;
            }
            double downRotation = downAngle - (-Math.PI/2);
            if (debugLevel >= 2) System.out.println("              downRotation = "+downRotation+" = "+RTOD(downRotation)+"deg");
            double cos = Math.cos(downRotation);
            double sin = Math.sin(downRotation);
            // row-oriented rotation matrix
            // that takes canonical catenary orientation to the one with given downAngle
            double downRotationMatrix[][] = {{cos,sin},
                                            {-sin,cos}};
            // tranform v0 and v1 by inverse of downRotationMatrix,
            // i.e. into orientation of canonical catenary
            double invTransformedV0[] = VecMath.mxv(downRotationMatrix, v0);
            double invTransformedV1[] = VecMath.mxv(downRotationMatrix, v1);
            if (debugLevel >= 2) System.out.println("              cos = "+cos);
            if (debugLevel >= 2) System.out.println("              sin = "+sin);
            if (debugLevel >= 2) System.out.println("              invTransformedV0 = "+VecMath.toString(invTransformedV0));
            if (debugLevel >= 2) System.out.println("              invTransformedV1 = "+VecMath.toString(invTransformedV1));
            // Figure out catenary params a,b,c,t0,t1
            // such that the catenary is:
            //      x = a*asinh(t/a) + b
            //      y = sqrt(t^2+a^2) + c
            // for t=t0 to t1.
            // XXX TODO put this into class Catenary and CatenaryRotated
            double x0 = invTransformedV0[0];
            double y0 = invTransformedV0[1];
            double x1 = invTransformedV1[0];
            double y1 = invTransformedV1[1];
            double dx = x1 - x0;
            double dy = y1 - y0;
            double L = MyMath.hypot(dx, dy) + slack;
            if (debugLevel >= 2) System.out.println("              L = "+L);

            // paper says:
            //      2*a*sinh(dx/(2*a)) = sqrt(L*L - dy*dy)
            //      dx*(2a/dx)sinh(dx/(2a)) = sqrt(L*L - dy*dy)
            //      sinhc(dx/2a) = sqrt(L*L-dy*dy)/dx
            //      dx/2a = asinhc(sqrt(L^2-dy^2)/dx)
            //      a = dx/(2*asinhc(sqrt(L^2-dy^2)/dx))
            if (false)
            {
                PRINT(L);
                PRINT(dy);
                PRINT(dx);
                double foo = Math.sqrt(L*L - dy*dy) / dx;
                double bar = Catenary.asinhc(foo);
                double baz = MyMath.sinh(bar)/bar;
                PRINT(foo); // 1.0421906109874948
                PRINT(bar); // 0.5009200267192209
                PRINT(baz); // 1.0423479684321144 // ooh that's not good!
            }

            double s = dx==0. ? 0. :
                       dx/(2.*Catenary.asinhc(Math.sqrt(L*L - dy*dy) / dx));
            if (debugLevel >= 2) System.out.println("              s = "+s);

            assert(s != 0.); // XXX so goes to separable, for now

            double b = s==0. ? (x0+x1)/2. :
                       (x0+x1)/2. - s*MyMath.asinh(dy/(2.*s*MyMath.sinh(dx/(2.*s))));
            if (debugLevel >= 2) System.out.println("              b = "+b);
            double tMid = .5 * dy * Math.sqrt(1. + 4.*(s*s)/(L*L - dy*dy));
            if (debugLevel >= 2) System.out.println("              tMid = "+tMid);
            double t0 = tMid - L/2.;
            if (debugLevel >= 2) System.out.println("              t0 = "+t0);
            double t1 = t0 + L;
            if (debugLevel >= 2) System.out.println("              t1 = "+t1);
            double c = y0 - Math.sqrt(t0*t0 + s*s); // XXX that sqrt is used several times, should save it
            if (debugLevel >= 2) System.out.println("              c = "+c);
            if (maxLengthToIntegrate < L)
            {
                if (debugLevel >= 2) System.out.println("                  clamping! = ");
                L = maxLengthToIntegrate;
                t1 = t0 + L;
                x1 = (s==0. ? 0. : s * MyMath.asinh(t1/s)) + b;
                y1 = Math.sqrt(t1*t1 + s*s) + c;
                // note, dx,dy no longer right, but we don't use them any more
                if (debugLevel >= 2) System.out.println("                  L = "+L);
                if (debugLevel >= 2) System.out.println("                  t1 = "+t1);
                if (debugLevel >= 2) System.out.println("                  x1 = "+x1);
                if (debugLevel >= 2) System.out.println("                  y1 = "+y1);
            }

            double s_times_asinh_t0_over_s = s==0. ? 0. : s*MyMath.asinh(t0/s);
            double s_times_asinh_t1_over_s = s==0. ? 0. : s*MyMath.asinh(t1/s);
            double x_part_of_integral_at_t0 = t0*(b + s_times_asinh_t0_over_s) - s*Math.sqrt(t0*t0 + s*s);
            double x_part_of_integral_at_t1 = t1*(b + s_times_asinh_t1_over_s) - s*Math.sqrt(t1*t1 + s*s);
            double y_part_of_integral_at_t0 = t0*(c + .5*Math.sqrt(t0*t0+s*s)) + .5*s*s_times_asinh_t0_over_s;
            double y_part_of_integral_at_t1 = t1*(c + .5*Math.sqrt(t1*t1+s*s)) + .5*s*s_times_asinh_t1_over_s;
            double x_part_of_integral = x_part_of_integral_at_t1 - x_part_of_integral_at_t0;
            double y_part_of_integral = y_part_of_integral_at_t1 - y_part_of_integral_at_t0;
            double integral[] = {x_part_of_integral, y_part_of_integral};

            // Transform integral back into original space.
            VecMath.vxm(answer, integral, downRotationMatrix);
            if (vFinal != null)
            {
                double temp[] = integral; // reuse memory
                temp[0] = x1;
                temp[1] = y1;
                VecMath.vxm(vFinal, temp, downRotationMatrix);
            }
            if (debugLevel >= 1) System.out.println("            out integralOfCatenaryWithEndpointsRectangular, returning L="+L);
            return L;
        }
        return Double.NaN; // XXX to shut up compiler-- get rid

    } // integralOfCatenaryWithEndpointsRectangular

    public static void main(String args[])
    {
        System.out.println("    in CatenaryRotated.main");
        // Test utilities for integrals

        int testVerboseLevel = 3; // 0 = nothing, 1 = basic outer flow, 2 = dots at loop iterations, 3 = trace all loop iterations

        double downAngles[] = {-Math.PI/2., -Math.PI/4, 0., Math.PI/2, Math.PI};
        double invScales[] = {1., .5, 2., 0.};
        double xTranslates[] = {0., 2., -2.};
        double yTranslates[] = {0., 2., -2.};
        double x0s[] = {0.,-1.,-2.,1.,2.};
        double x1s[] = {1.,2.,0.,-1.,-2.};

        for (int ix0 = 0; ix0 < x0s.length; ++ix0)
        for (int ix1 = 0; ix1 < x1s.length; ++ix1)
        {
            double x0 = x0s[ix0];
            double x1 = x1s[ix1];

            if (x1 < x0)
            {
                // In constructing the example, we always go left to right.
                // Don't fret, we'll rotate to all sorts of orientations.
                continue;
            }

            if (testVerboseLevel >= 1) System.out.println("      ===============================================================");
            if (testVerboseLevel >= 1) System.out.println("      x0 = "+x0);
            if (testVerboseLevel >= 1) System.out.println("      x1 = "+x1);

            double sinhx0 = MyMath.sinh(x0);
            double sinhx1 = MyMath.sinh(x1);
            double coshx0 = MyMath.cosh(x0);
            double coshx1 = MyMath.cosh(x1);
            double v0[] = {x0, coshx0};
            double v1[] = {x1, coshx1};

            // Parametrizing cosh by arc length between those endpoints,
            // this part of the cosh curve is:
            //      <asinh(t), sqrt(1+t^2)> for x in [x0,x1]
            //                              i.e. for t in [sinh(x0),sinh(x1)]
            // The arc length of that part is sinh(x1) - sinh(x0).
            // The integral of that part is:
            //      {-sqrt(1+t^2) + t*asinh(t),
            //       (t*sqrt(1+t^2) + asinh(t))/2}
            // =    {-cosh(x) + sinh(x)*x,
            //       (sinh(x)*cosh(x) + x) / 2}
            double expectedArcLength = sinhx1 - sinhx0;
            double expectedIntegral[] = {
                (sinhx1*x1-coshx1)-(sinhx0*x0-coshx0),
                ((sinhx1*coshx1+x1)-(sinhx0*coshx0+x0))*.5,
            };
            double integral[] = new double[2]; // scratch

            double slack = Math.abs(expectedArcLength) - VecMath.dist(v0,v1);

            if (true)
            {
                // s=1
                double x = 0.;
                double y = -slack;
                double arcLength = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integral, null);
                if (testVerboseLevel >= 1) PRINT(arcLength);
                if (testVerboseLevel >= 1) PRINT(expectedArcLength);
                assert(EQ(arcLength, expectedArcLength, 1e-6));
                if (testVerboseLevel >= 1) PRINTVEC(integral);
                if (testVerboseLevel >= 1) PRINTVEC(expectedIntegral);
                assert(VecMath.dist(integral, expectedIntegral) < 1e-6);
            }


            double halfLength = VecMath.dist(v0,v1)*.5;
            double expectedIntegralOfSegment[] = VecMath.vxs(VecMath.vpv(v0,v1),halfLength);
            double expectedArcLengthOfSegment = VecMath.dist(v0,v1);
            double integralOfSegment[] = new double[2];

            if (true)
            {
                // s=infinity
                double x = 0.;
                double y = 0.;
                double arcLengthOfSegment = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integralOfSegment, null);
                if (testVerboseLevel >= 1) PRINTVEC(integralOfSegment);
                if (testVerboseLevel >= 1) PRINTVEC(expectedIntegralOfSegment);
                assert(VecMath.dist(integralOfSegment, expectedIntegralOfSegment) < 1e-6);
                if (testVerboseLevel >= 1) PRINT(arcLengthOfSegment);
                if (testVerboseLevel >= 1) PRINT(expectedArcLengthOfSegment);
                assert(EQ(arcLengthOfSegment, expectedArcLengthOfSegment, 1e-6));
            }

            for (int iDownAngle = 0; iDownAngle < downAngles.length; ++iDownAngle)
            for (int iInvScale = 0; iInvScale < invScales.length; ++iInvScale)
            for (int iXTranslate = 0; iXTranslate < xTranslates.length; ++iXTranslate)
            for (int iYTranslate = 0; iYTranslate < yTranslates.length; ++iYTranslate)
            {
                double downAngle = downAngles[iDownAngle];
                double invScale = invScales[iInvScale];
                double translate[] = {xTranslates[iXTranslate], yTranslates[iYTranslate]};

                if (testVerboseLevel >= 3) System.out.println("            ---------------------------------------------------------------");
                if (testVerboseLevel >= 3) System.out.println("            downAngle="+RTOD(downAngle)+"deg invScale="+invScale+" translate="+VecMath.toString(translate));


                // we're really doing two fundamentally different tests,
                // depending on whether invScale is 0 or not.
                // I think it ends up exercising everything though.
                // XXX except near-0 and near-infinity, which we need to exercise too

                double rotateDownAngleToMinusYAxis = -Math.PI/2 - downAngle;
                double c = Math.cos(rotateDownAngleToMinusYAxis);
                double s = Math.sin(rotateDownAngleToMinusYAxis);
                double rotateDownAngleToMinusYAxisMatrix[][] = { // row oriented
                   { c,s},
                   {-s,c},
                };
                // rotate minus Y axis to down angle
                double v0Transformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, v0); // by inverse of matrix
                if (invScale != 0.)
                    VecMath.vxs(v0Transformed, v0Transformed, 1./invScale);
                VecMath.vpv(v0Transformed, v0Transformed, translate);
                double v1Transformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, v1); // by inverse of matrix
                if (invScale != 0.)
                    VecMath.vxs(v1Transformed, v1Transformed, 1./invScale);
                VecMath.vpv(v1Transformed, v1Transformed, translate);

                double expectedIntegralTransformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix,
                                                                   invScale==0. ? expectedIntegralOfSegment : expectedIntegral);
                if (invScale != 0.)
                    VecMath.vxs(expectedIntegralTransformed, expectedIntegralTransformed, 1./(invScale*invScale));
                VecMath.vpsxv(expectedIntegralTransformed, expectedIntegralTransformed,
                              invScale==0. ? VecMath.dist(v0,v1) : expectedArcLength/invScale,
                              translate);
                double expectedArcLengthTransformed = invScale==0. ? expectedArcLengthOfSegment : expectedArcLength/invScale;

                if (true)
                {
                    double integralTransformed[] = new double[2];
                    // 0,-slack/invScale rotated by rotation that takes YAxis to downAngle

                    // keep in mind the invScale=0 test is really a different test, don't expect it to be totally analogous
                    double xy[] = {0, invScale==0. ? 0. : -slack/invScale};
                    xy = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, xy); // by inverse of matrix
                    double x = xy[0];
                    double y = xy[1];
                    double arcLengthTransformed = integralOfCatenaryWithEndpointsRectangular(v0Transformed, v1Transformed, x, y, Double.POSITIVE_INFINITY, integralTransformed, null);
                    if (testVerboseLevel >= 3) System.out.println("                arcLengthTransformed = "+arcLengthTransformed);
                    if (testVerboseLevel >= 3) System.out.println("                expectedArcLengthTransformed = "+expectedArcLengthTransformed);
                    assert(EQ(arcLengthTransformed, expectedArcLengthTransformed, 1e-6));
                    if (testVerboseLevel >= 3) System.out.println("                integralTransformed = "+VecMath.toString(integralTransformed));
                    if (testVerboseLevel >= 3) System.out.println("                expectedIntegralTransformed = "+VecMath.toString(expectedIntegralTransformed));
                    assert(VecMath.dist(integralTransformed, expectedIntegralTransformed) < 1e-6);
                }

                if (testVerboseLevel == 2) System.out.print(".");
                if (testVerboseLevel >= 3) System.out.println("            ---------------------------------------------------------------");
            }
            if (testVerboseLevel == 2) System.out.println();
            if (testVerboseLevel >= 1) System.out.println("      ===============================================================");
        } // for x0,x1
        System.out.println("    out CatenaryRotated.main");
    } // main

}  // CatenaryRotated
