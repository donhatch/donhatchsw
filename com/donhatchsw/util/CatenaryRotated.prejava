/* vim: set filetype=java: */
package com.donhatchsw.util;
#include "macros.h" 


/* WORK IN PROGRESS */
public class CatenaryRotated extends Catenary.FlippedMaybe
{
    static boolean XXX_ALLOW_FITFROMMOMENT_FAILURE = false; // hack hook so SmoothlyVaryingViewingParameter demo3 can proceed with manageable amount of noise

    public double cosRotation;
    public double sinRotation;

    @Override public void assertValid()
    {
        super.assertValid();
        double error = MyMath.hypot(cosRotation, sinRotation) - 1.;
        assert(SQR(error) + 1. - 1. == 0.); // implicit tolerance
    }

    // Unit-length derivative at time t.
    @Override public void differentiate(double t,
                                        double answer[/*2*/])
    {
        super.differentiate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
    }

    // Position at time t.
    @Override public void evaluate(double t,
                                   double answer[/*2*/])
    {
        super.evaluate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
    }
    // Arc length integral from focus to t.
    @Override public void integrate(double t,
                                    double answer[/*2*/])
    {
        int verboseLevel = 0;
        if (verboseLevel >= 1) System.out.println("                            in CatenaryRotated.integrate(t="+t+")");
        super.integrate(t, answer);
        rotate(this.cosRotation, this.sinRotation, answer[0], answer[1], answer);
        if (verboseLevel >= 1) System.out.println("                            out CatenaryRotated.integrate(t="+t+"), returning answer="+VecMath.toString(answer));
    }

        // XXX experimental at the moment... alternative to newton, see how it behaves
        private static void solveUsingMinimizer(double x[],
                                 double y[], // const
                                 NewtonSolver.Fun nfun,
                                 int minIterations, // seem to need this, or it thinks it stopped improving after 1 iteration in some sticky situations.  I think actually the termination condition should be that it didn't improve in some number of iterations? hmm. actually should make it smart and adaptive I think.
                                 int maxIterations,
                                 boolean adaptiveFlag)
        {
            final double yFinal[] = y;
            final NewtonSolver.Fun nfunFinal = nfun;
            final double fx[] = new double[y.length];
            Minimizer.VectorFunction mfun = new Minimizer.VectorFunction() {
                @Override public double apply(double x[])
                {
                    nfunFinal.f(x, fx);
                    // Which?
                    // Empirically dist gives larger errors-- needed error tolerance of 1e-4 or so,
                    // whereas 1e-6 works (barely) for distsqrd
                    //return VecMath.dist(fx, yFinal);
                    return VecMath.distsqrd(fx, yFinal);
                }
            };
            double initialGuess[] = x;
            double initialDelta = 1e-3; // somewhat arbitrary
            String paramNames[] = null;
            double answer[] = Minimizer.minimize(mfun,
                               initialGuess,
                               initialDelta,
                               maxIterations,
                               false, // returnNullOnMaxCallsReached
                               paramNames);
            assert(answer != null);
            VecMath.copyvec(x, answer);
        } // solveUsingMinimizer

    /**
    * Set members to be the parameters of the catenary
    * passing through points (x0,y0),(x1,y1)
    * with given moment (i.e. integral with respect to arc length).
    * Caveat: this is done numerically.
    * In general there may be 1, 3, or 2 solutions;
    * if there are more than 1 solutions, this function may find one of them,
    * or it may fail to converge.
    * If the function is not 1-to-1 in a neighborhood of the solution,
    * it will fail to converge.
    * If it fails to converge, [XXX what?] is thrown.
    * XXX use current contents as initial guess?
    */
    public void fitFromMoment(double x0, double y0,
                              double x1, double y1,
                              double xMoment, double yMoment,
                              com.donhatchsw.compat.ArrayList newtonPathOut)
    {
        int verboseLevel = 0; // XXX think about what we want here. make this a parameter?
        int fitVerboseLevel = 0; // XXX and this too?
        if (verboseLevel >= 1) System.out.println("            in CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+" yMoment="+yMoment+")");
        if (verboseLevel >= 1) System.out.println("              {"+x0+","+y0+", "+x1+","+y1+", "+xMoment+","+yMoment+"},"); // suitable for copying into confidence test

        double dist = MyMath.hypot(y1-y0, x1-x0);
        double desiredMoment[] = {xMoment, yMoment};

        // Represent a solution by polar coords slack,downAngle,
        // converted to rectangular coords x,y:
        //  x = slack * cos(downAngle)
        //  y = slack * sin(downAngle)
        // We will do a numeric solve for x,y.
        final int verboseLevelFinal = verboseLevel;
        final int fitVerboseLevelFinal = fitVerboseLevel;
        final com.donhatchsw.compat.ArrayList newtonPathOutFinal = newtonPathOut;
        final boolean inJ[] = {false};
        final double x0final = x0;
        final double y0final = y0;
        final double x1final = x1;
        final double y1final = y1;

        NewtonSolver.Fun fun = new NewtonSolver.Fun(2) {
            @Override public void f(double xy[], double answerIntegral[])
            {
                if (verboseLevelFinal >= 2) System.out.println("                in f(xy = "+Arrays.toStringCompact(xy)+")");

                // use self as scratch catenary
                CatenaryRotated self = CatenaryRotated.this;
                self.fitFromRectangularCoords(x0final,y0final, x1final,y1final, xy[0], xy[1], fitVerboseLevelFinal);

                self.integrate(self.t0, self.t1, answerIntegral);

                if (!inJ[0] && newtonPathOutFinal != null)
                {
                    newtonPathOutFinal.add(new double[][] {VecMath.copyvec(xy), VecMath.copyvec(answerIntegral)});
                }
                if (verboseLevelFinal >= 2) System.out.println("                out f(xy = "+Arrays.toStringCompact(xy)+"), returning answerIntegral="+Arrays.toStringCompact(answerIntegral));
            }
            @Override public void J(double xy[], double fxy[], double answerJacobian[][])
            {
                if (verboseLevelFinal >= 2) System.out.println("            in J");
                inJ[0] = true;
                try
                {
                    super.J(xy, fxy, answerJacobian);
                }
                finally
                {
                    inJ[0] = false; // executed even on the way out of a throw
                }
                if (verboseLevelFinal >= 2)
                {
                    PRINTMAT(answerJacobian);
                    PRINT(VecMath.conditionNumber(answerJacobian));
                    PRINTVEC(VecMath.singularValues(answerJacobian));
                }
                if (verboseLevelFinal >= 2) System.out.println("            out J");
            }
            @Override public double eps()
            {
                // Somewhat dog science:
                // When using adaptive flag,
                // 1e-4 makes it freak out and confidence test fail currently (evaluation functions not stabilized).
                // 1e-6 fixes it but makes it slow down when past the switch (which is the numerically challenging part)
                // But I think 1e-6 is probably better in general anyway...
                // assuming problem has been scaled to unit size.
                return 1e-6;
            }
        };

        // Make an initial guess-- this gets it in the correct upper or lower
        // half-plane, but is otherwise very rough.
        double xMomentIfZeroSlack = (x0+x1)*.5 * dist;
        double yMomentIfZeroSlack = (y0+y1)*.5 * dist;
        double xInitialGuess = xMoment - xMomentIfZeroSlack;
        double yInitialGuess = yMoment - yMomentIfZeroSlack;
        double xyAnswer[] = {xInitialGuess, yInitialGuess};
        boolean adaptiveFlag = false; // setting this to true makes the TRY_TO_DO_IT_RIGHT plan paths look much better in demo3 (since evaluation functions not stable yet)... but it makes it horribly slow instead of just freaking out!  so, leaving this false; need to fix the problem instead.
        boolean amoebaFlag = false; // XXX make this configurable?
        if (amoebaFlag)
        {
            int maxIterations = 1000;
            solveUsingMinimizer(xyAnswer,
                               desiredMoment,
                               fun,
                               10,
                               maxIterations,
                               adaptiveFlag);
        }
        else
            NewtonSolver.solve(xyAnswer,
                               desiredMoment,
                               fun,
                               10,
                               1000,
                               adaptiveFlag);

        if (newtonPathOut != null)
            newtonPathOut.add(new double[][]{null, desiredMoment}); // special entry for the target

        this.fitFromRectangularCoords(x0,y0, x1,y1, xyAnswer[0], xyAnswer[1], fitVerboseLevelFinal);
        double gotMoment[] = new double[2];
        this.integrate(this.t0, this.t1, gotMoment);
        if (verboseLevel >= 1) System.out.println("              "+this);
        if (verboseLevel >= 1) System.out.println("              desiredMoment"+VecMath.toString(desiredMoment));
        if (verboseLevel >= 1) System.out.println("              gotMoment"+VecMath.toString(gotMoment));

        try
        {
            assert_le(VecMath.dist(desiredMoment,gotMoment), 1e-6); // TODO: make this relative to problem scale? not sure
        }
        catch (Error e)
        {
            // more descriptive error
            e = new Error("    INTERNAL ERROR: CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+" yMoment="+yMoment+") failed: got moment "+VecMath.toString(gotMoment)+", error="+VecMath.dist(desiredMoment,gotMoment));
            if (XXX_ALLOW_FITFROMMOMENT_FAILURE)
            {
                System.err.println(e.getMessage());
                // but proceed
            }
            else
                throw e;
        }
        if (verboseLevel >= 1) System.out.println("            out CatenaryRotated.fitFromMoment(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", xMoment="+xMoment+" yMoment="+yMoment+")");
    } // fitFromMoment


    private void fitFromRectangularCoords(double x0, double y0,
                                          double x1, double y1,
                                          double x, double y, // slack,downAngle in rectangular coords
                                          int verboseLevel)
    {
        if (verboseLevel >= 1) System.out.println("                in CatenaryRotated.fitFromRectangularCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", x="+x+" y="+y+")");
        double slack = MyMath.hypot(x, y);
        assert(slack >= 0.); // XXX I've seen this fail, in demo3, but I guess that must mean there's nans coming in? at least I think it's here that is failing
        /*
            XXX actually I think the following was when adaptiveFlag was turned on for newton
            OH NO! SOMETHING AWFUL HAPPENED!
                    this.position = <736.56792077277,161.47365152524412>
                    this.velocity = <4.709008819183118,-0.07610513206341617>
                    this.targetPosition = <1199.0,154.0>
                    referenceTripDistance = 0.005994842503189409
                    referenceTripTime = 1.0
                    dt = 1.0
                    distanceBasedBounce = 0.0
            OH NO! SOMETHING AWFUL HAPPENED!
                    this.position = <1179.7054122310478,154.31178552684133>
                    this.velocity = <0.5766350670102477,-0.009319407913955911>
                    this.targetPosition = <1199.0,154.0>
                    referenceTripDistance = 0.0021544346900318834
                    referenceTripTime = 1.0
                    dt = 1.0
                    distanceBasedBounce = 0.0
            OH NO! SOMETHING AWFUL HAPPENED!
                    this.position = <1180.2777389914652,154.30253575825404>
                    this.velocity = <0.5680184538243997,-0.0091801292606132>
                    this.targetPosition = <1199.0,154.0>
                    referenceTripDistance = 0.0021544346900318834
                    referenceTripTime = 1.0
                    dt = 1.0
                    distanceBasedBounce = 0.0
            OH NO! SOMETHING AWFUL HAPPENED!
                    this.position = <1158.2760838977304,154.65825220590696>
                    this.velocity = <0.6486299113668444,-0.010482784426232152>
                    this.targetPosition = <1199.0,154.0>
                    referenceTripDistance = 0.001291549665014884
                    referenceTripTime = 1.0
                    dt = 1.0
                    distanceBasedBounce = 0.0
        */
        double downAngle = Math.atan2(y, x);
        double cosDownAngle = Math.cos(downAngle);
        double sinDownAngle = Math.sin(downAngle);
        // note cosDownAngle,sinDownAngle are just x,y normalized, robustly.
        // if I had a robust normalization function that I trusted, I'd use that instead.
        this.fitFromPolarCoords(x0,y0, x1,y1, slack, cosDownAngle, sinDownAngle, verboseLevel);
        if (verboseLevel >= 1) System.out.println("                out CatenaryRotated.fitFromRectangularCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", x="+x+" y="+y+")");
    } // fitFromRectangularCoords

    private void fitFromPolarCoords(double x0, double y0,
                                    double x1, double y1,
                                    double slack,
                                    double cosDownAngle,
                                    double sinDownAngle,
                                    int verboseLevel)
    {
        if (verboseLevel >= 1) System.out.println("                    in CatenaryRotated.fitFromPolarCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+" c="+cosDownAngle+" s="+sinDownAngle+")");
        // rotation = downAngle - (-pi/2)
        this.cosRotation = -sinDownAngle;
        this.sinRotation = cosDownAngle;
        double x0Unrotated = xPartOfUnrotated(this.cosRotation, this.sinRotation, x0, y0);
        double y0Unrotated = yPartOfUnrotated(this.cosRotation, this.sinRotation, x0, y0);
        double x1Unrotated = xPartOfUnrotated(this.cosRotation, this.sinRotation, x1, y1);
        double y1Unrotated = yPartOfUnrotated(this.cosRotation, this.sinRotation, x1, y1);
        // Note that when fit is done it will call our isValid() (which is admittedly odd)
        // so our cosRotation and sinRotation, as well as the FlippedMaybe members,
        // had better be valid.
        super.fit(x0Unrotated, y0Unrotated, 
                  x1Unrotated, y1Unrotated,
                  slack,
                  verboseLevel);
        if (verboseLevel >= 1) System.out.println("                    out CatenaryRotated.fitFromPolarCoords(x0="+x0+", y0="+y0+", x1="+x1+", y1="+y1+", slack="+slack+" c="+cosDownAngle+" s="+sinDownAngle+")");
    } // fitFromPolarCoords

    private static final double xPartOfRotated(double cosRotation, double sinRotation, double x, double y)
    {
        return cosRotation * x - sinRotation * y;
    }
    private static final double yPartOfRotated(double cosRotation, double sinRotation, double x, double y)
    {
        return sinRotation * x + cosRotation * y;
    }
    private static final double xPartOfUnrotated(double cosRotation, double sinRotation, double x, double y)
    {
        return cosRotation * x + sinRotation * y;
    }
    private static final double yPartOfUnrotated(double cosRotation, double sinRotation, double x, double y)
    {
        return -sinRotation * x + cosRotation * y;
    }
    private static final void rotate(double cosRotation, double sinRotation, double x, double y, double answer[/*2*/])
    {
        answer[0] = xPartOfRotated(cosRotation, sinRotation, x, y);
        answer[1] = yPartOfRotated(cosRotation, sinRotation, x, y);
    }
    private static final void unRotate(double cosRotation, double sinRotation, double x, double y, double answer[/*2*/])
    {
        answer[0] = xPartOfUnrotated(cosRotation, sinRotation, x, y);
        answer[1] = yPartOfUnrotated(cosRotation, sinRotation, x, y);
    }

    // XXX phase this out, moving to pure catenary routines... I think? confidence test still uses it at the moment.
    // A catenary is a scaled rotated translated cosh.
    // Path-length integrate from v0 to either v1, or to a length of maxLengthToIntegrate,
    // which ever comes first.
    // Answer gets put into answer. The function return value is the arc length.
    // vFinal is the point that the integral went to (either v1, or the point at distance maxLengthToIntegrate along the curve).
    private static double integralOfCatenaryWithEndpointsRectangular(double v0[/*2*/],
                                                                     double v1[/*2*/],
                                                                     double x, double y, // slack,downAngle in rectangular coords
                                                                     double maxLengthToIntegrate,
                                                                     double answer[/*2*/],
                                                                     double vFinal[/*2*/],
                                                                     double aFinal[/*2*/],
                                                                     CatenaryRotated scratchCatenaryRotated,
                                                                     int debugLevel) // 0: nothing, 1: in/out, 2: a bit more
    {
        int fitVerboseLevel = debugLevel;
        if (debugLevel >= 1) System.out.println("            in integralOfCatenaryWithEndpointsRectangular");
        if (debugLevel >= 2) System.out.println("              v0 = "+VecMath.toString(v0));
        if (debugLevel >= 2) System.out.println("              v1 = "+VecMath.toString(v1));
        if (debugLevel >= 2) System.out.println("              x = "+x+" y = "+y);
        if (debugLevel >= 2) System.out.println("              maxLengthToIntegrate = "+maxLengthToIntegrate);

        scratchCatenaryRotated.fitFromRectangularCoords(v0[0], v0[1], v1[0], v1[1], x, y, fitVerboseLevel);
        double t0 = scratchCatenaryRotated.t0;
        double t1 = scratchCatenaryRotated.t1;
        double arcLength = t1 - t0;
        if (maxLengthToIntegrate < arcLength)
        {
            if (debugLevel >= 2) System.out.println("              clamping arcLength from "+arcLength+" to "+maxLengthToIntegrate);
            arcLength = maxLengthToIntegrate;
            t1 = t0 + maxLengthToIntegrate;
        }
        if (debugLevel >= 1) System.out.println("                scratchCatenaryRotated.{cos,sin}Rotation = "+scratchCatenaryRotated.cosRotation+", "+scratchCatenaryRotated.sinRotation);
        scratchCatenaryRotated.integrate(t0, t1, answer);
        if (debugLevel >= 1) System.out.println("              integral answer = "+VecMath.toString(answer));
        if (vFinal != null)
        {
            scratchCatenaryRotated.evaluate(t1, vFinal);
            if (debugLevel >= 1) System.out.println("              vFinal = "+VecMath.toString(vFinal));
        }
        if (aFinal != null)
        {
            scratchCatenaryRotated.differentiate(t1, aFinal);
            if (debugLevel >= 1) System.out.println("              aFinal = "+VecMath.toString(aFinal));
        }
        if (debugLevel >= 1) System.out.println("            out integralOfCatenaryWithEndpointsRectangular, returning arcLength="+arcLength);
        return arcLength;
    } // integralOfCatenaryWithEndpointsRectangular

    public String toString()
    {
       StringBuffer sb = new StringBuffer();
       sb.append("{cos=");
       sb.append(this.cosRotation);
       sb.append(", sin=");
       sb.append(this.sinRotation);
       sb.append(", ");
       sb.append(super.toString());
       sb.append("}");
       return sb.toString();
    }

    public static void confidenceTests()
    {
        System.out.println("    in confidenceTests");




        // Test utilities for integrals

        int testVerboseLevel = 2; // 0 = nothing, 1 = basic outer flow, 2 = dots at loop iterations, 3 = trace all loop iterations


        if (true)
        {
            CatenaryRotated scratchCatenaryRotated = new CatenaryRotated();

            double downAngles[] = {-Math.PI/2., -Math.PI/4, 0., Math.PI/2, Math.PI};
            double invScales[] = {1., .5, 2., 0.};
            double xTranslates[] = {0., 2., -2.};
            double yTranslates[] = {0., 2., -2.};
            double x0s[] = {0.,-1.,-2.,1.,2.};
            //double x1s[] = {1.,2.,0.,-1.,-2.};
            double x1s[] = x0s; // XXX get rid

            for (int ix0 = 0; ix0 < x0s.length; ++ix0)
            for (int ix1 = 0; ix1 < x1s.length; ++ix1)
            {
                double x0 = x0s[ix0];
                double x1 = x1s[ix1];

                if (x1 < x0)
                {
                    // In constructing the example, we always go left to right.
                    // Don't fret, we'll rotate to all sorts of orientations.
                    continue;
                }

                if (testVerboseLevel >= 1) System.out.println("      ===============================================================");
                if (testVerboseLevel >= 1) System.out.println("      x0 = "+x0);
                if (testVerboseLevel >= 1) System.out.println("      x1 = "+x1);

                double sinhx0 = MyMath.sinh(x0);
                double sinhx1 = MyMath.sinh(x1);
                double coshx0 = MyMath.cosh(x0);
                double coshx1 = MyMath.cosh(x1);
                double v0[] = {x0, coshx0};
                double v1[] = {x1, coshx1};
                if (testVerboseLevel >= 1) System.out.println("      v0 = "+VecMath.toString(v0));
                if (testVerboseLevel >= 1) System.out.println("      v1 = "+VecMath.toString(v1));

                // Parametrizing cosh by arc length between those endpoints,
                // this part of the cosh curve is:
                //      <asinh(t), sqrt(1+t^2)> for x in [x0,x1]
                //                              i.e. for t in [sinh(x0),sinh(x1)]
                // The arc length of that part is sinh(x1) - sinh(x0).
                // The integral of that part is:
                //      {-sqrt(1+t^2) + t*asinh(t),
                //       (t*sqrt(1+t^2) + asinh(t))/2}
                // =    {-cosh(x) + sinh(x)*x,
                //       (sinh(x)*cosh(x) + x) / 2}
                double expectedArcLength = sinhx1 - sinhx0;
                double expectedIntegral[] = {
                    (sinhx1*x1-coshx1)-(sinhx0*x0-coshx0),
                    ((sinhx1*coshx1+x1)-(sinhx0*coshx0+x0))*.5,
                };
                double integral[] = new double[2]; // scratch

                double slack = Math.abs(expectedArcLength) - VecMath.dist(v0,v1);

                if (true)
                {
                    // s=1
                    OUT("        s=1 case");
                    double x = 0.;
                    double y = -slack;
                    double arcLength = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integral, null, null, scratchCatenaryRotated, 0);
                    if (testVerboseLevel >= 1) PRINT(arcLength);
                    if (testVerboseLevel >= 1) PRINT(expectedArcLength);
                    assert_almost_eq(arcLength, expectedArcLength, 1e-6);
                    if (testVerboseLevel >= 1) PRINTVEC(integral);
                    if (testVerboseLevel >= 1) PRINTVEC(expectedIntegral);
                    assert(VecMath.dist(integral, expectedIntegral) < 1e-6);
                }


                double halfLength = VecMath.dist(v0,v1)*.5;
                double expectedIntegralOfSegment[] = VecMath.vxs(VecMath.vpv(v0,v1),halfLength); // length times average
                double expectedArcLengthOfSegment = VecMath.dist(v0,v1);

                // in degenerate test, slack is 1
                // and gravity is from v1 towards v0 (or arbitrary direction if they are the same)
                double slackForDegenerate = 1.; // somewhat arbitrary XXX should try others
                double expectedArcLengthOfDegenerate = expectedArcLengthOfSegment + slackForDegenerate;
                double gravityForDegenerate[] = VecMath.normalize(VecMath.vmv(v0, v1));
                double expectedIntegralOfDegenerate[] = VecMath.vpv(expectedIntegralOfSegment,
                                                                    VecMath.vxs(VecMath.vpsxv(v0,slackForDegenerate/4.,gravityForDegenerate),
                                                                                slackForDegenerate));

                if (true)
                {
                    // s=infinity
                    OUT("        s=infinity case");
                    double x = 0.;
                    double y = 0.;
                    double integralOfSegment[] = new double[2];
                    double arcLengthOfSegment = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integralOfSegment, null, null, scratchCatenaryRotated, 0);
                    if (testVerboseLevel >= 1) PRINT(arcLengthOfSegment);
                    if (testVerboseLevel >= 1) PRINT(expectedArcLengthOfSegment);
                    assert_almost_eq(arcLengthOfSegment, expectedArcLengthOfSegment, 1e-6);
                    if (testVerboseLevel >= 1) PRINTVEC(integralOfSegment);
                    if (testVerboseLevel >= 1) PRINTVEC(expectedIntegralOfSegment);
                    assert(VecMath.dist(integralOfSegment, expectedIntegralOfSegment) < 1e-6);
                }

                if (true)
                {
                    // s=0, gravity from v1 towards v0 (or arbitrary dir if v0=v1)
                    OUT("        s=0 case");
                    PRINTVEC(gravityForDegenerate);
                    PRINTVEC(v0);
                    PRINTVEC(v1);
                    double x = slackForDegenerate * gravityForDegenerate[0];
                    double y = slackForDegenerate * gravityForDegenerate[1];
                    double integralOfDegenerate[] = new double[2];
                    double arcLengthOfDegenerate = integralOfCatenaryWithEndpointsRectangular(v0, v1, x, y, Double.POSITIVE_INFINITY, integralOfDegenerate, null, null, scratchCatenaryRotated, 0);
                    if (testVerboseLevel >= 1) PRINT(arcLengthOfDegenerate);
                    if (testVerboseLevel >= 1) PRINT(expectedArcLengthOfDegenerate);
                    assert_almost_eq(arcLengthOfDegenerate, expectedArcLengthOfDegenerate, 1e-6);
                    if (testVerboseLevel >= 1) PRINTVEC(integralOfDegenerate);
                    if (testVerboseLevel >= 1) PRINTVEC(expectedIntegralOfDegenerate);
                    assert(VecMath.dist(integralOfDegenerate, expectedIntegralOfDegenerate) < 1e-6);
                }

                if (testVerboseLevel == 2) System.out.print("        "); // indent for dots

                for (int iDownAngle = 0; iDownAngle < downAngles.length; ++iDownAngle)
                for (int iInvScale = 0; iInvScale < invScales.length; ++iInvScale)
                for (int iXTranslate = 0; iXTranslate < xTranslates.length; ++iXTranslate)
                for (int iYTranslate = 0; iYTranslate < yTranslates.length; ++iYTranslate)
                {
                    double downAngle = downAngles[iDownAngle];
                    double invScale = invScales[iInvScale];
                    double translate[] = {xTranslates[iXTranslate], yTranslates[iYTranslate]};

                    if (testVerboseLevel >= 3) System.out.println("            ---------------------------------------------------------------");
                    if (testVerboseLevel >= 3) System.out.println("            downAngle="+RTOD(downAngle)+"deg invScale="+invScale+" translate="+VecMath.toString(translate));


                    // we're really doing two fundamentally different tests,
                    // depending on whether invScale is 0 or not.
                    // I think it ends up exercising everything though.
                    // XXX except near-0 and near-infinity, which we need to exercise too

                    double rotateDownAngleToMinusYAxis = -Math.PI/2 - downAngle;
                    double c = Math.cos(rotateDownAngleToMinusYAxis);
                    double s = Math.sin(rotateDownAngleToMinusYAxis);
                    double rotateDownAngleToMinusYAxisMatrix[][] = { // row oriented
                       { c,s},
                       {-s,c},
                    };
                    // rotate minus Y axis to down angle
                    double v0Transformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, v0); // by inverse of matrix
                    if (invScale != 0.)
                        VecMath.vxs(v0Transformed, v0Transformed, 1./invScale);
                    VecMath.vpv(v0Transformed, v0Transformed, translate);
                    double v1Transformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, v1); // by inverse of matrix
                    if (invScale != 0.)
                        VecMath.vxs(v1Transformed, v1Transformed, 1./invScale);
                    VecMath.vpv(v1Transformed, v1Transformed, translate);

                    double expectedIntegralTransformed[] = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix,
                                                                       invScale==0. ? expectedIntegralOfSegment : expectedIntegral);
                    if (invScale != 0.)
                        VecMath.vxs(expectedIntegralTransformed, expectedIntegralTransformed, 1./(invScale*invScale));
                    VecMath.vpsxv(expectedIntegralTransformed, expectedIntegralTransformed,
                                  invScale==0. ? VecMath.dist(v0,v1) : expectedArcLength/invScale,
                                  translate);
                    double expectedArcLengthTransformed = invScale==0. ? expectedArcLengthOfSegment : expectedArcLength/invScale;

                    if (true)
                    {
                        double integralTransformed[] = new double[2];
                        // 0,-slack/invScale rotated by rotation that takes YAxis to downAngle

                        // keep in mind the invScale=0 test is really a different test, don't expect it to be totally analogous
                        double xy[] = {0, invScale==0. ? 0. : -slack/invScale};
                        xy = VecMath.mxv(rotateDownAngleToMinusYAxisMatrix, xy); // by inverse of matrix
                        double x = xy[0];
                        double y = xy[1];
                        double arcLengthTransformed = integralOfCatenaryWithEndpointsRectangular(v0Transformed, v1Transformed, x, y, Double.POSITIVE_INFINITY, integralTransformed, null, null, scratchCatenaryRotated, 0);
                        if (testVerboseLevel >= 3) System.out.println("                arcLengthTransformed = "+arcLengthTransformed);
                        if (testVerboseLevel >= 3) System.out.println("                expectedArcLengthTransformed = "+expectedArcLengthTransformed);
                        assert_almost_eq(arcLengthTransformed, expectedArcLengthTransformed, 1e-6);
                        if (testVerboseLevel >= 3) System.out.println("                integralTransformed = "+VecMath.toString(integralTransformed));
                        if (testVerboseLevel >= 3) System.out.println("                expectedIntegralTransformed = "+VecMath.toString(expectedIntegralTransformed));
                        assert(VecMath.dist(integralTransformed, expectedIntegralTransformed) < 1e-6);
                    }

                    if (testVerboseLevel == 2) System.out.print(".");
                    if (testVerboseLevel >= 3) System.out.println("            ---------------------------------------------------------------");
                }
                if (testVerboseLevel == 2) System.out.println(); // newline after dots
                if (testVerboseLevel >= 1) System.out.println("      ===============================================================");
            } // for x0,x1
        }

        if (true)
        {
            System.out.println("      testing some fitFromMoment cases that have been problematic");
            // XXX TODO: the stepScale refers to the thing that's hard coded inside fitFromMoment. not sure what the problem is, either:
            //           - it's getting foiled by known numerical issues since I'm not doing Catenary intelligently for near-degenerate cases
            //           - newton solve is really tricky in this case, need to make it adaptive or something

            double testCases[][] = {
                // x0,y0, x1,y1, xMoment,yMoment
                {-1.,0., 0.,0., -0.5036269106706781,-0.027290553371898757}, // good with stepScale=1 (currently)
                {-1.,0., 0.,0., -0.5019665247911539,-0.020949377300023747}, // fails with stepScale=1, succeeds with stepScale=.8 (currently)
                {-1.0,2.220446049250313E-16, 0.0,0.0, -0.5011288865208755,-0.016410201253350465}, // fails with stepScale=.8, succeeds with stepScale=.5 (currently)
                {-0.9999999999999999,2.7755575615628914E-17, 0.0,0.0, -0.5006712775428778,-0.013005663996619649}, // fails with stepScale=.5, succeeds with stepScale=.2 (currently)
                {-1.0,-5.551115123125783E-17, 0.0,0.0, -0.5004068444282271,-0.01036098511128418}, // fails with stepScale=.2 (currently)
            };
            for (int iTestCase = 0; iTestCase < testCases.length; ++iTestCase)
            {
                System.out.println("      fitFromMoment test case "+iTestCase+"/"+testCases.length+":");
                double x0 = testCases[iTestCase][0];
                double y0 = testCases[iTestCase][1];
                double x1 = testCases[iTestCase][2];
                double y1 = testCases[iTestCase][3];
                double xMoment = testCases[iTestCase][4];
                double yMoment = testCases[iTestCase][5];
                PRINT(x0);
                PRINT(y0);
                PRINT(x1);
                PRINT(y1);
                PRINT(xMoment);
                PRINT(yMoment);

                XXX_ALLOW_FITFROMMOMENT_FAILURE = true;
                CatenaryRotated catenaryRotated = new CatenaryRotated();
                com.donhatchsw.compat.ArrayList newtonPath = new com.donhatchsw.compat.ArrayList();
                catenaryRotated.fitFromMoment(x0,y0, x1,y1, xMoment,yMoment, newtonPath);
                PRINT(catenaryRotated);

                PRINTARRAY(newtonPath.toArray());
                if (true)
                {
                    newtonPath.add(new double[][] {{Double.NaN,Double.NaN},{Double.NaN,Double.NaN}}); // expedience
                    FORI (i, newtonPath.size())
                    {
                        double entry[][] = (double[][])newtonPath.get(i);
                        if (entry[0] == null)
                            entry[0] = new double[] {Double.NaN,Double.NaN}; // expedience
                        // apparently gnuplot likes inf but not nan :-(
                        System.out.println("    NEWTON PATH: "
                                +(Double.isNaN(entry[0][0])?"inf":entry[0][0])+" "
                                +(Double.isNaN(entry[0][1])?"inf":entry[0][1])+"  "
                                +(Double.isNaN(entry[1][0])?"inf":entry[1][0])+" "
                                +(Double.isNaN(entry[1][1])?"inf":entry[1][1]));
                    }
                }

                double momentActual[] = new double[2];
                double x0y0Actual[] = new double[2];
                double x1y1Actual[] = new double[2];
                double a0Actual[] = new double[2];
                double a1Actual[] = new double[2];
                catenaryRotated.integrate(catenaryRotated.t0, catenaryRotated.t1, momentActual);
                catenaryRotated.evaluate(catenaryRotated.t0, x0y0Actual);
                catenaryRotated.evaluate(catenaryRotated.t1, x1y1Actual);
                catenaryRotated.differentiate(catenaryRotated.t0, a0Actual);
                catenaryRotated.differentiate(catenaryRotated.t1, a1Actual);
                PRINTVEC(momentActual);
                double tol = 1e-12;
                assert_almost_eq(momentActual[0], xMoment, tol);
                assert_almost_eq(momentActual[1], yMoment, tol);
                assert_almost_eq(x0y0Actual[0], x0, tol);
                assert_almost_eq(x0y0Actual[1], y0, tol);
                assert_almost_eq(x1y1Actual[0], x1, tol);
                assert_almost_eq(x1y1Actual[1], y1, tol);
                assert_almost_eq(VecMath.norm(a0Actual), 1., tol);
                assert_almost_eq(VecMath.norm(a1Actual), 1., tol);
                System.out.println("        seems good!");
            }
            if (false)
            {
                System.out.println("WARNING: Exiting prematurely!");
                System.exit(1);
            }
        }

        System.out.println("    out confidenceTests");
    } // confidenceTests

    public static void interactiveDemo1()
    {
        final int eventVerbose = 0; // set to something else to debug
        java.awt.Canvas canvas = new java.awt.Canvas() {

            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            public boolean isFocusTraversable()
            {
                return true;
            }

            class Model
            {
#if 0
                public SmoothlyVaryingViewingParameter points[];
                public double referenceTripDistancesInPixels[];
                public double referenceTripTimesInRepaints[];
                public java.awt.Color colors[];
                //public double distanceBasedBounce = .53; // zeroing in on threshold of whether it does or doesn't settle, for QUADRATIC
                //public double distanceBasedBounce = 1.;
                public double distanceBasedBounce = 0.;
                public boolean paused = false;
                public double time = 0.;
                public Model()
                {
                    int n = 10;
                    //int n = 2;
                    points = new SmoothlyVaryingViewingParameter[n*3];
                    referenceTripDistancesInPixels = new double[n];
                    referenceTripTimesInRepaints = new double[n];
                    colors = new java.awt.Color[n*3];
                    FORI (i, n)
                    {
                        // Uniformly spaced speeds in log space, between 1 and 200
                        // (in pixels per frame).
                        double minDistance = 1.;
                        double maxDistance = 200.;
                        double frac = i/(n-1.); // uniform from 0 to 1 inclusive
                        referenceTripDistancesInPixels[i] = minDistance
                                                          * Math.pow(maxDistance/minDistance,
                                                                     frac);
                        //referenceTripTimesInRepaints[i] = 2.;
                        referenceTripTimesInRepaints[i] = 1.;
                        //referenceTripTimesInRepaints[i] = .5;
                        //referenceTripTimesInRepaints[i] = .25;
                        //referenceTripTimesInRepaints[i] = .2;
                        //referenceTripTimesInRepaints[i] = .19;
                        //referenceTripTimesInRepaints[i] = .18;
                        //referenceTripTimesInRepaints[i] = .15;
                        //referenceTripTimesInRepaints[i] = .14;
                        //referenceTripTimesInRepaints[i] = .13;
                        //referenceTripTimesInRepaints[i] = .12;
                        //referenceTripTimesInRepaints[i] = .1;
                        //referenceTripTimesInRepaints[i] = .05;

                        if (false) // not sure whether I like this
                        {
                            if (i == n-1)
                            {
                                // Make the last one a lot faster.
                                referenceTripTimesInRepaints[i] /= 5.;
                            }
                        }

                        FORI (j, 3)
                        {
                            points[i*3+j] = new SmoothlyVaryingViewingParameter(new double[]{0,0});
                            points[i*3+j].strategy = j==0 ? STRATEGY_SEPARABLE
                                                   : j==1 ? STRATEGY_TWO_PIECE_QUADRATIC
                                                          : STRATEGY_TRY_TO_DO_IT_RIGHT_WITH_SEPARABLE_BAILOUT;


                            points[3*i+j].setPosition(new double[]{0.,200.}); // left side of window, assuming initial window is 400x400
                            points[3*i+j].setVelocity(new double[]{0,.25}); // northward a bit

                            if (true)
                            {
                                // debug pure diagonal motion.  WTF, this makes the bounce not happen for separable??
                                points[3*i+j].setPosition(new double[]{0.,0.}); // lower-left corner of window-- pure diagonal.  bogus bounce doesn't happen!
                                points[3*i+j].setPosition(new double[]{10.,0.}); // lower-left corner of window plus a bit to the right-- OH this makes it happen!
                                points[3*i+j].setPosition(new double[]{20.,0.}); // lower-left corner of window plus a bit to the right-- OH this makes it happen!
                                points[3*i+j].setPosition(new double[]{40.,0.}); // lower-left corner of window plus a bit to the right-- OH this makes it happen!
                                points[3*i+j].setVelocity(new double[]{0.,0.});
                                // after window resize, target will be set to window center.
                            }
                            float hue = i/(n-1.f);
                            float sat = j==0 ? .2f : j==1 ? .45f : j==2 ? 1.f : 0.f;
                            float val = 1.f;
                            float rgb[] = new float[3];
                            HSVtoRGB(hue,sat,val,rgb);
                            colors[i*3+j] = new java.awt.Color(rgb[0],rgb[1],rgb[2]);
                        }
                    }
                } // Model ctor
                public void evolve(double dt)
                {
                    int N = points.length;
                    int n = N/3;
                    FORI (I, N)
                    {
                        int i = I/3;
                        int j = i%3;
                        //PRINTSUB(referenceTripDistancesInPixels,i);
                        //PRINTSUB(referenceTripTimesInRepaints,i);
                        // XXX huh? what is that 10000, fudge? so the numbers aren't what they claim tobe?
                        points[I].evolve(referenceTripDistancesInPixels[i]/10000.,
                                         referenceTripTimesInRepaints[i],
                                         dt,
                                         distanceBasedBounce);
                    }
                    time += dt;
                }
#endif // 0
            } // class Model
            class View
            {
                // Really viewing params (could separate into ViewParams and ViewState)...
                boolean antialiasFlag = true;

                int nPaintsDone = 0;
            }
            class Controller
            {
            }
            private Model model = new Model();
            private View view = new View();
            private Controller controller = new Controller();
            private com.donhatchsw.awt.MyGraphics mostRecentGraphics = null;


            // SIZE (demo1)
            public java.awt.Dimension getPreferredSize()
            {
                //return new java.awt.Dimension(850,850);
                return new java.awt.Dimension(400,400);
                //return new java.awt.Dimension(200,200);
            }




            private java.awt.Image backBuffer = null;
            private java.awt.Dimension backBufferSize = null;

            public void update(java.awt.Graphics g) { paint(g); } // don't flash
            // PAINT (demo1)
            public void paint(java.awt.Graphics frontBufferGraphics)
            {
                if (eventVerbose >= 2) System.out.println("    in paint");

                java.awt.Dimension size = size();
                int w = size.width, h = size.height;
                if (backBuffer == null
                 || !size.equals(backBufferSize))
                {
                    System.out.println("    creating back buffer of size "+w+"x"+h+"");
                    backBuffer = this.createImage(w, h);
                    backBufferSize = size;
                }
                java.awt.Graphics g = backBuffer.getGraphics();
                if (false)
                    g = frontBufferGraphics; // make it single buffered

                if (view.antialiasFlag)
                    ((java.awt.Graphics2D)g).setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                                                              java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
                else
                    ((java.awt.Graphics2D)g).setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
                                                              java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);

                int minSize = Math.min(w,h);
                com.donhatchsw.awt.MyGraphics mg = new com.donhatchsw.awt.MyGraphics(g, size(),
                                               .5,w-.5,
                                               .5,h-.5);

                // Clear to black
                if (g != frontBufferGraphics) // if not single buffered
                {
                    mg.setColor(java.awt.Color.black);
                    mg.fillWindow();
                }


                //
                // Evolve.
                //
#if 0
                if (!model.paused)
                    model.evolve(1.); // dt, in repaints
#endif


                //
                // Draw.
                //
#if 0
                double position[] = new double[2];
                double velocity[] = new double[2];
                double acceleration[] = new double[2];
                double observedAcceleration[] = new double[2];
                int N = model.points.length;
                int n = N/3;

                //FORI (i, n) // slower first, so faster on top
                FORIDOWN (i, n) // faster first, so slower on top
                {
                    FORI (j, 3) // separable first, so try_to_do_it_right on top
                    //FORIDOWN (j, 3) // try_to_do_it_right first, so separable on top
                    {
                        int I = 3*i+j;
                        // Even point sizes, target lands nicely on a pixel corner
                        // when it's an integer, which it generally is.

                        //int pointSize = 2*i + 1; // 1, 3, 5, ...
                        //int pointSize = 2*(n-1-i) + 1; // ..., 5, 3, 1
                        //int pointSize = 2*(n-1-i) + 2; // ..., 6, 4, 2
                        //int pointSize = 2*i + 2; // 2, 4, 6, ...
                        int pointSize = 2*i + 2; // 2, 4, 6, ...

                        model.points[I].get(position);
                        model.points[I].getVelocity(velocity);
                        model.points[I].getAcceleration(acceleration);
                        model.points[I].getObservedAcceleration(observedAcceleration);
                        //PRINTVEC(acceleration);
                        //PRINTVEC(observedAcceleration);
                        mg.setColor(model.colors[I]);
                        // XXX FUDGE- I think there may be a bug in MyGraphics, should not need to do the .5
                        mg.drawHollowPoint(position[0]+.5,
                                           position[1]+.5,
                                           pointSize);

                        double accelerationVisualScale = 20.;
                        double a = 4*model.referenceTripDistancesInPixels[i]/10000.
                                   / SQR(model.referenceTripTimesInRepaints[i]);
                        accelerationVisualScale /= a;
                        // So should all come out same length on screen.
                        // Note that we could accomplish that by just normalizing to that
                        // length... but the existing method is kind of a sanity check.

                        assert(Double.isNaN(acceleration[0])
                            == Double.isNaN(acceleration[1]));
                        if (!Double.isNaN(acceleration[0])
                         && VecMath.normsqrd(acceleration) != 0.)
                        {
                            mg.drawLine(position[0]+.5,
                                        position[1]+.5,
                                        position[0]+.5-acceleration[0]*accelerationVisualScale,
                                        position[1]+.5-acceleration[1]*accelerationVisualScale);
                            // And the observed acceleration, half as big.
                            // If things are working correctly, this should be in
                            // almost exactly the same direction as the actual acceleration,
                            // so should not not be noticeable.
                            mg.drawLine(position[0]+.5,
                                        position[1]+.5,
                                        position[0]+.5-observedAcceleration[0]*accelerationVisualScale*.5,
                                        position[1]+.5-observedAcceleration[1]*accelerationVisualScale*.5);
                        }
                        if (I >= N-view.nPlansToShow)
                        {
                            com.donhatchsw.compat.ArrayList plannedPositions = new com.donhatchsw.compat.ArrayList();
                            com.donhatchsw.compat.ArrayList plannedAccelerations = new com.donhatchsw.compat.ArrayList();

                            SmoothlyVaryingViewingParameter scratchPoint = new SmoothlyVaryingViewingParameter(model.points[I]);

                            double savedPosition[] = new double[2];
                            double savedVelocity[] = new double[2];
                            // save position and velocity
                            scratchPoint.get(savedPosition);
                            scratchPoint.getVelocity(savedVelocity);

                            int skip = 5;
                            for (; scratchPoint.isMoving(); nTimestepsInFuture += skip)
                            {
                                // restore position and velocity for before evolve
                                // (evolve doesn't use prior accelerations so don't bother with those)
                                scratchPoint.setVelocity(savedVelocity);
                                scratchPoint.setPosition(savedPosition);
                                scratchPoint.evolve(model.referenceTripDistancesInPixels[i]/10000.,
                                                       model.referenceTripTimesInRepaints[i],
                                                       nTimestepsInFuture*1., // dt, in repaints
                                                       model.distanceBasedBounce);
                                double plannedPosition[] = new double[2];
                                double plannedAcceleration[] = new double[2];
                                scratchPoint.get(plannedPosition);
                                plannedPositions.add(plannedPosition);
                                scratchPoint.getAcceleration(plannedAcceleration);
                                plannedAccelerations.add(plannedAcceleration);
                            }

                            for (int iPlan = 0; iPlan < plannedPositions.size(); ++iPlan)
                            {
                                double plannedPosition[] = (double[])plannedPositions.get(iPlan);
                                double plannedAcceleration[] = (double[])plannedAccelerations.get(iPlan);
                                mg.drawHollowPoint(plannedPosition[0]+.5,
                                                   plannedPosition[1]+.5,
                                                   2);
                                if (view.showPlanAccelerationsFlag)
                                {
                                    mg.drawLine(plannedPosition[0]+.5,
                                                plannedPosition[1]+.5,
                                                plannedPosition[0]+.5-plannedAcceleration[0]*accelerationVisualScale,
                                                plannedPosition[1]+.5-plannedAcceleration[1]*accelerationVisualScale);
                                }
                            }
                        } // if I >= nPlansToShow
                     } // for j
                } // for i
#endif

                //
                // If anything's still moving, make paint get called again
                //
#if 0
                if (!model.paused)
                {
                    boolean someoneIsStillMoving = false;
                    FORI (I, N)
                    {
                        if (model.points[I].isMoving())
                        {
                            someoneIsStillMoving = true;
                            break;
                        }
                    }
                    if (someoneIsStillMoving)
                        repaint();
                    else
                    {
                        // XXX should do this iff verboseLevel >= 0 ... but currently verboseLevel isn't accessible from here. need to straighten out my thinking
                        //System.out.println("================================================================================================================");
                    }
                }
#endif




                view.nPaintsDone++;
                //if (viewParams.showNumPaintsDone.get())
                {
                    g.setColor(java.awt.Color.white);
                    java.awt.Dimension viewSize = getSize(); // getWidth,getHeight don't exist in 1.1
                    int W = viewSize.width;
                    int H = viewSize.height;
                    com.donhatchsw.awt.MyGraphics mgTemp = new com.donhatchsw.awt.MyGraphics(g, viewSize, 0,W,H,0);
                    mgTemp.drawString("("+view.nPaintsDone+" paint"+(view.nPaintsDone==1?"":"s")+")", W-2, 2, 1, -1.);
                }

                if (g != frontBufferGraphics)
                    frontBufferGraphics.drawImage(backBuffer, 0, 0, this);
                mostRecentGraphics = mg;


                if (eventVerbose >= 2) System.out.println("    out paint");
            } // paint
            {
                addKeyListener(new java.awt.event.KeyAdapter() {
                    public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        boolean controlIsDown = ((e.getModifiers() & java.awt.event.InputEvent.CTRL_MASK) != 0);
                        int keyCode = e.getKeyCode();
                        char c = e.getKeyChar();
                        if (eventVerbose >= 1) System.out.println("    in keyPressed, keyEvent = "+e+" keyChar = (char)"+(int)c+"");

                        if (false) {}
                        else if (keyCode == java.awt.event.KeyEvent.VK_LEFT)
                        {
                        }
                        else if (keyCode == java.awt.event.KeyEvent.VK_RIGHT)
                        {
                        }
                        else if (keyCode == java.awt.event.KeyEvent.VK_UP)
                        {
                        }
                        else if (keyCode == java.awt.event.KeyEvent.VK_DOWN)
                        {
                        }
                        else if (c == java.awt.event.KeyEvent.CHAR_UNDEFINED)
                        {
                            // This is the case for things like arrow keys
                            //System.out.println("CHAR_UNDEFINED");
                        }
                        #define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a'+1)
                        else if (c == java.awt.event.KeyEvent.VK_ESCAPE
                              || c == CTRL('c')) // XXX do I want this? should be control panel I think, if I ever make one for this demo1
                        {
                            System.out.println("ciao!");
                            System.exit(0); // asinine way of doing things
                        }
                        else if (c == 'h')
                        {
                            System.out.println("The following keys do things:");
                            System.out.println("              h - show this help message");
                        }
                        else
                        {
                            System.out.println("Huh?");
                        }
                    }
                });
                addMouseListener(new java.awt.event.MouseListener() {
                    public void mouseClicked(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseClicked at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseClicked");
                    }
                    public void mousePressed(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mousePressed at "+e.getX()+","+e.getY()+"");
                        // XXX dup code
                        if (mostRecentGraphics != null)
                        {
                            double thisPoint[] = new double[2];
                            mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                            if (eventVerbose >= 1) System.out.println("        thisPoint = "+Arrays.toStringCompact(thisPoint));
                            // do something with it
                            repaint();
                        }
                        if (eventVerbose >= 1) System.out.println("    out mousePressed");
                    }
                    public void mouseReleased(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseReleased at "+e.getX()+","+e.getY()+"");

                        if (eventVerbose >= 1) System.out.println("    out mouseReleased");
                    }
                    public void mouseEntered(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseEntered at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseEntered");
                    }
                    public void mouseExited(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseExited at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseExited");
                    }
                });
                addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                    public void mouseMoved(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 3) System.out.println("    in mouseMoved to "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 3) System.out.println("    out mouseMoved");
                    }
                    public void mouseDragged(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseDragged to "+e.getX()+","+e.getY()+"");
                        if (mostRecentGraphics != null)
                        {
                            double thisPoint[] = new double[2];
                            mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                            // do something with it
                        }
                        if (eventVerbose >= 1) System.out.println("    out mouseDragged");
                    }
                });
            }
        }; // canvas
        canvas.requestFocus(); // seems to be needed initially XXX see whether this is true

        final java.awt.Frame frame = new java.awt.Frame("Optimal Trajectories");
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we)
            {
                frame.dispose();
                System.out.println("ciao!");
                System.exit(0); // asinine way of doing things
            }
        });
        frame.setForeground(java.awt.Color.white);
        frame.setBackground(java.awt.Color.black);
        frame.add(canvas);
        frame.pack();
        frame.show();
    } // interactiveDemo1

    public static void main(String args[])
    {
        System.out.println("in main");
        if (args.length == 1 && args[0].equals("demo1"))
            interactiveDemo1();
        else if (args.length == 1 && args[0].equals("confidenceTests"))
            confidenceTests();
        else
        {
            System.err.println("Usage: CatenaryRotated [demo|confidenceTests]\n");
            System.exit(1);
        }

        System.out.println("out main");
    }

}  // CatenaryRotated
