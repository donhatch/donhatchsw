#include "macros.h"
package com.donhatchsw.util;
/**
* A binary heap whose items are (index,value) pairs
* where the indices are in a known range 0,...,n-1
* and the values are doubles.
* <p>
* The binary heap implementation is described here:
* <a href="http://en.wikipedia.org/wiki/Binary_heap">http://en.wikipedia.org/wiki/Binary_heap</a>
*/
public class IndexBinaryHeap
{
    private double values[];        // index to value
    private int heap[];             // heap index to index
    private int indexToHeapIndex[]; // index to heap index
    private int size;               // size of heap

    /** Constructs a heap whose indices are in the range 0,...,max-1. */
    public IndexBinaryHeap(int max)
    {
        values = VecMath.fillvec(max, Double.NaN);
        heap = VecMath.fillvec(max, -1);
        indexToHeapIndex = VecMath.fillvec(max, -1);
        size = 0;
    }
    /** Adds the given index to the heap, with the given value.  It is an error to call this on an index that is already in the heap. */
    public void add(int index, double val)
    {
        assert(Double.isNaN(values[index]));
        assert(indexToHeapIndex[index] == -1);
        values[index] = val;
        indexToHeapIndex[index] = size;
        heap[size] = index;
        size++;

        adjust(index, val);
    }
    /** Remove the given index from the heap.  It is an error to call this on an index that is not in the heap. */
    public void remove(int index)
    {
        assert(size >= 1);
        assert(!Double.isNaN(values[index]));
        int heapIndex = indexToHeapIndex[index];
        assert(heapIndex != -1);

        values[index] = Double.NaN;
        indexToHeapIndex[index] = -1;
        size--;

        if (heapIndex != size)
        {
            // Move the last heap item into the vacated position
            int indexBeingMoved = heap[size];
            heap[size] = -1;
            heap[heapIndex] = indexBeingMoved;
            indexToHeapIndex[indexBeingMoved] = heapIndex;

            adjust(indexBeingMoved, values[indexBeingMoved]);
        }
        else
        {
            heap[size] = -1;
        }
    }
    /** Returns the index with minimum value, without removing it.  It is an error to call this if the heap is empty. */
    public int min()
    {
        assert(size >= 1);
        return heap[0];
    }
    
    /** Removes and returns the index with minimum value.  It is an error to call this if the heap is empty. */
    public int extractMin()
    {
        int ret = min();
        remove(ret);
        return ret;
    }
    /** Tells whether the heap is empty. */
    public boolean isEmpty()
    {
        return size == 0;
    }
    /** Equivalent to remove(index); add(index,val); but more efficient. */
    public void adjust(int index, double val)
    {
        //System.out.println("in adjust(index="+index+", val="+val+")");
        int heapIndex = indexToHeapIndex[index];
        assert(heapIndex != -1);

        #define HEAP_PARENT(i) (((i)-1)>>1)
        #define HEAP_CHILD0(i) (((i)<<1)+1)
        #define HEAP_CHILD1(i) (((i)<<1)+2)

        int heapIndexParent;
        if (heapIndex > 0
         && val < values[heap[heapIndexParent = HEAP_PARENT(heapIndex)]])
        {
            // trickle up
            //System.out.println("TRICKLING UP");
            do
            {
                // swap heapIndex with heapIndexParent,
                // but don't bother to fill it in at the parent,
                // and ascend
                int indexParent = heap[heapIndexParent];
                heap[heapIndex] = indexParent;
                indexToHeapIndex[indexParent] = heapIndex;
                heapIndex = heapIndexParent;
                // index stays the same
            } while (heapIndex > 0
                  && val < values[heap[heapIndexParent = HEAP_PARENT(heapIndex)]]);
        }
        else
        {
            // trickle down
            //System.out.println("TRICKLING DOWN");
            while (true)
            {
                int heapIndexChild0 = HEAP_CHILD0(heapIndex);
                if (heapIndexChild0 >= size)
                    break; // at leaf of tree; done

                int heapIndexChild1 = HEAP_CHILD1(heapIndex);
                int heapIndexChild = (heapIndexChild1 < size
                                   && values[heap[heapIndexChild1]] < values[heap[heapIndexChild0]] ? heapIndexChild1 : heapIndexChild0);
                if (val > values[heap[heapIndexChild]])
                {
                    // swap with smaller of children,
                    // but don't bother to fill it in at the child,
                    // and descend
                    int indexChild = heap[heapIndexChild];
                    heap[heapIndex] = indexChild;
                    indexToHeapIndex[indexChild] = heapIndex;
                    heapIndex = heapIndexChild;
                    // index stays the same
                }
                else
                    break; // happy with children; done
            }
        }
        heap[heapIndex] = index;
        indexToHeapIndex[index] = heapIndex;
        values[index] = val;
        //System.out.println("out adjust");
    } // adjust


    // totally hacky
    private void print()
    {
        System.out.println("-----");
        PRINT(size);
        PRINTARRAY(heap);
        PRINTARRAY(indexToHeapIndex);
        PRINTARRAY(values);
        System.out.println("-----");
    }
    private void sanityCheck()
    {
        if (false)
        {
            System.out.println("in sanityCheck");
            print();
        }

        int max = values.length;
        assert(max == heap.length);
        assert(max == indexToHeapIndex.length);
        assert(INRANGE(0 <=, size, <= max));

        int nValid = 0;
        int nInvalid = 0;
        FORI (i, max)
        {
            if (indexToHeapIndex[i] != -1)
            {
                assert(!Double.isNaN(values[i]));
                assert(INRANGE(0 <=, indexToHeapIndex[i], < size));
                assert(heap[indexToHeapIndex[i]] == i);
                nValid++;
            }
            else
            {
                assert(Double.isNaN(values[i]));
                nInvalid++;
            }
        }
        assert(nValid == size);
        assert(nValid+nInvalid == max);

        FORI (i, size)
        {
            assert(INRANGE(0 <=, heap[i], < max));
            assert(indexToHeapIndex[heap[i]] == i);
        }
        for (int i = size; i < max; ++i)
        {
            assert(heap[i] == -1);
        }

        for (int i = 1; i < size; ++i) // all but [0]
        {
            assert(values[heap[HEAP_PARENT(i)]] <= values[heap[i]]);
        }
    } // sanityCheck

    // This isn't intended to ever be used externally,
    // it's just for the confidence test.
    private static int[] heapSortWithSanityChecks(double vals[])
    {
        int sortedInds[] = new int[vals.length];
        IndexBinaryHeap heap = new IndexBinaryHeap(vals.length);
        heap.sanityCheck();
        FORI (i, vals.length)
        {
            heap.add(i, vals[i]);
            heap.sanityCheck();
        }
        FORI (i, sortedInds.length)
        {
            assert(!heap.isEmpty());
            sortedInds[i] = heap.extractMin();
            heap.sanityCheck();
        }
        assert(heap.isEmpty());
        return sortedInds;
    } // heapSortWithSanityChecks

    /**
    * Little confidence test program.
    */
    public static void main(String args[])
    {
        System.out.println("in IndexBinaryHeap.main");
        int nMaxes = 15;
        int nSortsPerMax = 15;
        java.util.Random rng = new java.util.Random(0);
        FORI (max, nMaxes)
        {
            FORI (iSort, nSortsPerMax)
            {
                double vals[] = VecMath.random(max, rng);
                PRINTARRAY(vals);
                int sortedInds[] = heapSortWithSanityChecks(vals);
                PRINTARRAY(sortedInds);
                System.out.println("============");
                assert(sortedInds.length == max);
                FORI (i, max-1)
                    assert(vals[sortedInds[i]] <= vals[sortedInds[i+1]]);
                assert(VecMath.sum(sortedInds) == max*(max-1)/2); // if this is right then we probably got all the indices
            }
        }
        System.out.println("ALL GOOD!");
        System.out.println("out IndexBinaryHeap.main");
    }
} // class IndexBinaryHeap

