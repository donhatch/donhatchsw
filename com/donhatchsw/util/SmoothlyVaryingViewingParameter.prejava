package com.donhatchsw.util;
#include "macros.h" 

/**
* Viewing parameters that always change SMOOTHLY
* so I don't have an anxiety attack.  You can knock the target value
* all over the place, and the actual value will smoothly move towards to it,
* without any instantaneous changes in velocity.  Well, except you can tell it to linearly interpolate if you want to.
*/
public class SmoothlyVaryingViewingParameter
{
    private double[] position;
    private double[] velocity;
    private double targetPosition[];

    /** Convenience constructor for a scalar parameter; equivalent to SmoothlyVaryingViewingParameter(new double[]{initialPosition}). */
    public SmoothlyVaryingViewingParameter(double initialPosition)
    {
        // XXX huh?  why can't I do the following? weird, maybe a typo
        //SmoothlyVaryingViewingParameter(new double[]{initialPosition});

        // so copy the code instead...
        this.position = VecMath.copyvec(new double[]{initialPosition});
        this.velocity = new double[this.position.length]; // zero
        this.targetPosition = VecMath.copyvec(new double[]{initialPosition});
    }
    /** Constructor. */
    public SmoothlyVaryingViewingParameter(double initialPosition[])
    {
        this.position = VecMath.copyvec(initialPosition);
        this.velocity = new double[this.position.length]; // zero
        this.targetPosition = VecMath.copyvec(initialPosition);
    }

    /** Sets the target value of this scalar variable. Equivalent to set(new double[]{targetPosition}); */
    public void set(double targetPosition)
    {
        set(new double[]{targetPosition});
    }

    /** Sets the target value of this variable. */
    public void set(double[] targetPosition)
    {
        if (targetPosition.length != this.targetPosition.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: new target has dimension "+targetPosition.length+", expected "+this.targetPosition.length+"");
        VecMath.copyvec(this.targetPosition, targetPosition);
    }
    /** Snaps to the specified position. Equivalent to set(targetPosition) followed by evolve(1.,0.,1.) (i.e. infinite power). */
    public void snap(double[] targetPosition)
    {
        set(targetPosition);
        evolve(1,0,1,0); // infinite power
    }
    /** Snaps to the specified position (scalar version).  Equivalent to snap(new double[]{targetPosition}). */
    public void snap(double targetPosition)
    {
        snap(new double[]{targetPosition});
    }
    /** Warps to the specified position, without changing velocity or target. If you want to do this, you are weird. */
    public void warp(double[] newPosition)
    {
        VecMath.copyvec(this.position, newPosition);
    }
    /** Warps to the specified position (scalar version).  Equivalent to warp(new double[]{targetPosition}). */
    public void warp(double targetPosition)
    {
        warp(new double[]{targetPosition});
    }

    /** Gets the value of this scalar variable now.  Throws an IllegalArgumentException if this parameter was initialized as a vector of dimension other than 1. */
    public double get()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return position[0];
    }
    /** Gets the value of this vector variable now, into the given array. */
    public void get(double position[])
    {
        if (position.length != this.position.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: return buffer size is "+position.length+", expected "+this.position.length+"");
        VecMath.copyvec(position, this.position);
    }
    /** Gets the velocity of this scalar variable now, in case you're interested.  You can't set the velocity directly (except to zero, by calling snap() or the equivalent).  Throws an IllegalArgumentException if this parameter was initialized as a vector of dimension other than 1. */
    // XXX needs a vector version
    public double getVelocity()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return velocity[0];
    }

    // this is PRIVATE. XXX well maybe I shouldn't be so hard-line, if I make it public, change the above comment
    private void setVelocity(double velocity[])
    {
        if (velocity.length != this.velocity.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.setVelocity: new velocity has dimension "+velocity.length+", expected "+this.velocity.length+"");
        VecMath.copyvec(this.velocity, velocity);
    }
    private void setVelocity(double velocity)
    {
        if (this.velocity.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.setVelocity: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        setVelocity(new double[]{velocity});
    }

    /** Gets the target value of this scalar variable now, if it's a scalar, otherwise throws an IllegalArgumentException. */
    // XXX needs a vector version
    public double getTarget()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.getTarget: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return targetPosition[0];
    }


    /**
    * 0: nothing
    * 1: some haphazard stuff
    * 2: more detailed haphazard stuff
    */
    public static int verboseLevel = 0;

    /**
    * Evolves dt seconds towards the target,
    * always pushing with constant-magnitude force
    * (possibly with a mid-trip thrust reversal).
    * <p>
    * You specify the force magnitude by how long it takes
    * to do some reference trip smoothly.
    * For example, if you know you can go 1 mile in 60 seconds,
    * starting and ending smoothly,
    * you would say canonicalTripDistance=1 and canonicalTripTime=60.
    * <p>
    * The acceleration will be equal to
    * 2*canonicalTripDistance/canonicalTripTime<sup>2</sup>.
    * This shows that if you can go 1 mile in 1 second,
    * then you will be able to go 100 miles in 10 seconds
    * (using the same constant acceleration/deceleration magnitude).
    * <p>
    * @param bounce  Set this to a number from 0 to 1.  Setting it to a positive number causes the spring to be underdamped and so it will overshoot and osciallate as it converges on the target.
    */
    public void evolve(double referenceTripDistance,
                       double referenceTripTime,
                       double dt,
                       double bounce)
    {
        if (isMoving())
        {
            if (referenceTripTime == 0.)
            {
                if (referenceTripDistance == 0.)
                    throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.evolve: referenceTripDistance/referenceTripTime is 0/0 !?");
                // Infinite power-- bonk it there.
                VecMath.copyvec(this.position, targetPosition);
                VecMath.zerovec(this.velocity);
                return;
            }

            double p_and_v[] = new double[2];
            for (int i = 0; i < position.length; ++i)
            {
                p_and_v[0] = position[i] - targetPosition[i];
                p_and_v[1] = velocity[i];
                update_p_and_v(p_and_v, referenceTripDistance, referenceTripTime, dt, bounce);
                position[i] = p_and_v[0] + targetPosition[i];
                velocity[i] = p_and_v[1];
            }
        }
    } // evolve

    /** Returns true if we are still moving towards the target (i.e. if an evolve() would actually change anything), false otherwise. */
    public boolean isMoving()
    {
        return !VecMath.equalsExactly(position, targetPosition)
             || VecMath.normsqrd(velocity) != 0.;
    }

    private static void update_p_and_v(double p_and_v[/*2*/],
                                       double referenceTripDistance,
                                       double referenceTripTime,
                                       double dt,
                                       double bounce)
    {
        boolean debug = false;
        if (debug) System.out.println("in update_p_and_v");
        assert(bounce >= 0); // XXX make this a bad param exception or something

        // acceleration magnitude...
        double aMag = 4 * referenceTripDistance
                        / SQR(referenceTripTime);
        double p = p_and_v[0];
        double v = p_and_v[1];
        double vSign = (v<0 ? -1. : 1.);
        double vMag = vSign*v;
        if (debug) System.out.println("    p = "+p);
        if (debug) System.out.println("    v = "+v);

        //
        // Call the current time 0.
        // What is the nearest time before and after now
        // that v could be 0,
        // given acceleration magnitude aMag?
        //
        double still_t_after = vMag/aMag;
        double still_p_after = p + vSign*.5*v*v/aMag;
        double still_a_after = -vSign*aMag;

        double still_t_before = -vMag/aMag;
        double still_p_before = p - vSign*.5*v*v/aMag;
        double still_a_before = vSign*aMag;

        double t0, p0, a0;
        if (p*v <= 0 &&
            still_p_after/still_p_before > -bounce) // XXX FIX THIS-- I think there is danger of a zero-divide here?
        {
            // Need to push forward harder... still_before is the relevant one.
            if (debug) System.out.println("    Need to push forward harder... still_before is the relevant one.");
            t0 = still_t_before;
            p0 = still_p_before;
            a0 = still_a_before;

            if (v == 0. && p > 0.)
            {
                // XXX HACK!
                // It was wrong in this case.
                // The following seems to make it work, but
                // need to organize things better so that it's
                // possible to understand what is going on here.
                t0 = still_t_after;
                p0 = still_p_after;
                a0 = still_a_after;
            }
        }
        else
        {
            // Need to be decelerating so we don't over-overshoot.
            if (debug) System.out.println("    Need to be decelerating so we don't over-overshoot.");
            t0 = still_t_after;
            p0 = still_p_after;
            a0 = still_a_after;
        }
        if (debug) System.out.println("    a0 = "+a0);

        // Figure out the position,time,acceleration of the following
        // still point (after the next bounce).
        // From one still point to the next looks just like
        // a scaled reference trip.
        double p1 = -bounce*p0;
        double a1 = -a0;
        double t1 = t0 + Math.sqrt((Math.abs(p1-p0)/referenceTripDistance))
                       * referenceTripTime;

        // Each piece takes sqrt(bounce) as much time as the previous one.
        // So the time at which we will settle is:
        //     t0 + (t1-t0)*(1 + bounce^(1/2) + bounce + bounce^(3/2) + ...)
        //   = t0 + (t1-t0)/(1-sqrt(bounce))
        // Check whether we are being asked to evolve to or beyond
        // the settling time, i.e. whether
        //     dt >= t0 + (t1-t0)/(1-sqrt(bounce))
        // Don't do that division explicitly (in case bounce is very close
        // to 1); instead, check whether:
        //     (dt-t0)*(1-sqrt(bounce)) >= t1-t0
        if ((dt-t0)*(1-Math.sqrt(bounce)) >= t1-t0)
        {
            // Settled
            if (debug) System.out.println("    Settled");
            p = 0;
            v = 0;
        }
        else
        {
            // Not settled.
            if (debug) System.out.println("    Not settled.");
            // Which time segment t_(i-1) .. t_i
            // is dt in?
            int i = 0;
            double p_iminus1 = Double.NaN;
            double t_iminus1 = Double.NaN;
            double a_iminus1 = Double.NaN;
            double t_i = t0;
            double p_i = p0;
            double a_i = a0;
            while (dt > t_i)
            {
                p_iminus1 = p_i;
                t_iminus1 = t_i;
                a_iminus1 = a_i;
                i++;
                p_i = -bounce * p_iminus1;
                a_i = -a_iminus1;
                // XXX note first one is redundant with calculation of t1 above, should try to consolidate
                t_i += Math.sqrt((Math.abs(p_i-p_iminus1)/referenceTripDistance))
                     * referenceTripTime;
                if (i > 1000*1000)
                {
                    // Ridiculous number of iterations.
                    // We are probably very close to the settling point,
                    // and stuck due to floating point roundoff error.
                    assert(false); // coverage
                    p_and_v[0] = 0;
                    p_and_v[1] = 0;
                    return;
                }
            }
            if (debug) System.out.println("    i = "+i);
            double frac = i==0 ? 1. : (dt-t_iminus1)/(t_i-t_iminus1);
            if (debug) System.out.println("    frac = "+frac);
            //frac = 0; // XXX get rid
            if (frac < .5)
            {
                // Follow the parabola forwards
                // from the previous still point t_iminus1,p_iminus1
                v = (dt-t_iminus1) * a_iminus1;
                p = p_iminus1 + .5*a_iminus1*SQR(dt-t_iminus1);
                if (debug) System.out.println("    a_iminus1 = "+a_iminus1);
                if (debug) System.out.println("    p = "+p);
                if (debug) System.out.println("    v = "+v);
            }
            else
            {
                // Follow the parabola backwards
                // from the next still point t_i,p_i
                v = (t_i-dt) * -a_i;
                p = p_i - .5* -a_i *SQR(t_i-dt);
            }
        }
        p_and_v[0] = p;
        p_and_v[1] = v;
        if (debug) System.out.println("out update_p_and_v");
    } // private update_p_and_v



    private static double lerp(double a, double b, double t)
    {
        return a*(1-t) + b*t;
    }




    private static void confidenceTests()
    {
        {
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            x.set(1.);
            PRINT(x.get());
            PRINT(x.getTarget());
            PRINT(x.getVelocity());
            x.evolve(1, 1, .1, 0);
            PRINT(x.get());
            //System.exit(0);
        }
        {
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(1.);
            x.set(0.);
            PRINT(x.get());
            PRINT(x.getTarget());
            PRINT(x.getVelocity());
            x.evolve(1, 1, .1, 0);
            PRINT(x.get());
            //System.exit(0);
        }

        double bounce = 0.; // XXX should write some tests with this
        double eps = 1e-5;
        {
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            x.set(1.);
            // Try the canonical trip: 1 second to go 1 unit of distance,
            // with time steps of 1/10 second.
            // It should get there in exactly 10 steps and then stay there.
            double dt = .1;
            double t = 0.;
            for (int i = 0; i < 15; ++i)
            {
                double p0 = x.get();
                double v0 = x.getVelocity();
                System.out.println("    Before evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p0, v0));
                x.evolve(1,1, dt, bounce);
                t += dt;
                double p1 = x.get();
                double v1 = x.getVelocity();
                System.out.println("     After evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p1, v1));
                if (LT(t,1.,eps))
                    assert(LT(x.get(), 1., eps));
                else
                    assert(x.get() == 1.);
                System.out.println();
            }
            assert(x.get() == 1.);
        }
        System.out.println("================================================");

        {
            //
            // See if we can get it to overshoot,
            // by starting out strong until the halfway point
            // where we have maximum speed and then losing power
            // during the landing.
            //
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            x.set(1.);
            double dt = .1;
            double t = 0.;
            for (int i = 0; i < 55; ++i)
            {
                double p0 = x.get();
                double v0 = x.getVelocity();
                System.out.println("    Before evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p0, v0));
                x.evolve(1,
                         i>=5 ? 2 : 1,   // reduce to half power at i=5
                         dt,
                         bounce);
                t += dt;
                double p1 = x.get();
                double v1 = x.getVelocity();
                System.out.println("     After evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p1, v1));
                if (LEQ(t,2.5,eps))
                    assert(p1 > p0);
                else if (LEQ(t, 5.,eps))
                    assert(p1 < p0);
                else
                    assert(p0 == 1. && p1 == 1.);
                System.out.println();
            }
            assert(x.get() == 1.);
        }

        {
            //
            // Try lots of different trips
            // without changing any strengths midstream.
            // All the trips should end up being scaled
            // versions of the canonical trip... no overshooting,
            // i.e. the position should be monotonically increasing
            // or decreasing towards the target.
            //
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            double canonicalDistances[] = {.1, 1, 10};
            double canonicalTimes[] = {.1, 1, 10};
            double starts[] = {-100, -1, -.1, 0, .1, 1, 100};
            double targets[] = {-100, -1, -.1, 0, .1, 1, 100};
            double nIncrss[] = {.5, 1, 1.5, 2, 2.5, 9.5, 10, 10.5};
            FORI (iCanonicalDistance, canonicalDistances.length)
            FORI (iCanonicalTime, canonicalTimes.length)
            FORI (iStart, starts.length)
            FORI (iTarget, targets.length)
            FORI (iIncr, nIncrss.length)
            {
                System.out.println("================================================");
                double canonicalDistance = canonicalDistances[iCanonicalDistance];
                double canonicalTime = canonicalTimes[iCanonicalTime];
                double start = starts[iStart];
                double target = targets[iTarget];
                double nIncrs = nIncrss[iIncr];
                double dt = canonicalTime / nIncrs; // XXX this doesn't really give good coverage
                PRINT(canonicalDistance);
                PRINT(canonicalTime);
                PRINT(start);
                PRINT(target);
                PRINT(nIncrs);
                PRINT(dt);

                x.snap(start);
                PRINT(x.get());
                PRINT(x.getVelocity());
                assert(x.get() == start);
                assert(x.getVelocity() == 0.);
                assert(!x.isMoving());

                x.set(target);

                int overallDir = LT(start,target,eps) ? 1 : GT(start,target,eps) ? -1 : 0;
                double t = 0.;
                for (int i = 0; i < nIncrs + 5; ++i)
                {
                    double p0 = x.get();
                    double v0 = x.getVelocity();
                    // XXX argh, my printf is too slow for all this
                    if (false)
                        System.out.println("    Before evolve: "+
                            com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                                t, p0, v0));
                    x.evolve(canonicalDistance,canonicalTime, dt, bounce);
                    t += dt;
                    double p1 = x.get();
                    double v1 = x.getVelocity();
                    if (false)
                        System.out.println("     After evolve: "+
                            com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                                t, p1, v1));
                    PRINT(overallDir);
                    PRINT(p0);
                    PRINT(p1);
                    if (overallDir > 0)
                        assert(GEQ(p1,p0,eps));
                    else if (overallDir < 0)
                        assert(LEQ(p1,p0,eps));
                    else
                        assert(EQ(p1,p0,eps));

                    System.out.println();
                }
            }
        }

    } // confidenceTests

    // Trying to visualize the kinodynamic planning problem.
    // not part of the SmoothlyVaryingViewingParameter implementation yet.
    private static void interactiveDemo2()
    {
        final int eventVerbose = 0; // set to something else to debug

        java.awt.Canvas canvas = new java.awt.Canvas() {
            class Model
            {
                double A0[] = {1.5,-.5};
                double At1[] = {1.5,0};
                double A1[] = VecMath.lerp(A0, At1, 1./VecMath.dist(A0,At1));

                // 0: A0
                // 1: A1, to change the angle only
                // 2: At1, to move in and out on the line
                // 3: both A1 and At1-- allow dragging At1 freely
                int pickClosestThing(double x, double y)
                {
                    double dist = VecMath.dist(A0,At1);
                    if (dist == 0.)
                        return 3; // At1 freely, so user can separate them
                    double points[][] = {
                        A0,
                        A1,
                        At1,
                    };
                    double distSqrds[] = new double[points.length];
                    for (int i = 0; i < points.length; ++i)
                        distSqrds[i] = (x-points[i][0])*(x-points[i][0])
                                     + (y-points[i][1])*(y-points[i][1]);

                    double pickRadiusSqrd = .1*.1; // XXX hack-- should be a fixed number of pixels
                    if (distSqrds[0] <= pickRadiusSqrd
                     && distSqrds[0] < distSqrds[1]
                     && distSqrds[0] < distSqrds[2])
                        return 0;

                    if (distSqrds[1] <= pickRadiusSqrd
                     && distSqrds[2] <= pickRadiusSqrd)
                        return 3; // picked both

                    if (distSqrds[1] <= pickRadiusSqrd)
                        return 1;
                    if (distSqrds[2] <= pickRadiusSqrd)
                        return 2;
                    return -1;
                } // pickClosestThing
            }
            Model model = new Model();
            com.donhatchsw.awt.MyGraphics mostRecentGraphics = null;
            double prevPoint[] = null;
            int indexOfThingBeingDragged = -1;

            public java.awt.Dimension getPreferredSize()
            {
                return new java.awt.Dimension(800,800);
                //return new java.awt.Dimension(200,200);
            }


            // Stuff so I don't have to translate from mathematica
            private double[] List(double x, double y) {return new double[]{x,y};}
            private double Power(double x, int y) {assert(y==2); return x*x;}
            private double Power(double x, double y) {return Math.pow(x,y);}
            private double Sqrt(double x) {return Math.sqrt(x);}
            private double Log(double x) {return Math.log(x);}

            /*
                Integral from 0 to t
                of lerp(A0,A1,u)/|lerp(A0,A1,u)| du
            */
            private double[] calcVelocity(double A0[],
                                          double A1[],
                                          double t)
            {
                double x0 = A0[0];
                double y0 = A0[1];
                double x1 = A1[0];
                double y1 = A1[1];
                return
List(-(((-x0 + x1)*Sqrt(Power(x0, 2) + Power(y0, 2)))/(Power(x0, 2) - 
                2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2))) + ((-x0 + x1)*
            Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 2*(-1 + t)*t*x0*x1 + 
                Power(y0, 2) + 
                Power(t, 2)*(Power(x1, 2) + Power(y0 - y1, 2)) - 
                2*t*y0*(y0 - y1)))/(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
            Power(y0 - y1, 2)) - ((y0 - y1)*(x1*y0 - x0*y1)*
              Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                            Sqrt(Power(x0, 2) + Power(y0, 2))*
                              Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)) + y0*y1))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0 - y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5) + ((y0 - y1)*(x1*y0 - x0*y1)*
              Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                            t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                            Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 
                                  2*(-1 + t)*t*x0*x1 + Power(y0, 2) + 
                                  Power(t, 
                                      2)*(Power(x1, 2) + Power(y0 - y1, 2)) - 
                                  2*t*y0*(y0 - y1))*
                              Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)) + y0*y1 - 2*t*y0*y1 + 
                            t*Power(y1, 2)))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0 - y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5), -((Sqrt(Power(x0, 2) + Power(y0, 2))*(-y0 + y1))/(Power(x0, 
                    2) - 2*x0*x1 + Power(x1, 2) + 
                Power(y0 - y1, 2))) + (Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 
                2*(-1 + t)*t*x0*x1 + Power(y0, 2) + 
                Power(t, 2)*(Power(x1, 2) + Power(y0 - y1, 2)) - 
                2*t*y0*(y0 - y1))*(-y0 + y1))/(Power(x0, 2) - 2*x0*x1 + 
            Power(x1, 2) + 
            Power(y0 - y1, 2)) - ((x0 - x1)*(-(x1*y0) + x0*y1)*
              Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                            Sqrt(Power(x0, 2) + Power(y0, 2))*
                              Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)) + y0*y1))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0 - y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5) + ((x0 - x1)*(-(x1*y0) + x0*y1)*
              Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                            t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                            Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 
                                  2*(-1 + t)*t*x0*x1 + Power(y0, 2) + 
                                  Power(t, 
                                      2)*(Power(x1, 2) + Power(y0 - y1, 2)) - 
                                  2*t*y0*(y0 - y1))*
                              Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)) + y0*y1 - 2*t*y0*y1 + 
                            t*Power(y1, 2)))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0 - y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5));
            } // calcVelocity
            /*
                Integral from 0 to t
                of integral from 0 to u
                of lerp(A0,A1,v)/|lerp(A0,A1,v)| dv du
            */
            private double[] calcPosition(double A0[],
                                          double A1[],
                                          double t)
            {
                double x0 = A0[0];
                double y0 = A0[1];
                double x1 = A1[0];
                double y1 = A1[1];
                return
List((t*(x0 - x1)*Sqrt(Power(x0, 2) + Power(y0, 2)))/(Power(x0, 2) - 
            2*x0*x1 + Power(x1, 2) + 
            Power(y0 - y1, 2)) - ((y0 - y1)*(x1*y0 - x0*y1)*
            Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + Power(t, 2)*Power(x0, 2) + 
                2*t*x0*x1 - 2*Power(t, 2)*x0*x1 + Power(t, 2)*Power(x1, 2) + 
                Power(y0, 2) - 2*t*Power(y0, 2) + Power(t, 2)*Power(y0, 2) + 
                2*t*y0*y1 - 2*Power(t, 2)*y0*y1 + 
                Power(t, 2)*Power(y1, 2)))/(Power(Power(x0, 2) - 2*x0*x1 + 
                Power(x1, 2) + Power(y0 - y1, 2), 1.5)*
            Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2))) + ((-x0 + x1)*
            Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 2*(-1 + t)*x0*x1 - 
                2*Power(-1 + t, 2)*x0*x1 + Power(x1, 2) + 
                2*(-1 + t)*Power(x1, 2) + Power(-1 + t, 2)*Power(x1, 2) + 
                Power(-1 + t, 2)*Power(y0, 2) - 2*(-1 + t)*y0*y1 - 
                2*Power(-1 + t, 2)*y0*y1 + Power(y1, 2) + 
                2*(-1 + t)*Power(y1, 2) + 
                Power(-1 + t, 2)*Power(y1, 2))*((-1 + t)/
                  2. - (x0*x1 - Power(x1, 2) + y0*y1 - 
                      Power(y1, 2))/(2.*(Power(x0, 2) - 2*x0*x1 + 
                          Power(x1, 2) + Power(y0, 2) - 2*y0*y1 + 
                          Power(y1, 2)))))/(Power(x0, 2) - 2*x0*x1 + 
            Power(x1, 2) + Power(y0, 2) - 2*y0*y1 + 
            Power(y1, 2)) + (t*(y0 - y1)*(-(x1*y0) + x0*y1)*
              Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                            Sqrt(Power(x0, 2) + Power(y0, 2))*
                              Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)) + y0*y1))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0 - y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5) + ((-2*
                    Sqrt(Power(x0, 2) + Power(y0, 2))*(y0 - y1)*(-(x1*y0) + 
                        x0*y1))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2) + ((x0 - x1)*
                    Sqrt(Power(x0, 2) + Power(y0, 2))*(-Power(x0, 2) + 
                        x0*x1 + y0*(-y0 + y1)))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2) - (2*(Power(x0, 2) - x0*x1 + y0*(y0 - y1))*(y0 - 
                        y1)*(-(x1*y0) + 
                        x0*y1)*(Log(2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                                  Sqrt(Power(x0, 2) + Power(y0, 2))*
                                    Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                  y0*y1)) - 
                        Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                                        Sqrt(Power(x0, 2) + Power(y0, 2))*
                                        Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                        y0*y1))/
                                Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)))))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2.5) + ((x0 - x1)*Power(x1*y0 - x0*y1, 2)*
                    Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                                  Sqrt(Power(x0, 2) + Power(y0, 2))*
                                    Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                  y0*y1))/
                          Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                            Power(y0 - y1, 2))))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2.5) - (2*(Power(x0, 2) - x0*x1 + y0*(y0 - y1))*(y0 - 
                        y1)*(-(x1*y0) + x0*y1)*
                    Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                                  Sqrt(Power(x0, 2) + Power(y0, 2))*
                                    Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                  y0*y1))/
                          Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                            Power(y0 - y1, 2))))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 2.5))/
        2. + ((-x0 + x1)*Power(-(x1*y0) + x0*y1, 2)*
            Log((2*((-1 + t)*Power(x0, 2) - x0*x1 - 2*(-1 + t)*x0*x1 + 
                            Power(x1, 2) + (-1 + t)*Power(x1, 2) + (-1 + t)*
                              Power(y0, 2) - y0*y1 - 2*(-1 + t)*y0*y1 + 
                            Power(y1, 2) + (-1 + t)*Power(y1, 2)))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0, 2) - 2*y0*y1 + Power(y1, 2)) + 
                2*Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 2*(-1 + t)*x0*x1 - 
                      2*Power(-1 + t, 2)*x0*x1 + Power(x1, 2) + 
                      2*(-1 + t)*Power(x1, 2) + 
                      Power(-1 + t, 2)*Power(x1, 2) + 
                      Power(-1 + t, 2)*Power(y0, 2) - 2*(-1 + t)*y0*y1 - 
                      2*Power(-1 + t, 2)*y0*y1 + Power(y1, 2) + 
                      2*(-1 + t)*Power(y1, 2) + 
                      Power(-1 + t, 2)*Power(y1, 2))))/(2.*
            Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2), 2.5)) + (t*(y0 - y1)*(x1*y0 - x0*y1)*
              Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                            t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                            y0*y1 - 2*t*y0*y1 + t*Power(y1, 2) + 
                            Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                              Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                                  Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                                  2*Power(t, 2)*x0*x1 + 
                                  Power(t, 2)*Power(x1, 2) + Power(y0, 2) - 
                                  2*t*Power(y0, 2) + 
                                  Power(t, 2)*Power(y0, 2) + 2*t*y0*y1 - 
                                  2*Power(t, 2)*y0*y1 + 
                                  Power(t, 2)*Power(y1, 2))))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0, 2) - 2*y0*y1 + Power(y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5) + ((y0 - y1)*(x1*y0 - x0*y1)*(-Power(x0, 2) + x0*x1 - 
                Power(y0, 2) + y0*y1)*
            Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                          t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                          y0*y1 - 2*t*y0*y1 + t*Power(y1, 2) + 
                          Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                            Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                                Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                                2*Power(t, 2)*x0*x1 + 
                                Power(t, 2)*Power(x1, 2) + Power(y0, 2) - 
                                2*t*Power(y0, 2) + Power(t, 2)*Power(y0, 2) + 
                                2*t*y0*y1 - 2*Power(t, 2)*y0*y1 + 
                                Power(t, 2)*Power(y1, 2))))/
                  Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                    2*y0*y1 + Power(y1, 2))))/(Power(Power(x0, 2) - 2*x0*x1 + 
                Power(x1, 2) + Power(y0 - y1, 2), 
              1.5)*(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2))) + ((y0 - y1)*(x1*y0 - 
                x0*y1)*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                y0*y1)*(-Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 
                                2*t*x0*x1 + t*Power(x1, 2) - Power(y0, 2) + 
                                t*Power(y0, 2) + y0*y1 - 2*t*y0*y1 + 
                                t*Power(y1, 2) + 
                                Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                      Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                                  Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                                      Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                                      2*Power(t, 2)*x0*x1 + 
                                      Power(t, 2)*Power(x1, 2) + 
                                      Power(y0, 2) - 2*t*Power(y0, 2) + 
                                      Power(t, 2)*Power(y0, 2) + 2*t*y0*y1 - 
                                      2*Power(t, 2)*y0*y1 + 
                                      Power(t, 2)*Power(y1, 2))))/
                        Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                          Power(y0, 2) - 2*y0*y1 + Power(y1, 2))) + 
                Log(2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                            t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                            y0*y1 - 2*t*y0*y1 + t*Power(y1, 2)) + 
                      2*Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                            Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                        Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                            Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                            2*Power(t, 2)*x0*x1 + Power(t, 2)*Power(x1, 2) + 
                            Power(y0, 2) - 2*t*Power(y0, 2) + 
                            Power(t, 2)*Power(y0, 2) + 2*t*y0*y1 - 
                            2*Power(t, 2)*y0*y1 + 
                            Power(t, 2)*Power(y1, 2)))))/(Power(Power(x0, 
                    2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
              1.5)*(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2))), (t*
            Sqrt(Power(x0, 2) + Power(y0, 2))*(y0 - y1))/(Power(x0, 2) - 
            2*x0*x1 + Power(x1, 2) + 
            Power(y0 - y1, 2)) - ((x0 - x1)*(-(x1*y0) + x0*y1)*
            Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + Power(t, 2)*Power(x0, 2) + 
                2*t*x0*x1 - 2*Power(t, 2)*x0*x1 + Power(t, 2)*Power(x1, 2) + 
                Power(y0, 2) - 2*t*Power(y0, 2) + Power(t, 2)*Power(y0, 2) + 
                2*t*y0*y1 - 2*Power(t, 2)*y0*y1 + 
                Power(t, 2)*Power(y1, 2)))/(Power(Power(x0, 2) - 2*x0*x1 + 
                Power(x1, 2) + Power(y0 - y1, 2), 1.5)*
            Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2))) + ((-y0 + y1)*
            Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 2*(-1 + t)*x0*x1 - 
                2*Power(-1 + t, 2)*x0*x1 + Power(x1, 2) + 
                2*(-1 + t)*Power(x1, 2) + Power(-1 + t, 2)*Power(x1, 2) + 
                Power(-1 + t, 2)*Power(y0, 2) - 2*(-1 + t)*y0*y1 - 
                2*Power(-1 + t, 2)*y0*y1 + Power(y1, 2) + 
                2*(-1 + t)*Power(y1, 2) + 
                Power(-1 + t, 2)*Power(y1, 2))*((-1 + t)/
                  2. - (x0*x1 - Power(x1, 2) + y0*y1 - 
                      Power(y1, 2))/(2.*(Power(x0, 2) - 2*x0*x1 + 
                          Power(x1, 2) + Power(y0, 2) - 2*y0*y1 + 
                          Power(y1, 2)))))/(Power(x0, 2) - 2*x0*x1 + 
            Power(x1, 2) + Power(y0, 2) - 2*y0*y1 + 
            Power(y1, 2)) - (t*(x0 - x1)*(-(x1*y0) + x0*y1)*
              Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                            Sqrt(Power(x0, 2) + Power(y0, 2))*
                              Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)) + y0*y1))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0 - y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5) + ((2*(x0 - x1)*
                    Sqrt(Power(x0, 2) + Power(y0, 2))*(-(x1*y0) + x0*y1))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2) + (Sqrt(Power(x0, 2) + Power(y0, 2))*(y0 - 
                        y1)*(-Power(x0, 2) + x0*x1 + y0*(-y0 + y1)))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2) + ((y0 - y1)*Power(x1*y0 - x0*y1, 2)*
                    Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                                  Sqrt(Power(x0, 2) + Power(y0, 2))*
                                    Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                  y0*y1))/
                          Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                            Power(y0 - y1, 2))))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2.5) + (2*(x0 - x1)*(Power(x0, 2) - x0*x1 + 
                        y0*(y0 - y1))*(-(x1*y0) + x0*y1)*
                    Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                                  Sqrt(Power(x0, 2) + Power(y0, 2))*
                                    Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                  y0*y1))/
                          Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                            Power(y0 - y1, 2))))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 
                2.5) - (2*(x0 - x1)*(Power(x0, 2) - x0*x1 + 
                        y0*(y0 - y1))*(-(x1*y0) + 
                        x0*y1)*(-Log(2*(-Power(x0, 2) + x0*x1 - 
                                  Power(y0, 2) + 
                                  Sqrt(Power(x0, 2) + Power(y0, 2))*
                                    Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                  y0*y1)) + 
                        Log((2*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                                        Sqrt(Power(x0, 2) + Power(y0, 2))*
                                        Sqrt(Power(x0, 2) - 2*x0*x1 + 
                                        Power(x1, 2) + Power(y0 - y1, 2)) + 
                                        y0*y1))/
                                Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0 - y1, 2)))))/
                Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                  Power(y0 - y1, 2), 2.5))/
        2. + ((-y0 + y1)*Power(-(x1*y0) + x0*y1, 2)*
            Log((2*((-1 + t)*Power(x0, 2) - x0*x1 - 2*(-1 + t)*x0*x1 + 
                            Power(x1, 2) + (-1 + t)*Power(x1, 2) + (-1 + t)*
                              Power(y0, 2) - y0*y1 - 2*(-1 + t)*y0*y1 + 
                            Power(y1, 2) + (-1 + t)*Power(y1, 2)))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0, 2) - 2*y0*y1 + Power(y1, 2)) + 
                2*Sqrt(Power(-1 + t, 2)*Power(x0, 2) - 2*(-1 + t)*x0*x1 - 
                      2*Power(-1 + t, 2)*x0*x1 + Power(x1, 2) + 
                      2*(-1 + t)*Power(x1, 2) + 
                      Power(-1 + t, 2)*Power(x1, 2) + 
                      Power(-1 + t, 2)*Power(y0, 2) - 2*(-1 + t)*y0*y1 - 
                      2*Power(-1 + t, 2)*y0*y1 + Power(y1, 2) + 
                      2*(-1 + t)*Power(y1, 2) + 
                      Power(-1 + t, 2)*Power(y1, 2))))/(2.*
            Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2), 
              2.5)) + (t*(x0 - x1)*(-(x1*y0) + x0*y1)*
              Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                            t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                            y0*y1 - 2*t*y0*y1 + t*Power(y1, 2) + 
                            Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                  Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                              Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                                  Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                                  2*Power(t, 2)*x0*x1 + 
                                  Power(t, 2)*Power(x1, 2) + Power(y0, 2) - 
                                  2*t*Power(y0, 2) + 
                                  Power(t, 2)*Power(y0, 2) + 2*t*y0*y1 - 
                                  2*Power(t, 2)*y0*y1 + 
                                  Power(t, 2)*Power(y1, 2))))/
                    Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                      Power(y0, 2) - 2*y0*y1 + Power(y1, 2))))/
          Power(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
          1.5) + ((x0 - x1)*(-(x1*y0) + x0*y1)*(-Power(x0, 2) + x0*x1 - 
                Power(y0, 2) + y0*y1)*
            Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                          t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                          y0*y1 - 2*t*y0*y1 + t*Power(y1, 2) + 
                          Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                            Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                                Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                                2*Power(t, 2)*x0*x1 + 
                                Power(t, 2)*Power(x1, 2) + Power(y0, 2) - 
                                2*t*Power(y0, 2) + Power(t, 2)*Power(y0, 2) + 
                                2*t*y0*y1 - 2*Power(t, 2)*y0*y1 + 
                                Power(t, 2)*Power(y1, 2))))/
                  Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                    2*y0*y1 + Power(y1, 2))))/(Power(Power(x0, 2) - 2*x0*x1 + 
                Power(x1, 2) + Power(y0 - y1, 2), 
              1.5)*(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2))) + ((x0 - x1)*(-(x1*y0) + 
                x0*y1)*(-Power(x0, 2) + x0*x1 - Power(y0, 2) + 
                y0*y1)*(-Log((2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 
                                2*t*x0*x1 + t*Power(x1, 2) - Power(y0, 2) + 
                                t*Power(y0, 2) + y0*y1 - 2*t*y0*y1 + 
                                t*Power(y1, 2) + 
                                Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                                      Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                                  Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                                      Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                                      2*Power(t, 2)*x0*x1 + 
                                      Power(t, 2)*Power(x1, 2) + 
                                      Power(y0, 2) - 2*t*Power(y0, 2) + 
                                      Power(t, 2)*Power(y0, 2) + 2*t*y0*y1 - 
                                      2*Power(t, 2)*y0*y1 + 
                                      Power(t, 2)*Power(y1, 2))))/
                        Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                          Power(y0, 2) - 2*y0*y1 + Power(y1, 2))) + 
                Log(2*(-Power(x0, 2) + t*Power(x0, 2) + x0*x1 - 2*t*x0*x1 + 
                            t*Power(x1, 2) - Power(y0, 2) + t*Power(y0, 2) + 
                            y0*y1 - 2*t*y0*y1 + t*Power(y1, 2)) + 
                      2*Sqrt(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + 
                            Power(y0, 2) - 2*y0*y1 + Power(y1, 2))*
                        Sqrt(Power(x0, 2) - 2*t*Power(x0, 2) + 
                            Power(t, 2)*Power(x0, 2) + 2*t*x0*x1 - 
                            2*Power(t, 2)*x0*x1 + Power(t, 2)*Power(x1, 2) + 
                            Power(y0, 2) - 2*t*Power(y0, 2) + 
                            Power(t, 2)*Power(y0, 2) + 2*t*y0*y1 - 
                            2*Power(t, 2)*y0*y1 + 
                            Power(t, 2)*Power(y1, 2)))))/(Power(Power(x0, 
                    2) - 2*x0*x1 + Power(x1, 2) + Power(y0 - y1, 2), 
              1.5)*(Power(x0, 2) - 2*x0*x1 + Power(x1, 2) + Power(y0, 2) - 
                2*y0*y1 + Power(y1, 2))));
            } // calcPosition

            // PAINT
            public void paint(java.awt.Graphics g)
            {
                if (eventVerbose >= 2) System.out.println("    in paint");
                com.donhatchsw.awt.MyGraphics mg = new com.donhatchsw.awt.MyGraphics(g, getSize(),
                                               -1.,5.,-3.,3.);


                java.awt.Color lightBlue = new java.awt.Color(128, 128, 255);

                // Draw a white unit circle around the origin
                mg.setColor(java.awt.Color.white);
                mg.drawArc(-1.,-1.,2.,2.,0.,2*Math.PI);

                int pointSize = 7;

                double A0[] = model.A0;
                double A1[] = model.A1;
                double At1[] = model.At1;
                double a0[] = VecMath.normalize(A0);
                double a1[] = VecMath.normalize(A1);
                double at1[] = VecMath.normalize(At1);

                double v1[] = calcVelocity(A0,A1,1);
                double p1[] = calcPosition(A0,A1,1);
                double t1 = VecMath.dist(A0, At1);
                double vt1[] = calcVelocity(A0,A1,t1);
                double pt1[] = calcPosition(A0,A1,t1);

                // Draw a cyan circle point at the origin,
                // since both v0 (green) and p0 (blue) are there
                mg.setColor(java.awt.Color.cyan);
                mg.drawHollowCirclePoint(0.,0.,
                                         pointSize);

                //
                // Accelerations in red
                //
                mg.setColor(java.awt.Color.red);
                mg.drawHollowCirclePoint(A0[0],
                                         A0[1],
                                         pointSize);
                mg.drawHollowCirclePoint(a0[0],
                                         a0[1],
                                         pointSize);
                mg.drawHollowRegularPolygonPoint(At1[0],
                                                 At1[1],
                                                 3, // triangle
                                                 pointSize+1);
                mg.drawHollowRegularPolygonPoint(at1[0],
                                                 at1[1],
                                                 3, // triangle
                                                 pointSize);

                mg.drawHollowPoint(A1[0],
                                   A1[1],
                                   pointSize);
                mg.drawHollowPoint(a1[0],
                                   a1[1],
                                   pointSize);

                //
                // Velocities in green
                //
                mg.setColor(java.awt.Color.green);
                mg.drawHollowPoint(v1[0],
                                   v1[1],
                                   pointSize);
                mg.drawHollowRegularPolygonPoint(vt1[0],
                                                 vt1[1],
                                                 3, // triangle
                                                 pointSize+1);
                //
                // Positions in blue
                //
                mg.setColor(lightBlue);
                mg.drawHollowPoint(p1[0],
                                   p1[1],
                                   pointSize);
                mg.drawHollowRegularPolygonPoint(pt1[0],
                                                 pt1[1],
                                                 3, // triangle
                                                 pointSize+1);



                int nSubdivs = 10;
                for (int i = 0; i <= t1 * nSubdivs; ++i)
                {
                    double t = (double)i/nSubdivs;
                    double A[] = VecMath.lerp(A0, A1, t);
                    double a[] = VecMath.normalize(A);
                    double v[] = calcVelocity(A0, A1, t);
                    double p[] = calcPosition(A0, A1, t);

                    mg.setColor(java.awt.Color.red);
                    mg.drawPoint(A[0],A[1], 3);
                    mg.drawPoint(a[0],a[1], 3);
                    mg.setColor(java.awt.Color.green);
                    mg.drawPoint(v[0],v[1], 3);
                    mg.setColor(lightBlue);
                    mg.drawPoint(p[0],p[1], 3);
                }



                int w = getSize().width;
                int h = getSize().height;
                g.setColor(java.awt.Color.red);
                g.drawString("Acceleration (drag the circle, square, and triangle around)", 20, h - 60);
                g.setColor(java.awt.Color.green);
                g.drawString("Velocity", 20, h - 40);
                g.setColor(lightBlue);
                g.drawString("Position", 20, h - 20);
                           
                mostRecentGraphics = mg;

                if (eventVerbose >= 2) System.out.println("    out paint");
            } // paint
            {
                addMouseListener(new java.awt.event.MouseListener() {
                    public void mouseClicked(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseClicked at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseClicked");
                    }
                    public void mousePressed(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mousePressed at "+e.getX()+","+e.getY()+"");

                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                        indexOfThingBeingDragged = model.pickClosestThing(thisPoint[0], thisPoint[1]);
                        if (eventVerbose >= 1) PRINT(indexOfThingBeingDragged);

                        prevPoint = thisPoint;
                        if (eventVerbose >= 1) System.out.println("    out mousePressed");
                    }
                    public void mouseReleased(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseReleased at "+e.getX()+","+e.getY()+"");

                        if (eventVerbose >= 1) System.out.println("    out mouseReleased");
                    }
                    public void mouseEntered(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseEntered at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseEntered");
                    }
                    public void mouseExited(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseExited at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseExited");
                    }
                });
                addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                    public void mouseMoved(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 3) System.out.println("    in mouseMoved to "+e.getX()+","+e.getY()+"");
                        if (mostRecentGraphics != null)
                        {
                            double thisPoint[] = new double[2];
                            mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                            prevPoint = thisPoint;
                        }
                        if (eventVerbose >= 3) System.out.println("    out mouseMoved");
                    }
                    public void mouseDragged(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseDragged to "+e.getX()+","+e.getY()+"");
                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);

                        double delta[] = VecMath.vmv(thisPoint, prevPoint);
                        if (indexOfThingBeingDragged == 0)
                        {
                            // dragging A0 drags the whole line
                            VecMath.vpv(model.A0,model.A0, delta);
                            VecMath.vpv(model.At1,model.At1, delta);
                        }
                        else if (indexOfThingBeingDragged == 1)
                        {
                            // dragging A1 spins the line around A0,
                            // and recalculate At1.
                            double thisTheta = Math.atan2(thisPoint[1]-model.A0[1],
                                                          thisPoint[0]-model.A0[0]);
                            double prevTheta = Math.atan2(prevPoint[1]-model.A0[1],
                                                          prevPoint[0]-model.A0[0]);
                            double thetaDelta = thisTheta - prevTheta;
                            double oldTheta = Math.atan2(model.At1[1]-model.A0[1],
                                                         model.At1[0]-model.A0[0]);
                            double newTheta = oldTheta + thetaDelta;
                            model.A1[0] = model.A0[0] + Math.cos(newTheta);
                            model.A1[1] = model.A0[1] + Math.sin(newTheta);
                            double t1 = VecMath.dist(model.A0, model.At1);
                            VecMath.lerp(model.At1, model.A0, model.A1, t1);
                        }
                        else if (indexOfThingBeingDragged == 2)
                        {
                            // dragging At1 just moves At1 in the line dir.
                            // Project delta onto the line direction
                            double lineDir[] = VecMath.normalize(VecMath.vmv(model.At1, model.A0));
                            VecMath.vxs(delta, lineDir, VecMath.dot(delta, lineDir));
                            VecMath.vpv(model.At1,model.At1, delta);
                        }
                        else if (indexOfThingBeingDragged == 3)
                        {
                            // picked both A1 and At1--
                            // allow At1 to move freely,
                            // then recalculate A1
                            VecMath.vpv(model.At1,model.At1, delta);
                            double t1 = VecMath.dist(model.A0, model.At1);
                            if (t1 != 0.)
                                VecMath.lerp(model.A1, model.A0, model.At1, 1./t1);
                        }
                        repaint();

                        prevPoint = thisPoint;
                        if (eventVerbose >= 1) System.out.println("    out mouseDragged");
                    }
                });
            }
        }; // canvas
        canvas.requestFocus(); // seems to be needed initially XXX see whether this is true

        final java.awt.Frame frame = new java.awt.Frame("Smoothly Varying Viewing Parameters");
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we)
            {
                frame.dispose();
                System.out.println("ciao!");
                System.exit(0); // asinine way of doing things
            }
        });
        frame.setForeground(java.awt.Color.white);
        frame.setBackground(java.awt.Color.black);
        frame.add(canvas);
        frame.pack();
        frame.show();
    } // interactiveDemo2

    private static void interactiveDemo()
    {
        final int eventVerbose = 0; // set to something else to debug

        java.awt.Canvas canvas = new java.awt.Canvas() {

            class Model
            {
                double referenceTripDistance = .5;
                double referenceTripTime = .5;
                //double unclampedBounce = .5;
                double unclampedBounce = 0.;
                //double segmentEndPoints[][] = {{-.6,.4},{-.5,.5}};
                //double segmentEndPoints[][] = {{-.6,.5},{-.5,.5}};
                double segmentEndPoints[][] = {{-.6,.0},{-.5,.0}};

                // 0: segment endpoint 0
                // 1: segment endpoint 1
                // 2: ref trip end
                // 3: bounce point
                int pickClosestThing(double x, double y)
                {
                    double points[][] = {
                        segmentEndPoints[0],
                        segmentEndPoints[1],
                        {-1+referenceTripTime,
                         -1+referenceTripDistance},
                        {-1+referenceTripTime*(1+Math.sqrt(Math.max(unclampedBounce,0))),
                         -1+referenceTripDistance*(1-Math.max(unclampedBounce,0))},
                    };
                    int bestI = -1;
                    double bestDistSqrd = Double.POSITIVE_INFINITY;
                    for (int i = 0; i < points.length; ++i)
                    {
                        double thisDistSqrd = (x-points[i][0])*(x-points[i][0])
                                            + (y-points[i][1])*(y-points[i][1]);
                        if (thisDistSqrd < bestDistSqrd)
                        {
                            bestI = i;
                            bestDistSqrd = thisDistSqrd;
                        }
                        // Special case-- if bounce is 0,
                        // then ref trip end and bounce point are the same...
                        // in this case prefer the bounce point
                        // iff pick point is to the right.
                        if (thisDistSqrd == bestDistSqrd
                         && bestI == 2
                         && i == 3
                         && x > points[i][0])
                        {
                            bestI = i;
                            bestDistSqrd = thisDistSqrd;
                        }
                    }
                    return bestI;
                } // pickClosestThing
            }
            Model model = new Model();
            com.donhatchsw.awt.MyGraphics mostRecentGraphics = null;
            double prevPoint[] = null;
            int indexOfThingBeingDragged = -1;

            public java.awt.Dimension getPreferredSize()
            {
                //return new java.awt.Dimension(800,800);
                return new java.awt.Dimension(200,200);
            }
            // PAINT
            public void paint(java.awt.Graphics g)
            {
                if (eventVerbose >= 2) System.out.println("    in paint");
                com.donhatchsw.awt.MyGraphics mg = new com.donhatchsw.awt.MyGraphics(g, getSize(),
                                               -1.,1.,-1.,1.);

                // Draw the reference trip endpoints
                mg.setColor(java.awt.Color.red);
                mg.drawString("Ref trip", -1+model.referenceTripTime,
                                          -1+model.referenceTripDistance,
                                          -1.1, 1.1); // bleah, give it a tiny bit of space
                mg.drawPoint(-1+model.referenceTripTime,
                             -1+model.referenceTripDistance,
                             3);
                double bounce = Math.max(model.unclampedBounce, 0);
                // And where we think the first bounce will be
                mg.drawPoint(-1+model.referenceTripTime*(1+Math.sqrt(bounce)),
                             -1+model.referenceTripDistance*(1-bounce),
                             3);
                // And the second one
                if (false) // nah, can't drag it so it's confusing
                    mg.drawPoint(-1+model.referenceTripTime*(1+Math.sqrt(bounce+bounce)),
                                 -1+model.referenceTripDistance*(1-bounce+bounce*bounce),
                                 3);

                // Draw the reference trip
                {
                    SmoothlyVaryingViewingParameter param = new SmoothlyVaryingViewingParameter(-1.);
                    // Concoct a target so that the first upward piece
                    // goes to exactly referenceTripDistance.
                    // So it should be -1 + refTripDistance * 
                    //                  (1 - b + b^2 - ...)
                    param.set(-1. + model.referenceTripDistance / (1.+bounce));

                    double dt = 1/1000.;
                    double t = -1.;
                    FORI (i, 2000+1)
                    {
                        param.evolve(model.referenceTripDistance,
                                     model.referenceTripTime,
                                     dt,
                                     bounce);
                        t += dt;
                        mg.drawPoint(t, param.get(), 1);
                    }
                }

                if (true)
                {
                    double x0 = model.segmentEndPoints[0][0];
                    double y0 = model.segmentEndPoints[0][1];
                    double x1 = model.segmentEndPoints[1][0];
                    double y1 = model.segmentEndPoints[1][1];

                    if (x0 > x1)
                    {
                        double temp;
                        SWAP(x0,x1,temp);
                        SWAP(y0,y1,temp);
                    }

                    // Draw the segment endpoints
                    mg.setColor(java.awt.Color.getHSBColor(.75f, 1.f, 1.f));
                    mg.drawPoint(x0,y0, 5);
                    mg.drawPoint(x1,y1, 5);
                    // Draw the segment
                    FORI (i, 1000+1)
                    {
                        double t = i/1000.;
                        mg.drawPoint(lerp(x0,x1,t),
                                     lerp(y0,y1,t),
                                     1);
                    }
                    // Draw the forward trip
                    if (x1 != x0)
                    {
                        assert(x1 > x0);
                        double v = (y1-y0)/(x1-x0);
                        SmoothlyVaryingViewingParameter param = new SmoothlyVaryingViewingParameter(y1);
                        param.set(0.); // target
                        param.setVelocity(v);
                        double t = x1;
                        double dt = 1/1000.;
                        FORI (i, 2000+1)
                        {
                            param.evolve(model.referenceTripDistance,
                                         model.referenceTripTime,
                                         dt,
                                         bounce);
                            t += dt;
                            mg.drawPoint(t, param.get(), 1);
                        }
                    }
                    // Draw the backward trip
                    if (x1 != x0)
                    {
                        assert(x1 > x0);
                        double v = -(y1-y0)/(x1-x0);
                        SmoothlyVaryingViewingParameter param = new SmoothlyVaryingViewingParameter(y0);
                        param.set(0.); // target
                        param.setVelocity(v);
                        double t = x0;
                        double dt = 1/1000.;
                        FORI (i, 2000+1)
                        {
                            param.evolve(model.referenceTripDistance,
                                         model.referenceTripTime,
                                         dt,
                                         bounce);
                            t -= dt;
                            mg.drawPoint(t, param.get(), 1);
                        }
                    }
                }

                mostRecentGraphics = mg;

                if (eventVerbose >= 2) System.out.println("    out paint");
            }
            {
                addMouseListener(new java.awt.event.MouseListener() {
                    public void mouseClicked(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseClicked at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseClicked");
                    }
                    public void mousePressed(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mousePressed at "+e.getX()+","+e.getY()+"");

                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                        indexOfThingBeingDragged = model.pickClosestThing(thisPoint[0], thisPoint[1]);
                        if (eventVerbose >= 1) PRINT(indexOfThingBeingDragged);

                        prevPoint = thisPoint;
                        if (eventVerbose >= 1) System.out.println("    out mousePressed");
                    }
                    public void mouseReleased(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseReleased at "+e.getX()+","+e.getY()+"");

                        // no longer dragging-- make it be where it looks like it is
                        model.unclampedBounce = Math.max(model.unclampedBounce, 0);

                        if (eventVerbose >= 1) System.out.println("    out mouseReleased");
                    }
                    public void mouseEntered(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseEntered at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseEntered");
                    }
                    public void mouseExited(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseExited at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseExited");
                    }
                });
                addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                    public void mouseMoved(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 3) System.out.println("    in mouseMoved to "+e.getX()+","+e.getY()+"");
                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                        prevPoint = thisPoint;
                        if (eventVerbose >= 3) System.out.println("    out mouseMoved");
                    }
                    public void mouseDragged(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseDragged to "+e.getX()+","+e.getY()+"");
                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);

                        double delta[] = VecMath.vmv(thisPoint, prevPoint);
                        if (indexOfThingBeingDragged == 0)
                            VecMath.vpv(model.segmentEndPoints[0], model.segmentEndPoints[0], delta);
                        else if (indexOfThingBeingDragged == 1)
                            VecMath.vpv(model.segmentEndPoints[1], model.segmentEndPoints[1], delta);
                        else if (indexOfThingBeingDragged == 2)
                        {
                            model.referenceTripTime += delta[0];
                            model.referenceTripDistance += delta[1];
                        }
                        else if (indexOfThingBeingDragged == 3)
                        {
                            double bouncePoint = -1+model.referenceTripDistance*(1-model.unclampedBounce);
                            bouncePoint += delta[1];
                            model.unclampedBounce = 1 - (bouncePoint - -1)/model.referenceTripDistance;
                        }
                        repaint();

                        prevPoint = thisPoint;
                        if (eventVerbose >= 1) System.out.println("    out mouseDragged");
                    }
                });
            }
        }; // new Canvas

        canvas.requestFocus(); // seems to be needed initially XXX see whether this is true

        final java.awt.Frame frame = new java.awt.Frame("Smoothly Varying Viewing Parameters");
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent we)
            {
                frame.dispose();
                System.out.println("ciao!");
                System.exit(0); // asinine way of doing things
            }
        });
        frame.setForeground(java.awt.Color.white);
        frame.setBackground(java.awt.Color.black);
        frame.add(canvas);
        frame.pack();
        frame.show();
    } // interactiveDemo



    /** Test program. */
    public static void main(String args[])
    {
        System.out.println("in main");

        boolean justDoConfidenceTests = (args.length>0);
        if (justDoConfidenceTests)
            confidenceTests();
        else
        {
            // XXX make option for either
            //interactiveDemo();
            interactiveDemo2();
        }

        System.out.println("out main");
    } // main

} // SmoothlyVaryingViewingParameter



/*
Trying to figure it out for multiple dimensions... it's not separable.
I'm not sure whether the answer is still two quadratics or not,
but let's assume it is, and try solving.
For starters, so it's easy to think about, we will let
the start (not the end) have position and velocity 0.
Given:
        0,0 = position at time t=0
        0,0 = velocity at time t=0
        p1 = px1,py1 = position at time t=t1
        v1 = vx1,vy1 = velocity at time t=t1
Find t0,t1,ax0,ay0,ax1,ay1 such that:
        0 <= t0 <= t1
        a0 = ax0,ay0 = acceleration during first leg [0..t0]
        a1 = ax1,ay1 = acceleration during second leg [t0..t1]
        and a0,a1 are unit length.
i.e. such that:
        v1 == a0*t0 + a1*(t1-t0)
        p1 == .5*a0*t0^2 + a0*t0*(t1-t0) + .5*a1*(t1-t0)^2
        ||a0|| == 1
        ||a1|| == 1
Expanding out the vectors in 2 dimensions using:
        p1 = px1,py1
        v1 = vx1,vy1
        a0 = ax0,ay0
        a1 = ax1,ay1
This means we are trying to solve the following 6 equations
for the 6 variables ax0,ay0,ax1,ay1,t0,t1:
        vx1 == ax0*t0 + ax1*(t1-t0)
        vy1 == ay0*t0 + ay1*(t1-t0)
        px1 == .5*ax0*t0^2 + ax0*t0*(t1-t0) + .5*ax1*(t1-t0)^2
        py1 == .5*ay0*t0^2 + ay0*t0*(t1-t0) + .5*ay1*(t1-t0)^2
        ax0^2 + ay0^2 == 1
        ax1^2 + ay1^2 == 1
So give the following to mathematica:
        Solve[{
            vx1 == ax0*t0 + ax1*(t1-t0),
            vy1 == ay0*t0 + ay1*(t1-t0),
            px1 == .5*ax0*t0^2 + ax0*t0*(t1-t0) + .5*ax1*(t1-t0)^2,
            py1 == .5*ay0*t0^2 + ay0*t0*(t1-t0) + .5*ay1*(t1-t0)^2,
            ax0^2 + ay0^2 == 1,
            ax1^2 + ay1^2 == 1
            }, {ax0,ay0,ax1,ay1,t0,t1}]
Well, mathematica is taking a LONG time on that one.

Well let's try rephrasing it...
This time we'll let the end position and velocity be 0,0.
Given:
        p0 = start position
        v0 = start velocity
Find a,t such that ||a||=1 and such that
intermediate position p = p0 + v0*t + .5*a*t^2  and
intermediate velocity v = v0 + a*t
line up with the origin so that it can be smoothly landed by a parabola
with acceleration 1.
In other words, p,v should satisfy
        p = -.5*v*|v|
i.e.    px,py = -.5*(vx,vy)*Sqrt[vx^2+vy^2]
So we are trying to solve the following 3 equations
for the 3 variables ax,ay,t:
        ax^2+ay^2 == 1
        px0 + vx0*t + .5*ax*t^2 == -.5*(v0x+ax*t)*Sqrt[(v0x+ax*t)^2+(v0y+ay*t)^2]
        py0 + vy0*t + .5*ay*t^2 == -.5*(v0y+ay*t)*Sqrt[(v0x+ax*t)^2+(v0y+ay*t)^2]
So give the following to mathematica:
        Solve[{
            ax^2+ay^2 == 1,
            px0 + vx0*t + .5*ax*t^2 == -.5*(v0x+ax*t)*Sqrt[(v0x+ax*t)^2+(v0y+ay*t)^2],
            py0 + vy0*t + .5*ay*t^2 == -.5*(v0y+ay*t)*Sqrt[(v0x+ax*t)^2+(v0y+ay*t)^2]
            }, {ax,ay,t}]
Bleah, it's taking a long time on that one too,
and eventually ate up all the memory on my machine.

Okay let's try lining up both...
Lining up with the initial p0,v0 means
there is some time t and unit a such that
        v = v0 + a*t
        p = p0 + v0*t + .5*a*t^2
So from the first equation, t = ||v-v0||
and a = (v-v0)/||v-v0||.
Plugging those into the second equation, we get:
        p = p0 + v0*||v-v0|| + .5*(v-v0)/||v-v0||*||v-v0||^2
          = p0 + v0*||v-v0|| + .5*(v-v0)*||v-v0||
          = p0 + .5*(v+v0)*||v-v0||
Matching up this formula for p with the other formula for p,
we get a single vector equation that we want to solve for v:
    -.5*v*||v|| = p0 + .5*(v+v0)*||v-v0||
i.e. two scalar equations that we want to solve for vx,vy:
    -.5*vx*Sqrt[vx^2+vy^2] == px0 + .5*(vx+vx0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2]
    -.5*vy*Sqrt[vx^2+vy^2] == py0 + .5*(vy+vy0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2]
Not sure if we will get better results by squaring both sides, but if we do,
it will be:
    .25*vx^2*(vx^2+vy^2) == (px0 + .5*(vx+vx0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2])^2
    .25*vy^2*(vx^2+vy^2) == (py0 + .5*(vy+vy0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2])^2

So give mathematica either of the following:
    Solve[{-1/2*vx*Sqrt[vx^2+vy^2] == px0 + 1/2*(vx+vx0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2],
           -1/2*vy*Sqrt[vx^2+vy^2] == py0 + 1/2*(vy+vy0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2]},
          {vx,vy}]
    Solve[{1/4*vx^2*(vx^2+vy^2) == (px0 + 1/2*(vx+vx0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2])^2,
           1/4*vy^2*(vx^2+vy^2) == (py0 + 1/2*(vy+vy0)*Sqrt[(vx-vx0)^2+(vy-vy0)^2])^2},
          {vx,vy}]
Same thing, it's eating up all my memory.
Dangit, mathematica seems to be useless for this problem.

Subject: optimal trajectory for smooth landing

I'll rephrase it as "smooth starting" instead of "smooth landing"
because it's an equivalent problem but easier to think about
for what I'm going to say...

Given: initial position 0, initial velocity 0,
final position p1, final velocity v1, and constant acceleration magnitude 1,
in 1 dimension, we know that there is a unique 2-piece quadratic trajectory
that satisfies these constraints.

I said before that this can't be true in >= 2 dimensions
because the number of degrees of freedom is wrong... but now I think
I was mistaken.
In n dimensions, the number of degrees of freedom in the inputs p1,v1 is 2*n.
The two quadratic output trajectories can be parametrized by:
    acceleration during the first part (n-1 degrees of freedom)
    duration of the first part (1 degree of freedom)
    acceleration during the second part (n-1 degrees of freedom)
    duration of the second part (1 degree of freedom)
So the total number of degrees of freedom in the output is 2*n as well.

So, it *might* be true that the general optimal trajectory
between any starting and ending position&velocity, in any number of dimensions,
will always be a 2-piece quadratic spline.

However, finding the two quadratic trajectories, given p1 and v1,
in 2 dimensions, seems to be surprisingly difficult.
I tried to ask mathematica, phrasing it in various different ways,
but it took forever and ate up all my memory every time.

Don

*/




