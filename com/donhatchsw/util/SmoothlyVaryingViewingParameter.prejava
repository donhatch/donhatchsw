package com.donhatchsw.util;
#include "macros.h" 

/**
* Viewing parameters that always change SMOOTHLY
* so I don't have an anxiety attack.  You can knock the target value
* all over the place, and the actual value will smoothly move towards to it,
* without any instantaneous changes in velocity.  Well, except you can tell it to linearly interpolate if you want to.
*/
public class SmoothlyVaryingViewingParameter
{
    private double[] position;
    private double[] velocity;
    private double targetPosition[];

    /** Convenience constructor for a scalar parameter; equivalent to SmoothlyVaryingViewingParameter(new double[]{initialPosition}). */
    public SmoothlyVaryingViewingParameter(double initialPosition)
    {
        // XXX huh?  why can't I do the following? weird, maybe a typo
        //SmoothlyVaryingViewingParameter(new double[]{initialPosition});

        // so copy the code instead...
        this.position = VecMath.copyvec(new double[]{initialPosition});
        this.velocity = new double[this.position.length];
        this.targetPosition = new double[this.position.length];
    }
    /** Constructor. */
    public SmoothlyVaryingViewingParameter(double initialPosition[])
    {
        this.position = VecMath.copyvec(initialPosition);
        this.velocity = new double[this.position.length];
        this.targetPosition = new double[this.position.length];
    }

    /** Sets the target value of this scalar variable. Equivalent to set(new double[]{targetPosition}); */
    public void set(double targetPosition)
    {
        set(new double[]{targetPosition});
    }

    /** Sets the target value of this variable. */
    public void set(double[] targetPosition)
    {
        if (targetPosition.length != this.targetPosition.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: new target has dimension "+targetPosition.length+", expected "+this.targetPosition.length+"");
        VecMath.copyvec(this.targetPosition, targetPosition);
    }
    /** Snaps to the specified position. Equivalent to set(targetPosition) followed by evolve(1.,0.,1.) (i.e. infinite power). */
    public void snap(double[] targetPosition)
    {
        set(targetPosition);
        evolve(1,0,1,1); // infinite power
    }
    /** Snaps to the specified position (scalar version).  Equivalent to snap(new double[]{targetPosition}). */
    public void snap(double targetPosition)
    {
        snap(new double[]{targetPosition});
    }
    /** Warps to the specified position, without changing velocity or target. If you want to do this, you are weird. */
    public void warp(double[] newPosition)
    {
        VecMath.copyvec(this.position, newPosition);
    }
    /** Warps to the specified position (scalar version).  Equivalent to warp(new double[]{targetPosition}). */
    public void warp(double targetPosition)
    {
        warp(new double[]{targetPosition});
    }

    /** Gets the value of this scalar variable now.  Throws an IllegalArgumentException if this parameter was initialized as a vector of dimension other than 1. */
    public double get()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return position[0];
    }
    /** Gets the value of this vector variable now, into the given array. */
    public void get(double position[])
    {
        if (position.length != this.position.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: return buffer size is "+position.length+", expected "+this.position.length+"");
        VecMath.copyvec(position, this.position);
    }
    /** Gets the velocity of this scalar variable now, in case you're interested.  You can't set the velocity directly (except to zero, by calling snap() or the equivalent).  Throws an IllegalArgumentException if this parameter was initialized as a vector of dimension other than 1. */
    // XXX needs a vector version
    public double getVelocity()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return velocity[0];
    }

    /** Gets the target value of this scalar variable now, if it's a scalar, otherwise throws an IllegalArgumentException. */
    // XXX needs a vector version
    public double getTarget()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.getTarget: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return targetPosition[0];
    }


    /**
    * 0: nothing
    * 1: some haphazard stuff
    */
    public static int verboseLevel = 0;

    /**
    * Evolves dt seconds towards the target,
    * always pushing with constant-magnitude force
    * (possibly with a mid-trip thrust reversal).
    * <p>
    * You specify the force magnitude by how long it takes
    * to do some reference trip smoothly.
    * For example, if you know you can go 1 mile in 60 seconds,
    * starting and ending smoothly,
    * you would say canonicalTripDistance=1 and canonicalTripTime=60.
    * <p>
    * The acceleration will be equal to
    * 2*canonicalTripDistance/canonicalTripTime<sup>2</sup>.
    * This shows that if you can go 1 mile in 1 second,
    * then you will be able to go 100 miles in 10 seconds
    * (using the same constant acceleration/deceleration magnitude).
    * <p>
    * @param criticalDampingFraction  Set this to 1.  If you set it to &lt;, you'll get slower progress; if you set it to &gt;1 you will be underdamped and you'll overshoot and oscillate as you converge on the target.
    */
    public void evolve(double referenceTripDistance,
                       double referenceTripTime,
                       double dt,
                       double criticalDampingFraction)
    {
        if (isMoving())
        {
            if (referenceTripTime == 0.)
            {
                if (referenceTripDistance == 0.)
                    throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.evolve: referenceTripDistance/referenceTripTime is 0/0 !?");
                // Infinite power-- bonk it there.
                VecMath.copyvec(this.position, targetPosition);
                VecMath.zerovec(this.velocity);
                return;
            }

            //
            // The internal function
            // takes a potentially different accelerationMultiplier
            // and decelerationMultiplier; however the implementation is such
            // that it will not do the right thing if they are different,
            // so the public API only exposes a single parameter.
            // Also, if we lower the acc/decelerationMultipler,
            // that would mean, of course, that the acceleration
            // felt will be lower... we'd like that to not happen,
            // so fudge referenceTripDistance here so that it doesn't
            // (this works because the acceleration experienced
            // is linearly proportional to referenceTripDistance,
            // see above).
            // XXX Actually maybe this is NOT the right thing to do...
            // XXX it makes the acceleration the same,
            // XXX but it makes it so the time it takes to do the trip
            // XXX is no longer accurate!  But I'm thinking it's more
            // XXX usable this way anyway, the user should think of
            // XXX the referenceTripDistance and referenceTripTime
            // XXX as being if damping were 1... maybe the params
            // XXX should be renamed that?
            // XXX Also if we DIDN'T do this correction,
            // XXX the time estimate still wouldn't be right...
            // XXX we'd have to correct it in a different way,
            // XXX I'm not sure how.
            //
            double accelerationMultiplier = criticalDampingFraction;
            double decelerationMultiplier = criticalDampingFraction;
            referenceTripDistance /= criticalDampingFraction;

            double p_and_v[] = new double[2];
            for (int i = 0; i < position.length; ++i)
            {
                p_and_v[0] = position[i] - targetPosition[i];
                p_and_v[1] = velocity[i];
                update_p_and_v(p_and_v, referenceTripDistance, referenceTripTime, dt, accelerationMultiplier, decelerationMultiplier);
                position[i] = p_and_v[0] + targetPosition[i];
                velocity[i] = p_and_v[1];
            }
        }
    } // evolve

    /** Returns true if we are still moving towards the target (i.e. if an evolve() would actually change anything), false otherwise. */
    public boolean isMoving()
    {
        return !VecMath.equalsExactly(position, targetPosition)
             || VecMath.normsqrd(velocity) != 0.;
    }

    //
    // Let's say we don't know the target time...
    // But we know our maximum acceleration,
    // and we want to get there as quickly as possible
    // without exceeding that acceleration.
    // The solution will be piecewise quadratic; two pieces,
    // the first of which "falls" with constant acceleration towards the target
    // and the second of which decelerates so as to land softly
    // (with zero velocity).
    //
    // So in this case we know:
    //          current position p0
    //          current velocity v0
    //          target position = 0
    //          target velocity = 0
    //          the constant acceleration magnitude
    //             (if it takes 1 second
    //             to take the canonical reference trip of length 1
    //             starting and ending at zero velocity,
    //             then we are following the quadratic 2 t^2
    //             for the first half of the trip (taking it to 1/2 at 1/2),
    //             which means the velocity at any t during the first half
    //             of the trip is 4 t, and the acceleration is 4.
    //             therefore in general we like to do acceleration=4
    //             and we will use it at all times in every trip anywhere.)
    // And we have to figure out the time it should take
    // to make a soft landing at the target position,
    // using this constant acceleration magnitude.
    //          

    private static void update_p_and_v(double p_and_v[/*2*/],
                                       double referenceTripDistance,
                                       double referenceTripTime,
                                       double dt,
                                       double accelerationMultiplier,
                                       double decelerationMultiplier)
    {
        //
        // We need to change units so that referenceTripDistance
        // and referenceTripTime in old units
        // are both 1 in new units.
        // So to convert from old to new units:
        //    - times should get divided by referenceTripTime
        //    - distances should get divided by eferenceTripDistance
        //    - velocities (=distance/time) should get divided
        //        by eferenceTripDistance/referenceTripTime
        //
        p_and_v[0] /= referenceTripDistance;
        p_and_v[1] *= referenceTripTime/referenceTripDistance;
        update_p_and_v_for_canonical_accel(p_and_v,
                                           dt / referenceTripTime,
                                           accelerationMultiplier,
                                           decelerationMultiplier);
        // Convert back to old units...
        p_and_v[0] *= referenceTripDistance;
        p_and_v[1] *= referenceTripDistance/referenceTripTime;
    } // private update_p_and_v

    // Do it assuming the canonical reference trip of 1 unit of distance
    // starting and stopping softly, takes 1 unit of time.
    // The multipliers are applied at the very last instant,
    // after we do all our smart planning... they represent
    // how badly we erred in estimating our actual strength.
    private static void update_p_and_v_for_canonical_accel(
                                       double p_and_v[/*2*/],
                                       double dt,
                                       double accelerationMultiplier,
                                       double decelerationMultiplier)
    {
        if (verboseLevel >= 1) System.out.println("in update_p_and_v_for_canonical_accel");
        //
        // We need to figure out:
        //      - the (negative) time t0 that we have to start at
        //        so that we can reach the target softly at time 0
        //      - the thrust-reversal time t1 such that:
        //            t0 <= t1 <= 0
        //      - constants b1,c1 such that the first leg of the journey
        //        is the parabola:
        //            f0(t) = +-2 t^2 + b1 t + c1
        // We need the position and velocity of f0 at time t1
        // to match that of the landing leg of the journey,
        // which is either the upward or downward parabola:
        //            f1(t) = -+2 t^2
        // (with the sign being the opposite of the sign appearing in f0).
        // So our unknowns are:
        //        t0
        //        t1
        //        b1
        //        c1
        // And our constraints are:
        //        f0(t0) = p0         i.e. +-2 t0^2 + b1 t0 + c1 == p0
        //        f0'(t0) = v0        i.e. +-4 t0   + b1         == v0
        //        f0(t1) = f1(t1)     i.e. +-2 t1^2 + b1 t1 + c1 == -+2 t1^2
        //        f0'(t1) = f1'(t1)   i.e. +-4 t1   + b1         == -+4 t1
        // Feeding this into mathematica,
        // first with the + (i.e. the first leg is concave upwards
        // and the second leg is concave downwards):
        /*
                       Solve[{
                           2 t0^2 + b1 t0 + c1 == p0,
                           4 t0   + b1         == v0,
                           2 t1^2 + b1 t1 + c1 == -2 t1^2,
                           4 t1   + b1         == -4 t1
                        }, {t0,t1,b1,c1}] // Simplify
            After the usual hand simplifying because Mathematica
            can never figure it out, there are two solutions,
            but only one of them has t1<0 like we require:
                First solution (concave upward initial leg):
                    t1 = -sqrt(-p0+v0^2/8)/2
                    t0 = v0/4 + 2*t1
            Now with the - (i.e. the first leg is concave downwards):
                        Solve[{
                            -2 t0^2 + b1 t0 + c1 == p0,
                            -4 t0   + b1         == v0,
                            -2 t1^2 + b1 t1 + c1 == 2 t1^2,
                            -4 t1   + b1         == 4 t1
                        }, {t0,t1,b1,c1}] // Simplify
                Second solution (concave downward initial leg):
                    t1 = -sqrt(p0+v0^2/8)/2
                    t0 = -v0/4 + 2*t1
        */
        double p0 = p_and_v[0];
        double v0 = p_and_v[1];

        boolean use_concave_upward_for_initial_leg;
        if (v0 >= 0)
        {
            // if the concave downward one works at all,
            // then it's the one, else it's the concave upward one.
            if (p0+v0*v0/8 >= 0)
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = false;
            }
            else
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = true;
            }
        }
        else
        {
            // the opposite.
            if (-p0+v0*v0/8 >= 0)
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = true;
            }
            else
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = false;
            }
        }
        if (verboseLevel >= 1) System.out.println("    use_concave_upward_for_initial_leg = "+use_concave_upward_for_initial_leg);
        double t0, t1;
        if (use_concave_upward_for_initial_leg)
        {
            t1 = -Math.sqrt(-p0+v0*v0/8)/2;
            t0 = v0/4 + 2*t1;
        }
        else
        {
            t1 = -Math.sqrt(p0+v0*v0/8)/2;
            t0 = -v0/4 + 2*t1;
        }

        //
        // All right, now we know the initial time t0
        // and the thrust-reversal time t1.
        //
        double t = t0+dt; // when we want to evaluate
        if (t >= 0)
        {
            // We are gonna get all the way there within this timestep.
            // 
            if (verboseLevel >= 1) System.out.println("We are gonna get all the way there within this timestep");
            p_and_v[0] = 0.;
            p_and_v[1] = 0.;
            //assert(false); // uncomment for coverage test

            // NOTE we fail to do the acceleration/deceleration
            // multiplier thing in this case.  I'm thinking this
            // is probably a good thing, since it will cut short
            // a possibly long but visually undetectable
            // tiny exponentially decaying oscillation.

            if (verboseLevel >= 1) System.out.println("out update_p_and_v_for_canonical_accel (early)");
            return;
        }

        if (t >= t1)
        {
            //
            // It's the landing leg of the journey...
            // calculate from the target.
            // if we used concave upwards for the initial leg,
            // that means we use concave downward for the final leg.
            if (verboseLevel >= 1) System.out.println("It's the landing leg");
            if (use_concave_upward_for_initial_leg)
            {
                // use the concave downward parabola for final leg
                p_and_v[0] = -2*t*t;
                p_and_v[1] = -4*t; // >0 because t<0
                //assert(false); // uncomment for coverage test
            }
            else
            {
                // use the concave upward parabola for final leg
                p_and_v[0] = 2*t*t;
                p_and_v[1] = 4*t; // <0 because t<0
                //assert(false); // uncomment for coverage test
            }

            //
            // Fudge time!
            // Take the effect we're going to have on the velocity,
            // and multiply it by decelerationMultiplier.
            //
            //p_and_v[0] = lerp(p0, p_and_v[0], decelerationMultiplier);
            p_and_v[1] = lerp(v0, p_and_v[1], decelerationMultiplier);
        }
        else
        {
            // It's the first leg of the journey...
            // Calculate from time 2*t1, which is where
            // the first leg has velocity 0.  Call that the base.
            // it might be before or after t0.
            if (verboseLevel >= 1) System.out.println("It's the first leg");
            double base_t = 2*t1;
            if (use_concave_upward_for_initial_leg)
            {
                double p1 = -2*t1*t1; // concave downward on final leg
                double base_p = 2*p1;
                double p = base_p + 2*(t-base_t)*(t-base_t);
                double v = 4*(t-base_t);
                p_and_v[0] = p;
                p_and_v[1] = v;
                //assert(false); // uncomment for coverage test
            }
            else // use concave downward for initial leg
            {
                double p1 = 2*t1*t1; // concave upward on final leg
                double base_p = 2*p1;
                double p = base_p - 2*(t-base_t)*(t-base_t);
                double v = -4*(t-base_t);
                p_and_v[0] = p;
                p_and_v[1] = v;
                //assert(false); // uncomment for coverage test
            }

            //
            // Fudge time!
            // Take the effect we're going to have on the velocity,
            // and multiply it by accelerationMultiplier.
            //
            //p_and_v[0] = lerp(p0, p_and_v[0], accelerationMultiplier);
            p_and_v[1] = lerp(v0, p_and_v[1], accelerationMultiplier);
        }

        // Sanity check...
        {
            double dp = Math.abs(p_and_v[0] - p0);
            double dv = Math.abs(p_and_v[1] - v0);
            //PRINT(p_and_v[1] - v0); // should always be <= 4*dt! (and usually exactly, unless we passed the thrust-reversal time)
            double maxFudge = Math.max(accelerationMultiplier, decelerationMultiplier);
            assert(dv < 4.01*dt * maxFudge);
            double maxPossibleSpeedInInterval = Math.max(Math.abs(v0), Math.abs(p_and_v[1])) + 2*dt;
            assert(dp < (2.01*dt*dt + 4.01*maxPossibleSpeedInInterval) * maxFudge);
        }

        if (verboseLevel >= 1) System.out.println("out update_p_and_v_for_canonical_accel");
    } // private update_p_and_v_for_canonical_accel


    private static double lerp(double a, double b, double t)
    {
        return a*(1-t) + b*t;
    }


    /** Test program. */
    public static void main(String args[])
    {
        System.out.println("in main");
        double criticalDampingFraction = 1.; // XXX should write some tests with this
        double eps = 1e-5;
        {
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            x.set(1.);
            // Try the canonical trip: 1 second to go 1 unit of distance,
            // with time steps of 1/10 second.
            // It should get there in exactly 10 steps and then stay there.
            double dt = .1;
            double t = 0.;
            for (int i = 0; i < 15; ++i)
            {
                double p0 = x.get();
                double v0 = x.getVelocity();
                System.out.println("    Before evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p0, v0));
                x.evolve(1,1, dt, criticalDampingFraction);
                t += dt;
                double p1 = x.get();
                double v1 = x.getVelocity();
                System.out.println("     After evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p1, v1));
                if (LT(t,1.,eps))
                    assert(LT(x.get(), 1., eps));
                else
                    assert(x.get() == 1.);
                System.out.println();
            }
            assert(x.get() == 1.);
        }
        System.out.println("================================================");

        {
            //
            // See if we can get it to overshoot,
            // by starting out strong until the halfway point
            // where we have maximum speed and then losing power
            // during the landing.
            //
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            x.set(1.);
            double dt = .1;
            double t = 0.;
            for (int i = 0; i < 55; ++i)
            {
                double p0 = x.get();
                double v0 = x.getVelocity();
                System.out.println("    Before evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p0, v0));
                x.evolve(1,
                         i>=5 ? 2 : 1,   // reduce to half power at i=5
                         dt,
                         criticalDampingFraction);
                t += dt;
                double p1 = x.get();
                double v1 = x.getVelocity();
                System.out.println("     After evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p1, v1));
                if (LEQ(t,2.5,eps))
                    assert(p1 > p0);
                else if (LEQ(t, 5.,eps))
                    assert(p1 < p0);
                else
                    assert(p0 == 1. && p1 == 1.);
                System.out.println();
            }
            assert(x.get() == 1.);
        }

        {
            //
            // Try lots of different trips
            // without changing any strengths midstream.
            // All the trips should end up being scaled
            // versions of the canonical trip... no overshooting,
            // i.e. the position should be monotonically increasing
            // or decreasing towards the target.
            //
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            double canonicalDistances[] = {.1, 1, 10};
            double canonicalTimes[] = {.1, 1, 10};
            double starts[] = {-100, -1, -.1, 0, .1, 1, 100};
            double targets[] = {-100, -1, -.1, 0, .1, 1, 100};
            double nIncrss[] = {.5, 1, 1.5, 2, 2.5, 9.5, 10, 10.5};
            FORI (iCanonicalDistance, canonicalDistances.length)
            FORI (iCanonicalTime, canonicalTimes.length)
            FORI (iStart, starts.length)
            FORI (iTarget, targets.length)
            FORI (iIncr, nIncrss.length)
            {
                System.out.println("================================================");
                double canonicalDistance = canonicalDistances[iCanonicalDistance];
                double canonicalTime = canonicalTimes[iCanonicalTime];
                double start = starts[iStart];
                double target = targets[iTarget];
                double nIncrs = nIncrss[iIncr];
                double dt = canonicalTime / nIncrs; // XXX this doesn't really give good coverage
                PRINT(canonicalDistance);
                PRINT(canonicalTime);
                PRINT(start);
                PRINT(target);
                PRINT(nIncrs);
                PRINT(dt);

                x.snap(start);
                PRINT(x.get());
                PRINT(x.getVelocity());
                assert(x.get() == start);
                assert(x.getVelocity() == 0.);
                assert(!x.isMoving());


                int overallDir = LT(start,target,eps) ? 1 : GT(start,target,eps) ? -1 : 0;
                double t = 0.;
                for (int i = 0; i < nIncrs + 5; ++i)
                {
                    double p0 = x.get();
                    double v0 = x.getVelocity();
                    // XXX argh, my printf is too slow for all this
                    if (false)
                        System.out.println("    Before evolve: "+
                            com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                                t, p0, v0));
                    x.evolve(canonicalDistance,canonicalTime, dt, criticalDampingFraction);
                    t += dt;
                    double p1 = x.get();
                    double v1 = x.getVelocity();
                    if (false)
                        System.out.println("     After evolve: "+
                            com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                                t, p1, v1));
                    PRINT(overallDir);
                    PRINT(p0);
                    PRINT(p1);
                    if (overallDir > 0)
                        assert(GEQ(p1,p0,eps));
                    else if (overallDir < 0)
                        assert(LEQ(p1,p0,eps));
                    else
                        assert(EQ(p1,p0,eps));

                    System.out.println();
                }
            }
        }

        System.out.println("out main");
    } // main

} // SmoothlyVaryingViewingParameter
