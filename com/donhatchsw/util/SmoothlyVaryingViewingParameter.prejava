package com.donhatchsw.util;
#include "macros.h" 

/**
* Viewing parameters that always change SMOOTHLY
* so I don't have an anxiety attack.  You can knock the target value
* all over the place, and the actual value will smoothly move towards to it,
* without any instantaneous changes in velocity.  Well, except you can tell it to linearly interpolate if you want to.
*/
public class SmoothlyVaryingViewingParameter
{
    private double[] position;
    private double[] velocity;
    private double targetPosition[];

    /** Convenience constructor for a scalar parameter; equivalent to SmoothlyVaryingViewingParameter(new double[]{initialPosition}). */
    public SmoothlyVaryingViewingParameter(double initialPosition)
    {
        // XXX huh?  why can't I do the following? weird, maybe a typo
        //SmoothlyVaryingViewingParameter(new double[]{initialPosition});

        // so copy the code instead...
        this.position = VecMath.copyvec(new double[]{initialPosition});
        this.velocity = new double[this.position.length];
        this.targetPosition = new double[this.position.length];
    }
    /** Constructor. */
    public SmoothlyVaryingViewingParameter(double initialPosition[])
    {
        this.position = VecMath.copyvec(initialPosition);
        this.velocity = new double[this.position.length];
        this.targetPosition = new double[this.position.length];
    }

    /** Sets the target value of this scalar variable. Equivalent to set(new double[]{targetPosition}); */
    public void set(double targetPosition)
    {
        set(new double[]{targetPosition});
    }

    /** Sets the target value of this variable. */
    public void set(double[] targetPosition)
    {
        if (targetPosition.length != this.targetPosition.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: new target has dimension "+targetPosition.length+", expected "+this.targetPosition.length+"");
        VecMath.copyvec(this.targetPosition, targetPosition);
    }
    /** Snaps to the specified position. Equivalent to set(targetPosition) followed by evolve(1.,0.,1.) (i.e. infinite power). */
    public void snap(double[] targetPosition)
    {
        set(targetPosition);
        evolve(1,0,1,1,0); // infinite power
    }
    /** Snaps to the specified position (scalar version).  Equivalent to snap(new double[]{targetPosition}). */
    public void snap(double targetPosition)
    {
        snap(new double[]{targetPosition});
    }
    /** Warps to the specified position, without changing velocity or target. If you want to do this, you are weird. */
    public void warp(double[] newPosition)
    {
        VecMath.copyvec(this.position, newPosition);
    }
    /** Warps to the specified position (scalar version).  Equivalent to warp(new double[]{targetPosition}). */
    public void warp(double targetPosition)
    {
        warp(new double[]{targetPosition});
    }

    /** Gets the value of this scalar variable now.  Throws an IllegalArgumentException if this parameter was initialized as a vector of dimension other than 1. */
    public double get()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return position[0];
    }
    /** Gets the value of this vector variable now, into the given array. */
    public void get(double position[])
    {
        if (position.length != this.position.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: return buffer size is "+position.length+", expected "+this.position.length+"");
        VecMath.copyvec(position, this.position);
    }
    /** Gets the velocity of this scalar variable now, in case you're interested.  You can't set the velocity directly (except to zero, by calling snap() or the equivalent).  Throws an IllegalArgumentException if this parameter was initialized as a vector of dimension other than 1. */
    // XXX needs a vector version
    public double getVelocity()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.get: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return velocity[0];
    }

    // this is PRIVATE. XXX well maybe I shouldn't be so hard-line, if I make it public, change the above comment
    private void setVelocity(double velocity[])
    {
        if (velocity.length != this.velocity.length)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.setVelocity: new velocity has dimension "+velocity.length+", expected "+this.velocity.length+"");
        VecMath.copyvec(this.velocity, velocity);
    }
    private void setVelocity(double velocity)
    {
        if (this.velocity.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.setVelocity: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        setVelocity(new double[]{velocity});
    }

    /** Gets the target value of this scalar variable now, if it's a scalar, otherwise throws an IllegalArgumentException. */
    // XXX needs a vector version
    public double getTarget()
    {
        if (position.length != 1)
            throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.getTarget: no-arg version is only for scalars, this one is a vector of dimension "+position.length);
        return targetPosition[0];
    }


    /**
    * 0: nothing
    * 1: some haphazard stuff
    * 2: more detailed haphazard stuff
    */
    public static int verboseLevel = 0;

    /**
    * Evolves dt seconds towards the target,
    * always pushing with constant-magnitude force
    * (possibly with a mid-trip thrust reversal).
    * <p>
    * You specify the force magnitude by how long it takes
    * to do some reference trip smoothly.
    * For example, if you know you can go 1 mile in 60 seconds,
    * starting and ending smoothly,
    * you would say canonicalTripDistance=1 and canonicalTripTime=60.
    * <p>
    * The acceleration will be equal to
    * 2*canonicalTripDistance/canonicalTripTime<sup>2</sup>.
    * This shows that if you can go 1 mile in 1 second,
    * then you will be able to go 100 miles in 10 seconds
    * (using the same constant acceleration/deceleration magnitude).
    * <p>
    * @param criticalDampingFraction  Set this to 1.  If you set it to &lt;, you'll get slower progress; if you set it to &gt;1 you will be underdamped and you'll overshoot and oscillate as you converge on the target.
    */
    public void evolve(double referenceTripDistance,
                       double referenceTripTime,
                       double dt,
                       double criticalDampingFraction,
                       double bounce)
    {
OUT("in evolve");
PRINT(criticalDampingFraction);
PRINT(bounce);
        if (isMoving())
        {
            if (referenceTripTime == 0.)
            {
                if (referenceTripDistance == 0.)
                    throw new IllegalArgumentException("SmoothlyVaryingViewingParameter.evolve: referenceTripDistance/referenceTripTime is 0/0 !?");
                // Infinite power-- bonk it there.
                VecMath.copyvec(this.position, targetPosition);
                VecMath.zerovec(this.velocity);
                return;
            }

            //
            // The internal function
            // takes a potentially different accelerationMultiplier
            // and decelerationMultiplier; however the implementation is such
            // that it will not do the right thing if they are different,
            // so the public API only exposes a single parameter.
            // Also, if we lower the acc/decelerationMultipler,
            // that would mean, of course, that the acceleration
            // felt will be lower... we'd like that to not happen,
            // so fudge referenceTripDistance here so that it doesn't
            // (this works because the acceleration experienced
            // is linearly proportional to referenceTripDistance,
            // see above).
            // XXX Actually maybe this is NOT the right thing to do...
            // XXX it makes the acceleration the same,
            // XXX but it makes it so the time it takes to do the trip
            // XXX is no longer accurate!  But I'm thinking it's more
            // XXX usable this way anyway, the user should think of
            // XXX the referenceTripDistance and referenceTripTime
            // XXX as being if damping were 1... maybe the params
            // XXX should be renamed that?
            // XXX Also if we DIDN'T do this correction,
            // XXX the time estimate still wouldn't be right...
            // XXX we'd have to correct it in a different way,
            // XXX I'm not sure how.
            //
            criticalDampingFraction = MAX(criticalDampingFraction, 1e-6); // lame
            double accelerationMultiplier = criticalDampingFraction;
            double decelerationMultiplier = criticalDampingFraction;
            referenceTripDistance /= criticalDampingFraction;

            double p_and_v[] = new double[2];
            for (int i = 0; i < position.length; ++i)
            {
                p_and_v[0] = position[i] - targetPosition[i];
                p_and_v[1] = velocity[i];
                if (true)
                    new_update_p_and_v(p_and_v, referenceTripDistance, referenceTripTime, dt, bounce);
                else
                    update_p_and_v(p_and_v, referenceTripDistance, referenceTripTime, dt, accelerationMultiplier, decelerationMultiplier);
                position[i] = p_and_v[0] + targetPosition[i];
                velocity[i] = p_and_v[1];
            }
        }
    } // evolve

    /** Returns true if we are still moving towards the target (i.e. if an evolve() would actually change anything), false otherwise. */
    public boolean isMoving()
    {
        return !VecMath.equalsExactly(position, targetPosition)
             || VecMath.normsqrd(velocity) != 0.;
    }

    //
    // Let's say we don't know the target time...
    // But we know our maximum acceleration,
    // and we want to get there as quickly as possible
    // without exceeding that acceleration.
    // The solution will be piecewise quadratic; two pieces,
    // the first of which "falls" with constant acceleration towards the target
    // and the second of which decelerates so as to land softly
    // (with zero velocity).
    //
    // So in this case we know:
    //          current position p0
    //          current velocity v0
    //          target position = 0
    //          target velocity = 0
    //          the constant acceleration magnitude
    //             (if it takes 1 second
    //             to take the canonical reference trip of length 1
    //             starting and ending at zero velocity,
    //             then we are following the quadratic 2 t^2
    //             for the first half of the trip (taking it to 1/2 at 1/2),
    //             which means the velocity at any t during the first half
    //             of the trip is 4 t, and the acceleration is 4.
    //             therefore in general we like to do acceleration=4
    //             and we will use it at all times in every trip anywhere.)
    // And we have to figure out the time it should take
    // to make a soft landing at the target position,
    // using this constant acceleration magnitude.
    //          

    private static void update_p_and_v(double p_and_v[/*2*/],
                                       double referenceTripDistance,
                                       double referenceTripTime,
                                       double dt,
                                       double accelerationMultiplier,
                                       double decelerationMultiplier)
    {
        //
        // We need to change units so that referenceTripDistance
        // and referenceTripTime in old units
        // are both 1 in new units.
        // So to convert from old to new units:
        //    - times should get divided by referenceTripTime
        //    - distances should get divided by eferenceTripDistance
        //    - velocities (=distance/time) should get divided
        //        by eferenceTripDistance/referenceTripTime
        //
        p_and_v[0] /= referenceTripDistance;
        p_and_v[1] *= referenceTripTime/referenceTripDistance;
        update_p_and_v_for_canonical_accel(p_and_v,
                                           dt / referenceTripTime,
                                           accelerationMultiplier,
                                           decelerationMultiplier);
        // Convert back to old units...
        p_and_v[0] *= referenceTripDistance;
        p_and_v[1] *= referenceTripDistance/referenceTripTime;
    } // private update_p_and_v

    private static void new_update_p_and_v(double p_and_v[/*2*/],
                                           double referenceTripDistance,
                                           double referenceTripTime,
                                           double dt,
                                           double bounce)
    {
OUT("in new_update_p_and_v");
PRINT(bounce);
OUT("");
        assert(bounce >= 0); // XXX make this a bad param exception or something

        {
            // XXX FUDGE! I guess I messed up somehow and high bounces are making the acceleration sharper than it should be, so fudge to adjust for now until I figure out what I did wrong
            referenceTripDistance *= 1-bounce;
        }



        // acceleration magnitude...
        double aMag = 4 * referenceTripDistance
                        / SQR(referenceTripTime);
        double p = p_and_v[0];
        double v = p_and_v[1];
        double vSign = (v<0 ? -1. : 1.);
        double vMag = vSign*v;

        //
        // Call the current time 0.
        // What is the nearest time before and after now
        // that v could be 0,
        // given acceleration magnitude aMag?
        //
        double still_t_after = vMag/aMag;
        double still_p_after = p + vSign*.5*v*v/aMag;
        double still_a_after = -vSign*aMag;

        double still_t_before = -vMag/aMag;
        double still_p_before = p - vSign*.5*v*v/aMag;
        double still_a_before = vSign*aMag;
        if (false)
        {
            PRINT(p);
            PRINT(v);
            PRINT(vSign);
            PRINT(vMag);
            PRINT(still_t_before);
            PRINT(still_p_before);
            PRINT(still_a_before);
            PRINT(still_t_after);
            PRINT(still_p_after);
            PRINT(still_a_after);
        }

        double t0, p0, a0;
        if (p*v <= 0 &&
            still_p_after/still_p_before > -bounce)
        {
            // Need to push forward harder... still_before is the relevant one.
            t0 = still_t_before;
            p0 = still_p_before;
            a0 = still_a_before;
        }
        else
        {
            // Need to be decelerating so we don't over-overshoot.
            t0 = still_t_after;
            p0 = still_p_after;
            a0 = still_a_after;
        }

        // Figure out the position,time,acceleration of the following
        // still point (after the next bounce).
        // From one still point to the next looks just like
        // a scaled reference trip.
        double p1 = -bounce*p0;
        double a1 = -a0;
        double t1 = t0 + Math.sqrt((Math.abs(p1-p0)/referenceTripDistance))
                       * referenceTripTime;

        // Each piece takes sqrt(bounce) as much time as the previous one.
        // So the time at which we will settle is:
        //     t0 + (t1-t0)*(1 + bounce^(1/2) + bounce + bounce^(3/2) + ...)
        //   = t0 + (t1-t0)/(1-sqrt(bounce))
        // Check whether we are being asked to evolve to or beyond
        // the settling time, i.e. whether
        //     dt >= t0 + (t1-t0)/(1-sqrt(bounce))
        // Don't do that division explicitly (in case bounce is very close
        // to 1); instead, check whether:
        //     (dt-t0)*(1-sqrt(bounce)) >= t1-t0
        if ((dt-t0)*(1-Math.sqrt(bounce)) >= t1-t0)
        {
            // Settled
            p = 0;
            v = 0;
        }
        else
        {
            // Not settled.
            // Which time segment t_(i-1) .. t_i
            // is dt in?
            int i = 0;
            double p_iminus1 = Double.NaN;
            double t_iminus1 = Double.NaN;
            double a_iminus1 = Double.NaN;
            double t_i = t0;
            double p_i = p0;
            double a_i = a0;
            while (dt > t_i)
            {
                p_iminus1 = p_i;
                t_iminus1 = t_i;
                a_iminus1 = a_i;
                i++;
                p_i = -bounce * p_iminus1;
                a_i = -a_iminus1;
                // XXX note first one is redundant with calculation of t1 above, should try to consolidate
                t_i += Math.sqrt((Math.abs(p_i-p_iminus1)/referenceTripDistance))
                     * referenceTripTime;
                if (i > 1000)
                {
                    // Ridiculous number of iterations.
                    // We are probably very close to the settling point,
                    // and stuck due to floating point roundoff error.
                    assert(false); // coverage
                    p_and_v[0] = 0;
                    p_and_v[1] = 0;
                    return;
                }
            }
            if (false)
            {
                PRINT(p_iminus1);
                PRINT(p_i);
                PRINT(t_iminus1);
                PRINT(t_i);
                PRINT(i);
            }
            double frac = i==0 ? 1. : (dt-t_iminus1)/(t_i-t_iminus1);
            //frac = 0; // XXX get rid
            if (frac < .5)
            {
                // Follow the parabola forwards
                // from the previous still point t_iminus1,p_iminus1
                if (false)
                {
                    OUT("----------------------------");
                    PRINT(a_iminus1);
                }
                v = (dt-t_iminus1) * a_iminus1;
                p = p_iminus1 + .5*a_iminus1*SQR(dt-t_iminus1);
            }
            else
            {
                // Follow the parabola backwards
                // from the next still point t_i,p_i
                if (false)
                {
                    OUT("++++++++++++++++++++++++++++");
                    PRINT(a_i);
                }
                v = (t_i-dt) * -a_i;
                p = p_i - .5* -a_i *SQR(t_i-dt);
            }
            if (false)
            {
                PRINT(p);
                PRINT(v);
                OUT("");
            }
        }
        p_and_v[0] = p;
        p_and_v[1] = v;
    } // private new_update_p_and_v

    // Do it assuming the canonical reference trip of 1 unit of distance
    // starting and stopping softly, takes 1 unit of time.
    // The multipliers are applied at the very last instant,
    // after we do all our smart planning... they represent
    // how badly we erred in estimating our actual strength.
    private static void update_p_and_v_for_canonical_accel(
                                       double p_and_v[/*2*/],
                                       double dt,
                                       double accelerationMultiplier,
                                       double decelerationMultiplier)
    {
        if (verboseLevel >= 1) System.out.println("in update_p_and_v_for_canonical_accel");
        if (verboseLevel >= 2) PRINTVEC(p_and_v);
        if (verboseLevel >= 2) PRINT3(dt, accelerationMultiplier, decelerationMultiplier);
        //
        // We need to figure out:
        //      - the (negative) time t0 that we have to start at
        //        so that we can reach the target softly at time 0
        //      - the thrust-reversal time t1 such that:
        //            t0 <= t1 <= 0
        //      - constants b1,c1 such that the first leg of the journey
        //        is the parabola:
        //            f0(t) = +-2 t^2 + b1 t + c1
        // We need the position and velocity of f0 at time t1
        // to match that of the landing leg of the journey,
        // which is either the upward or downward parabola:
        //            f1(t) = -+2 t^2
        // (with the sign being the opposite of the sign appearing in f0).
        // So our unknowns are:
        //        t0
        //        t1
        //        b1
        //        c1
        // And our constraints are:
        //        f0(t0) = p0         i.e. +-2 t0^2 + b1 t0 + c1 == p0
        //        f0'(t0) = v0        i.e. +-4 t0   + b1         == v0
        //        f0(t1) = f1(t1)     i.e. +-2 t1^2 + b1 t1 + c1 == -+2 t1^2
        //        f0'(t1) = f1'(t1)   i.e. +-4 t1   + b1         == -+4 t1
        // Feeding this into mathematica,
        // first with the + (i.e. the first leg is concave upwards
        // and the second leg is concave downwards):
        /*
                       Solve[{
                           2 t0^2 + b1 t0 + c1 == p0,
                           4 t0   + b1         == v0,
                           2 t1^2 + b1 t1 + c1 == -2 t1^2,
                           4 t1   + b1         == -4 t1
                        }, {t0,t1,b1,c1}] // Simplify
            After the usual hand simplifying because Mathematica
            can never figure it out, there are two solutions,
            but only one of them has t1<0 like we require:
                First solution (concave upward initial leg):
                    t1 = -sqrt(-p0+v0^2/8)/2
                    t0 = v0/4 + 2*t1
            Now with the - (i.e. the first leg is concave downwards):
                        Solve[{
                            -2 t0^2 + b1 t0 + c1 == p0,
                            -4 t0   + b1         == v0,
                            -2 t1^2 + b1 t1 + c1 == 2 t1^2,
                            -4 t1   + b1         == 4 t1
                        }, {t0,t1,b1,c1}] // Simplify
                Second solution (concave downward initial leg):
                    t1 = -sqrt(p0+v0^2/8)/2
                    t0 = -v0/4 + 2*t1
        */
        double p0 = p_and_v[0];
        double v0 = p_and_v[1];

        boolean use_concave_upward_for_initial_leg;
        if (v0 >= 0)
        {
            // if the concave downward one works at all,
            // then it's the one, else it's the concave upward one.
            if (p0+v0*v0/8 >= 0)
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = false;
            }
            else
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = true;
            }
        }
        else
        {
            // the opposite.
            if (-p0+v0*v0/8 >= 0)
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = true;
            }
            else
            {
                //assert(false); // uncomment for coverage test
                use_concave_upward_for_initial_leg = false;
            }
        }
        if (verboseLevel >= 1) System.out.println("    use_concave_upward_for_initial_leg = "+use_concave_upward_for_initial_leg);
        double t0, t1;
        if (use_concave_upward_for_initial_leg)
        {
            t1 = -Math.sqrt(-p0+v0*v0/8)/2;
            t0 = v0/4 + 2*t1;
        }
        else
        {
            t1 = -Math.sqrt(p0+v0*v0/8)/2;
            t0 = -v0/4 + 2*t1;
        }

        //
        // All right, now we know the initial time t0
        // and the thrust-reversal time t1.
        //
        double t = t0+dt; // when we want to evaluate
        if (t >= 0)
        {
            // We are gonna get all the way there within this timestep.
            // 
            if (verboseLevel >= 1) System.out.println("We are gonna get all the way there within this timestep");
            p_and_v[0] = 0.;
            p_and_v[1] = 0.;
            //assert(false); // uncomment for coverage test

            // NOTE we fail to do the acceleration/deceleration
            // multiplier thing in this case.  I'm thinking this
            // is probably a good thing, since it will cut short
            // a possibly long but visually undetectable
            // tiny exponentially decaying oscillation.

            if (verboseLevel >= 2) PRINTVEC(p_and_v);
            if (verboseLevel >= 1) System.out.println("out update_p_and_v_for_canonical_accel (early)");
            return;
        }

        if (t >= t1)
        {
            //
            // It's the landing leg of the journey...
            // calculate from the target.
            // if we used concave upwards for the initial leg,
            // that means we use concave downward for the final leg.
            if (verboseLevel >= 1) System.out.println("It's the landing leg");
            if (use_concave_upward_for_initial_leg)
            {
                // use the concave downward parabola for final leg
                p_and_v[0] = -2*t*t;
                p_and_v[1] = -4*t; // >0 because t<0
                //assert(false); // uncomment for coverage test
            }
            else
            {
                // use the concave upward parabola for final leg
                p_and_v[0] = 2*t*t;
                p_and_v[1] = 4*t; // <0 because t<0
                //assert(false); // uncomment for coverage test
            }

            //
            // Fudge time!
            // Take the effect we're going to have on the velocity,
            // and multiply it by decelerationMultiplier.
            //
            //p_and_v[0] = lerp(p0, p_and_v[0], decelerationMultiplier);
            p_and_v[1] = lerp(v0, p_and_v[1], decelerationMultiplier);
        }
        else
        {
            // It's the first leg of the journey...
            // Calculate from time 2*t1, which is where
            // the first leg has velocity 0.  Call that the base.
            // it might be before or after t0.
            if (verboseLevel >= 1) System.out.println("It's the first leg");
            double base_t = 2*t1;
            if (use_concave_upward_for_initial_leg)
            {
                double p1 = -2*t1*t1; // concave downward on final leg
                double base_p = 2*p1;
                double p = base_p + 2*(t-base_t)*(t-base_t);
                double v = 4*(t-base_t);
                p_and_v[0] = p;
                p_and_v[1] = v;
                //assert(false); // uncomment for coverage test
            }
            else // use concave downward for initial leg
            {
                double p1 = 2*t1*t1; // concave upward on final leg
                double base_p = 2*p1;
                double p = base_p - 2*(t-base_t)*(t-base_t);
                double v = -4*(t-base_t);
                p_and_v[0] = p;
                p_and_v[1] = v;
                //assert(false); // uncomment for coverage test
            }

            //
            // Fudge time!
            // Take the effect we're going to have on the velocity,
            // and multiply it by accelerationMultiplier.
            //
            //p_and_v[0] = lerp(p0, p_and_v[0], accelerationMultiplier);
            p_and_v[1] = lerp(v0, p_and_v[1], accelerationMultiplier);
        }

        // Sanity check...
        {
            double dp = Math.abs(p_and_v[0] - p0);
            double dv = Math.abs(p_and_v[1] - v0);
            //PRINT(p_and_v[1] - v0); // should always be <= 4*dt! (and usually exactly, unless we passed the thrust-reversal time)
            double maxFudge = Math.max(accelerationMultiplier, decelerationMultiplier);
            assert(dv < 4.01*dt * maxFudge);
            double maxPossibleSpeedInInterval = Math.max(Math.abs(v0), Math.abs(p_and_v[1])) + 2*dt;
            assert(dp < (2.01*dt*dt + 4.01*maxPossibleSpeedInInterval) * maxFudge);
        }

        PRINTVEC(p_and_v);
        if (verboseLevel >= 2) PRINTVEC(p_and_v);
        if (verboseLevel >= 1) System.out.println("out update_p_and_v_for_canonical_accel");
    } // private update_p_and_v_for_canonical_accel


    private static double lerp(double a, double b, double t)
    {
        return a*(1-t) + b*t;
    }




    private static void confidenceTests()
    {
        double criticalDampingFraction = 1.; // XXX should write some tests with this
        double bounce = 0.; // XXX should write some tests with this
        double eps = 1e-5;
        {
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            x.set(1.);
            // Try the canonical trip: 1 second to go 1 unit of distance,
            // with time steps of 1/10 second.
            // It should get there in exactly 10 steps and then stay there.
            double dt = .1;
            double t = 0.;
            for (int i = 0; i < 15; ++i)
            {
                double p0 = x.get();
                double v0 = x.getVelocity();
                System.out.println("    Before evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p0, v0));
                x.evolve(1,1, dt, criticalDampingFraction, bounce);
                t += dt;
                double p1 = x.get();
                double v1 = x.getVelocity();
                System.out.println("     After evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p1, v1));
                if (LT(t,1.,eps))
                    assert(LT(x.get(), 1., eps));
                else
                    assert(x.get() == 1.);
                System.out.println();
            }
            assert(x.get() == 1.);
        }
        System.out.println("================================================");

        {
            //
            // See if we can get it to overshoot,
            // by starting out strong until the halfway point
            // where we have maximum speed and then losing power
            // during the landing.
            //
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            x.set(1.);
            double dt = .1;
            double t = 0.;
            for (int i = 0; i < 55; ++i)
            {
                double p0 = x.get();
                double v0 = x.getVelocity();
                System.out.println("    Before evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p0, v0));
                x.evolve(1,
                         i>=5 ? 2 : 1,   // reduce to half power at i=5
                         dt,
                         criticalDampingFraction,
                         bounce);
                t += dt;
                double p1 = x.get();
                double v1 = x.getVelocity();
                System.out.println("     After evolve: "+
                    com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                        t, p1, v1));
                if (LEQ(t,2.5,eps))
                    assert(p1 > p0);
                else if (LEQ(t, 5.,eps))
                    assert(p1 < p0);
                else
                    assert(p0 == 1. && p1 == 1.);
                System.out.println();
            }
            assert(x.get() == 1.);
        }

        {
            //
            // Try lots of different trips
            // without changing any strengths midstream.
            // All the trips should end up being scaled
            // versions of the canonical trip... no overshooting,
            // i.e. the position should be monotonically increasing
            // or decreasing towards the target.
            //
            SmoothlyVaryingViewingParameter x = new SmoothlyVaryingViewingParameter(0.);
            double canonicalDistances[] = {.1, 1, 10};
            double canonicalTimes[] = {.1, 1, 10};
            double starts[] = {-100, -1, -.1, 0, .1, 1, 100};
            double targets[] = {-100, -1, -.1, 0, .1, 1, 100};
            double nIncrss[] = {.5, 1, 1.5, 2, 2.5, 9.5, 10, 10.5};
            FORI (iCanonicalDistance, canonicalDistances.length)
            FORI (iCanonicalTime, canonicalTimes.length)
            FORI (iStart, starts.length)
            FORI (iTarget, targets.length)
            FORI (iIncr, nIncrss.length)
            {
                System.out.println("================================================");
                double canonicalDistance = canonicalDistances[iCanonicalDistance];
                double canonicalTime = canonicalTimes[iCanonicalTime];
                double start = starts[iStart];
                double target = targets[iTarget];
                double nIncrs = nIncrss[iIncr];
                double dt = canonicalTime / nIncrs; // XXX this doesn't really give good coverage
                PRINT(canonicalDistance);
                PRINT(canonicalTime);
                PRINT(start);
                PRINT(target);
                PRINT(nIncrs);
                PRINT(dt);

                x.snap(start);
                PRINT(x.get());
                PRINT(x.getVelocity());
                assert(x.get() == start);
                assert(x.getVelocity() == 0.);
                assert(!x.isMoving());


                int overallDir = LT(start,target,eps) ? 1 : GT(start,target,eps) ? -1 : 0;
                double t = 0.;
                for (int i = 0; i < nIncrs + 5; ++i)
                {
                    double p0 = x.get();
                    double v0 = x.getVelocity();
                    // XXX argh, my printf is too slow for all this
                    if (false)
                        System.out.println("    Before evolve: "+
                            com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                                t, p0, v0));
                    x.evolve(canonicalDistance,canonicalTime, dt, criticalDampingFraction, bounce);
                    t += dt;
                    double p1 = x.get();
                    double v1 = x.getVelocity();
                    if (false)
                        System.out.println("     After evolve: "+
                            com.donhatchsw.compat.Format.sprintf("t = %20.17g p = %20.17g  v = %20.17g",
                                                t, p1, v1));
                    PRINT(overallDir);
                    PRINT(p0);
                    PRINT(p1);
                    if (overallDir > 0)
                        assert(GEQ(p1,p0,eps));
                    else if (overallDir < 0)
                        assert(LEQ(p1,p0,eps));
                    else
                        assert(EQ(p1,p0,eps));

                    System.out.println();
                }
            }
        }

    } // confidenceTests

    private static int eventVerbose = 2;

    private static void interactiveDemo()
    {
        java.awt.Canvas canvas = new java.awt.Canvas() {

            class Model
            {
                double referenceTripDistance = .5;
                double referenceTripTime = .5;
                //double unclampedBounce = .5;
                double unclampedBounce = 0.;
                double segmentEndPoints[][] = {{-.6,.4},{-.5,.5}};

                // 0: segment endpoint 0
                // 1: segment endpoint 1
                // 2: ref trip end
                // 3: bounce point
                int pickClosestThing(double x, double y)
                {
                    double points[][] = {
                        segmentEndPoints[0],
                        segmentEndPoints[1],
                        {-1+referenceTripTime,
                         -1+referenceTripDistance},
                        {-1+referenceTripTime*(1+Math.sqrt(Math.max(unclampedBounce,0))),
                         -1+referenceTripDistance*(1-Math.max(unclampedBounce,0))},
                    };
                    int bestI = -1;
                    double bestDistSqrd = Double.POSITIVE_INFINITY;
                    for (int i = 0; i < points.length; ++i)
                    {
                        double thisDistSqrd = (x-points[i][0])*(x-points[i][0])
                                            + (y-points[i][1])*(y-points[i][1]);
                        if (thisDistSqrd < bestDistSqrd)
                        {
                            bestI = i;
                            bestDistSqrd = thisDistSqrd;
                        }
                        // Special case-- if bounce is 0,
                        // then ref trip end and bounce point are the same...
                        // in this case prefer the bounce point
                        // iff pick point is to the right.
                        if (thisDistSqrd == bestDistSqrd
                         && bestI == 2
                         && i == 3
                         && x > points[i][0])
                        {
                            bestI = i;
                            bestDistSqrd = thisDistSqrd;
                        }
                    }
                    return bestI;
                }
            }
            Model model = new Model();
            com.donhatchsw.awt.MyGraphics mostRecentGraphics = null;
            double prevPoint[] = null;
            int indexOfThingBeingDragged = -1;

            public java.awt.Dimension getPreferredSize()
            {
                //return new java.awt.Dimension(800,800);
                return new java.awt.Dimension(200,200);
            }
            // PAINT
            public void paint(java.awt.Graphics g)
            {
                if (eventVerbose >= 2) System.out.println("    in paint");
                com.donhatchsw.awt.MyGraphics mg = new com.donhatchsw.awt.MyGraphics(g, getSize(),
                                               -1.,1.,-1.,1.);

                // Draw the reference trip endpoints
                mg.setColor(java.awt.Color.red);
                mg.drawString("Ref trip", -1+model.referenceTripTime,
                                          -1+model.referenceTripDistance,
                                          -1.1, 1.1); // bleah, give it a tiny bit of space
                mg.drawPoint(-1+model.referenceTripTime,
                             -1+model.referenceTripDistance,
                             3);
                double bounce = Math.max(model.unclampedBounce, 0);
                // And where we think the first bounce will be
                mg.drawPoint(-1+model.referenceTripTime*(1+Math.sqrt(bounce)),
                             -1+model.referenceTripDistance*(1-bounce),
                             3);
                // And the second one
                if (false) // nah, can't drag it so it's confusing
                    mg.drawPoint(-1+model.referenceTripTime*(1+Math.sqrt(bounce+bounce)),
                                 -1+model.referenceTripDistance*(1-bounce+bounce*bounce),
                                 3);

                // Draw the reference trip
                {
                    SmoothlyVaryingViewingParameter param = new SmoothlyVaryingViewingParameter(-1.);
                    // Concoct a target so that the first upward piece
                    // goes to exactly referenceTripDistance.
                    // So it should be -1 + refTripDistance * 
                    //                  (1 - b + b^2 - ...)
                    param.set(-1. + model.referenceTripDistance / (1.+bounce));

                    double dt = 1/1000.;
                    double t = -1.;
                    FORI (i, 2000+1)
                    {
                        param.evolve(model.referenceTripDistance,
                                     model.referenceTripTime,
                                     dt,
                                     1-bounce,
                                     bounce);
                        t += dt;
                        mg.drawPoint(t, param.get(), 1);
                    }
                }

                if (true)
                {
                    double x0 = model.segmentEndPoints[0][0];
                    double y0 = model.segmentEndPoints[0][1];
                    double x1 = model.segmentEndPoints[1][0];
                    double y1 = model.segmentEndPoints[1][1];

                    if (x0 > x1)
                    {
                        double temp;
                        SWAP(x0,x1,temp);
                        SWAP(y0,y1,temp);
                    }

                    // Draw the segment endpoints
                    mg.setColor(java.awt.Color.getHSBColor(.75f, 1.f, 1.f));
                    mg.drawPoint(x0,y0, 5);
                    mg.drawPoint(x1,y1, 5);
                    // Draw the segment
                    FORI (i, 1000+1)
                    {
                        double t = i/1000.;
                        mg.drawPoint(lerp(x0,x1,t),
                                     lerp(y0,y1,t),
                                     1);
                    }
                    // Draw the forward trip
                    if (x1 != x0)
                    {
                        assert(x1 > x0);
                        double v = (y1-y0)/(x1-x0);
                        SmoothlyVaryingViewingParameter param = new SmoothlyVaryingViewingParameter(y1);
                        param.set(0.); // target
                        param.setVelocity(v);
                        double t = x1;
                        double dt = 1/1000.;
                        FORI (i, 2000+1)
                        {
                            param.evolve(model.referenceTripDistance,
                                         model.referenceTripTime,
                                         dt,
                                         1-bounce,
                                         bounce);
                            t += dt;
                            mg.drawPoint(t, param.get(), 1);
                        }
                    }
                    // Draw the backward trip
                    if (x1 != x0)
                    {
                        assert(x1 > x0);
                        double v = -(y1-y0)/(x1-x0);
                        SmoothlyVaryingViewingParameter param = new SmoothlyVaryingViewingParameter(y0);
                        param.set(0.); // target
                        param.setVelocity(v);
                        double t = x0;
                        double dt = 1/1000.;
                        FORI (i, 2000+1)
                        {
                            param.evolve(model.referenceTripDistance,
                                         model.referenceTripTime,
                                         dt,
                                         1-bounce,
                                         bounce);
                            t -= dt;
                            mg.drawPoint(t, param.get(), 1);
                        }
                    }
                }

                mostRecentGraphics = mg;

                if (eventVerbose >= 2) System.out.println("    out paint");
            }
            {
                addMouseListener(new java.awt.event.MouseListener() {
                    public void mouseClicked(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseClicked at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseClicked");
                    }
                    public void mousePressed(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mousePressed at "+e.getX()+","+e.getY()+"");

                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                        indexOfThingBeingDragged = model.pickClosestThing(thisPoint[0], thisPoint[1]);
                        PRINT(indexOfThingBeingDragged);

                        prevPoint = thisPoint;
                        if (eventVerbose >= 1) System.out.println("    out mousePressed");
                    }
                    public void mouseReleased(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseReleased at "+e.getX()+","+e.getY()+"");

                        // no longer dragging-- make it be where it looks like it is
                        model.unclampedBounce = Math.max(model.unclampedBounce, 0);

                        if (eventVerbose >= 1) System.out.println("    out mouseReleased");
                    }
                    public void mouseEntered(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseEntered at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseEntered");
                    }
                    public void mouseExited(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseExited at "+e.getX()+","+e.getY()+"");
                        if (eventVerbose >= 1) System.out.println("    out mouseExited");
                    }
                });
                addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                    public void mouseMoved(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 3) System.out.println("    in mouseMoved to "+e.getX()+","+e.getY()+"");
                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);
                        prevPoint = thisPoint;
                        if (eventVerbose >= 3) System.out.println("    out mouseMoved");
                    }
                    public void mouseDragged(java.awt.event.MouseEvent e)
                    {
                        if (eventVerbose >= 1) System.out.println("    in mouseDragged to "+e.getX()+","+e.getY()+"");
                        double thisPoint[] = new double[2];
                        mostRecentGraphics.pick(e.getX(), e.getY(), thisPoint);

                        double delta[] = VecMath.vmv(thisPoint, prevPoint);
                        if (indexOfThingBeingDragged == 0)
                            VecMath.vpv(model.segmentEndPoints[0], model.segmentEndPoints[0], delta);
                        else if (indexOfThingBeingDragged == 1)
                            VecMath.vpv(model.segmentEndPoints[1], model.segmentEndPoints[1], delta);
                        else if (indexOfThingBeingDragged == 2)
                        {
                            model.referenceTripTime += delta[0];
                            model.referenceTripDistance += delta[1];
                        }
                        else if (indexOfThingBeingDragged == 3)
                        {
                            double bouncePoint = -1+model.referenceTripDistance*(1-model.unclampedBounce);
                            bouncePoint += delta[1];
                            model.unclampedBounce = 1 - (bouncePoint - -1)/model.referenceTripDistance;
                        }
                        repaint();

                        prevPoint = thisPoint;
                        if (eventVerbose >= 1) System.out.println("    out mouseDragged");
                    }
                });
            }
        }; // new Canvas

            canvas.requestFocus(); // seems to be needed initially XXX see whether this is true

            final java.awt.Frame frame = new java.awt.Frame("Smoothly Varying Viewing Parameters");
            frame.addWindowListener(new java.awt.event.WindowAdapter() {
                public void windowClosing(java.awt.event.WindowEvent we)
                {
                    frame.dispose();
                    System.out.println("ciao!");
                    System.exit(0); // asinine way of doing things
                }
            });
            frame.setForeground(java.awt.Color.white);
            frame.setBackground(java.awt.Color.black);
            frame.add(canvas);
            frame.pack();
            frame.show();
        } // interactiveDemo



    /** Test program. */
    public static void main(String args[])
    {
        System.out.println("in main");

        boolean justDoConfidenceTests = (args.length>0);
        if (justDoConfidenceTests)
            confidenceTests();
        else
            interactiveDemo();

        System.out.println("out main");
    } // main

} // SmoothlyVaryingViewingParameter
