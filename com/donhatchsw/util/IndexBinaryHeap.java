// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// 102 # 1 "com/donhatchsw/util/IndexBinaryHeap.prejava"
// 103 # 1 "<built-in>"
// 104 # 1 "<command-line>"
// 105 # 1 "com/donhatchsw/util/IndexBinaryHeap.prejava"
/* vim: set filetype=java: */
// 107 # 1 "com/donhatchsw/util/macros.h" 1
//
// macros.h
//
// 111 # 14 "com/donhatchsw/util/macros.h"
// NOTE: this causes a,b to be evaluated twice on failure, so is not ideal. might be better to do a block... ?
// 113 # 30 "com/donhatchsw/util/macros.h"
// Note: the additional "(a)==(b)||" is to make it work correctly for infinities...
// and causes the args to be evaluated twice.
// 116 # 67 "com/donhatchsw/util/macros.h"
// XXX ... what a mess
// 118 # 3 "com/donhatchsw/util/IndexBinaryHeap.prejava" 2
package com.donhatchsw.util;
/**
* Binary heap, as described here:
* <a href="http://en.wikipedia.org/wiki/Binary_heap">http://en.wikipedia.org/wiki/Binary_heap</a>
*/
public class IndexBinaryHeap
{
    SortStuff.IntComparator cmp;
    private int heap[]; // heap index to index
    private int indexToHeapIndex[]; // index to heap index
    private int size; // size of heap

    /** Constructs a heap whose indices are in the range 0,...,max-1. */
    public IndexBinaryHeap(int max, SortStuff.IntComparator cmp)
    {
        do { if (!((max)>=(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+18 +"): (" + "max" + ")" + ">=" + "(" + "0" + ") ("+(max)+" vs. "+(0)+")"); } while (false);
        do { if (!((cmp)!=(null))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+19 +"): (" + "cmp" + ")" + "!=" + "(" + "null" + ") ("+(cmp)+" vs. "+(null)+")"); } while (false);
        this.heap = VecMath.fillvec(max, -1);
        this.indexToHeapIndex = VecMath.fillvec(max, -1);
        this.size = 0;
        this.cmp = cmp;
    }
    /** Adds the given index to the heap.  It is an error to call this on an index that is already in the heap. */
    public void add(int index)
    {
        do { if (!((indexToHeapIndex[index])==(-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+28 +"): (" + "indexToHeapIndex[index]" + ")" + "==" + "(" + "-1" + ") ("+(indexToHeapIndex[index])+" vs. "+(-1)+")"); } while (false);
        indexToHeapIndex[index] = size;
        heap[size] = index;
        size++;
        adjust(index);
    }
    /** Remove the given index from the heap.  It is an error to call this on an index that is not in the heap. */
    public void remove(int index)
    {
        do { if (!(size >= 1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+37 +"): " + "size >= 1" + ""); } while (false);
        int heapIndex = indexToHeapIndex[index];
        do { if (!((heapIndex)!=(-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+39 +"): (" + "heapIndex" + ")" + "!=" + "(" + "-1" + ") ("+(heapIndex)+" vs. "+(-1)+")"); } while (false);

        indexToHeapIndex[index] = -1;
        size--;

        if (heapIndex != size)
        {
            // Move the last heap item into the vacated position
            int indexBeingMoved = heap[size];
            heap[size] = -1;
            heap[heapIndex] = indexBeingMoved;
            indexToHeapIndex[indexBeingMoved] = heapIndex;
            adjust(indexBeingMoved);
        }
        else
        {
            heap[size] = -1;
        }
    }
    public boolean contains(int i)
    {
        do { if (!(((0)<=(i))&&((i)<(heap.length)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+60 +"): (" + "0" + ")" + "<=" + "(" + "i" + ")" + "<" + "(" + "heap.length" + ") ("+(0)+" vs. "+(i)+" vs. "+(heap.length)+")"); } while (false);
        return indexToHeapIndex[i] != -1;
    }

    /** Returns the index with minimum value, without removing it.  It is an error to call this if the heap is empty. */
    public int min()
    {
        do { if (!(size >= 1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+67 +"): " + "size >= 1" + ""); } while (false);
        return heap[0];
    }

    /** Removes and returns the index with minimum value.  It is an error to call this if the heap is empty. */
    public int extractMin()
    {
        int ret = min();
        remove(ret);
        return ret;
    }
    /** Tells whether the heap is empty. */
    public boolean isEmpty()
    {
        return size == 0;
    }
    /** Equivalent to remove(index); add(index,val); but more efficient. It's allowed for index to have changed "value", i.e. for cmp to place it in a different position in the linear ordering than before, but the relative positions of other items must stay the same. */
    public void adjust(int index)
    {
        //System.out.println("in adjust(index="+index+")");
        int heapIndex = indexToHeapIndex[index];
        do { if (!((heapIndex)!=(-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+88 +"): (" + "heapIndex" + ")" + "!=" + "(" + "-1" + ") ("+(heapIndex)+" vs. "+(-1)+")"); } while (false);





        int heapIndexParent;
        if (heapIndex > 0
         && cmp.compare(index, heap[heapIndexParent = (((heapIndex)-1)>>1)]) < 0)
        {
            // trickle up
            //System.out.println("TRICKLING UP");
            do
            {
                // swap heapIndex with heapIndexParent,
                // but don't bother to fill it in at the parent,
                // and ascend
                int indexParent = heap[heapIndexParent];
                heap[heapIndex] = indexParent;
                indexToHeapIndex[indexParent] = heapIndex;
                heapIndex = heapIndexParent;
                // index stays the same
            } while (heapIndex > 0
                  && cmp.compare(index, heap[heapIndexParent = (((heapIndex)-1)>>1)]) < 0);
        }
        else
        {
            // trickle down
            //System.out.println("TRICKLING DOWN");
            while (true)
            {
                int heapIndexChild0 = (((heapIndex)<<1)+1);
                if (heapIndexChild0 >= size)
                    break; // at leaf of tree; done

                int heapIndexChild1 = (((heapIndex)<<1)+2);
                int heapIndexChild = heapIndexChild1 < size &&
                    cmp.compare(heap[heapIndexChild1], heap[heapIndexChild0]) < 0 ? heapIndexChild1 : heapIndexChild0;
                if (cmp.compare(index, heap[heapIndexChild]) > 0)
                {
                    // swap with smaller of children,
                    // but don't bother to fill it in at the child,
                    // and descend
                    int indexChild = heap[heapIndexChild];
                    heap[heapIndex] = indexChild;
                    indexToHeapIndex[indexChild] = heapIndex;
                    heapIndex = heapIndexChild;
                    // index stays the same
                }
                else
                    break; // happy with children; done
            }
        }
        heap[heapIndex] = index;
        indexToHeapIndex[index] = heapIndex;
        //System.out.println("out adjust");
    } // adjust

    public void sanityCheck(boolean isTotalOrder)
    {
        if (false)
        {
            System.out.println("in sanityCheck");
            //print();
        }

        int max = heap.length;
        do { if (!((max)==(indexToHeapIndex.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+155 +"): (" + "max" + ")" + "==" + "(" + "indexToHeapIndex.length" + ") ("+(max)+" vs. "+(indexToHeapIndex.length)+")"); } while (false);
        do { if (!(((0)<=(size))&&((size)<=(max)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+156 +"): (" + "0" + ")" + "<=" + "(" + "size" + ")" + "<=" + "(" + "max" + ") ("+(0)+" vs. "+(size)+" vs. "+(max)+")"); } while (false);

        int nValid = 0;
        int nInvalid = 0;
        for (int i = 0; (i) < (max); ++i)
        {
            if (indexToHeapIndex[i] != -1)
            {
                //CHECK(!Double.isNaN(values[i])); // hmm, can't assert this... should I add API for determining if value in heap?
                do { if (!(((0)<=(indexToHeapIndex[i]))&&((indexToHeapIndex[i])<(size)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+165 +"): (" + "0" + ")" + "<=" + "(" + "indexToHeapIndex[i]" + ")" + "<" + "(" + "size" + ") ("+(0)+" vs. "+(indexToHeapIndex[i])+" vs. "+(size)+")"); } while (false);
                do { if (!((heap[indexToHeapIndex[i]])==(i))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+166 +"): (" + "heap[indexToHeapIndex[i]]" + ")" + "==" + "(" + "i" + ") ("+(heap[indexToHeapIndex[i]])+" vs. "+(i)+")"); } while (false);
                nValid++;
            }
            else
            {
                //CHECK(Double.isNaN(values[i])); // hmm, can't assert this... should I add API for determining if value in heap?
                nInvalid++;
            }
        }
        do { if (!((nValid)==(size))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+175 +"): (" + "nValid" + ")" + "==" + "(" + "size" + ") ("+(nValid)+" vs. "+(size)+")"); } while (false);
        do { if (!((nValid+nInvalid)==(max))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+176 +"): (" + "nValid+nInvalid" + ")" + "==" + "(" + "max" + ") ("+(nValid+nInvalid)+" vs. "+(max)+")"); } while (false);

        for (int i = 0; (i) < (size); ++i)
        {
            do { if (!(((0)<=(heap[i]))&&((heap[i])<(max)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+180 +"): (" + "0" + ")" + "<=" + "(" + "heap[i]" + ")" + "<" + "(" + "max" + ") ("+(0)+" vs. "+(heap[i])+" vs. "+(max)+")"); } while (false);
            do { if (!((indexToHeapIndex[heap[i]])==(i))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+181 +"): (" + "indexToHeapIndex[heap[i]]" + ")" + "==" + "(" + "i" + ") ("+(indexToHeapIndex[heap[i]])+" vs. "+(i)+")"); } while (false);
        }
        for (int i = size; i < max; ++i)
        {
            do { if (!((heap[i])==(-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+185 +"): (" + "heap[i]" + ")" + "==" + "(" + "-1" + ") ("+(heap[i])+" vs. "+(-1)+")"); } while (false);
        }

        for (int i = 1; i < size; ++i) // all but [0]
        {
            if (isTotalOrder)
            {
                // can assert strictly less, since nothing's exactly equal
                // due to tiebreaking by index.
                do { if (!((cmp.compare(heap[(((i)-1)>>1)], heap[i]))<(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+194 +"): (" + "cmp.compare(heap[(((i)-1)>>1)], heap[i])" + ")" + "<" + "(" + "0" + ") ("+(cmp.compare(heap[(((i)-1)>>1)], heap[i]))+" vs. "+(0)+")"); } while (false);
            }
            else
            {
                do { if (!((cmp.compare(heap[(((i)-1)>>1)], heap[i]))<=(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeap.prejava"+"("+198 +"): (" + "cmp.compare(heap[(((i)-1)>>1)], heap[i])" + ")" + "<=" + "(" + "0" + ") ("+(cmp.compare(heap[(((i)-1)>>1)], heap[i]))+" vs. "+(0)+")"); } while (false);
            }
        }
    } // sanityCheck

    // For test program, see IndexBinaryHeapKeyed
} // class IndexBinaryHeap
