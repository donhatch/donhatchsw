/*
  To visualize possible cases of cubes intersecting unit sphere:
  In gnuplot:
    set term wxt size 1000,1000
    set size square
    n = 10
    set isosamples 2,n+1
    set parametric
    c(t) = cos(pi/2/n*t)
    s(t) = sin(pi/2/n*t)
    splot [0:n] [0:n] [0:1] [0:1] [0:1] c(u)*c(v),s(u)*c(v),s(v), c(u)*c(v),s(v),s(u)*c(v), s(v),c(u)*c(v),s(u)*c(v)
  But that's not interesting, going to do a quad tree on cubmap faces instead
*/
package com.donhatchsw.util;
#include "macros.h"

import com.donhatchsw.util.VecMath;

// Temporarily, so PRINT, OUT, etc. will go to System.err instead of System.out
#define out err

// TODO: blue noise on unit sphere
// TODO: varying disk radii
public class BlueNoise
{

    private static class Cell
    {
        public double min[];
        public double max[];
        public int baseGridIndex;
        public void init(double min[], double max[], int baseGridIndex)
        {
            this.min = min; // acquires ownership
            this.max = max; // acquires ownership
            this.baseGridIndex = baseGridIndex;
        }
        public Cell(double min[], double max[], int baseGridIndex)
        {
            init(min, max, baseGridIndex);
        }
        public String toString()
        {
            return "["+VecMath.toString(min)+" .. "+VecMath.toString(max)+"]("+baseGridIndex+")";
        }
    } // class Cell

    private static boolean contains(Cell cell, double[] point)
    {
        FORI (i, point.length)
            if (!INRANGE(cell.min[i] <=, point[i], <= cell.max[i]))
                return false;
        return true;
    }

    private static void expandIndex(int iBaseGrid[], int nBaseGrid, int IBaseGrid)
    {
        int d = iBaseGrid.length;
        FORI (i, d)
        {
            iBaseGrid[i] = IBaseGrid % nBaseGrid;
            IBaseGrid /= nBaseGrid;
        }
        assert_eq(IBaseGrid, 0);
    }

    private static double wrappedDistSqrd(double a, double b)
    {
        double dist = a - b;
        if (dist > .5)
            dist -= 1.;
        else if (dist < -.5)
            dist += 1.;
        assert(INRANGE(-.5 <=, dist, <= .5));
        return dist*dist;
    }

    static boolean BRUTEFORCE = true;

    private static boolean isCoveredByADisk(double nonOverlappingDiskRadius,
                                            int maxIndexDifferenceOfInterest,
                                            int nBaseGrid,
                                            double baseGrid[][],
                                            double point[/*d*/],
                                            int startIndex)
    {
        int d = point.length;
        double thresholdDist2 = SQR(nonOverlappingDiskRadius*2.);
        int NBaseGrid = baseGrid.length;
        if (BRUTEFORCE || startIndex == -1)
        {
            // XXX brute force for starters
            FORI (IBaseGrid, NBaseGrid)
            {
                // dup code below
                double sample[] = baseGrid[IBaseGrid];
                if (sample != null)
                {
                    //System.err.println("              (in func) sample = "+VecMath.toString(sample));
                    double thisDist2 = 0.;
                    FORI (iDim, d)
                    {
                        thisDist2 += wrappedDistSqrd(sample[iDim], point[iDim]);
                    }
                    if (thisDist2 < thresholdDist2)
                    {
                        //System.err.println("                  yes");
                        return true;
                    }
                    else
                    {
                        //System.err.println("                  no");
                    }
                }
            }
        }
        else
        {
            assert_eq(d, 2);
            // XXX hard code 2d for starters
            // XXX hard code maxIndexDifferenceOfInterest for starters
            int i0 = startIndex / nBaseGrid;
            int j0 = startIndex % nBaseGrid;
            for (int di = -maxIndexDifferenceOfInterest; di <= maxIndexDifferenceOfInterest; ++di)
            for (int dj = -maxIndexDifferenceOfInterest; dj <= maxIndexDifferenceOfInterest; ++dj)
            {
                int i = MOD(i0+di, nBaseGrid);
                int j = MOD(j0+dj, nBaseGrid);
                int IBaseGrid = i*nBaseGrid + j;
                //System.err.println("          checking i="+i+" j="+j+" -> IBaseGrid="+IBaseGrid);

                // dup code from above
                double sample[] = baseGrid[IBaseGrid];
                if (sample != null)
                {
                    double thisDist2 = 0.;
                    FORI (iDim, d)
                    {
                        thisDist2 += wrappedDistSqrd(sample[iDim], point[iDim]);
                    }
                    if (thisDist2 < thresholdDist2)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    static boolean screwyVerbose = false;
    private static boolean isCompletelyCoveredByADisk(double nonOverlappingDiskRadius,
                                                      int maxIndexDifferenceOfInterest,
                                                      int nBaseGrid,
                                                      double baseGrid[][],
                                                      double min[/*d*/], double max[/*d*/],
                                                      int startIndex)
    {
        int verboseLevel = (screwyVerbose ? 1 : 0);
        if (verboseLevel >= 1) System.err.println("    in isCompletelyCoveredByADisk");
        int d = min.length;
        double thresholdDist2 = SQR(nonOverlappingDiskRadius*2.);
        int NBaseGrid = baseGrid.length;

        if (BRUTEFORCE || startIndex == -1)
        {
            // XXX brute force for starters
            FORI (IBaseGrid, NBaseGrid)
            {
                // dup code from below
                double sample[] = baseGrid[IBaseGrid];
                if (sample != null)
                {
                    double thisDist2 = 0.;
                    FORI (iDim, d)
                    {
                        double a = wrappedDistSqrd(sample[iDim], min[iDim]);
                        double b = wrappedDistSqrd(sample[iDim], max[iDim]);
                        thisDist2 += MAX(a, b);
                    }
                    if (thisDist2 < thresholdDist2)
                    {
                        //System.err.println("        yup. (brute force)");
                        if (verboseLevel >= 1) System.err.println("    out isCompletelyCoveredByADisk (yes, completely covered by disk centered at "+VecMath.toString(sample)+") because thisDist2="+thisDist2+" < "+thresholdDist2+"=thresholdDist2 i.e. thisDist="+Math.sqrt(thisDist2)+" < "+Math.sqrt(thresholdDist2)+"=thresholdDist");
                        return true;
                    }
                }
            }
        }
        else
        {
            assert_eq(d, 2);
            // XXX hard code 2d for starters
            // XXX hard code maxIndexDifferenceOfInterest for starters
            int i0 = startIndex / nBaseGrid;
            int j0 = startIndex % nBaseGrid;
            for (int di = -maxIndexDifferenceOfInterest; di <= maxIndexDifferenceOfInterest; ++di)
            for (int dj = -maxIndexDifferenceOfInterest; dj <= maxIndexDifferenceOfInterest; ++dj)
            {
                int i = MOD(i0+di, nBaseGrid);
                int j = MOD(j0+dj, nBaseGrid);
                int IBaseGrid = i*nBaseGrid + j;
                //System.err.println("          checking i="+i+" j="+j+" -> IBaseGrid="+IBaseGrid);

                // dup code from above
                double sample[] = baseGrid[IBaseGrid];
                if (sample != null)
                {
                    double thisDist2 = 0.;
                    FORI (iDim, d)
                    {
                        double a = wrappedDistSqrd(sample[iDim], min[iDim]);
                        double b = wrappedDistSqrd(sample[iDim], max[iDim]);
                        thisDist2 += MAX(a, b);
                    }
                    if (thisDist2 < thresholdDist2)
                    {
                        //System.err.println("        yes!");
                        if (verboseLevel >= 1) System.err.println("    out isCompletelyCoveredByADisk (yes, completely covered by disk centered at "+VecMath.toString(sample)+")");
                        return true;
                    }
                }
            }
        }
        if (verboseLevel >= 1) System.err.println("    out isCompletelyCoveredByADisk (nope)");
        return false;
    }
    private static int intpow(int a, int b)
    {
        int answer = 1;
        FORI (i, b)
            answer *= a;
        return answer;
    }

    public static int calcMaxIndexDifferenceOfInterest(double nonOverlappingDiskRadius,
                                                       double cellWidth)
    {
        // Say cellWidth is 1.
        // If overlappingDiskRadius>1 then answer=1.
        // If overlappingDiskRadius in (1,2) then a disk can completely cover one cell width
        // so answer is 2.
        // If overlappingDiskRadius in (2,3) then a disk can completely cover 2 cell widths
        // so answer is 3.
        // So answer is ceil(overlappingDiskRadius); however,
        // when exactly on a boundary, can round down, so say floor(...+1) instead of ceil(...).
        int answer = (int)Math.floor(2.*nonOverlappingDiskRadius / cellWidth) + 1;
        return answer;
    }

    // Maximal blue noise in unit box [-.5,.5]^n, toroidally wrapped.
    public static double[][] blueNoiseInUnitBox(int d, double nonOverlappingDiskRadius,
                                                java.util.Random rng)
    {
        int verboseLevel = 1;
        if (verboseLevel >= 1) System.err.println("    in blueNoiseInUnitBox");
        if (verboseLevel >= 1) System.err.println("      d="+d);
        if (verboseLevel >= 1) System.err.println("      nonOverlappingDiskRadius="+nonOverlappingDiskRadius);
        // http://www.cs.sandia.gov/~samitch/papers/eurographics_mps-final-with-appendix.pdf
        double A = .5; // see paper
        double B = 2; // see paper... although I don't use it because I don't quite understand

        // Choose base grid cell size so its diagonal
        // is <= (min distance between two samples) = 2*nonOverlappingDiskRadius.
        double minBaseGridCellDiagonal = 2. * nonOverlappingDiskRadius;
        System.err.println("      minBaseGridCellDiagonal = "+minBaseGridCellDiagonal);
        double minBaseGridCellWidth = minBaseGridCellDiagonal / Math.sqrt(d);
        System.err.println("      minBaseGridCellWidth = "+minBaseGridCellWidth);

        if (false)
        {
            System.err.println("      FUDGING=======================!");
            // FUDGE til get right answer. 4 is still too small. huh?
            //minBaseGridCellWidth /= 8.;
            //minBaseGridCellWidth /= 4.;
            minBaseGridCellWidth /= 2.;
        }

        int nBaseGrid = (int)Math.ceil(1./minBaseGridCellWidth);
        System.err.println("      nBaseGrid = "+nBaseGrid);
        double baseGridCellWidth = 1./nBaseGrid;
        System.err.println("      baseGridCellWidth = "+baseGridCellWidth);
        int maxIndexDifferenceOfInterest = calcMaxIndexDifferenceOfInterest(nonOverlappingDiskRadius, baseGridCellWidth);
        System.err.println("      maxIndexDifferenceOfInterest = "+maxIndexDifferenceOfInterest);

        int NBaseGrid = intpow(nBaseGrid, d);
        double baseGrid[][] = new double[NBaseGrid][]; // all null initially
        int nAnswer = 0;
        {
            Cell activeCells[] = new Cell[NBaseGrid];
            int iBaseGrid[] = new int[d]; // scratch for loop
            FORI (IBaseGrid, NBaseGrid)
            {
                expandIndex(iBaseGrid, nBaseGrid, IBaseGrid);
                //System.err.println("          iBaseGrid = "+Arrays.toStringCompact(iBaseGrid));
                double min[] = new double[d];
                double max[] = new double[d];
                FORI (i, d)
                {
                    min[i] = (iBaseGrid[i]+0)/(double)nBaseGrid - .5;
                    max[i] = (iBaseGrid[i]+1)/(double)nBaseGrid - .5;
                }
                activeCells[IBaseGrid] = new Cell(min, max, IBaseGrid);
                //System.err.println("          activeCells["+IBaseGrid+"] = "+activeCells[IBaseGrid]);
            }
            int nActiveCells = NBaseGrid;


            while (nActiveCells > 0)
            {
                System.err.println("      nActiveCells = "+nActiveCells);

                // throw darts
                int nThrows = (int)Math.ceil(A * activeCells.length);
                FORI (iThrow, nThrows)
                {
                    // select an active cell uniformly at random
                    int iCell = rng.nextInt(nActiveCells);
                    Cell cell = activeCells[iCell];
                    if (baseGrid[cell.baseGridIndex] != null) // if parent base grid cell has a sample
                    {
                        // remove activeCells[iCell]
                        activeCells[iCell] = activeCells[--nActiveCells];
                    }
                    else
                    {
                        // throw candidate dart into the cell, uniform random
                        double[] dart = new double[d];
                        FORI (i, d)
                        {
                            double t = rng.nextDouble();
                            dart[i] = LERP(cell.min[i], cell.max[i], t);
                        }
                        //System.err.println("              dart: "+VecMath.toString(dart));
                        if (!isCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, dart, cell.baseGridIndex))
                        {
                            //assert (!isCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, dart, -1));
                            // promote dart to sample by adding it to the base grid
                            //System.err.println("                  promoting to sample!");
                            baseGrid[cell.baseGridIndex] = dart;
                            nAnswer++;

                            // remove activeCells[iCell]
                            activeCells[iCell] = activeCells[--nActiveCells];
                            // additional cells might be covered, but these are ignored for now
                        }
                    }
                    if (nActiveCells == 0)
                        break;
                }

                // subdivide each cell into 2^d subcells, and
                // retain the uncovered ones.
                // The paper refers to "B" and "b" but I don't understand it.
                Cell subcells[] = new Cell[nActiveCells * (1<<d)];
                int nSubCells = 0;
                double min[] = new double[d];
                double max[] = new double[d];
                //double screwyPoint[] = {0.25672363723250224,0.19255509143253713};
                double screwyPoint[] = {0.3407809705593303,0.2899772882313273};
                PRINTVEC(screwyPoint);
                FORI (iCell, nActiveCells)
                {
                    Cell cell = activeCells[iCell];
                    boolean isScrewy = false;
                    if (contains(cell, screwyPoint))
                    {
                        System.err.println("Hey! screwy point is in cell "+cell);
                        isScrewy = true;
                        screwyVerbose = true;
                        System.err.println("   is completely covered? "+isCompletelyCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, cell.min, cell.max, cell.baseGridIndex));
                        screwyVerbose = false;

                    }
                    if (!isCompletelyCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, cell.min, cell.max, cell.baseGridIndex))
                    {
                        //assert (!isCompletelyCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, cell.min, cell.max, -1));
                        FORI (iSub, 1<<d)
                        {
                            FORI (i, d)
                            {
                                int bit = (iSub>>i) & 1;
                                if (bit == 0)
                                {
                                    min[i] = cell.min[i];
                                    max[i] = (cell.min[i]+cell.max[i])/2.;
                                }
                                else
                                {
                                    min[i] = (cell.min[i]+cell.max[i])/2.;
                                    max[i] = cell.max[i];
                                }
                            }
                            if (contains(new Cell(min, max, cell.baseGridIndex), screwyPoint))
                            {
                                System.err.println("Hey! screwy point is in subcell cell "+new Cell(min, max, cell.baseGridIndex));
                                isScrewy = true;
                                screwyVerbose = true;
                                System.err.println("   is completely covered? "+isCompletelyCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, cell.min, cell.max, cell.baseGridIndex));
                                screwyVerbose = false;
                            }
                            // If we can't easily prove that the subcell is covered, then retain it
                            if (!isCompletelyCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, min, max, cell.baseGridIndex))
                            {
                                //assert (!isCompletelyCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, min, max, -1));
                                subcells[nSubCells++] = new Cell(min, max, cell.baseGridIndex);
                                // that acquired ownership of min,max, so reallocate
                                min = new double[d];
                                max = new double[d];
                            }
                        }
                    }
                }

                System.err.println("          nSubCells = "+nSubCells);

                activeCells = subcells;
                nActiveCells = nSubCells;
            } // while (nActiveCells > 0)
        }
        double answer[][] = new double[nAnswer][];
        {
            int iAnswer = 0;
            FORI (IBaseGrid, NBaseGrid)
            {
                if (baseGrid[IBaseGrid] != null)
                    answer[iAnswer++] = baseGrid[IBaseGrid];
            }
            assert_eq(iAnswer, nAnswer);
        }

        if (true)
        {
            // sanity check that nothing uncovered remains
            System.err.println("  sanity checking that nothing uncovered remains...");
            int nChecks = 1000;
            double checkPoint[] = new double[d]; // scratch for loop
            FORI (iCheck, nChecks)
            {
                FORI (i, d)
                {
                    checkPoint[i] = rng.nextDouble() - .5;
                }
                boolean isCovered = false;
                //System.err.println("          checkPoint = "+VecMath.toString(checkPoint));
                FORI (iSample, answer.length)
                {
                    //System.err.println("              sample = "+VecMath.toString(answer[iSample]));
                    double scratchPoint[] = VecMath.copyvec(checkPoint);
                    FORI (i, d)
                        if (scratchPoint[i] > answer[iSample][i]+.5)
                            scratchPoint[i] -= 1.;
                        else if (scratchPoint[i] < answer[iSample][i]-.5)
                            scratchPoint[i] += 1.;
                    if (VecMath.dist(scratchPoint, answer[iSample]) < 2*nonOverlappingDiskRadius)
                    {
                        //System.err.println("                  yes, covered");
                        isCovered = true;
                    }
                    else
                    {
                        //System.err.println("                  no, not covered");
                    }
                }
                int baseGridIndex = -1; // -1 means check all base grid cells
                assert_eq(isCovered, isCoveredByADisk(nonOverlappingDiskRadius, maxIndexDifferenceOfInterest, nBaseGrid, baseGrid, checkPoint, baseGridIndex));
                if (!isCovered)
                {
                    System.err.println("checkPoint = "+VecMath.toString(checkPoint));
                }
                assert(isCovered);
            }
            System.err.println("  done.");
        }

        if (verboseLevel >= 1) System.err.println("    out blueNoiseInUnitBox");
        return answer;
    } // blueNoiseInUnitBox
    // Maximal blue noise on d-1 dimensional surface of hypersphere in d dimensions.
    public static double[][] blueNoiseOnUnitSphere(int d, double nonOverlappingDiskRadius)
    {
        unimplemented(); // TODO: implement me!
        return null;
    } // blueNoiseOnUnitSphere

    // little test program
    public static void main(String args[])
    {
        if (args.length < 2)
        {
            System.err.println("Usage: BlueNoise <d> <nonOverlappingDiskRadius> [<seed>]");
            System.exit(1);
        }
        int d = Integer.parseInt(args[0]);
        double nonOverlappingDiskRadius = Double.parseDouble(args[1]);
        long seed = args.length>=3 ? Long.parseLong(args[2]) : 0;
        java.util.Random rng = new java.util.Random(seed);
        System.err.println("d = "+d);
        System.err.println("nonOverlappingDiskRadius = "+nonOverlappingDiskRadius);
        double blueNoise[][] = blueNoiseInUnitBox(d, nonOverlappingDiskRadius, rng);
        System.err.println("blueNoise.length = "+blueNoise.length);
#undef out
        FORI (iSample, blueNoise.length)
        {
            FORI (i, d)
                System.out.print(" "+blueNoise[iSample][i]);
            System.out.println();
        }
    } // main
} // class BlueNoise
