// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// 102 # 1 "com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"
// 103 # 1 "<built-in>"
// 104 # 1 "<command-line>"
// 105 # 1 "com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"
/* vim: set filetype=java: */
// 107 # 1 "com/donhatchsw/util/macros.h" 1
//
// macros.h
//
// 111 # 14 "com/donhatchsw/util/macros.h"
// NOTE: this causes a,b to be evaluated twice on failure, so is not ideal. might be better to do a block... ?
// 113 # 30 "com/donhatchsw/util/macros.h"
// Note: the additional "(a)==(b)||" is to make it work correctly for infinities...
// and causes the args to be evaluated twice.
// 116 # 67 "com/donhatchsw/util/macros.h"
// XXX ... what a mess
// 118 # 3 "com/donhatchsw/util/IndexBinaryHeapKeyed.prejava" 2
package com.donhatchsw.util;
/**
* A binary heap whose items are (index,value) pairs
* where the indices are in a known range 0,...,n-1
* and the values are doubles.
*/
public class IndexBinaryHeapKeyed
{
    private IndexBinaryHeap heapGeneral;
    private double values[]; // index to value

    /** Constructs a heap whose indices are in the range 0,...,max-1. */
    public IndexBinaryHeapKeyed(int max)
    {
        this.values = VecMath.fillvec(max, Double.NaN);
        this.heapGeneral = new IndexBinaryHeap(max, new SortStuff.IntComparator() {
            @Override public int compare(int i, int j)
            {
                if (values[i] < values[j]) return -1;
                if (values[i] > values[j]) return 1;
                // Use indices themselves as tiebreakers, for determistic sort order
                if (i < j) return -1;
                if (i > j) return 1;
                return 0;
            }
        });
    }

    /** Adds the given index to the heap, with the given value.  It is an error to call this on an index that is already in the heap. */
    public void add(int index, double val)
    {
        do { if (!(!Double.isNaN(val))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+34 +"): " + "!Double.isNaN(val)" + ""); } while (false);
        do { if (!(Double.isNaN(values[index]))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+35 +"): " + "Double.isNaN(values[index])" + ""); } while (false);
        values[index] = val;
        heapGeneral.add(index);
    }
    /** Remove the given index from the heap.  It is an error to call this on an index that is not in the heap. */
    public void remove(int index)
    {
        do { if (!(!Double.isNaN(values[index]))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+42 +"): " + "!Double.isNaN(values[index])" + ""); } while (false);
        values[index] = Double.NaN;
        heapGeneral.remove(index);
    }
    /** Returns the index with minimum value, without removing it.  It is an error to call this if the heap is empty. */
    public int min()
    {
        return heapGeneral.min();
    }

    /** Removes and returns the index with minimum value.  It is an error to call this if the heap is empty. */
    public int extractMin()
    {
        int ret = min();
        remove(ret);
        return ret;
        // ... or could call heapGeneral.extractMin() and set values[index] = Double.NaN.
    }
    /** Tells whether the heap is empty. */
    public boolean isEmpty()
    {
        return heapGeneral.isEmpty();
    }
    /** Equivalent to remove(index); add(index,val); but more efficient. */
    public void adjust(int index, double val)
    {
        do { if (!(!Double.isNaN(values[index]))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+68 +"): " + "!Double.isNaN(values[index])" + ""); } while (false);
        values[index] = val;
        heapGeneral.adjust(index);
    } // adjust
    /** get current value of the given index, or NaN if not in the heap. */
    public double getValue(int index)
    {
        return values[index];
    }

    private void sanityCheck()
    {
        if (false)
        {
            System.out.println("in sanityCheck");
        }

        int max = values.length;
        for (int i = 0; (i) < (max); ++i)
        {
            do { if (!((heapGeneral.contains(i))==(!Double.isNaN(values[i])))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+88 +"): (" + "heapGeneral.contains(i)" + ")" + "==" + "(" + "!Double.isNaN(values[i])" + ") ("+(heapGeneral.contains(i))+" vs. "+(!Double.isNaN(values[i]))+")"); } while (false);
        }

        heapGeneral.sanityCheck(true);

        if (false)
        {
            System.out.println("out sanityCheck");
        }
    } // sanityCheck

    // This isn't intended to ever be used externally,
    // it's just for the confidence test.
    private static int[] heapSortWithSanityChecks(double vals[], java.util.Random rng)
    {
        int sortedInds[] = new int[vals.length];
        IndexBinaryHeapKeyed heap = new IndexBinaryHeapKeyed(vals.length);
        heap.sanityCheck();

        // insert in random order; that's a better stress-test of the heap
        int randomPerm[] = VecMath.randomperm(vals.length, rng);
        for (int ii = 0; (ii) < (vals.length); ++ii)
        {
            int i = randomPerm[ii];
            heap.add(i, vals[i]);
            heap.sanityCheck();
        }
        for (int i = 0; (i) < (sortedInds.length); ++i)
        {
            do { if (!(!heap.isEmpty())) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+117 +"): " + "!heap.isEmpty()" + ""); } while (false);
            sortedInds[i] = heap.extractMin();
            heap.sanityCheck();
        }
        do { if (!(heap.isEmpty())) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+121 +"): " + "heap.isEmpty()" + ""); } while (false);
        return sortedInds;
    } // heapSortWithSanityChecks

    /**
    * Little confidence test program.
    */
    public static void main(String args[])
    {
        System.out.println("in IndexBinaryHeapKeyed.main");
        int nMaxes = 15;
        int nSortsPerMax = 15;
        java.util.Random rng = new java.util.Random(0);
        for (int max = 0; (max) < (nMaxes); ++max)
        {
            for (int iSort = 0; (iSort) < (nSortsPerMax); ++iSort)
            {
                double vals[] = VecMath.random(max, rng);

                // make some of them equal to others
                for (int iFudge = 0; (iFudge) < (max*3/4); ++iFudge)
                    vals[Arrays.randomIndex(max,rng)] = vals[Arrays.randomIndex(max,rng)];

                System.out.println("        " + "vals" + " = " + Arrays.toStringCompact(vals));
                int sortedInds[] = heapSortWithSanityChecks(vals, rng);
                System.out.println("        " + "sortedInds" + " = " + Arrays.toStringCompact(sortedInds));
                System.out.println("============");
                do { if (!((sortedInds.length)==(max))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+148 +"): (" + "sortedInds.length" + ")" + "==" + "(" + "max" + ") ("+(sortedInds.length)+" vs. "+(max)+")"); } while (false);
                for (int i = 0; (i) < (max-1); ++i)
                {
                    do { if (!(vals[sortedInds[i]] <= vals[sortedInds[i+1]])) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+151 +"): " + "vals[sortedInds[i]] <= vals[sortedInds[i+1]]" + ""); } while (false);
                    // Nothing's exactly "equal" due to tiebreaking by index.
                    int I = sortedInds[i];
                    int J = sortedInds[i+1];
                    do { if (!(vals[I] < vals[J] || (vals[I]==vals[J] && I<J))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+155 +"): " + "vals[I] < vals[J] || (vals[I]==vals[J] && I<J)" + ""); } while (false);
                }
                do { if (!((VecMath.sum(sortedInds))==(max*(max-1)/2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/IndexBinaryHeapKeyed.prejava"+"("+157 +"): (" + "VecMath.sum(sortedInds)" + ")" + "==" + "(" + "max*(max-1)/2" + ") ("+(VecMath.sum(sortedInds))+" vs. "+(max*(max-1)/2)+")"); } while (false); // if this is right then we probably got all the indices
            }
        }
        System.out.println("ALL GOOD!");
        System.out.println("out IndexBinaryHeapKeyed.main");
    }
} // class IndexBinaryHeapKeyed
