#include "macros.h" // XXX get rid
#undef PRINTARRAY
#define PRINTARRAY(x) System.out.println(#x + " = " + arrayToString(x))

//
// XXX to do:
//     - need asset radius
//     - do NOT steal focus on startup!! dang it!
//     - and what is the beep???
//     - think about whether I can jitter or something
//           to handle multiple events with exact same srcs and dsts
//     - center it initially and when window resized
//     - antialiased lines?
//     - thicken lines? nah...
//     - label assets? might help for debugging
//     - gui elements for +, -, clean up circle
//     - autoclean! (when n, d, or move)
//     - save/load?
//     - clever centering zoom
//     - arrowheads on single-sources? not sure


class AssetGraphUtils
{

    //
    // Get curves representing an event.
    //
    public static java.awt.Shape[] getCurves(
              double srcs[][/*2*/], int srcInds[], // inds may be null
              double dsts[][/*2*/], int dstInds[], // inds may be null
              double srcRadii[], // keep arrows this far away
              double dstRadii[], // keep arrows this far away
              double arrowHeadLength,

              double graphCenterForSingle[/*2*/],
              double arrowLengthForSingle)
    {
        int nSrcs = (srcInds != null ? srcInds.length : srcs.length);
        int nDsts = (dstInds != null ? dstInds.length : dsts.length);

        if (nSrcs == 0 && nDsts == 0)
        {
            return new java.awt.Shape[0];
        }
        else if (nSrcs == 1 && nDsts == 0)
        {
            // Make an arrow from this src to nothingness
            int nCurves = 1;
            java.awt.Shape curves[] = new java.awt.Shape[nCurves];
            double src[] = (srcInds != null ? srcs[srcInds[0]] : srcs[0]);
            double dst[] = lerp(graphCenterForSingle, src,
                                 1. + arrowLengthForSingle/dist(graphCenterForSingle[0],graphCenterForSingle[1], src[0],src[1]));
            int iCurve = 0;
            curves[iCurve++] = new java.awt.geom.CubicCurve2D.Double(
                                            src[0], src[1],
                                            src[0], src[1],
                                            dst[0], dst[1],
                                            dst[0], dst[1]);
            assert(iCurve == nCurves);
            return curves;
        }
        else if (nDsts == 1 && nSrcs == 0)
        {
            // Make an arrow from nothingness to this dst
            int nCurves = 3;
            java.awt.Shape curves[] = new java.awt.Shape[nCurves];
            double dst[] = (dstInds != null ? dsts[dstInds[0]] : dsts[0]);
            double src[] = lerp(graphCenterForSingle, dst,
                                 1. + arrowLengthForSingle/dist(graphCenterForSingle[0],graphCenterForSingle[1], dst[0],dst[1]));
            int iCurve = 0;
            curves[iCurve++] = new java.awt.geom.CubicCurve2D.Double(
                                            src[0], src[1],
                                            src[0], src[1],
                                            dst[0], dst[1],
                                            dst[0], dst[1]);
            curves[iCurve++] = arrowHeadSide(src[0], src[1],
                                             dst[0], dst[1],
                                             arrowHeadLength,
                                             Math.PI*5/6);
            curves[iCurve++] = arrowHeadSide(src[0], src[1],
                                             dst[0], dst[1],
                                             arrowHeadLength,
                                             -Math.PI*5/6);
            assert(iCurve == nCurves);
            return curves;
        }
        else if (nDsts == 0)
        {
            // Only srcs
            int nCurves = nSrcs;
            java.awt.Shape curves[] = new java.awt.Shape[nCurves];
            double srcCenter[/*2*/] = average(srcs, srcInds);
            int iCurve = 0;
            for (int iSrc = 0; iSrc < nSrcs; ++iSrc)
            {
                double src[/*2*/] = (srcInds != null ? srcs[srcInds[iSrc]] : srcs[iSrc]);
                curves[iCurve++] = new java.awt.geom.CubicCurve2D.Double(
                                            src[0], src[1],
                                            src[0], src[1],
                                            srcCenter[0], srcCenter[1],
                                            srcCenter[0], srcCenter[1]);
            }
            assert(iCurve == nCurves);
            return curves;
        }
        else if (nSrcs == 0)
        {
            // Only dsts
            int nCurves = nDsts*3;
            java.awt.Shape curves[] = new java.awt.Shape[nCurves];
            double dstCenter[/*2*/] = average(dsts, dstInds);
            int iCurve = 0;
            for (int iDst = 0; iDst < nDsts; ++iDst)
            {
                double dst[/*2*/] = (dstInds != null ? dsts[dstInds[iDst]] : dsts[iDst]);
                curves[iCurve++] = new java.awt.geom.CubicCurve2D.Double(
                                            dst[0], dst[1],
                                            dst[0], dst[1],
                                            dstCenter[0], dstCenter[1],
                                            dstCenter[0], dstCenter[1]);
                curves[iCurve++] = arrowHeadSide(dstCenter[0], dstCenter[1],
                                                 dst[0], dst[1],
                                                 arrowHeadLength,
                                                 Math.PI*5/6);
                curves[iCurve++] = arrowHeadSide(dstCenter[0], dstCenter[1],
                                                 dst[0], dst[1],
                                                 arrowHeadLength,
                                                 -Math.PI*5/6);
            }
            assert(iCurve == nCurves);
            return curves;
        }
        else // nSrcs > 0 && nDsts > 0
        {
            int nCurves = nSrcs + 1 + nDsts*3;
            java.awt.Shape curves[] = new java.awt.Shape[nCurves];
            double srcCenter[/*2*/] = average(srcs, srcInds);
            double dstCenter[/*2*/] = average(dsts, dstInds);
            double centerCenter[/*2*/] = lerp(srcCenter, dstCenter, .5);
            double A[/*2*/] = lerp(srcCenter, centerCenter, .5);
            double B[/*2*/] = lerp(dstCenter, centerCenter, .5);

            //double controlA[/*2*/] = lerp(A, srcCenter, 1./3.);
            //double controlB[/*2*/] = lerp(B, dstCenter, 1./3.);
            // XXX experimenting... it's nicer (more curvy) when closer to srcCenter, but then sometimes the arrow heads and up cramped
            double controlA[/*2*/] = lerp(A, srcCenter, .5);
            double controlB[/*2*/] = lerp(B, dstCenter, .5);
            if (nSrcs + nDsts == 3)
            {
                // hack, sort of... just put A and B right in the center;
                // average of the 3 sites.
                // this means the bar will be zero-length.
                A = B = lerp(srcCenter, dstCenter, (double)nDsts/(nSrcs+nDsts));
            }

            int iCurve = 0;
            for (int iSrc = 0; iSrc < nSrcs; ++iSrc)
            {
                double src[/*2*/] = (srcInds != null ? srcs[srcInds[iSrc]] : srcs[iSrc]);
                curves[iCurve++] = new java.awt.geom.CubicCurve2D.Double(
                                            src[0], src[1],
                                            src[0], src[1],
                                            controlA[0], controlA[1],
                                            A[0], A[1]);
            }
            for (int iDst = 0; iDst < nDsts; ++iDst)
            {
                double dst[/*2*/] = (dstInds != null ? dsts[dstInds[iDst]] : dsts[iDst]);
                curves[iCurve++] = new java.awt.geom.CubicCurve2D.Double(
                                            B[0], B[1],
                                            controlB[0], controlB[1],
                                            dst[0], dst[1],
                                            dst[0], dst[1]);
            }
            // Arrowheads...
            for (int iDst = 0; iDst < nDsts; ++iDst)
            {
                double dst[/*2*/] = (dstInds != null ? dsts[dstInds[iDst]] : dsts[iDst]);
                // XXX note, controlB is kind of a hack... but it sorta works most of the time.
                curves[iCurve++] = arrowHeadSide(controlB[0], controlB[1],
                                                 dst[0], dst[1],
                                                 arrowHeadLength,
                                                 Math.PI*5/6);
                curves[iCurve++] = arrowHeadSide(controlB[0], controlB[1],
                                                 dst[0], dst[1],
                                                 arrowHeadLength,
                                                 -Math.PI*5/6);
            }

            // Straight line between A and B...
            curves[iCurve++] = new java.awt.geom.CubicCurve2D.Double(
                A[0], A[1],
                A[0], A[1],
                B[0], B[1],
                B[0], B[1]);
            assert(iCurve == nCurves);
            return curves;
        }
    } // getCurves


        private static java.awt.Shape arrowHeadSide(double x0, double y0,
                                                    double x1, double y1,
                                                    double arrowHeadLength,
                                                    double angDelta)
        {
            double ang = Math.atan2(y1-y0,x1-x0);
            double newAng = ang + angDelta;
            double x = x1 + arrowHeadLength * Math.cos(newAng);
            double y = y1 + arrowHeadLength * Math.sin(newAng);
            return new java.awt.geom.Line2D.Double(x1,y1, x,y);
        } // leftArrowHead

        private static double[] average(double points[][/*dim*/], int inds[])
        {
            if (points.length == 0)
                return null;
            int dim = points[0].length;
            double result[] = new double[dim]; // initially all zeros
            int n = (inds != null ? inds.length : points.length);
            for (int i = 0; i < n; ++i)
            {
                double point[] = points[inds != null ? inds[i] : i];
                assert(point.length == dim);
                for (int j = 0; j < dim; ++j)
                    result[j] += point[j];
            }
            for (int j = 0; j < dim; ++j)
                result[j] *= 1./n;
            return result;
        } // average


    //========================================================================
    // The rest of this is for main()
    //

    // A fuzzy point, i.e. a closed unit disk with center x,y and radius r.
    // We store r*r instead of r, since r itself is hardly
    // ever needed so this saves computing a lot of square roots.
    static class FuzzyPoint {
        double x, y, rSqrd;
    }
    static void getCurveBoundingBall(java.awt.geom.CubicCurve2D curve,
                                     FuzzyPoint result)
    {
        // A CubicCurve2D is always contained inside
        // the bounding box of its 4 definining points...
        double x0 = curve.getX1();
        double y0 = curve.getY1();
        double x1 = curve.getCtrlX1();
        double y1 = curve.getCtrlY1();
        double x2 = curve.getCtrlX2();
        double y2 = curve.getCtrlY2();
        double x3 = curve.getX2();
        double y3 = curve.getY2();
        double x = (x0+x1+x2+x3)*.25;
        double y = (y0+y1+y2+y3)*.25;

        double distSqrd0 = distSqrd(x,y, x0,y0);
        double distSqrd1 = distSqrd(x,y, x1,y1);
        double distSqrd2 = distSqrd(x,y, x2,y2);
        double distSqrd3 = distSqrd(x,y, x3,y3);
        double rSqrd = max4(distSqrd0,distSqrd1,distSqrd2,distSqrd3);

        result.x = x;
        result.y = y;
        result.rSqrd = rSqrd;
    } // getCurveBoundingBall


    private static int[/*2*/] getClosestPointOnCubicCurves(
                                   double x, double y,
                                   java.awt.Shape curves[][],
                                   double tooFar,
                                   double maxFuzzyRadius,
                                   FuzzyPoint closestPoint) // output
    {
        int bestI = -1;
        int bestJ = -1;
        double bestX = Double.NaN;
        double bestY = Double.NaN;
        double bestRSqrd = Double.NaN;

        for (int i = 0; i < curves.length; ++i)
        for (int j = 0; j < curves[i].length; ++j)
        {
            if (curves[i][j] instanceof java.awt.geom.CubicCurve2D)
            {
                java.awt.geom.CubicCurve2D curve = (java.awt.geom.CubicCurve2D)curves[i][j];
                if (getClosestPointOnCubicCurve(x, y, curve,
                                                tooFar,
                                                maxFuzzyRadius,
                                                closestPoint,
                                                0)) // verbose
                {
                    bestI = i;
                    bestJ = j;
                    bestX = closestPoint.x;
                    bestY = closestPoint.y;
                    bestRSqrd = closestPoint.rSqrd;
                    double newTooFar = dist(x, y, bestX, bestY);
                    // XXX argh, the following fails, need fuzzy comparison I think? or else I messed up my logic
                    if (newTooFar >= tooFar)
                    {
                        System.out.println("uh oh, newTooFar = "+newTooFar+", tooFar = "+tooFar+"");
                    }
                    assert(newTooFar < tooFar); // it shouldn't have succeeded otherwise
                    tooFar = newTooFar;
                }
            }
        }

        closestPoint.x = bestX;
        closestPoint.y = bestY;
        closestPoint.rSqrd = bestRSqrd;

        return new int[] {bestI, bestJ};
    } // getClosestPointOnCubicCurves


    private static boolean getClosestPointOnCubicCurve(
                               double x, double y,
                               java.awt.geom.CubicCurve2D curve,
                               double tooFar,
                               double maxFuzzyRadius,
                               FuzzyPoint closestPoint, // output
                               int verbose)
    {
        // recursive function assumes closestPoint
        // has been filled in with a bounding ball...
        // (this is an optimization because
        // in all recursive calls, the caller already knows the bounding ball).
        getCurveBoundingBall(curve, closestPoint);
        int nSubdivsCalled[] = {0};
        //System.out.println("========");
        boolean result = _getClosestPointOnCubicCurve(x,y, curve, tooFar,
                                                      maxFuzzyRadius,
                                                      closestPoint,
                                                      nSubdivsCalled,

                                                      null
                                                      //"." use this instead to debug

                                                      );
        if (verbose >= 1) System.out.println("    num subdivs called = "+nSubdivsCalled[0]+"");
        return result;
    } // getClosestPointOnCubicCurve

    // Recursive work function of getClosestPointOnCubicCurve().
    // closestPoint must be initialized to a bounding ball
    // of the curve (caller can do this using getCurveBoundingBall).
    private static boolean _getClosestPointOnCubicCurve(
                               double x, double y,
                               java.awt.geom.CubicCurve2D curve,
                               double tooFar,
                               double maxFuzzyRadius,
                               FuzzyPoint closestPoint, // input/output
                               int nSubdivsCalled[/*1*/], // output statistics
                               String addressForDebugging)
    {
        if (addressForDebugging != null)
            System.out.println("Looking at: "+addressForDebugging);
        // Caller has already filled in closestPoint with
        // a bounding ball of the curve...
        double distSqrd = distSqrd(x,y, closestPoint.x,closestPoint.y);
        if (closestPoint.rSqrd <= maxFuzzyRadius*maxFuzzyRadius)
        {
            // fuzzy point is small enough, no need to subdivide further,
            // and closestPoint is already filled in.
            //System.out.println("    SMALL ENOUGH");
            return distSqrd < tooFar*tooFar;
        }
        double minPossibleDist = Math.sqrt(distSqrd)
                               - Math.sqrt(closestPoint.rSqrd);
        if (minPossibleDist < 0)
            minPossibleDist = 0;
        //PRINT(minPossibleDist);
        if (minPossibleDist*minPossibleDist >= tooFar*tooFar)
        {
            //System.out.println("    TOO FAR");
            return false;
        }
        //System.out.println("    SUBDIVIDING");

        //
        // Subdivide
        //
        java.awt.geom.CubicCurve2D left = new java.awt.geom.CubicCurve2D.Double();
        java.awt.geom.CubicCurve2D right = new java.awt.geom.CubicCurve2D.Double();
        curve.subdivide(left, right);
        ++nSubdivsCalled[0];

        FuzzyPoint leftPoint = new FuzzyPoint();
        FuzzyPoint rightPoint = new FuzzyPoint();

        getCurveBoundingBall(left, leftPoint);
        getCurveBoundingBall(right, rightPoint);

        double leftDistSqrd = distSqrd(x,y,leftPoint.x,leftPoint.y);
        double rightDistSqrd = distSqrd(x,y,rightPoint.x,rightPoint.y);

        //System.out.println("    dists = "+Math.sqrt(leftDistSqrd)+","+Math.sqrt(rightDistSqrd));
        boolean swapped = false; // for debugging
        if (rightDistSqrd < leftDistSqrd)
        //if (rightDistSqrd > leftDistSqrd) // XXX WRONG! testing, should be grossly inefficient
        {
            // Swap left and right so that left is closer
            { java.awt.geom.CubicCurve2D temp = left; left = right; right = temp; }
            { FuzzyPoint temp = leftPoint; leftPoint = rightPoint; rightPoint = temp; }
            swapped = true;
        }

        boolean leftResult = _getClosestPointOnCubicCurve(x, y, left,
                                                          tooFar,
                                                          maxFuzzyRadius,
                                                          leftPoint,
                                                          nSubdivsCalled,
                                                          addressForDebugging != null ? "    "+addressForDebugging+(swapped?"l":"L"):null);
        if (leftResult)
        {
            double newTooFar = dist(x, y, leftPoint.x, leftPoint.y);
            // XXX argh, the following fails, need fuzzy comparison I think? or else I messed up my logic
            if (newTooFar >= tooFar)
            {
                System.out.println("uh oh, newTooFar = "+newTooFar+", tooFar = "+tooFar+"");
            }
            assert(newTooFar < tooFar); // it shouldn't have succeeded otherwise
            tooFar = newTooFar;
        }
        boolean rightResult = _getClosestPointOnCubicCurve(x, y, right,
                                                           tooFar,
                                                           maxFuzzyRadius,
                                                           rightPoint,
                                                           nSubdivsCalled,
                                                           addressForDebugging != null ? "    "+addressForDebugging+(swapped?"r":"R"):null);
        if (rightResult)
        {
            closestPoint.x = rightPoint.x;
            closestPoint.y = rightPoint.y;
            closestPoint.rSqrd = rightPoint.rSqrd;
            return true;
        }
        else if (leftResult)
        {
            closestPoint.x = leftPoint.x;
            closestPoint.y = leftPoint.y;
            closestPoint.rSqrd = leftPoint.rSqrd;
            return true;
        }
        else
        {
            return false;
        }
    } // _getClosestPointOnCubicCurve


    //
    // Little utils...
    //
    private static double max4(double a, double b, double c, double d)
    {
        double max = a;
        if (b > max) max = b;
        if (c > max) max = c;
        if (d > max) max = d;
        return max;
    } // max4
    private static double min4(double a, double b, double c, double d)
    {
        double min = a;
        if (b < min) min = b;
        if (c < min) min = c;
        if (d < min) min = d;
        return min;
    } // min4
    private static int min4i(double a, double b, double c, double d)
    {
        int i = 0;
        double min = a;
        if (b < min) {i = 1; min = b;}
        if (c < min) {i = 2; min = c;}
        if (d < min) {i = 3; min = d;}
        return i;
    } // min4i
    private static double distSqrd(double x0, double y0, double x1, double y1)
    {
        return (x1-x0)*(x1-x0) + (y1-y0)*(y1-y0);
    } // distSqrd
    private static double dist(double x0, double y0, double x1, double y1)
    {
        return Math.sqrt(distSqrd(x0,y0, x1,y1));
    }
    private static double[] lerp(double a[], double b[], double t)
    {
        int n = a.length;
        assert(n == b.length);
        double result[] = new double[n];
        for (int i = 0; i < n; ++i)
            result[i] = (1.-t)*a[i] + t*b[i];
        return result;
    } // lerp



    //======================================================================
        static void drawSquare(java.awt.Graphics2D g2d,
                               double x, double y, double r)
        {
            java.awt.geom.Rectangle2D.Double square = new java.awt.geom.Rectangle2D.Double(x-r, y-r, 2*r, 2*r);
            g2d.draw(square);
        } // drawSquare

        // draw showing subdivision points, for debugging.
        // if nLevels is 0, just draw normally.
        static void drawCurveSubdivided(java.awt.Graphics2D g2d, java.awt.geom.CubicCurve2D curve, int nLevels)
        {
            if (nLevels > 0)
            {
                java.awt.geom.CubicCurve2D left = new java.awt.geom.CubicCurve2D.Double();
                java.awt.geom.CubicCurve2D right = new java.awt.geom.CubicCurve2D.Double();
                curve.subdivide(left, right);
                drawCurveSubdivided(g2d, left, nLevels-1);
                drawCurveSubdivided(g2d, right, nLevels-1);
                // both should end up in same place...
                drawSquare(g2d, left.getX2(),left.getY2(), 2);
                drawSquare(g2d, right.getX1(),right.getY1(), 4);
            }
            else
            {
                g2d.draw(curve);
            }
        } // drawCurveSubdivided

    public static class MyPanel
        extends javax.swing.JPanel
    {
        // PAINT
        public void paintComponent(java.awt.Graphics g)
        {
            if (eventVerbose >= 2) System.out.println("    in paint");

            if (nFramesUntilFuture > 0
             && futureAssets != null)
            {
                // I guess we can tolerate an asset being added...
                assert(futureAssets.length <= assets.length);
                for (int i = 0; i < futureAssets.length; ++i)
                {
                    double a = scheduleUntilFuture[scheduleUntilFuture.length-1-nFramesUntilFuture];
                    double b = scheduleUntilFuture[scheduleUntilFuture.length-nFramesUntilFuture];
                    double t = (b-a)/(1.-a);
                    assets[i] = lerp(assets[i], futureAssets[i], t);
                }
                connectionCurves = null; // dirty
                --nFramesUntilFuture;
                repaint(); // so we'll come back around again
            }

            clear(g);
            java.awt.Graphics2D g2d = (java.awt.Graphics2D)g;

            if (mouseState == STATE_MOVING)
            {
                g2d.setColor(java.awt.Color.blue);
                drawSquare(g2d, curX, curY, selectRadiusPixels);
            }

            g2d.setColor(java.awt.Color.black);

            if (mode == MODE_ONE_CURVE)
            {
                for (int i = 0; i < controlPoints.length; ++i)
                {
                    double x = controlPoints[i][0];
                    double y = controlPoints[i][1];
                    double r = 3;
                    drawSquare(g2d, x, y, r);
                }
                java.awt.geom.CubicCurve2D curve = new java.awt.geom.CubicCurve2D.Double(
                        controlPoints[0][0],
                        controlPoints[0][1],
                        controlPoints[1][0],
                        controlPoints[1][1],
                        controlPoints[2][0],
                        controlPoints[2][1],
                        controlPoints[3][0],
                        controlPoints[3][1]);
                java.awt.Stroke oldStroke = g2d.getStroke();
                g2d.setStroke(new java.awt.BasicStroke(2)); // line thickness = 2
                //g2d.draw(curve);
                drawCurveSubdivided(g2d, curve, nDebugSubdivisionLevels);
                g2d.setStroke(oldStroke);

                FuzzyPoint closestPoint = new FuzzyPoint();
                boolean result = getClosestPointOnCubicCurve(
                                     curX, curY,
                                     curve,

                                     Double.POSITIVE_INFINITY, // tooFar
                                     //selectRadiusPixels

                                     maxFuzzyRadiusPixels,
                                     closestPoint,
                                     this.verbose);
                if (result)
                {
                    double x = closestPoint.x;
                    double y = closestPoint.y;
                    double r = Math.sqrt(closestPoint.rSqrd);
                    g2d.setColor(java.awt.Color.red);
                    drawSquare(g2d, x, y, 1);
                    drawSquare(g2d, x, y, r); // dot in the middle
                }
            }
            else if (mode == MODE_ASSETS)
            {
                if (connectionCurves == null)
                    recalculateCurves();
                for (int i = 0; i < assets.length; ++i)
                {
                    drawSquare(g2d, assets[i][0],assets[i][1], 2);
                }

                int lineThickness = 1;
                java.awt.Stroke oldStroke = g2d.getStroke();
                g2d.setStroke(new java.awt.BasicStroke(lineThickness));
                for (int i = 0; i < connectionCurves.length; ++i)
                {
                    for (int j = 0; j < connectionCurves[i].length; ++j)
                    {
                        //g2d.draw(connectionCurves[i][j]);
                        if (connectionCurves[i][j] instanceof java.awt.geom.CubicCurve2D)
                            drawCurveSubdivided(g2d,(java.awt.geom.CubicCurve2D)connectionCurves[i][j],nDebugSubdivisionLevels);
                        else
                            g2d.draw(connectionCurves[i][j]);
                    }
                }

                g2d.setStroke(oldStroke);

                {
                    FuzzyPoint closestPoint = new FuzzyPoint();
                    int closestIndices[/*2*/] = getClosestPointOnCubicCurves(
                                                    curX, curY,
                                                    connectionCurves,
            
                                                    //selectRadiusPixels
                                                    Double.POSITIVE_INFINITY,

                                                    maxFuzzyRadiusPixels,
                                                    closestPoint);
                    if (closestIndices[0] != -1)
                    {
                        double x = closestPoint.x;
                        double y = closestPoint.y;
                        double r = Math.sqrt(closestPoint.rSqrd);
                        g2d.setColor(java.awt.Color.red);
                        drawSquare(g2d, x, y, r); // dot in the middle
                        drawSquare(g2d, x, y, 1); // dot in the middle
                    }
                }

                {
                    double tooFar = Double.POSITIVE_INFINITY;
                    FuzzyPoint closestPoint = new FuzzyPoint();
                    int indicesOfClosestThing[/*3*/] = getIndicesOfClosestThing(
                                                    curX, curY,
                                                    assets,
                                                    connectionCurves,
                                                    tooFar,
                                                    maxFuzzyRadiusPixels,
                                                    closestPoint,
                                                    false);
                    //PRINTARRAY(indicesOfClosestThing);
                    if (indicesOfClosestThing[0] != -1) // an asset
                    {
                        double x = closestPoint.x;
                        double y = closestPoint.y;
                        double r = Math.sqrt(closestPoint.rSqrd);
                        g2d.setColor(java.awt.Color.green);
                        drawSquare(g2d, x, y, 5);
                    }
                    if (indicesOfClosestThing[1] != -1) // a curve
                    {
                        double x = closestPoint.x;
                        double y = closestPoint.y;
                        double r = Math.sqrt(closestPoint.rSqrd);
                        g2d.setColor(java.awt.Color.red);
                        drawSquare(g2d, x, y, 2);
                    }
                }
            }

            if (eventVerbose >= 2) System.out.println("    out paint");
        } // paint

        // super.paintComponent clears offscreen pixmap,
        // since we're using double buffering by default.
        protected void clear(java.awt.Graphics g)
        {
            super.paintComponent(g);
        }

        public MyPanel()
        {
            super();
            this.addMouseMotionListener(new java.awt.event.MouseMotionListener() {
                public void mouseMoved(java.awt.event.MouseEvent e)
                {
                    if (eventVerbose >= 2) System.out.println("    in mouseMoved to "+e.getX()+","+e.getY()+"");
                    curX = e.getX();
                    curY = e.getY();
                    repaint();
                    if (eventVerbose >= 2) System.out.println("    out mouseMoved");
                }
                public void mouseDragged(java.awt.event.MouseEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in mouseDragged to "+e.getX()+","+e.getY()+"");

                    int prevX = curX;
                    int prevY = curY;
                    curX = e.getX();
                    curY = e.getY();
                    if (mode == MODE_ONE_CURVE)
                    {
                        if (indexOfThingBeingDragged != -1)
                        {
                            controlPoints[indexOfThingBeingDragged][0] += curX - prevX;
                            controlPoints[indexOfThingBeingDragged][1] += curY - prevY;
                        }
                    }
                    else if (mode == MODE_ASSETS)
                    {
                        if (mouseState == STATE_DRAGGING_ASSET)
                        {
                            if (indexOfThingBeingDragged != -1)
                            {
                                assets[indexOfThingBeingDragged][0] += curX - prevX;
                                assets[indexOfThingBeingDragged][1] += curY - prevY;
                                connectionCurves = null; // dirty
                            }
                        }
                        else if (mouseState == STATE_DRAGGING_EVENT)
                        {
                            // dragging an event doesn't really do anything.
                        }
                        else if (mouseState == STATE_DRAGGING_NOTHING)
                        {
                            // pan the whole scene.
                            // XXX this is silly, shouldn't need to recalculate connectionCurves, should just tweak the window transform matrix
                            pan(assets, curX-prevX, curY-prevY);
                            if (futureAssets != null)
                                pan(futureAssets, curX-prevX, curY-prevY);
                            connectionCurves = null; // dirty;
                        }
                    }

                    repaint();
                    if (eventVerbose >= 1) System.out.println("    out mouseDragged");
                }
            });
            this.addMouseListener(new java.awt.event.MouseListener() {
                public void mouseClicked(java.awt.event.MouseEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in mouseClicked at "+e.getX()+","+e.getY()+"");
                    if (eventVerbose >= 1) System.out.println("    out mouseClicked");
                }
                public void mousePressed(java.awt.event.MouseEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in mousePressed at "+e.getX()+","+e.getY()+"");

                    // Set controlPointBeingDragged to the closest
                    // control point
                    if (mode == MODE_ONE_CURVE)
                    {
                        indexOfThingBeingDragged = findClosest(curX, curY, controlPoints, selectRadiusPixels);
                        System.out.println("indexOfThingBeingDragged = "+indexOfThingBeingDragged);
                    }
                    else if (mode == MODE_ASSETS)
                    {
                        double tooFar = selectRadiusPixels;
                        FuzzyPoint closestPoint = new FuzzyPoint();
                        int indicesOfClosestThing[/*3*/] = getIndicesOfClosestThing(
                                                        curX, curY,
                                                        assets,
                                                        connectionCurves,
                                                        tooFar,
                                                        maxFuzzyRadiusPixels,
                                                        closestPoint,
                                                        true);
                        PRINTARRAY(indicesOfClosestThing);
                        PRINT(e.isControlDown());
                        if (indicesOfClosestThing[0] != -1)
                        {
                            mouseState = (e.isControlDown() ? STATE_CTRL_DRAGGING_ASSET : STATE_DRAGGING_ASSET);
                            indexOfThingBeingDragged = indicesOfClosestThing[0];
                            subIndexOfThingBeingDragged = -1;
                        }
                        else if (indicesOfClosestThing[1] != -1)
                        {
                            mouseState = (e.isControlDown() ? STATE_CTRL_DRAGGING_EVENT : STATE_DRAGGING_EVENT);
                            indexOfThingBeingDragged = indicesOfClosestThing[1];
                            subIndexOfThingBeingDragged = indicesOfClosestThing[2];
                        }
                        else
                        {
                            mouseState = (e.isControlDown() ? STATE_CTRL_DRAGGING_NOTHING : STATE_DRAGGING_NOTHING); // panning
                            indexOfThingBeingDragged = -1;
                            subIndexOfThingBeingDragged = -1;
                        }
                        System.out.println("indexOfThingBeingDragged = "+indexOfThingBeingDragged+","+subIndexOfThingBeingDragged+"");
                    }
                    repaint();

                    if (eventVerbose >= 1) System.out.println("    out mousePressed");
                }
                public void mouseReleased(java.awt.event.MouseEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in mouseReleased at "+e.getX()+","+e.getY()+"");
                    if (curX != e.getX()
                     || curY != e.getY())
                    {
                        System.out.println("I'M CONFUSED: current position was "+curX+","+curY+", but mouse released at "+e.getX()+","+e.getY()+"");
                    }
                    assert(curX == e.getX()); // XXX not sure this is reliable
                    assert(curY == e.getY()); // XXX not sure this is reliable
                    curX = e.getX();
                    curY = e.getY();
                    if (mode == MODE_ASSETS)
                    {
                        double tooFar = dropRadiusPixels;
                        FuzzyPoint closestPoint = new FuzzyPoint();
                        if (connectionCurves == null)
                            recalculateCurves();
                        int indicesOfClosestThing[/*3*/] = getIndicesOfClosestThing(
                                                        curX, curY,
                                                        assets,
                                                        connectionCurves,
                                                        tooFar,
                                                        maxFuzzyRadiusPixels,
                                                        closestPoint,
                                                        true);
                        PRINTARRAY(indicesOfClosestThing);

                        if (mouseState == STATE_CTRL_DRAGGING_ASSET)
                        {
                            // attach the asset, as src,
                            // to the event or other asset (or the "nothing")
                            // we just dragged it to.
                            if (indicesOfClosestThing[0] != -1)
                            {
                                // to an asset
                                System.out.println("dragged an asset to another asset");
                                PRINTARRAY(connections);
                                connections = (int[][][])append(connections, new int[][] {{indexOfThingBeingDragged},{indicesOfClosestThing[0]}});
                                PRINTARRAY(connections);
                                connectionCurves = null; // dirty
                            }
                            else if (indicesOfClosestThing[1] != -1)
                            {
                                // to an event
                                System.out.println("dragged an asset to an event");
                                PRINTARRAY(connections);
                                connections[indicesOfClosestThing[1]][0] =
                                        (int[])append(connections[indicesOfClosestThing[1]][0], new Integer(indexOfThingBeingDragged));
                                PRINTARRAY(connections);
                                connectionCurves = null; // dirty
                            }
                            else
                            {
                                // to nothingness
                                System.out.println("dragged an asset to nothing");
                                PRINTARRAY(connections);
                                connections = (int[][][])append(connections, new int[][] {{indexOfThingBeingDragged},{}});
                                PRINTARRAY(connections);
                                connectionCurves = null; // dirty
                            }
                        }
                        else if (mouseState == STATE_CTRL_DRAGGING_EVENT)
                        {
                            // if event was dragged to an asset,
                            // add that asset to the event.
                            // if event was dragged to another event,
                            // merge the events.
                            if (indicesOfClosestThing[0] != -1)
                            {
                                // to an asset
                                System.out.println("dragged an event to an asset");
                                PRINTARRAY(connections);
                                connections[indexOfThingBeingDragged][1] = (int[])append(connections[indexOfThingBeingDragged][1], new Integer(indicesOfClosestThing[0]));
                                PRINTARRAY(connections);
                                connectionCurves = null; // dirty
                            }
                            else if (indicesOfClosestThing[1] != -1)
                            {
                                // to an event
                                System.out.println("dragged an event to an event");
                                int i0 = indexOfThingBeingDragged;
                                int i1 = indicesOfClosestThing[1];
                                PRINTARRAY(connections);
                                connections[i0][0] = (int[])concat(connections[i0][0], connections[i1][0]);
                                connections[i0][1] = (int[])concat(connections[i0][1], connections[i1][1]);
                                connections = (int[][][])deleteElement(connections, i1);
                                PRINTARRAY(connections);
                                connectionCurves = null; // dirty
                            }
                            else
                            {
                                // to nothingness
                                System.out.println("dragged an event to nothing");
                            }
                        }
                        else if (mouseState == STATE_CTRL_DRAGGING_NOTHING)
                        {
                            // if "nothing" was dragged to an asset,
                            // make a new event with no srcs
                            // and just that asset as its destination.
                            if (indicesOfClosestThing[0] != -1)
                            {
                                // to an asset
                                System.out.println("dragged nothingness to an asset");
                                PRINTARRAY(connections);
                                connections = (int[][][])append(connections, new int[][] {{},{indicesOfClosestThing[0]}});
                                PRINTARRAY(connections);
                                connectionCurves = null; // dirty
                            }
                            else if (indicesOfClosestThing[1] != -1)
                            {
                                // to an event
                                System.out.println("dragged nothingness to an event (that does nothing)");
                            }
                            else
                            {
                                // to nothingness
                                System.out.println("dragged nothingness to nothing (that does nothing)");
                            }
                        }
                    }
                    indexOfThingBeingDragged = -1;
                    subIndexOfThingBeingDragged = -1;
                    repaint();

                    if (eventVerbose >= 1) System.out.println("    out mouseReleased");
                }
                public void mouseEntered(java.awt.event.MouseEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in mouseEntered at "+e.getX()+","+e.getY()+"");
                    mouseState = STATE_MOVING;
                    repaint();
                    if (eventVerbose >= 1) System.out.println("    out mouseEntered");
                }
                public void mouseExited(java.awt.event.MouseEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in mouseExited at "+e.getX()+","+e.getY()+"");
                    mouseState = STATE_NOTHING;
                    repaint();
                    if (eventVerbose >= 1) System.out.println("    out mouseExited");
                }
            });
            this.addKeyListener(new java.awt.event.KeyListener() {
                public void keyPressed(java.awt.event.KeyEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in keyPressed");
                    char c = e.getKeyChar();
                    switch(c)
                    {
                        case 'h':
                        case '?':
                            System.out.println("");
                            System.out.println("    Mouse:");
                            System.out.println("            Left-drag - move asset or pan whole picture");
                            System.out.println("            Ctrl-Left drag - connect something:");
                            System.out.println("                asset -> asset -- new event from src to dst");
                            System.out.println("                asset -> event -- add the asset to the event as another src");
                            System.out.println("                event -> asset -- add the asset to the event as another dst");
                            System.out.println("                event -> event -- merge the events");
                            System.out.println("                asset -> nothingness -- new event with just the single src");
                            System.out.println("                nothingness -> asset -- new event with just the single dst");

                            System.out.println("    Keys:");
                            System.out.println("            n -- new asset");
                            System.out.println("     Delete/d -- delete nearest asset or event");
                            System.out.println("            c -- clean up circle (after n, d, and dragging assets around)");
                            System.out.println("            - -- zoom out");
                            System.out.println("          =/+ -- zoom in");
                            System.out.println("            m -- toggle mode between asset graph and single cubic curve");
                            System.out.println("          ?/h -- show this help message");
                            System.out.println("");
                            break;

                        case '+': case '=':
                        case '-':
                            {
                                double center[] = average(assets, null);
                                double scale = Math.pow(2., .1);
                                if (c == '-')
                                {
                                    scale = 1./scale;
                                    // Attempt clever way to make everything
                                    // drift towards centered--
                                    // expand from center of object,
                                    // but shrink towards center of screen!
                                    center =  new double[] {getWidth()/2,getHeight()/2};
                                }
                                for (int i = 0; i < assets.length; ++i)
                                    assets[i] = lerp(center, assets[i], scale);
                            }
                            connectionCurves = null; // dirty
                            repaint();
                            break;

                        case 'm': // switch between MODE_ASSETS and MODE_ONE_CURVE
                            mode = 1-mode;
                            repaint();
                            break;
                        case 'c':
                            futureAssets = cleanUpCircle(assets);

                            nFramesUntilFuture = 1000;
                            scheduleUntilFuture = new double[nFramesUntilFuture+1];
                            for (int i = 0; i <= nFramesUntilFuture; ++i)
                            {
                                double x = (double)i/nFramesUntilFuture;
                                // Fooey, these ease ones aren't ready for prime time; they cause speed discontinuity if you start one animation when a previous one hasn't completed yet.  Maybe need to put all assets on their own schedule, so one can be moving fast (in the middle of its trajectory) while another is moving slow (at the beginning or end of its trajectory?
                                // gnuplot:
                                //    plot [0:1] (3-2*x)*x*x, (1-cos(x*pi))/2, x<=.5?2*x*x : 1-2*(1-x)*(1-x)
                                //scheduleUntilFuture[i] = (x<=.5?2*x*x : 1-2*(1-x)*(1-x)); // piecewise quadratic
                                //scheduleUntilFuture[i] = (1-Math.cos(x*Math.PI))/2; // sin-like

                                //scheduleUntilFuture[i] = (3 - 2*x)*x*x; // cubic ease in/out
                                scheduleUntilFuture[i] = x; // linear
                            }

                            connectionCurves = null; // dirty
                            repaint();
                            break;
                        case 'n': // add a new asset
                            if (mode == MODE_ASSETS)
                            {
                                assets = (double[][])append(assets, new double[] {curX, curY});
                            }
                            // no need to dirty curves since this is added on the end and isn't a part of any curve
                            repaint();
                            break;
                        case java.awt.event.KeyEvent.VK_DELETE:
                        case 'd': // delete an asset
                            if (mode == MODE_ASSETS)
                            {
                                // delete closest thing
                                // (asset, event, or membership)
                                double tooFar = deleteRadiusPixels;
                                FuzzyPoint closestPoint = new FuzzyPoint();
                                int indicesOfClosestThing[/*3*/] = getIndicesOfClosestThing(
                                                                curX, curY,
                                                                assets,
                                                                connectionCurves,
                                                                tooFar,
                                                                maxFuzzyRadiusPixels,
                                                                closestPoint,
                                                                false);
                                if (indicesOfClosestThing[0] != -1)
                                {
                                    int ind = indicesOfClosestThing[0]; // asset index to delete
                                    assets = (double[][])deleteElement(assets, ind);
                                    if (futureAssets != null)
                                        futureAssets = (double[][])deleteElement(futureAssets, ind);
                                    {
                                        for (int i = 0; i < connections.length; ++i)
                                        for (int j = 0; j < connections[i].length; ++j)
                                        {
                                            int nNew = 0;
                                            for (int kOld = 0; kOld < connections[i][j].length; ++kOld)
                                            {
                                                int old = connections[i][j][kOld];
                                                if (old != ind)
                                                    connections[i][j][nNew++] = (old>ind ? old-1 : old);
                                            }
                                            if (nNew != connections[i][j].length)
                                            {
                                                connections[i][j] = (int[])subarray(connections[i][j], 0, nNew);
                                            }


                                        }
                                    }
                                }
                                else if (indicesOfClosestThing[1] != -1)
                                {
                                    System.out.println("    deleting an event or connection or something");
                                    // XXX should just delete the connection
                                    connections = (int[][][])deleteElement(connections, indicesOfClosestThing[1]);
                                }
                            }
                            connectionCurves = null; // dirty
                            repaint();
                            break;
                        default:
                            if (c != 65535) // XXX empirically, shift and ctrl-- weird
                            {
                                System.out.println("Unknown key '"+c+"'("+(int)c+")");
                            }
                            break;
                    }
                    if (eventVerbose >= 1) System.out.println("    out keyPressed");
                }
                public void keyReleased(java.awt.event.KeyEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in keyReleased");
                    if (eventVerbose >= 1) System.out.println("    out keyReleased");
                }
                public void keyTyped(java.awt.event.KeyEvent e)
                {
                    if (eventVerbose >= 1) System.out.println("    in keyTyped");
                    if (eventVerbose >= 1) System.out.println("    out keyTyped");
                }
            });
        } // MyPanel() ctor

        private static void pan(double points[][/*2*/],
                                double dx,
                                double dy)
        {
            for (int i = 0; i < points.length; ++i)
            {
                points[i][0] += dx;
                points[i][1] += dy;
            }
        } // pan


        private static double[][] makeCircle(int n, double x, double y, double r)
        {
            double assets[][] = new double[n][2];
            for (int i = 0; i < n; ++i)
            {
                double ang = 2*Math.PI*i/n;
                assets[i][0] = x + r*Math.cos(ang);
                assets[i][1] = y - r*Math.sin(ang); // XXX upside down, for now, til I get coord space fixed
            }
            return assets;
        } // makeCircle

        private static double[][/*2*/] cleanUpCircle(double oldCircle[][/*2*/])
        {
            int n = oldCircle.length;
            if (n <= 2)
                return oldCircle;
            double center[/*2*/] = AssetGraphUtils.average(oldCircle,null);
            double distsFromCenter[] = new double[n];
            for (int i = 0; i < n; ++i)
                distsFromCenter[i] = dist(center[0],center[1],oldCircle[i][0], oldCircle[i][1]);
            double newRadius = median(distsFromCenter);

            final double angs[] = new double[n];
            for (int i = 0; i < n; ++i)
                angs[i] = Math.atan2(oldCircle[i][1]-center[1],
                                     oldCircle[i][0]-center[0]);
            int inds[] = getSortedInds(angs);

            //
            // We want ang0
            // such that ang0 + 2*Math.PI*i/n  is as close as possible 
            // to angs[inds[i]] for all i.
            //
            double ang0 = 0.;
            {
                double totalAdjustmentNeeded = 0.;
                for (int i = 0; i < n; ++i)
                    totalAdjustmentNeeded += angs[inds[i]]
                                           - (ang0 + 2*Math.PI*i/n);
                ang0 += totalAdjustmentNeeded / n;
            }

            double newCircle[][] = new double[n][2];
            for (int i = 0; i < n; ++i)
            {
                double oldAng = angs[inds[i]];
                double newAng = ang0 + 2*Math.PI*i/n;
                newCircle[inds[i]][0] = center[0] + newRadius*Math.cos(newAng);
                newCircle[inds[i]][1] = center[1] + newRadius*Math.sin(newAng);
            }
            return newCircle;
        } // cleanUpCircle

        private static double median(final double A[])
        {
            int n = A.length;
            int inds[] = getSortedInds(A);
            if (n == 0)
                return 0.;
            else if (n % 2 == 0)
                return (A[inds[n/2-1]] + A[inds[n/2]]) / 2;
            else
                return A[inds[(n-1)/2]];
        } // median

        // Return a list of indices into A,
        // such that A[inds[0]] <= A[inds[1]] <= ... <= A[inds[n-1]].
        private static int[] getSortedInds(final double A[])
        {
            int n = A.length;
            Integer Inds[] = new Integer[n];
            for (int i = 0; i < n; ++i)
                Inds[i] = new Integer(i);
            java.util.Arrays.sort(Inds, new java.util.Comparator() {
                public int compare(Object aObj, Object bObj)
                {
                    int a = ((Integer)aObj).intValue();
                    int b = ((Integer)bObj).intValue();
                    return A[a] < A[b] ? -1 :
                           A[a] > A[b] ? 1 : 0;
                }
            });
            int inds[] = new int[n];
            for (int i = 0; i < n; ++i)
                inds[i] = Inds[i].intValue();
            return inds;
        } // getSortedInds

        private static int findClosest(double x, double y, double points[][/*2*/], double tooFar)
        {
            int bestI = -1;
            double bestDistSqrd = tooFar*tooFar;

            for (int i = 0; i < points.length; ++i)
            {
                double thisDistSqrd = distSqrd(x, y, points[i][0], points[i][1]);
                if (thisDistSqrd < bestDistSqrd)
                {
                    bestDistSqrd = thisDistSqrd;
                    bestI = i;
                }
            }
            return bestI;
        } // findClosest

        //
        // If closest thing is an asset,
        // return its index in [0] and set [1] and [2] to -1.
        // If closest thing is a curve segment of an event,
        // then set [1] and [2] to its indices and set [0]
        // to zero.
        //
        private static int[/*3*/] getIndicesOfClosestThing(
                                      double curX, double curY,
                                      double assets[][/*2*/],
                                      java.awt.Shape curves[][],
                                      double tooFar,
                                      double maxFuzzyRadius,
                                      FuzzyPoint closestPoint, // output
                                      boolean assetsShouldTakePrecedenceIfFound)
        {
            int closestAssetIndex = findClosest(curX, curY, assets, tooFar);
            //PRINT(closestAssetIndex);
            //PRINT(assetsShouldTakePrecedenceIfFound);
            if (closestAssetIndex != -1)
                tooFar = dist(curX,curY,assets[closestAssetIndex][0],assets[closestAssetIndex][1]);
            int closestCurveIndices[];
            if (closestAssetIndex != -1 && assetsShouldTakePrecedenceIfFound)
            {
                closestCurveIndices = new int[] {-1,-1};
            }
            else
            {
                assert(curves != null);
                closestCurveIndices = getClosestPointOnCubicCurves(
                                            curX, curY,
                                            curves,
                                            tooFar,
                                            maxFuzzyRadiusPixels,
                                            closestPoint);
            }
            if (closestCurveIndices[0] != -1)
                return new int[] {-1, closestCurveIndices[0], closestCurveIndices[1]};
            else if (closestAssetIndex != -1)
            {
                closestPoint.x = assets[closestAssetIndex][0];
                closestPoint.y = assets[closestAssetIndex][1];
                closestPoint.rSqrd = 0.;
                return new int[] {closestAssetIndex, -1, -1};
            }
            else
                return new int[] {-1,-1,-1};
        } // getIndicesOfClosestThing



        // How close does the mouse have to be to select something?
        private static final double selectRadiusPixels = 10;
        private static final double dropRadiusPixels = 20;
        private static final double deleteRadiusPixels = 10000; // just allow deleting from arbitrary distance
        private static final double maxFuzzyRadiusPixels = .5; // how precisely to get closest point on curves


        private int curX = 0;
        private int curY = 0;

        private int eventVerbose = 0;
        private int verbose = 0;
        private int nDebugSubdivisionLevels = 0; // set to higher to see curve subdivisions

        private static final int MODE_ONE_CURVE = 0;
        private static final int MODE_ASSETS = 1;
        private int mode = MODE_ASSETS;
        //private int mode = MODE_ONE_CURVE;

        private static final int STATE_NOTHING = 0;
        private static final int STATE_MOVING = 1;
        private static final int STATE_CTRL_MOVING = 2;
        private static final int STATE_DRAGGING_ASSET = 3;
        private static final int STATE_CTRL_DRAGGING_ASSET = 4;
        private static final int STATE_DRAGGING_EVENT = 5;
        private static final int STATE_CTRL_DRAGGING_EVENT = 6;
        private static final int STATE_DRAGGING_NOTHING = 7;
        private static final int STATE_CTRL_DRAGGING_NOTHING = 8;

        private int mouseState = STATE_NOTHING;

            // these mean something when mouseState is ...DRAGGING...
            private int indexOfThingBeingDragged = -1;
            private int subIndexOfThingBeingDragged = -1;


            //
            // For when mode is MODE_ONE_CURVE...
            //
                double controlPoints[][] = {
                    {10,100},
                    {20, 50},
                    {80, 50},
                    {90, 100},
                };
            //
            // For when mode is MODE_ASSETS...
            //
                double srcRadii[] = {10}; // how far to keep arrow feet away
                double dstRadii[] = {10}; // how far to keep arrow heads away
                double arrowHeadLength = 10;
                double arrowLengthForSingle = 40;

                int nAssets = 18;
                double assets[][] = makeCircle(nAssets, 100, 100, 90);
                int connections[][/*2*/][] = {
                    {{5},{4}},
                    {{6},{3,2}},
                    {{7,8},{1}},
                    {{9,10},{17,0}},
                    {{11},{}},
                    {{},{16}},
                    {{12,13},{}},
                    {{},{14,15}},
                };

                // If easing in to a reconfiguration,
                // we set futureAssets and a number of frames
                // in which to ease into it.
                // XXX need to guarantee nothing changes
                // XXX while animating, or need to destroy futureAssets!
                double futureAssets[][] = null;
                int nFramesUntilFuture = 0;
                double scheduleUntilFuture[] = null;

                java.awt.Shape connectionCurves[][] = null; // dirty; calculated on demand

        private void recalculateCurves()
        {
            connectionCurves = new java.awt.Shape[connections.length][];
            for (int i = 0; i < connections.length; ++i)
            {
                connectionCurves[i] = getCurves(
                                assets,connections[i][0],
                                assets,connections[i][1],
                                srcRadii,
                                dstRadii,
                                arrowHeadLength,
                                average(assets,null),
                                arrowLengthForSingle);
                assert(connectionCurves[i] != null);
            }
        } // calculateCurves

        private static Object subarray(Object array, int start, int n)
        {
            Object subarray = java.lang.reflect.Array.newInstance(
                                    array.getClass().getComponentType(), n);
            System.arraycopy(array, start, subarray, 0, n);
            return subarray;
        } // subarray
        private static Object deleteElement(Object array, int ind)
        {
            int n = java.lang.reflect.Array.getLength(array);
            Object newArray = java.lang.reflect.Array.newInstance(
                                    array.getClass().getComponentType(), n-1);
            PRINT(ind);
            System.arraycopy(array, 0, newArray, 0, ind);
            System.arraycopy(array, ind+1, newArray, ind, n-1-ind);
            return newArray;
        } // deleteElement
        /**
         * Returns a newly allocated array
         * consisting of the old array with the "last" object appended.
         * <br>
         * array can have scalar components,
         * in which case last should be of the corresponding wrapper type.
         */
        public static Object append(Object array,
                                    Object last)
        {
            int n = java.lang.reflect.Array.getLength(array);
            Object result = java.lang.reflect.Array.newInstance(
                                    array.getClass().getComponentType(), n+1);
            System.arraycopy(array, 0, result, 0, n);
            java.lang.reflect.Array.set(result, n, last);
            return result;
        } // append
        /**
         * Returns a newly allocated array
         * that is the concatenation of the given arrays.
         */
        public static Object concat(Object array0,
                                    Object array1)
        {
            int n0 = java.lang.reflect.Array.getLength(array0);
            int n1 = java.lang.reflect.Array.getLength(array1);
            Object newArray = java.lang.reflect.Array.newInstance(
                                        array0.getClass().getComponentType(),
                                        n0 + n1);
            System.arraycopy(array0, 0, newArray, 0, n0);
            System.arraycopy(array1, 0, newArray, n0, n1);
            return newArray;
        } // concat

        // XXX wtf? jikes chokes on both of these using 1.5 libraries
        public static String arrayToString(Object array)
        {
            StringBuffer sb = new StringBuffer();
            appendArrayToString(array, sb);
            return sb.toString();
        }
        public static void appendArrayToString(Object array, StringBuffer sb)
        {
            if (!array.getClass().isArray())
                sb.append(array);
            else
            {
                int n = java.lang.reflect.Array.getLength(array);
                sb.append("{");
                for (int i = 0; i < n; ++i)
                {
                    if (i > 0)
                        sb.append(",");
                    appendArrayToString(java.lang.reflect.Array.get(array,i), sb);
                }
                sb.append("}");
            }
        }
    } // class MyPanel



    public static void main(String args[])
    {
        System.out.println("in main");
        String title = "Asset Graph Arcs";
        javax.swing.JFrame frame = new javax.swing.JFrame(title);
        frame.setBackground(java.awt.Color.black);
        frame.setForeground(java.awt.Color.white);
        int w = 300, h = 300;
        frame.setSize(w, h);
        final MyPanel myPanel = new MyPanel();
        frame.setContentPane(myPanel);
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent event)
            {
                System.out.println("Chow!");
                System.exit(0);
            }
        });
        frame.setVisible(true);
        myPanel.requestFocus();
        System.out.println("out main");
    } // main

} // class AssetGraph
