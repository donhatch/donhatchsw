#include "macros.h"
package com.donhatchsw.util;
/**
* http://www.cse.unsw.edu.au/~lambert/java/3d/quickhull.html
*/
import com.donhatchsw.compat.ArrayList;
import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.compat.DoubleArrayList;

public class ConvexHull
{
    private ConvexHull() {} // uninstantiatable

    /**
    * Caller can set this for debugging, although it's not thread-safe.
    * 0: nothing, 1: function in/out, 2: phases, 3: detail
    */
    public static int debugLevel = 0;

    /**
    * Computes the convex hull in d dimensions,
    * using the QuickHull algorithm
    * (i.e. the incremental algorithm, but always
    * choosing the next point farthest from the current hull).
    * Returns a list of (d-1)-dimensional simplices.
    * <p>
    * WARNING: this hasn't had much testing yet
    * <p>
    * WARNING: the search for visible faces isn't smart so the whole thing is O(n^2)
    * <p>
    * WARNING: no attempt is made to correct topological faults yet
    */
    public static int[][/*d*/] convexHull(double verts[][/*d*/],
                                          double eps)
    {
        if (debugLevel >= 1)
        {
            System.out.println("    in convexHull");
            PRINTVEC(verts);
            PRINT(eps);
        }
        int nVerts = verts.length;
        if (nVerts == 0)
        {
            if (debugLevel >= 1)
                System.out.println("    out convexHull (nVerts==0, returning new int[0][])");
            return new int[0][];
        }
        int d = verts[0].length;
        if (d == 0)
        {
            if (debugLevel >= 1)
                System.out.println("    out convexHull (d==0, returning new int[0][])");
            return new int[0][]; // not sure what the hell's going on here
        }
        if (d == 1)
        {
            // In this case expressing the sidedness of a facet
            // is problematic.  So just do it the trivial way,
            // returning the lowest and highest vertex.
            int answer[][] = new int[2][1];
            PRINTVEC(answer);
            answer[0][0] = answer[1][0] = 0;
            for (int iVert = 1; iVert < nVerts; ++iVert) // skip 0
            {
                if (verts[iVert][0] < verts[answer[0][0]][0]) // < so prefer first index
                    answer[0][0] = iVert;
                if (verts[iVert][0] >= verts[answer[1][0]][0]) // >= so prefer last index
                    answer[1][0] = iVert;
            }
            if (debugLevel >= 1)
                System.out.println("    out convexHull (d==1, returning lowest and highest vertex)");
            return answer;
        }

        if (nVerts < d)
        {
            if (debugLevel >= 1)
                System.out.println("    out convexHull (nVerts<d, returning new int[0][])");
            return new int[0][]; // not enough vertices to make a facet out of
        }

        assert(nVerts >= d && d >= 2);

        if (debugLevel >= 2)
        {
            System.out.println("        choosing a non-degenerate (d-1)-dimensional simplex");
        }

        // Start with any non-degenerate (d-1)-dimensional simplex
        // (if there is any).
        // (The paper starts with a d-dimensional simplex
        // but I don't see advantage of that.)

        int firstHullFacet[] = VecMath.fillvec(d, -1);
        double biggestContentSquared = -1.;
        FORI (i, d)
        {
            if (i == 0)
            {
                firstHullFacet[i] = 0;
                biggestContentSquared = 1.;
            }
            else
            {
                int bestVert = -1;
                biggestContentSquared = -1.;
                FORI (iVert, nVerts)
                {
                    if (Arrays.indexOf(i, firstHullFacet, iVert) != -1)
                        continue; // this vertex is already on the facet
                    firstHullFacet[i] = iVert; // speculatively
                    double thisContentSquared = calcParallelotopeContentSquared(verts,
                                                                                firstHullFacet,
                                                                                i+1);
                    //PRINT(thisContentSquared);
                    if (thisContentSquared > biggestContentSquared)
                    {
                        biggestContentSquared = thisContentSquared;
                        bestVert = iVert;
                    }
                }
                assert(bestVert != -1);
                firstHullFacet[i] = bestVert;
            }
            if (debugLevel >= 3)
                System.out.println("            "+firstHullFacet[i]);
        }
        double firstFacetUnsignedArea = Math.sqrt(biggestContentSquared);
        if (firstFacetUnsignedArea <= Math.pow(eps, d-1))
        {
            if (debugLevel >= 1)
                System.out.println("    out convexHull (firstFacetUnsignedArea = "+firstFacetUnsignedArea+" <= eps ^ d-1, returning null)");
            return null; // XXX throw?
        }
        double firstFacetUnitNormal[] = calcUnitNormal(verts, firstHullFacet);
        VecMath.normalize(firstFacetUnitNormal, firstFacetUnitNormal);

        // Second hull facet is opposite of first
        int secondHullFacet[] = VecMath.copyvec(firstHullFacet);
        Arrays.swap(secondHullFacet, 0, secondHullFacet, 1);


        // As long as result so far is coplanar,
        // we need to symbolically perturb each new vertex
        // out of that plane,
        // so that it appears to be on a consistent side
        // of what's been seen so far.
        double symbolicPerturbation[] = firstFacetUnitNormal;

        if (debugLevel >= 2)
        {
            System.out.println("        initializing queue");
        }

        IndexBinaryHeap queue = new IndexBinaryHeap(nVerts);

        IntArrayList vertsAboveOrOnFirstHullFacetPlane = new IntArrayList();
        IntArrayList vertsBelowFirstHullFacetPlane = new IntArrayList();

        double distanceFromHull[] = new double[nVerts];

        double scratchVec[] = new double[d];
        FORI (iVert, nVerts)
        {
            if (Arrays.indexOf(firstHullFacet, iVert) != -1)
                continue; // this vertex is already part of the hull

            VecMath.vmv(scratchVec, verts[iVert], verts[firstHullFacet[0]]);
            double height = VecMath.dot(firstFacetUnitNormal, scratchVec);

            if (height >= 0.)
            {
                vertsAboveOrOnFirstHullFacetPlane.add(iVert);
                if (debugLevel >= 3)
                    System.out.println("            vertex "+iVert+" is hovering at height "+height+" over facet "+Arrays.toStringCompact(firstHullFacet));
            }
            else
            {
                height = -height;
                vertsBelowFirstHullFacetPlane.add(iVert);
                if (debugLevel >= 3)
                    System.out.println("            vertex "+iVert+" is hovering at height "+height+" over facet "+Arrays.toStringCompact(secondHullFacet));
            }
            assert(height >= 0.);
            queue.add(iVert, -height); // reverse sense so we can extract max height item as min item
        }


        FacetArrayList hullFacetStructs = new FacetArrayList();

        // use knowledge of how second facet was constructed from first...
        int firstAndSecondFacetNeighborsIndexOfMe[] = VecMath.identityperm(d);
        firstAndSecondFacetNeighborsIndexOfMe[0] = 1;
        firstAndSecondFacetNeighborsIndexOfMe[1] = 0;



        Facet firstHullFacetStruct = new Facet(0,
                                               firstHullFacet,
                                               firstFacetUnitNormal,
                                               vertsAboveOrOnFirstHullFacetPlane,
                                               null, // neighbors to be filled in momentarily
                                               firstAndSecondFacetNeighborsIndexOfMe);
        Facet secondHullFacetStruct = new Facet(1,
                                                secondHullFacet,
                                                VecMath.sxv(-1., firstFacetUnitNormal),
                                                vertsBelowFirstHullFacetPlane,
                                                null, // neighbors to be filled in momentarily
                                                firstAndSecondFacetNeighborsIndexOfMe);
        firstHullFacetStruct.neighbors = (Facet[])Arrays.fill(d, secondHullFacetStruct);
        secondHullFacetStruct.neighbors = (Facet[])Arrays.fill(d, firstHullFacetStruct);

        hullFacetStructs.add(firstHullFacetStruct);
        hullFacetStructs.add(secondHullFacetStruct);


        IntArrayList visibleFacets = new IntArrayList(); // scratch, logically local to loop body below
        java.util.Hashtable visibleBoundary = new java.util.Hashtable(); // scratch, logically local to loop body below
        int scratchRidge[] = new int[d-1];
        IntArrayHashKey scratchRidgeHashKey = new IntArrayHashKey(scratchRidge);
        if (debugLevel >= 2)
        {
            System.out.println("        servicing the queue");
        }
        while (!queue.isEmpty())
        {
            int iVert = queue.extractMin();
            if (debugLevel >= 3)
            {
                System.out.println("            extracted vertex "+iVert);
                System.out.println("                hull was "+hullFacetStructs.toStringCompact());
            }
            int nFacetsBefore = hullFacetStructs.size();
            visibleFacets.clear();
            visibleBoundary.clear();

            FORI (iFacet, nFacetsBefore)
            {
                Facet facetStruct = (Facet)hullFacetStructs.get(iFacet);
                int facet[] = facetStruct.vertInds;
                if (debugLevel >= 3)
                    System.out.println("                    can I see hull facet "+Arrays.toStringCompact(facet)+"?");

                double facetUnitNormal[] = facetStruct.unitNormal;
                VecMath.vmv(scratchVec, verts[iVert], verts[facet[0]]);
                double height = VecMath.dot(scratchVec, facetUnitNormal);

                if (debugLevel >= 3)
                    System.out.println("                        height = "+height);
                if (symbolicPerturbation != null)
                {
                    if (!EQ(height, 0., eps))
                    {
                        if (debugLevel >= 3)
                            System.out.println("                        vert is out of initial plane, killing symbolicPerturbation");
                        symbolicPerturbation = null; // no need for it any more
                    }
                    else
                    {
                        if (debugLevel >= 3)
                            System.out.println("                        symbolically perturbing new vert to get it out of initial plane");

                        double facetNormal[] = calcUnitNormal(verts,
                                                              facet);
                        height = VecMath.dot(d, facetNormal, symbolicPerturbation);
                        assert(!EQ(height, 0., eps));
                    }
                }

                if (GEQ(height, 0., eps)) // if facet is visible or borderline visible from vertex
                {
                    if (debugLevel >= 3)
                        System.out.println("                        it's visible");
                    visibleFacets.add(iFacet);
                    FORI (iRidgeThisFacet, d)
                    {
                        // Look at the ridge formed by omitting
                        // the iRidgeThisFacet'th vertex from the facet
                        FORI (i, d-1)
                            scratchRidge[i] = facet[i>=iRidgeThisFacet ? i+1 : i];
                        SortStuff.sort(scratchRidge); // canonical order  XXX is this necessary? is facet not already sorted?

                        if (visibleBoundary.remove(scratchRidgeHashKey) == null)
                        {
                            // it wasn't there before-- add it.
                            int ridge[] = VecMath.copyvec(scratchRidge);
                            IntArrayHashKey ridgeKey = new IntArrayHashKey(ridge);
                            int newFacetMaybe[] = VecMath.copyvec(facet);
                            newFacetMaybe[iRidgeThisFacet] = iVert;
                            visibleBoundary.put(ridgeKey, newFacetMaybe);
                            if (debugLevel >= 3)
                                System.out.println("                        ridge "+Arrays.toStringCompact(scratchRidge)+" was not on boundary so adding ridge "+Arrays.toStringCompact(ridge));
                        }
                        else
                        {
                            if (debugLevel >= 3)
                                System.out.println("                        removed ridge "+Arrays.toStringCompact(scratchRidge)+" from boundary");
                        }
                    }
                }
                else
                {
                    if (debugLevel >= 3)
                        System.out.println("                        it's not visible");
                }
            }

            int nVisibleFacets = visibleFacets.size();
            if (debugLevel >= 3)
            {
                ArrayList scratch = new ArrayList();
                FORI (iVisibleFacet, visibleFacets.size())
                    scratch.add(((Facet)hullFacetStructs.get(visibleFacets.get(iVisibleFacet))).vertInds);
                System.out.println("                visibleFacets = "+intArrayArrayListToStringCompact(scratch));
                System.out.println("                visible boundary size = "+visibleBoundary.size());
            }
            assert(nVisibleFacets >= 1); // the facet that iVert was hovering over, at least

            // For each ridge on the visible boundary...
            for (java.util.Enumeration e = visibleBoundary.keys();
                 e.hasMoreElements();)
            {
                IntArrayHashKey ridgeKey = (IntArrayHashKey)e.nextElement();
                int newFacet[] = (int[])visibleBoundary.get(ridgeKey);
                IntArrayList hoveringVerts = new IntArrayList();

                Facet newFacetStruct = new Facet(hullFacetStructs.size(),
                                                 newFacet,
                                                 calcUnitNormal(verts, newFacet),
                                                 hoveringVerts,
                                                 new Facet[d], // TODO: figure out new facet neighbors
                                                 new int[d]); // TODO: figure out new facet back pointers
                hullFacetStructs.add(newFacetStruct);
            }

            int nFacetsAfterAdding = hullFacetStructs.size();
            if (debugLevel >= 3)
            {
                PRINT(nFacetsBefore);
                PRINT(nFacetsAfterAdding);
            }
            assert(nFacetsAfterAdding > nFacetsBefore); // added at least one, and didn't delete any yet

            // Transfer the hovering vertices
            // from the visible facets (which are about to be deleted)
            // to the facets that just got created
            FORI (iVisibleFacet, nVisibleFacets)
            {
                int iFacet = visibleFacets.get(iVisibleFacet);
                // For each vertex that was hovering over this visible facet...
                IntArrayList hoverers = ((Facet)hullFacetStructs.get(iFacet)).hoveringVerts;
                int nHoverers = hoverers.size();
                FORI (iHoverer, nHoverers)
                {
                    int jVert = hoverers.get(iHoverer);
                    if (jVert == iVert)
                        continue; // don't transfer iVert, we're done with it

                    int theNewFacetIndex = -1;
                    double highestHeight = Double.NEGATIVE_INFINITY;
                    for (int iNewFacet = nFacetsBefore; iNewFacet < nFacetsAfterAdding; ++iNewFacet)
                    {
                        Facet newFacetStruct = (Facet)hullFacetStructs.get(iNewFacet);
                        int newFacet[] = newFacetStruct.vertInds;
                        double facetUnitNormal[] = newFacetStruct.unitNormal;
                        VecMath.vmv(scratchVec, verts[jVert], verts[newFacet[0]]);
                        double height = VecMath.dot(scratchVec, facetUnitNormal);

                        if (height > highestHeight
                         && height >= -eps)
                        {
                            highestHeight = height;
                            theNewFacetIndex = iNewFacet;
                        }
                    }
                    if (theNewFacetIndex != -1)
                    {
                        if (debugLevel >= 3)
                            System.out.println("        transferring vertex "+jVert+" from facet "+Arrays.toStringCompact(((Facet)hullFacetStructs.get(iVisibleFacet)).vertInds)+" to hovering at height "+highestHeight+" above facet "+Arrays.toStringCompact(((Facet)hullFacetStructs.get(theNewFacetIndex)).vertInds)+"");
                        ((Facet)hullFacetStructs.get(theNewFacetIndex)).hoveringVerts.add(jVert);
                        queue.adjust(jVert, -highestHeight);
                    }
                    else
                    {
                        // Nothing was >= -eps.
                        // So jVert is inside the hull, so it should
                        // be ignored.
                        if (debugLevel >= 3)
                            System.out.println("        transferring vertex "+jVert+" from facet "+Arrays.toStringCompact(hullFacetStructs.get(iVisibleFacet).vertInds)+" to the void because it's inside the hull");
                        queue.remove(jVert);
                    }
                }
            }

            int nAdded = nFacetsAfterAdding - nFacetsBefore;
            int nToRemove = nVisibleFacets;
            //PRINT(nAdded);
            //PRINT(nToRemove);

            assert(nToRemove <= nAdded); // XXX this would explain the mystery below, but is a bogus assumption!  I think?? if so, why am I not seeing it ever violated??


            // Remove the visible facets from the hull
            FORI (iVisibleFacet, nVisibleFacets)
            {
                // TODO: how the hell are we getting away with this? not re-indexing in visibleFacets list?? huh?
                int iFacet = visibleFacets.get(iVisibleFacet);

                hullFacetStructs.fastRemove(iFacet);
            }

            if (debugLevel >= 3)
            {
                int nFacetsAfterRemoving = hullFacetStructs.size();
                PRINT(nFacetsAfterRemoving);
                System.out.println("                hull is now "+hullFacetStructs.toStringCompact());
            }
        } // while queue not empty

        int hullFacetsArray[][] = new int[hullFacetStructs.size()][];
        FORI (iFacet, hullFacetsArray.length)
            hullFacetsArray[iFacet] = hullFacetStructs.get(iFacet).vertInds;
        if (debugLevel >= 1)
        {
            System.out.println("        "+hullFacetsArray.length+" facets");
            PRINTARRAY(hullFacetsArray);
            System.out.println("    out convexHull");
        }
        return hullFacetsArray;
    } // convexHull

    private static class Facet
    {
        Facet(int myIndex,
              int vertInds[],
              double unitNormal[],
              IntArrayList hoveringVerts,
              Facet neighbors[],
              int neighborsIndexOfMe[])
        {
            this.myIndex = myIndex;
            this.vertInds = vertInds;
            this.unitNormal = unitNormal;
            this.hoveringVerts = hoveringVerts;
            this.neighbors = neighbors;
            this.neighborsIndexOfMe = neighborsIndexOfMe;
        }

        public int myIndex;
        public int vertInds[/*d*/];
        public double unitNormal[/*d*/];
        public IntArrayList hoveringVerts;
        public Facet neighbors[/*d*/];
        public int neighborsIndexOfMe[/*d*/];
    } // class Facet


    // ArrayList of Facet,
    // that manages each Facet's myIndex
    private static class FacetArrayList
    {
        public int size()
        {
            return facetArrayList.size();
        }
        public Facet get(int i)
        {
            Facet facet = (Facet)facetArrayList.get(i);
            assert(facet.myIndex == i);
            return facet;
        }
        public void add(Facet facet)
        {
            facet.myIndex = facetArrayList.size();
            facetArrayList.add(facet);
        }
        public void set(int i, Facet facet)
        {
            facet.myIndex = i;
            facetArrayList.set(i, facet);
        }
        public void fastRemove(int i)
        {
            int n = facetArrayList.size();
            if (i != n-1)
                set(i, get(n-1));
            facetArrayList.remove(n-1);
        }
        public String toStringCompact()
        {
            ArrayList scratchArrayList = new ArrayList();
            int n = size();
            FORI (i, n)
                scratchArrayList.add(get(i).vertInds);
            int scratchArray[][] = new int[scratchArrayList.size()][];
            scratchArrayList.toArray(scratchArray);
            return Arrays.toStringCompact(scratchArray);
        }
        private ArrayList facetArrayList = new ArrayList();

    } // class FacetArrayList



    //
    // Little private utilities...
    //
        private static double calcParallelotopeContentSquared(
                                    double verts[][/*d*/],
                                    int points[/*1<= <=d+1*/],
                                    int nPoints)
        {
            // Could make caller do these memory allocations,
            // but this isn't really called enough for it to matter
            double M[][] = new double[nPoints-1][];
            FORI (iRow, M.length)
                M[iRow] = VecMath.vmv(verts[points[iRow+1]],
                                      verts[points[0]]);
            return VecMath.det(VecMath.mxm(M,
                                           VecMath.transpose(M)));

        } // calcParallelotopeContentSquared
        private static double calcParallelotopeContent(
                                    double verts[][/*d*/],
                                    int points[/*d+1*/])
        {
            // Should maybe make caller do this
            double M[][] = new double[points.length-1][];
            FORI (iRow, M.length)
                M[iRow] = VecMath.vmv(verts[points[iRow+1]],
                                      verts[points[0]]);
            return VecMath.det(M);
        }
        private static double[] calcUnitNormal(
                                    double verts[][/*d*/],
                                    int points[/*d*/])
        {
            double M[][] = new double[points.length-1][];
            FORI (iRow, M.length)
                M[iRow] = VecMath.vmv(verts[points[iRow+1]],
                                      verts[points[0]]);
            double normal[] = VecMath.crossprod(M);
            VecMath.normalize(normal, normal);
            return normal;

        }
        private static void fastRemove(ArrayList arrayList, int index)
        {
            int n = arrayList.size();
            arrayList.set(index, arrayList.get(n-1));
            arrayList.remove(n-1);
        }
        private static void fastRemove(DoubleArrayList arrayList, int index)
        {
            int n = arrayList.size();
            arrayList.set(index, arrayList.get(n-1));
            arrayList.removeIndex(n-1);
        }

        private static class IntArrayHashKey
        {
            private int item[];
            IntArrayHashKey(int item[])
            {
                this.item = item;
            }
            public int hashCode()
            {
                int hash = 47;
                for (int i = 0; i < item.length; ++i)
                    hash = hash*31 + item[i];
                return hash;
            }
            public boolean equals(Object that)
            {
                return VecMath.equals(this.item, ((IntArrayHashKey)that).item);
            }
        } // class IntArrayHashKey

        // XXX won't be needed when Arrays.toStringCompact gets smarter
        static String intArrayArrayListToStringCompact(ArrayList arrayList)
        {
            int scratch[][] = new int[arrayList.size()][];
            arrayList.toArray(scratch);
            return Arrays.toStringCompact(scratch);
        }


        // return the parity (0 or 1) of the permutation
        // that sorts the given list.
        // works by bubble sort.
        private static int permParity(int order[])
        {
            int n = order.length;
            int scratch[] = VecMath.copyvec(order);
            int nSwaps = 0;
            FORIDOWN (k, n)
            {
                FORI (i, k)
                {
                    if (scratch[i] > scratch[i+1])
                    {
                        Arrays.swap(scratch, i, scratch, i+1);
                        nSwaps++;
                    }
                }
            }
            FORI (i, n-1)
                assert(scratch[i] < scratch[i+1]);
            return nSwaps % 2;
        }


    public static void sanityCheckConvexHull(int d, double verts[][], int hull[][], double eps)
    {
        if (verts.length < d)
        {
            assert(hull.length == 0);
        }
        else
        {
            //
            // Make sure it's boundaryless (i.e. has no
            // boundary ridges).
            // Actually stronger than that: each ridge
            // occuring on a facet of the hull
            // must appear on exactly one other facet of the hull,
            // in the opposite orientation.
            // TODO: assert connected, too.
            // TODO: and that each ridge is locally convex.
            //
            {
                // ridgeParityToFacets maps a canonical-order ridge
                // to an array of two arrays:
                // the facets containing the ridge with parity 0,
                // and the facets containing the ridge with parity 1.
                java.util.Hashtable ridgeParityToFacets = new java.util.Hashtable();
                FORI (iFacet, hull.length)
                {
                    int facet[] = hull[iFacet];
                    assert(facet.length == d);

                    // assert all verts on facet are distinct
                    {
                        int sortedFacet[] = VecMath.copyvec(facet);
                        SortStuff.sort(sortedFacet);
                        FORI (i, d-1)
                            assert(sortedFacet[i+1] != sortedFacet[i]);
                    }

                    FORI (iRidgeThisFacet, d)
                    {
                        int ridge[] = new int[d-1]; // must be unique array since ownership will be transferred to the IntArrayHashKey
                        FORI (i, d-1)
                            ridge[i] = facet[i>=iRidgeThisFacet ? i+1 : i];
                        if (d-1 >= 2 && iRidgeThisFacet % 2 == 1)
                            Arrays.swap(ridge, 0, ridge, 1);
                        int parity = (d-1==0 ? iFacet :
                                      d-1==1 ? iRidgeThisFacet : permParity(ridge));

                        SortStuff.sort(ridge); // canonical order

                        IntArrayHashKey ridgeKey = new IntArrayHashKey(ridge);

                        int parityToFacets[][] = (int[][])ridgeParityToFacets.get(ridgeKey);
                        if (parityToFacets == null)
                        {
                            parityToFacets = new int[3][0];
                            parityToFacets[2] = ridge; // smuggle in ridge itself
                            ridgeParityToFacets.put(ridgeKey, parityToFacets);
                        }
                        parityToFacets[parity] = Arrays.append(parityToFacets[parity],
                                                               iFacet);
                    }
                }
                boolean okSoFar = true;
                for (java.util.Enumeration e = ridgeParityToFacets.keys(); e.hasMoreElements();)
                {
                    IntArrayHashKey ridgeKey = (IntArrayHashKey)e.nextElement();
                    int value[][] = (int[][])ridgeParityToFacets.get(ridgeKey);
                    assert(value.length == 3);
                    int ridge[] = value[2];
                    if (value[0].length != 1
                     || value[1].length != 1)
                    {
                        if (value[0].length+value[1].length == 2)
                            System.out.println("HEY! both occurrences of ridge "+Arrays.toStringCompact(ridge)+" have same orientation!");
                        else
                            System.out.println("HEY! ridge "+Arrays.toStringCompact(ridge)+" occurs "+(value[0].length+value[1].length)+" times, should be 2");
                        FORI (parity, 2)
                        {
                            System.out.println("    occurrences with parity "+parity+":");
                            FORI (iFacetThisParity, value[parity].length)
                            {
                                int iFacet = value[parity][iFacetThisParity];
                                System.out.println("        facet "+iFacet+" = "+Arrays.toStringCompact(hull[iFacet]));
                            }
                        }
                        okSoFar = false;
                    }
                }
                assert(okSoFar);
            }

            //
            // Make sure it bounds the hull
            //
            {
                double vertsCenter[] = VecMath.average(verts);

                double facetVerts[][] = new double[d][];
                double facetPlaneVecs[][] = new double[MAX(d-1,0)][d];
                double facetNormal[] = new double[d];
                double facetCenter[] = new double[d];
                double facetCenterToVert[] = new double[d];

                int sign = 0;

                FORI (iFacet, hull.length)
                {
                    FORI (i, d)
                        facetVerts[i] = verts[hull[iFacet][i]];
                    FORI (i, d-1)
                        VecMath.vmv(facetPlaneVecs[i], facetVerts[i+1], facetVerts[0]);
                    VecMath.crossprod(facetNormal, facetPlaneVecs);
                    // special case for d==1 --
                    // in this case cross product always
                    // returns {+1} and so gives no information
                    if (d == 1)
                        facetNormal[0] = facetVerts[0][0] - vertsCenter[0];
                    VecMath.normalize(facetNormal, facetNormal);
                    // XXX need to deal with degeneracy here maybe
                    assert(EQ(VecMath.normsqrd(facetNormal), 1., 2*eps));
                    VecMath.average(facetCenter, facetVerts);


                    FORI (iVert, verts.length)
                    {
                        double vert[] = verts[iVert];
                        VecMath.vmv(facetCenterToVert,
                                    vert, facetCenter);
                        double foo = VecMath.dot(facetNormal, facetCenterToVert);
                        int thisSign = (LT(foo,0,eps) ? -1 : GT(foo,0,eps) ? 1 : 0);
                        if (sign == 0)
                            sign = thisSign; // might still be 0
                        if (! (sign * thisSign >= 0))
                        {
                            PRINT(foo);
                            PRINT(thisSign);
                            PRINT(sign);
                        }
                        assert(sign * thisSign >= 0);
                    }
                }
            }
        }
    } // sanityCheckConvexHull


    private static void testTheseVerts(int d, double verts[][])
    {
        PRINT(d);
        PRINTARRAY(verts);
        FORI (iVert, verts.length)
            assert(verts[iVert].length == d);

        int hull[][] = convexHull(verts, 1e-11); // argh! 1e-12 made it fail in real life (test case below), 1e-9 made it fail randomized confidence test, 1e-10 made it fail in real life (test case below)

        PRINTARRAY(hull);
        sanityCheckConvexHull(d, verts, hull, 1e-9);
        System.out.println("======================");
    } // testTheseVerts


    /**
    * Little confidence test program.
    */
    public static void main(String args[])
    {
        if (true)
        {
            // This one is currently failing the test with eps=1e-10:
            // there's a ridge that occurs 4 times.
            //debugLevel = 3;
            testTheseVerts(3, new double[][] {
                {.2,-1.,.6},
                {1.,-0.8,-0.348},
                {.9999999999907109,-0.75,-0.07},
                {1,-0.67,0.185},
                {1,-0.5833333333337675,0.407},
                {1,-0.5,0.6},
                {.999,0.8333333333349515,-0.348},
                {1,.9,-0.66},
                {-1,1,1},
                {1,1,-1},
            });
        }
        if (true)
        {
            // This one is currently failing the test with eps=1e-9 and eps=1e-10:
            // there's a ridge that occurs 4 times.
            //debugLevel = 3;
            testTheseVerts(3, new double[][] {
                {0.19999999999752163,-1.0,-0.0608695652201183},
                {0.19999999999751436,-0.9166666666666868,0.13913043478051065},
                {0.33333333333282594,-0.9166666666689404,0.026086956515650562},
                {0.8666666666602593,-0.8333333333320317,-0.4173913043485713},
                {1.0,-0.8333333333356353,-0.6173913043580689},
                {0.866666666661337,-0.7499999999994108,-0.2521739130452495},
                {0.9999999999907109,-0.7499999999977524,-0.4521739130414001},
                {-0.2000000000010617,-0.6666666666676166,0.8695652173907314},
                {-0.06666666666832106,-0.6666666666670459,0.8086956521736584},
                {0.8666666666634107,-0.6666666666671198,-0.10434782609068219},
                {0.9999999999995162,-0.6666666666683736,-0.3043478260948236},
                {-0.200000000001057,-0.5833333333342121,0.9999999999999999},
                {-0.06666666666827076,-0.5833333333337624,0.9391304347827705},
                {0.8666666666662302,-0.5833333333348921,0.026086956515653622},
                {0.999999999996486,-0.5833333333337675,-0.17391304348220885},
                {0.9999999999956884,-0.5000000000001696,-0.0608695652201183},
                {0.9999999999999829,0.8333333333349515,-0.6173913043580528},
                {0.9999999999980657,0.9166666666673757,-0.8000000000085122},
                {-0.9999999999999999,1.0,0.1739130434753577},
                {0.9999999999920242,0.9999999999970313,-1.0000000000000002}
            });
        }

        if (true)
        {
            // these failed with eps=1e-12.
            // that's not entirely surprising, since they are flirting with eps.
            // changed test eps to 1e-9 as a result.
            testTheseVerts(3, new double[][] {
                {1, .5, 1},
                {-0.9999999999988493, 1, -1},
                {-0.9999999999985804, .5, -0.64},
                {-1, 0, -0.38},
                {-1, -.5, -0.25},
                {-1, -1, -0.25},
            });
            testTheseVerts(3, new double[][] {
                {-0.9999999999989534,-1.0,-0.17948717948721649},
                {-0.9999999999994659,-0.4999999999998996,-0.230769230769602},
                {-1.0,3.7423153752734264E-13,-0.3846153846161367},
                {-0.9999999999985804,0.4999999999998616,-0.6410256410254186},
                {1.0,0.5000000000002361,1.0000000000000002},
                {-0.9999999999988493,1.0,-1.0},
            });
        }
        if (true)
        {
            testTheseVerts(3, new double[][] {{1,1,0},{-1,1,0},{-1,-1,0},{.5,-.5,.1}}); // not coplanar, not problematic
            testTheseVerts(3, new double[][] {{1,-1,0},{-1,-1,0},{-1,1,0},{.5,.5,0}}); // four coplanar was problematic
            testTheseVerts(3, new double[][] {{1,-1,0},{-1,-1,0},{-1,1,0},{1,1,.1}});
        }
        if (false)
        {
            // Some problematic cases...
            // XXX the coords are huge... do we care about these or not??
            testTheseVerts(3, new double[][] {{-1.0,0.6049382716049382,-0.710306904419669},{1.0,1.0,-0.5235452788122057},{-0.01562500000000001,-1.0,-0.22752077864939793}}); // succeeds
            testTheseVerts(3, new double[][] {{-1.0,0.6049382716049382,-0.710306904419669},{1.0,1.0,-0.5235452788122057},{-0.01562500000000001,-1.0,-0.22752077864939793}}); // succeeds
            testTheseVerts(3, new double[][] {{-1.0,0.6049382716049382,-1.023660131220196E16},{1.0,1.0,-7.545082632224744E15},{-0.015625000000000024,-1.0,-3.278919980622317E15}}); // assert fails
            testTheseVerts(3, new double[][] {{-1.0,1.0,-8.011042245140311E15},{-0.553030303030303,-1.0,-2.335983685036597E15},{1.0,0.811023622047244,-1.3737616349472596E16}}); // returns null

        }




        java.util.Random rng = new java.util.Random(0);

        int minDim = 0;
        int maxDim = 5;
        int minVerts = 0;
        int maxVerts = 20;
        int nTestsPerSize = 10;
        for (int d = minDim; d <= maxDim; ++d)
        {
            for (int nVerts = minVerts; nVerts < maxVerts; ++nVerts)
            {
                FORI (iTest, nTestsPerSize)
                {
                    System.out.println("======================");
                    System.out.println("    Testing d="+d+" nVerts="+nVerts+" iTest="+iTest+"/"+nTestsPerSize+"");
                    double verts[][] = new double[nVerts][];
                    if (iTest == 0)
                    {
                        double invScale = Math.pow(nVerts, d); // if nVerts is 0 we'll never use it
                        FORI (iVert, nVerts)
                        {
                            verts[iVert] = new double[d];
                            FORI (i, d)
                                verts[iVert][i] = Math.pow(iVert, i+1)/invScale;
                        }
                    }
                    else
                        FORI (iVert, nVerts)
                            verts[iVert] = VecMath.random(d, rng);

                    testTheseVerts(d, verts);
                }
            }
        }
    } // main

} // class ConvexHull


