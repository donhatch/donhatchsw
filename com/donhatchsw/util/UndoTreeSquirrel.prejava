package com.donhatchsw.util;

import com.donhatchsw.compat.regex;

#include "macros.h"

/**
* Experimenting with the idea of an undo/redo tree.
* <a href="http://www.geocities.com/Hollywood/Set/4159/COULDWRK.WAV">It could work</a>!
*/

public class UndoTree
{
    // A node represents a state of the application;
    // Do's, undo's, redo's are edges that go from node to node.
    private static class Node
    {
        public int parent; // index relative to mine
        public Object itemOnEdgeFromParentToMe;
        public Object sharedLabel = null; // views might want to share a label or have their own private one
        public int children[] = new int[0]; // indices relative to mine
        public Node(int parent, Object itemOnEdgeFromParentToMe)
        {
            this.parent = parent;
            this.itemOnEdgeFromParentToMe = itemOnEdgeFromParentToMe;
        }
    } // Node

    private static PrivateNodeInfo getOrMakePrivateNodeInfo(java.util.Hashtable privateNodeInfosHashtable, Node node)
    {
        PrivateNodeInfo info = (PrivateNodeInfo)privateNodeInfosHashtable.get(node);
        if (info == null)
        {
            info = new PrivateNodeInfo();
            privateNodeInfosHashtable.put(node, info);
        }
        return info;
    } // PrivateNodeInfo


    private com.donhatchsw.compat.ArrayList/*<Node>*/ nodes; // set in ctor
    private com.donhatchsw.compat.ArrayList sharedListeners; // set in ctor
    private com.donhatchsw.compat.ArrayList privateListeners = new com.donhatchsw.compat.ArrayList();

    //
    // An UndoTree is actually a view into the nodes (the model).
    // So we don't store view-specific info on the nodes themselves;
    // that way multiple views can look at the same model.
    //
    private static class PrivateNodeInfo
    {
        public Object privateLabel = null;
        public int preferredChildIndex = -1;
    }
    private com.donhatchsw.compat.ArrayList/*<PrivateNodeInfo>*/ privateNodeInfos;
    private java.util.Hashtable/*<PrivateNodeInfo>*/ privateNodeInfosHashtable = new java.util.Hashtable(); // XXX get rid of this
    private int currentNodeIndex; // set in ctor

    /** A listening callback that you can create and install using addListener to listen for changes to the UndoTree. */
    public interface Listener
    {
        public void somethingChanged();
    }

    /**
    * Creates a new view onto an existing undo tree.
    * Both views will see the labels created via setSharedLabel(),
    * but a position label created via setPrivateLabel() will only be seen
    * in the view in which it was created.
    */
    // CTOR    (for quick find in editor)
    public UndoTree(UndoTree other)
    {
        if (other == null)
        {
            this.nodes = new com.donhatchsw.compat.ArrayList();
            this.nodes.add(new Node(-1,null));
            this.sharedListeners = new com.donhatchsw.compat.ArrayList();
            this.currentNodeIndex = 0;
        }
        else
        {
            this.nodes = other.nodes;
            this.sharedListeners = other.sharedListeners;
            this.currentNodeIndex = other.currentNodeIndex;
            // XXX should copy preferred child indices from the other too! and maybe private labels, but not sure about that. maybe that should be an argument to the constructor?
        }
    }

    /** Creates a new undo tree from scratch; equivalent to UndoTree(null). */
    public UndoTree()
    {
        this(null);
    }

    /** Changes the current position to be a newly created child
    * of the current current position,
    * associating the given Object with the newly created transition to the new child.
    * The new child is made to be the preferred child
    * of the former current position.
    * This method actually affects the model, i.e. it modifies the tree
    * (whereas other methods such as undo, and redo
    * only affects the individual view of the model).
    */
    public void Do(Object item)
    {
        if (item == null)
            throw new IllegalArgumentException("UndoTree.Do called with null item");
        int newChildIndex;
        synchronized(nodes)
        {
            newChildIndex = nodes.size();
            Node newChild = new Node(currentNodeIndex-newChildIndex, item);
            nodes.add(newChild);
        }

        Node currentNode = (Node)nodes.get(currentNodeIndex);
        int newChildIndexInCurrent;
        synchronized(currentNode)
        {
            newChildIndexInCurrent = currentNode.children.length;
            currentNode.children = (int[])Arrays.append(currentNode.children, newChildIndex-currentNodeIndex);
        }

        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        currentNodeInfo.preferredChildIndex = newChildIndexInCurrent;

        currentNodeIndex = newChildIndex;

        //checkSane(); // don't do this here, it's expensive

        // Note the sharedListeners list covers all the listeners
        // on the privateListers
        synchronized(sharedListeners)
        {
            for (int i = 0; i < sharedListeners.size(); ++i)
                ((Listener)sharedListeners.get(i)).somethingChanged();
        }
    }
    /** Performs an undo; that is, changes the current position to be one step closer to the root of the tree, returning the Object that was originally passed to Do() when the tree edge was created. */
    public Object undo()
    {
        if (currentNodeIndex != 0)
        {
            Node currentNode = (Node)nodes.get(currentNodeIndex);
            Object item = currentNode.itemOnEdgeFromParentToMe;
            currentNodeIndex += currentNode.parent; // relative
            synchronized(privateListeners)
            {
                for (int i = 0; i < privateListeners.size(); ++i)
                    ((Listener)privateListeners.get(i)).somethingChanged();
            }
            return item;
        }
        else
        {
            return null;
        }
    }
    /** Performs a redo; that is, changes the current position to be the preferred child of the current current position, returning the Object that was originally passed to Do() when that tree edge was created.  If you want to go to a different child, you need to explicitly make that the preferred child first. */
    public Object redo()
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        if (currentNode.children.length == 0)
            return null;
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        if (currentNodeInfo.preferredChildIndex == -1)
            currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...
        currentNodeIndex += currentNode.children[currentNodeInfo.preferredChildIndex]; // relative
        currentNode = (Node)nodes.get(currentNodeIndex);
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
        return currentNode.itemOnEdgeFromParentToMe;
    }
    /**
    * Changes the preferred child of the current position (i.e. the path that will be taken by a redo) to the next older child than the current favorite, if there is one.
    */
    public void preferOlderChild()
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        synchronized(currentNode)
        {
            if (currentNodeInfo.preferredChildIndex == -1)
                currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...

            if (currentNodeInfo.preferredChildIndex+1 < currentNode.children.length)
                currentNodeInfo.preferredChildIndex++;
        }
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
    }
    /**
    * Changes the preferred child of the current position (i.e. the path that will be taken by a redo) to the next younger child than the current favorite, if there is one.
    */
    public void preferYoungerChild()
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        synchronized(currentNode)
        {
            if (currentNodeInfo.preferredChildIndex == -1)
                currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...
            if (currentNodeInfo.preferredChildIndex-1 >= 0)
                currentNodeInfo.preferredChildIndex--;
        }
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
    }
    /** Oh, and this one updates the model too. Sets a label at the current position that will be seen by other views of this undo tree. */
    public void setSharedLabel(Object sharedLabel)
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        synchronized(currentNode)
        {
            currentNode.sharedLabel = sharedLabel;
        }
        synchronized(sharedListeners)
        {
            for (int i = 0; i < sharedListeners.size(); ++i)
                ((Listener)sharedListeners.get(i)).somethingChanged();
        }
    }
    /** Sets a label at the current position that will not be seen by other views of this undo tree. */
    public void setPrivateLabel(Object privateLabel)
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        privateNodeInfo.privateLabel = privateLabel;
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
    }

    /**
    * Installs a callback that will get called after
    * any change is made,
    * that is, when Do or setSharedLabel is called (by any view of the tree)
    * or when one of undo, redo, preferOlderChild, preferYoungerChild, setPrivateLabel
    * is called by this view of the tree.
    */
    public void addListener(Listener notifier)
    {
        synchronized(sharedListeners)
        {
            sharedListeners.remove(notifier); // XXX should throw IllegalArgumentException instead
            sharedListeners.add(notifier);
        }
        synchronized(privateListeners)
        {
            privateListeners.remove(notifier);
            privateListeners.add(notifier); // XXX should throw IllegalArgumentException
        }
    } // addListener
    /** Removes a callback that was previously installed with addListener(). */
    public void removeListener(Listener notifier)
    {
        synchronized(sharedListeners)
        {
            sharedListeners.remove(notifier);
        }
        synchronized(privateListeners)
        {
            privateListeners.remove(notifier);
        }
    } // removeListener


    /**
    * Returns a string something like this if stretchOutAlongTimeLine is true:
    * <pre>
    *   +---------+
    *   |    0    |
    *   |    +-+  | A
    *   |    1 |  |
    *   |  +-+ |  | B
    *   |  2 | |  |
    *   |    | |  | C
    *   |    | 3  |
    *   |    |    | D
    *   |    4    |
    *   |    |    | E
    *   |   (5)   |
    *   +---------+
    * </pre>
    * and something like this if stretchOutAlongTimeLine is false:
    * <pre>
    *   +---------+
    *   |    0    |
    *   |    +-+  | A C
    *   |    1 3  |
    *   |  +-+    | B D
    *   |  2 4    |
    *   |    |    | E
    *   |   (5)   |
    *   +---------+
    * </pre>
    * These were created by executing the following commands:
    * <pre>
    *   UndoTree tree = new UndoTree();
    *   tree.Do("A");
    *   tree.Do("B");
    *   tree.undo();
    *   tree.undo();
    *   tree.Do("C");
    *   tree.undo();
    *   tree.preferYoungerChild();
    *   tree.redo();
    *   tree.Do("D");
    *   tree.Do("E");
    *   System.out.println(tree.toStringVisualCool(true));
    *   System.out.println(tree.toStringVisualCool(false));
    * </pre>
    */
    // TODO: compactify even more if it gets bushy then stringy then bushy, the lower bush can go under the upper bush
    public String toStringVisualCool(boolean stretchOutAlongTimeLine)
    {
        int nNodes = nodes.size();
        //
        // Bottom up, figure out the number of leaves
        // under the node.  That will be the logical width
        // allotted to this node.
        // 
        int widths[] = new int[nNodes]; // zeros
        for (int iNode = nNodes-1; iNode >= 0; iNode--)
        {
            Node node = (Node)nodes.get(iNode);
            for (int iChild = 0; iChild < node.children.length; ++iChild)
            {
                int childIndex = iNode + node.children[iChild];
                widths[iNode] += widths[childIndex];
            }
            if (widths[iNode] == 0)
                widths[iNode] = 1; // leaf
        }


        //
        // Top down, figure out the left and right logical bounds allotted to
        // each node.  Parent decides for each child.
        //
        int xstarts[] = new int[nNodes];
        xstarts[0] = 0;
        for (int iNode = 0; iNode < nNodes; iNode++)
        {
            Node node = (Node)nodes.get(iNode);
            int childStart = xstarts[iNode];
            for (int iChild = 0; iChild < node.children.length; ++iChild)
            {
                int childIndex = iNode + node.children[iChild];
                xstarts[childIndex] = childStart;
                childStart += widths[childIndex];
            }
        }
        //
        // Bottom up, decide the x position within the node's bounds
        // that we will display the node.  We want to display it
        // directly over its preferred child.
        // These are physical, not logical any more.
        //
        int x[] = new int[nNodes];
        for (int iNode = nNodes-1; iNode >= 0; iNode--)
        {
            Node node = (Node)nodes.get(iNode);
            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node); // XXX shouldn't make it if it doesn't exist, that's lame
            if (node.children.length == 0)
            {
                x[iNode] = 2*xstarts[iNode]+1;
            }
            else
            {
                int preferredChildIndex = privateNodeInfo.preferredChildIndex;
                if (preferredChildIndex == -1)
                    preferredChildIndex = node.children.length-1;
                x[iNode] = x[iNode + node.children[preferredChildIndex]];
            }
        }

        int possibleEdgeLengths[] = {3,4,6};
        int edgeLengths[] = new int[nNodes];
        for (int iNode = 0; iNode < nNodes; ++iNode)
            edgeLengths[iNode] = possibleEdgeLengths[(int)(Math.random()*possibleEdgeLengths.length)];

        int y[] = new int[nNodes];
        //
        // Decide the y position
        // where we will display the node.
        //
        if (stretchOutAlongTimeLine)
        {
            // Easy!
            for (int iNode = 0; iNode < nNodes; ++iNode)
                y[iNode] = 2*iNode;
        }
        else
        {
            //
            // Top down, put each child at a level
            // just below its parent.
            // (Well leave one line between them for the edge.)
            //
            y[0] = 0;
            for (int iNode = 0; iNode < nNodes; iNode++)
            {
                Node node = (Node)nodes.get(iNode);
                int childStart = xstarts[iNode];
                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    y[childIndex] = y[iNode] + 2;
                }
            }
        }

        int maxy = 0;
        for (int iNode = 0; iNode < nNodes; iNode++)
            maxy = Math.max(maxy, y[iNode]);

        char buf[][] = new char[maxy+1][1 + 2*widths[0]];
        for (int i = 0; i < buf.length; ++i)
        for (int j = 0; j < buf[i].length; ++j)
            buf[i][j] = ' ';

        //
        // Top down or bottom up, it doesn't matter,
        // draw the stuff into the rectangular buffer.
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            Node node = (Node)nodes.get(iNode);
            buf[y[iNode]][x[iNode]] = (char)('0'+(iNode%10)); // XXX just last digit for now
            if (iNode == currentNodeIndex)
            {
                buf[y[iNode]][x[iNode]-1] = '('; // XXX argh, index out of bounds
                buf[y[iNode]][x[iNode]+1] = ')';
            }
            if (node.children.length > 0)
            {
                if (node.children.length >= 1)
                {
                    int firstChildX = x[iNode+node.children[0]];
                    int lastChildX = x[iNode+node.children[node.children.length-1]];
                    for (int i = firstChildX; i <= lastChildX; ++i)
                        buf[y[iNode]+1][i] = '-';
                }

                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    buf[y[iNode]+1][x[childIndex]] = node.children.length==1 ? '|' : '+';
                    for (int j = y[iNode]+2; j < y[childIndex]; ++j)
                        buf[j][x[childIndex]] = '|';
                }
            }
        }

        //
        // Put annotations into the annotation buffer.
        //
        StringBuffer annotations[] = new StringBuffer[buf.length];
        for (int i = 0; i < annotations.length; ++i)
            annotations[i] = new StringBuffer();
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            Node node = (Node)nodes.get(iNode);
            if (iNode != 0)
            {
                annotations[y[iNode]-1].append(" "+node.itemOnEdgeFromParentToMe);
            }
            if (node.sharedLabel != null)
                annotations[y[iNode]].append(" sharedLabel="+Arrays.toStringCompact(node.sharedLabel));
            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node); // XXX shouldn't make it if it doesn't exist, that's lame
            if (privateNodeInfo.privateLabel != null)
                annotations[y[iNode]].append(" privateLabel="+Arrays.toStringCompact(privateNodeInfo.privateLabel));
        }


        //
        // Put the rectangular buffer on the left,
        // with annotations on the right, into a StringBuffer
        // in preparation for final output.
        //
        String nl = System.getProperty("line.separator");
        StringBuffer sb = new StringBuffer();

        sb.append("+"+repeat("-", buf[0].length+2)+"+"+nl);

        for (int i = 0; i < buf.length; ++i)
        {
            sb.append("| ");
            sb.append(buf[i]);
            sb.append(" |" );
            sb.append(annotations[i]);
            sb.append(nl);
        }
        sb.append("+"+repeat("-", buf[0].length+2)+"+"); // no nl
        return sb.toString();
    } // toStringVisualCool






    /*
        XXX no this isn't right, we use relative offsets now
        Example:
            {"oh boy a puzzle!" 0 A 1 B "just did B" 2 C
                                    1 D 4 E 5 F
                                                     2 G
                                        4 H "oh boy I solved it"}
        Compact would be:
            {"oh boy a puzzle!" A B "just did B" C u D E F u2 G u3 H I "oh boy I solved it"}
    */

    interface ItemToString
    {
        public String regex();
        public String itemToString(Object item);
    }
    interface ItemFromString
    {
        public String regex();
        public Object itemFromString(String s);
    }
    /**
    * Returns a string something like this:
    * <pre>
    *   { A B (0) u2 C (you are here) u2 D E }
    * </pre>
    * You tell it how to stringify the individual items
    * by passing in an itemToString functor, and a regex that describes
    * what an item string can look like.
    * The result can be turned back into another UndoTree
    * by calling fromString(), so this is suitable for a save/load
    * mechanism.
    * <p>
    * Note that the tokens "u", "u2", "u3" etc. are used
    * to signify branching.  Your individual item regex is not allowed
    * to accept any of these strings (since if it did, it would be
    * impossible to tell whether "u" denoted an item or a branch indicator).
    * <p>
    * Similarly, the tokens "(0)", "(1)", etc. are used to signify
    * the preferred child of a given position (i.e. which edge
    * will be followed by a redo from that position).
    * Your individual item regex is not allowed to accept these either.
    * <p>
    * XXX More salient example coming soon.
    */
    public String toString(ItemToString itemToString,
                           String indentSpaces,
                           String separatorSpaces) // hmm, I guess itemToString isn't needed, it could just use the item's toString... but then where do we get the regex from?
    {
        if (!regex.matches(indentSpaces, "\\s*"))
            throw new IllegalArgumentException("UndoTree.toString given indent string "+Arrays.toStringCompact(indentSpaces)+", should be zero or more spaces");
        if (!regex.matches(separatorSpaces, "\\s+"))
            throw new IllegalArgumentException("UndoTree.toString given separator string "+Arrays.toStringCompact(separatorSpaces)+", should be one or more spaces");
        String itemRegex = itemToString.regex();
        regex.Matcher itemMatcher = regex.Pattern.compile(itemRegex).matcher("dummy");
        // XXX dup code in the other place, should combine
        if (itemMatcher.reset("").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches the empty string, that's messed up!");
        if (itemMatcher.reset("u").matches()
         || itemMatcher.reset("u1").matches()
         || itemMatcher.reset("u10").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches something starting with \"u\", can't do that because it's special!");
        if (itemMatcher.reset("(0)").matches()
         || itemMatcher.reset("(1)").matches()
         || itemMatcher.reset("(10)").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches a parenthesized number something like (2), can't do that because it's special!");

        StringBuffer sb = new StringBuffer();
        sb.append("{");
        sb.append(separatorSpaces);
        int nNodes = nodes.size();
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            sb.append(indentSpaces);
            Node node = (Node)nodes.get(iNode);
            if (iNode != 0)
            {
                String itemString = itemToString.itemToString(node.itemOnEdgeFromParentToMe);
                if (!itemMatcher.reset(itemString).matches())
                {
                    throw new IllegalArgumentException("UndoTree.toString given itemToString functor that produced string "+Arrays.toStringCompact(itemString)+" which does not match its regex pattern "+itemRegex+"!");
                }
                if (node.parent == -1)
                    ; // nothing, this is the default
                else if (node.parent == -2)
                    sb.append("u ");
                else  // -3 -> 2, -4 -> 3, etc.
                    sb.append("u").append(-node.parent-1).append(" ");
                sb.append(itemString).append(" ");
            }

            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node);
            // If printing private label and there's no shared label,
            // print "null" for the shared label
            if (node.sharedLabel != null
             || privateNodeInfo.privateLabel != null)
                sb.append(Arrays.toStringCompact(node.sharedLabel)+" ");
            if (privateNodeInfo.privateLabel != null)
                sb.append(Arrays.toStringCompact(privateNodeInfo.privateLabel)+" ");
            if (iNode == currentNodeIndex)
                sb.append("(you are here) ");
            if (privateNodeInfo.preferredChildIndex != -1
             && node.children.length > 1) // XXX a little odd... can go from having a preference of the single child, to having no preference which means can be overridden by someone else making a child... think about this.  it's only an issue if collabarative editing
                sb.append("("+privateNodeInfo.preferredChildIndex+") ");
            while (" \r\n".indexOf(sb.charAt(sb.length()-1)) != -1) // XXX lame test!
                sb.deleteCharAt(sb.length()-1);
            sb.append(separatorSpaces);
        }
        sb.append("}");
        return sb.toString();
    } // toString

    /** Parses a string that was created by toString(). */
    public static UndoTree fromString(String s, ItemFromString itemFromString)
    {
        String itemRegex = itemFromString.regex();
        regex.Matcher itemMatcher = regex.Pattern.compile(itemRegex).matcher("dummy");
        // XXX dup code in the other place, should combine
        if (itemMatcher.reset("").matches())
            throw new IllegalArgumentException("UndoTree.fromString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches the empty string, that's messed up!");
        if (itemMatcher.reset("u").matches()
         || itemMatcher.reset("u1").matches()
         || itemMatcher.reset("u10").matches())
            throw new IllegalArgumentException("UndoTree.fromString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches something starting with \"u\", can't do that because it's special!");
        if (itemMatcher.reset("(0)").matches()
         || itemMatcher.reset("(1)").matches()
         || itemMatcher.reset("(10)").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches a parenthesized number something like (2), can't do that because it's special!");

        regex.Matcher doubleQuotedStringMatcher = regex.Pattern.compile(
            "\"((\\\\|.)*)\""
        ).matcher("dummy");

        // XXX maybe should retain original s for error messages
        s = s.trim();
        if (s.length() < 2
         || s.charAt(0) != '{'
         || s.charAt(s.length()-1) != '}')
            throw new IllegalArgumentException("UndoTree.fromStringCompact called on string not surrounded by '{'");
        s = s.substring(1, s.length()-1).trim();

        String words[];
        {
            if (true)
            {
                // Brain dead way... works if there are no spaces at all
                // in the items or labels
                words = regex.split(s, "\\s+");
            }
            else
            {
                com.donhatchsw.compat.ArrayList/*<String>*/ wordsVector = new com.donhatchsw.compat.ArrayList();
                unimplemented(); // XXX implement me!
                words = new String[wordsVector.size()];
                wordsVector.toArray(words);
            }
        }

        // We'll stick these in the created undoTree when we
        // create it at the end
        int currentNodeIndex = -1;
        java.util.Hashtable/*<node, PrivateNodeInfo>*/ privateNodeInfosHashtable = new java.util.Hashtable();

        Node nodes[] = new Node[Math.max(words.length,1)]; // at most this many
        com.donhatchsw.compat.ArrayList/*Node*/ childrens[] = new com.donhatchsw.compat.ArrayList[nodes.length];

        int nNodes = 0;
        nodes[nNodes++] = new Node(-1, null);
        childrens[nNodes-1] = new com.donhatchsw.compat.ArrayList();

        int iWord = 0;
        while (iWord < words.length)
        {
            //
            // optional quoted shared label for this node... or "null"
            // (without the quotes)
            //
            if (words[iWord].equals("null"))
            {
                // just leave it null... this is a placeholder
                // because there's a private label coming
                iWord++;
            }
            else if (doubleQuotedStringMatcher.reset(words[iWord]).matches())
            {
                nodes[nNodes-1].sharedLabel = words[iWord].substring(1,words[iWord].length()-1); // XXX need to unescapify!
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional quoted private label for this node
            //
            if (doubleQuotedStringMatcher.reset(words[iWord]).matches())
            {
                PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, nodes[nNodes-1]);
                privateNodeInfo.privateLabel = words[iWord].substring(1,words[iWord].length()-1); // XXX need to unescapify!
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional (you are here) for this node
            //
            if (words[iWord].equals("(you are here)")
             || (iWord+2 < words.length // XXX this is only needed if doing the brain dead word tokenizing
              && words[iWord].equals("(you")
              && words[iWord+1].equals("are")
              && words[iWord+2].equals("here)")))
            {
                if (currentNodeIndex != -1)
                    throw new IllegalArgumentException("UndoTree.fromString given an undo tree with more than one current node!");
                currentNodeIndex = nNodes-1;
                if (words[iWord].equals("(you"))
                    iWord += 2;
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional parenthesized (<preferredChild>) for this node
            //
            if (regex.matches(words[iWord], "\\(-?\\d+\\)"))
            {
                PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, nodes[nNodes-1]);
                privateNodeInfo.preferredChildIndex = Integer.parseInt(words[iWord].substring(1,words[iWord].length()-1));
                // XXX should bounds check, but have to do that at the end!
                iWord++;
            }
            if (iWord == words.length) break;

            //
            // Not at the end of the input, so there's another node
            //
            nodes[nNodes++] = new Node(-1, null);
            childrens[nNodes-1] = new com.donhatchsw.compat.ArrayList();

            //
            // optional parent offset...
            //      nothing means -1
            //      "u" means -2
            //      "u2" means -3
            // etc.
            //
            if (words[iWord].matches("u\\d*")) // XXX precompile!
            {
                int parentOffset = -1 - 
                    (words[iWord].equals("u") ? 1 :
                                Integer.parseInt(words[iWord].substring(1)));
                if (nNodes-1+parentOffset < 0) // e.g. node 3 can have offset at most 2, which makes its parent node 0
                    throw new IllegalArgumentException("UndoTree.fromString node "+(nNodes-1)+"'s parent offset is "+parentOffset+", which would put the parent at "+(nNodes-1+parentOffset)+"");
                nodes[nNodes-1].parent = parentOffset;
                int parentIndex = nNodes-1+parentOffset;
                iWord++;
            }
            childrens[nNodes-1 + nodes[nNodes-1].parent].add(new Integer(-nodes[nNodes-1].parent));

            if (iWord == words.length)
                throw new IllegalArgumentException("UndoTree.fromString premature end of input trying to read item at word "+iWord+"");

            //
            // required item from regex
            //
            if (itemMatcher.reset(words[iWord]).matches())
            {
                Object item = itemFromString.itemFromString(words[iWord]);
                nodes[nNodes-1].itemOnEdgeFromParentToMe = item;
                iWord++;
            }
            else
            {
                PRINT(words[iWord]);
                throw new IllegalArgumentException("UndoTree.fromString expected item at word "+iWord+" but got "+Arrays.toStringCompact(words[iWord])+" which does not match regex "+Arrays.toStringCompact(itemRegex)+"");
            }
        } // while (iWord < words.length)

        if (currentNodeIndex == -1)
            throw new IllegalArgumentException("UndoTree.fromString given an undo tree with no current node!");

        //
        // Now go through and hang each child on each parent,
        // and verify that its preferred child index is in bounds
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            nodes[iNode].children = new int[childrens[iNode].size()];
            for (int iChild = 0; iChild < nodes[iNode].children.length; ++iChild)
            {
                nodes[iNode].children[iChild] = ((Integer)childrens[iNode].get(iChild)).intValue();
            }
            PrivateNodeInfo privateNodeInfo = (PrivateNodeInfo)privateNodeInfosHashtable.get(nodes[iNode]);
            if (privateNodeInfo != null
             && (privateNodeInfo.preferredChildIndex < -1 // -1 is always okay
              || privateNodeInfo.preferredChildIndex >= nodes[iNode].children.length))
            {
                throw new IllegalArgumentException("UndoTree.fromString node "+iNode+"'s preferred child is "+privateNodeInfo.preferredChildIndex+" but only has "+nodes[iNode].children.length+" children!");
            }
        }

        UndoTree undoTree = new UndoTree(null);
        undoTree.currentNodeIndex = currentNodeIndex;
        undoTree.privateNodeInfosHashtable = privateNodeInfosHashtable;
        undoTree.nodes = new com.donhatchsw.compat.ArrayList(nNodes);
        for (int iNode = 0; iNode < nNodes; ++iNode)
            undoTree.nodes.add(nodes[iNode]);

        undoTree.checkSane();

        return undoTree;
    } // fromString


        private void checkSane()
        {
            for (int iNode = 0; iNode < nodes.size(); ++iNode)
            {
                Node node = (Node)nodes.get(iNode);
                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    Node child = (Node)nodes.get(childIndex);
                    //System.out.println(""+iNode+"->"+childIndex);
                    assert(childIndex+child.parent == iNode);
                }
            }
        }

        private static String repeat(String s, int n)
        {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < n; ++i)
                sb.append(s);
            return sb.toString();
        }


    /** Test/example program. */
    public static void main(String args[])
    {
        System.out.println("in main");
        UndoTree tree = new UndoTree();
        tree.Do("A");
        tree.Do("B");
        tree.setPrivateLabel("private_before_fork");
        tree.undo();
        tree.undo();
        tree.Do("C");
        tree.setPrivateLabel("shared_before_fork");
        tree.undo();
        tree.preferYoungerChild();
        tree.redo();
        tree.Do("D");
        tree.Do("E");
        UndoTree tree0 = tree;
        UndoTree tree1 = new UndoTree(tree);
        tree0.Do("F0");
        tree1.Do("G1");
        tree0.Do("H0");
        tree0.setPrivateLabel("0_private_after_fork");
        tree1.setPrivateLabel("1_private_after_fork");
        tree0.setSharedLabel("0_shared_after_fork");
        tree1.setSharedLabel("1_shared_after_fork");
        System.out.println("Tree 0:");
        System.out.println(tree0.toStringVisualCool(true));
        System.out.println(tree0.toStringVisualCool(false));
        System.out.println("Tree 1:");
        System.out.println(tree1.toStringVisualCool(true));
        System.out.println(tree1.toStringVisualCool(false));



        UndoTree.ItemToString itemToString = new UndoTree.ItemToString(){
            public String regex()
            {
                //return "-?\\d+"; // ints
                if (false)
                    return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                else
                    return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public String itemToString(Object obj)
            {
                // is this method necessary? could just take the regex
                //return obj.toString(); // ints
                return obj.toString(); // identifiers too
            }
        };
        UndoTree.ItemFromString itemFromString = new UndoTree.ItemFromString(){
            public String regex()
            {
                // return "-?\\d+"; // ints
                if (false)
                    return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                else
                    return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public Object itemFromString(String s)
            {
                //return Integer.valueOf(s); // ints
                return s; // identifiers
            }
        };
        //String indentSpaces = "    ";
        //String separatorSpaces = System.getProperty("line.separator");
        String indentSpaces = "";
        String separatorSpaces = " ";

        String s0 = tree0.toString(itemToString, indentSpaces, separatorSpaces);
        String s1 = tree1.toString(itemToString, indentSpaces, separatorSpaces);

        UndoTree t0 = UndoTree.fromString(s0, itemFromString);
        UndoTree t1 = UndoTree.fromString(s1, itemFromString);

        String u0 = t0.toString(itemToString, indentSpaces, separatorSpaces);
        String u1 = t1.toString(itemToString, indentSpaces, separatorSpaces);
        PRINT(s0);
        PRINT(u0);
        assert(u0.equals(s0));
        assert(u1.equals(s1));

        // XXX maybe should compare the visualcools too?
    } // main
} // class UndoTree
