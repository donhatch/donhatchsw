package com.donhatchsw.util;

import com.donhatchsw.compat.regex;

#include "macros.h"

/**
* Experimenting with the idea of an undo/redo tree.
* <a href="http://www.geocities.com/Hollywood/Set/4159/COULDWRK.WAV">It could work</a>!
*/

public class UndoTree
{
    // A node represents a state of the application;
    // Do's, undo's, redo's are edges that go from node to node.
    private static class Node
    {
        public int parent; // index relative to mine
        public Object itemOnEdgeFromParentToMe;
        public long timeCreated;
        public Object sharedLabel = null; // views might want to share a label or have their own private one
        public int children[] = new int[0]; // indices relative to mine
        public Node(int parent, Object itemOnEdgeFromParentToMe, long timeCreated)
        {
            this.parent = parent;
            this.itemOnEdgeFromParentToMe = itemOnEdgeFromParentToMe;
            this.timeCreated = timeCreated;
        }
    } // Node

    private static PrivateNodeInfo getOrMakePrivateNodeInfo(java.util.Hashtable privateNodeInfosHashtable, Node node)
    {
        PrivateNodeInfo info = (PrivateNodeInfo)privateNodeInfosHashtable.get(node);
        if (info == null)
        {
            info = new PrivateNodeInfo();
            privateNodeInfosHashtable.put(node, info);
        }
        return info;
    } // PrivateNodeInfo


    private com.donhatchsw.compat.ArrayList/*<Node>*/ nodes; // set in ctor
    private com.donhatchsw.compat.ArrayList sharedListeners; // set in ctor
    private com.donhatchsw.compat.ArrayList privateListeners = new com.donhatchsw.compat.ArrayList();

    //
    // An UndoTree is actually a view into the nodes (the model).
    // So we don't store view-specific info on the nodes themselves;
    // that way multiple views can look at the same model.
    //
    private static class PrivateNodeInfo
    {
        public Object privateLabel = null;
        public int preferredChildIndex = -1;
    }
    private com.donhatchsw.compat.ArrayList/*<PrivateNodeInfo>*/ privateNodeInfos;
    private java.util.Hashtable/*<PrivateNodeInfo>*/ privateNodeInfosHashtable = new java.util.Hashtable(); // XXX get rid of this
    private int currentNodeIndex; // set in ctor
    private double currentNodeFraction = 1.; // current fraction of way from parent to current node
    private double currentNodeVelocity = 0.; // don't ask

    /** A listening callback that you can create and install using addListener to listen for changes to the UndoTree. */
    public interface Listener
    {
        public void somethingChanged();
    }

    /**
    * Creates a new view onto an existing undo tree.
    * Both views will see the labels created via setSharedLabel(),
    * but a position label created via setPrivateLabel() will only be seen
    * in the view in which it was created.
    */
    // CTOR    (for quick find in editor)
    public UndoTree(UndoTree other)
    {
        if (other == null)
        {
            this.nodes = new com.donhatchsw.compat.ArrayList();
            this.nodes.add(new Node(-1,null,System.currentTimeMillis()));
            this.sharedListeners = new com.donhatchsw.compat.ArrayList();
            this.currentNodeIndex = 0;
        }
        else
        {
            this.nodes = other.nodes;
            this.sharedListeners = other.sharedListeners;
            this.currentNodeIndex = other.currentNodeIndex;
            // XXX should copy preferred child indices from the other too! and maybe private labels, but not sure about that. maybe that should be an argument to the constructor?
        }
    }

    /** Creates a new undo tree from scratch; equivalent to UndoTree(null). */
    public UndoTree()
    {
        this(null);
    }

    /** Equivalent to Do(item, System.currentTimeMillis()). */
    public void Do(Object item)
    {
        Do(item, System.currentTimeMillis());
    }


    /** Changes the current position to be a newly created child
    * of the current current position,
    * associating the given Object with the newly created transition to the new child.
    * The new child is made to be the preferred child
    * of the former current position.
    * This method actually affects the model, i.e. it modifies the tree
    * (whereas other methods such as undo, and redo
    * only affects the individual view of the model).
    * <p>
    * The time stamp is stored as the creation time of the new child.
    * NOTE this is currently not saved or restored via fromString and toString!
    * (but it should be!)
    */
    public void Do(Object item, long timeStampMillis)
    {
        if (item == null)
            throw new IllegalArgumentException("UndoTree.Do called with null item");
        int newChildIndex;
        synchronized(nodes)
        {
            newChildIndex = nodes.size();
            Node newChild = new Node(currentNodeIndex-newChildIndex, item, timeStampMillis);
            nodes.add(newChild);
        }

        Node currentNode = (Node)nodes.get(currentNodeIndex);
        int newChildIndexInCurrent;
        synchronized(currentNode)
        {
            newChildIndexInCurrent = currentNode.children.length;
            currentNode.children = (int[])Arrays.append(currentNode.children, newChildIndex-currentNodeIndex);
        }

        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        currentNodeInfo.preferredChildIndex = newChildIndexInCurrent;

        currentNodeIndex = newChildIndex;

        //checkSane(); // don't do this here, it's expensive

        // Note the sharedListeners list covers all the listeners
        // on the privateListers, and maybe some more too (that
        // were added by other views after a fork, or that existed
        // in the sharedListeners list before we were born).
        synchronized(sharedListeners)
        {
            for (int i = 0; i < sharedListeners.size(); ++i)
                ((Listener)sharedListeners.get(i)).somethingChanged();
        }
    } // Do

    /** Destroys the entire underlying tree.  XXX I suspect this is not very safe if multiple views are looking at it, I think there may be assumptions that indices will remain valid. */
    public void Clear()
    {
        synchronized(nodes)
        {
            nodes.clear();
            this.nodes.add(new Node(-1,null,System.currentTimeMillis()));
            this.currentNodeIndex = 0; // XXX but woe to all the other views!!
            this.currentNodeFraction = 1.;
            this.currentNodeVelocity = 0.;
            this.privateNodeInfosHashtable.clear(); // XXX argh! should have more stuff locked down!
            // XXX and everyone should clear unused nodes in their hash table if they notice the size has decreased!
        }
        synchronized(sharedListeners)
        {
            for (int i = 0; i < sharedListeners.size(); ++i)
                ((Listener)sharedListeners.get(i)).somethingChanged();
        }
    } // Clear

    /** Performs an undo; that is, changes the current position to be one step closer to the root of the tree, returning the Object that was originally passed to Do() when the tree edge was created. */
    public Object undo()
    {
        if (currentNodeIndex != 0)
        {
            Node currentNode = (Node)nodes.get(currentNodeIndex);
            Object item = currentNode.itemOnEdgeFromParentToMe;
            currentNodeIndex += currentNode.parent; // relative
            synchronized(privateListeners)
            {
                for (int i = 0; i < privateListeners.size(); ++i)
                    ((Listener)privateListeners.get(i)).somethingChanged();
            }
            return item;
        }
        else
        {
            return null;
        }
    }
    /** Performs a redo; that is, changes the current position to be the preferred child of the current current position, returning the Object that was originally passed to Do() when that tree edge was created.  If you want to go to a different child, you need to explicitly make that the preferred child first. */
    public Object redo()
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        if (currentNode.children.length == 0)
            return null;
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        if (currentNodeInfo.preferredChildIndex == -1)
            currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...
        currentNodeIndex += currentNode.children[currentNodeInfo.preferredChildIndex]; // relative
        currentNode = (Node)nodes.get(currentNodeIndex);
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
        return currentNode.itemOnEdgeFromParentToMe;
    }
    /**
    * Changes the preferred child of the current position (i.e. the path that will be taken by a redo) to the next older child than the current favorite, if there is one.
    */
    public boolean preferOlderChild()
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        synchronized(currentNode)
        {
            if (currentNodeInfo.preferredChildIndex == -1)
                currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...
            if (currentNodeInfo.preferredChildIndex-1 < 0)
                return false;
            currentNodeInfo.preferredChildIndex--;
        }
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
        return true;
    } // preferOlderChild
    /**
    * Changes the preferred child of the current position (i.e. the path that will be taken by a redo) to the next younger child than the current favorite, if there is one.
    */
    public boolean preferYoungerChild()
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        synchronized(currentNode)
        {
            if (currentNodeInfo.preferredChildIndex == -1)
                currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...

            if (currentNodeInfo.preferredChildIndex+1 >= currentNode.children.length)
                return false;
            currentNodeInfo.preferredChildIndex++;
        }
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
        return true;
    } // preferYoungerChild
    /** Oh, and this one updates the model too. Sets a label at the current position that will be seen by other views of this undo tree. */
    public void setSharedLabel(Object sharedLabel)
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        synchronized(currentNode)
        {
            currentNode.sharedLabel = sharedLabel;
        }
        synchronized(sharedListeners)
        {
            for (int i = 0; i < sharedListeners.size(); ++i)
                ((Listener)sharedListeners.get(i)).somethingChanged();
        }
    }
    /** Sets a label at the current position that will not be seen by other views of this undo tree. */
    public void setPrivateLabel(Object privateLabel)
    {
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        privateNodeInfo.privateLabel = privateLabel;
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
    }

    /** Moves my current position one step towards the corrent position of the other view. Returns true iff it actually did something. */
    public boolean incrementViewTowardsOtherView(UndoTree otherView,
                                                 double increment) // XXX need to make this smarter for smooth motion along edges of varying lengths
    {
        if (otherView.nodes != nodes)
            throw new IllegalArgumentException("UndoTree.incrementViewTowardsOtherView called with a different underlying tree!");
        // XXX need to lock something down while we do this... if someone else changes currentNodeIndex out from under us we are super screwed!!!
        int targetNodeIndex = otherView.currentNodeIndex;
        if (currentNodeIndex >= nodes.size())
            currentNodeIndex = 0; // XXX ad-hoc... can happen after a clear
        Node currentNode = (Node)nodes.get(currentNodeIndex);
        if (currentNodeIndex == targetNodeIndex)
        {
            if (currentNodeFraction >= 1.)
            {
                // We're there
                return false;
            }
            //
            // We're on the home stretch--
            // just need to redo a little bit more.
            //
            currentNodeFraction += increment;
            if (currentNodeFraction >= 1.)
                currentNodeFraction = 1.; // just clamp and we're done

            // XXX lame duplicate code... restructure this function so it bottoms out nicely
            synchronized(privateListeners)
            {
                for (int i = 0; i < privateListeners.size(); ++i)
                    ((Listener)privateListeners.get(i)).somethingChanged();
            }
            return true;
        }
        int parentIndex = currentNodeIndex + currentNode.parent;
        if (parentIndex == targetNodeIndex)
        {
            //
            // We're on the home stretch--
            // just need to undo a little bit more.
            //
            currentNodeFraction -= increment;
            if (currentNodeFraction <= 0.)
            {
                currentNodeIndex = parentIndex;
                currentNodeFraction = 1.;
            }
            // XXX lame duplicate code... restructure this function so it bottoms out nicely
            synchronized(privateListeners)
            {
                for (int i = 0; i < privateListeners.size(); ++i)
                    ((Listener)privateListeners.get(i)).somethingChanged();
            }
            return true;
        }
        int ancestorIndex = findLowestCommonAncestorIndex(currentNodeIndex,
                                                          targetNodeIndex,
                                                          nodes);
        if (ancestorIndex == currentNodeIndex)
        {
            // Go down in the redo direction
            currentNodeFraction += increment;
            if (currentNodeFraction >= 1.)
            {
                currentNodeFraction = 0.;
                // currentNode = the child on the way towards target node.
                // XXX The following is kind of bogus,
                // XXX since we didn't lock anything down
                // XXX so the other view might have changed its
                // XXX preferred children.  But, we'll assume
                // XXX that there is a clear redo path to the target
                // XXX via other view's preferred children...
                // XXX if we get it wrong,
                // XXX the worst that can happen is we will have to backtrack
                // XXX a little next time,
                // XXX and it will never be noticed by the user.
                PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
                synchronized(otherView.privateNodeInfosHashtable) // XXX I'm positive this is the wrong thing
                {
                    PrivateNodeInfo currentNodeInfoInOtherView = (PrivateNodeInfo)otherView.privateNodeInfosHashtable.get(currentNode);
                    if (currentNodeInfoInOtherView == null
                     || currentNodeInfoInOtherView.preferredChildIndex == -1)
                        currentNodeInfo.preferredChildIndex = currentNode.children.length-1;
                    else
                        currentNodeInfo.preferredChildIndex = currentNodeInfoInOtherView.preferredChildIndex;
                }
                currentNodeIndex += currentNode.children[currentNodeInfo.preferredChildIndex];
            }
        }
        else
        {
            // Go up in the undo direction
            currentNodeFraction -= increment;
            if (currentNodeFraction <= 0.)
            {
                currentNodeFraction = 1.;
                currentNodeIndex = parentIndex;
            }

            //
            // Hack for beautiful smooth transition as we turn around.
            // If we are about to switch to redos when we hit the parent,
            // then set its preferred child *now* instead of when
            // we get to the parent.
            // (Usually the preferred child is always the branch we are in,
            // so this is nonstandard but I don't think anything depends
            // on that assumption.)
            // Then when the drawing code (actually the chooseNodePositions
            // utility function, down below in this file)
            // sees that the preferred child
            // isn't the one the current node is under,
            // it knows that this is happening and can reposition
            // the parent horizonally in proportion to how far
            // the child has gone so far.
            //
            {
                Node parentNode = (Node)nodes.get(parentIndex);
                PrivateNodeInfo parentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, parentNode);
                synchronized(otherView.privateNodeInfosHashtable) // XXX I'm positive this is the wrong thing
                {
                    PrivateNodeInfo parentNodeInfoInOtherView = (PrivateNodeInfo)otherView.privateNodeInfosHashtable.get(parentNode);
                    if (parentNodeInfoInOtherView == null
                     || parentNodeInfoInOtherView.preferredChildIndex == -1)
                        parentNodeInfo.preferredChildIndex = parentNode.children.length-1;
                    else
                        parentNodeInfo.preferredChildIndex = parentNodeInfoInOtherView.preferredChildIndex;
                }
            }
        }
        // XXX lame duplicate code... restructure this function so it bottoms out nicely
        synchronized(privateListeners)
        {
            for (int i = 0; i < privateListeners.size(); ++i)
                ((Listener)privateListeners.get(i)).somethingChanged();
        }
        return true;
    } // incrementViewTowardsOtherView

        // XXX this will be made easier and faster in the future,
        // XXX when I'll make each view mark its path
        // XXX from its current node to the root;
        // XXX then we won't have to walk up and down to the root
        // XXX each time.  (actually just marking each node with its depth
        // XXX would suffice-- that would be easy...
        // XXX although it might prevent some local pruning operations
        // XXX from being fast... hmm)
    private static int findLowestCommonAncestorIndex(int i0, int i1, com.donhatchsw.compat.ArrayList nodes)
    {
        // Do the common cases fast...
        if (i0 == i1)
            return i0;
        if (i0 != 0 && i0+((Node)nodes.get(i0)).parent == i1)
            return i1;
        if (i1 != 0 && i1+((Node)nodes.get(i1)).parent == i0)
            return i0;

        // No clue where they are with respect to each other.
        // Figure out the depths...
        int depth0 = 0;
        for (int i = i0; i > 0; i += ((Node)nodes.get(i)).parent)
            depth0++;
        int depth1 = 0;
        for (int i = i1; i > 0; i += ((Node)nodes.get(i)).parent)
            depth1++;

        // Walk up the deeper side til they are at common depth...
        while (depth0 > depth1)
        {
            i0 += ((Node)nodes.get(i0)).parent;
            depth0--;
        }
        while (depth1 > depth0)
        {
            i1 += ((Node)nodes.get(i1)).parent;
            depth1--;
        }
        // Then keep walking up til they are equal.
        while (i0 != i1)
        {
            i0 += ((Node)nodes.get(i0)).parent;
            i1 += ((Node)nodes.get(i1)).parent;
        }
        return i0;
    } // findLowestCommonAncestorIndex

    /**
    * Installs a callback that will get called after
    * any change is made,
    * that is, when Do or setSharedLabel is called (by any view of the tree)
    * or when one of undo, redo, preferOlderChild, preferYoungerChild, setPrivateLabel
    * is called by this view of the tree.
    */
    public void addListener(Listener notifier)
    {
        synchronized(sharedListeners)
        {
            sharedListeners.remove(notifier); // XXX should throw IllegalArgumentException instead
            sharedListeners.add(notifier);
        }
        synchronized(privateListeners)
        {
            privateListeners.remove(notifier);
            privateListeners.add(notifier); // XXX should throw IllegalArgumentException
        }
    } // addListener
    /** Removes a callback that was previously installed with addListener(). */
    public void removeListener(Listener notifier)
    {
        synchronized(sharedListeners)
        {
            sharedListeners.remove(notifier);
        }
        synchronized(privateListeners)
        {
            privateListeners.remove(notifier);
        }
    } // removeListener


    public static class Snapshot
    {
        public int nNodes = -1;
        public int currentNode;
        public double currentNodeFraction;
        public double currentNodeVelocity; // don't laugh, the viewer might want to draw speed lines
        public int parents[] = null;
        public Object edgeItems[] = null;
        public Object sharedLabels[] = null;
        public Object privateLabels[] = null;
        public int preferredChildIndices[] = null;
    } // Snapshot

    /** Take a snapshot of the undo queue, locking down the shared data structures for as short a time as possible. */
    public void takeSnapshot(Snapshot snapshot)
    {
        // Don't lock down while allocating,
        // just re-do the allocations if something changed,
        // which will almost never happen.
        // Note also, we do need to lock down even the private stuff
        // since other threads might be accessing it
        // (private here doesn't mean thread-local, it means
        // "view-local"-- it's all relative)
        while (true)
        {
            int nNodes = nodes.size();
            snapshot.nNodes = nNodes;
            if (snapshot.parents == null
             || snapshot.parents.length < nNodes)
                snapshot.parents = new int[nNodes];
            if (snapshot.edgeItems == null ||
                snapshot.edgeItems.length < nNodes)
                snapshot.edgeItems = new Object[nNodes];
            if (snapshot.sharedLabels == null ||
                snapshot.sharedLabels.length < nNodes)
                snapshot.sharedLabels = new String[nNodes];
            if (snapshot.privateLabels == null ||
                snapshot.privateLabels.length < nNodes)
                snapshot.privateLabels = new String[nNodes];
            if (snapshot.preferredChildIndices == null ||
                snapshot.preferredChildIndices.length < nNodes)
                snapshot.preferredChildIndices = new int[nNodes];
            synchronized(nodes) // XXX are wy synching on the right thing?
            {
                if (nodes.size() != nNodes)
                    continue; // someone changed something! try allocations again
                if (currentNodeIndex > nodes.size())
                    currentNodeIndex = 0; // XXX stopgap-- need to check this more pervasively! really if we were doing this right we should get notified of model changes, rather than this half-assed joint ownership thing

                for (int iNode = 0; iNode < nNodes; ++iNode)
                {
                    Node node = (Node)nodes.get(iNode);
                    PrivateNodeInfo privateNodeInfo = (PrivateNodeInfo)privateNodeInfosHashtable.get(node);
                    snapshot.parents[iNode] = iNode + node.parent; // change relative to absolute
                    snapshot.edgeItems[iNode] = node.itemOnEdgeFromParentToMe;
                    snapshot.sharedLabels[iNode] = node.sharedLabel;
                    if (privateNodeInfo != null)
                    {
                        snapshot.privateLabels[iNode] = privateNodeInfo.privateLabel;
                        snapshot.preferredChildIndices[iNode] = privateNodeInfo.preferredChildIndex;
                    }
                    else
                    {
                        snapshot.privateLabels[iNode] = null;
                        snapshot.preferredChildIndices[iNode] = -1;
                    }
                }
                snapshot.currentNode = currentNodeIndex;
                snapshot.currentNodeFraction = currentNodeFraction;
                snapshot.currentNodeVelocity = currentNodeVelocity;
                break;
            } // synchronized(nodes)
        }
        // we could nicify it here if we want... perhaps putting in the children pointers as well, we're in no hurry any more
    } // takeSnapshot // takeSnapshot


    /**
    * Returns a string something like this if stretchOutAlongTimeLine is true:
    * <pre>
    *   +---------+
    *   |    0    |
    *   |    +-+  | A
    *   |    1 |  |
    *   |  +-+ |  | B
    *   |  2 | |  |
    *   |    | |  | C
    *   |    | 3  |
    *   |    |    | D
    *   |    4    |
    *   |    |    | E
    *   |   (5)   |
    *   +---------+
    * </pre>
    * and something like this if stretchOutAlongTimeLine is false:
    * <pre>
    *   +---------+
    *   |    0    |
    *   |    +-+  | A C
    *   |    1 3  |
    *   |  +-+    | B D
    *   |  2 4    |
    *   |    |    | E
    *   |   (5)   |
    *   +---------+
    * </pre>
    * These were created by executing the following commands:
    * <pre>
    *   UndoTree tree = new UndoTree();
    *   tree.Do("A");
    *   tree.Do("B");
    *   tree.undo();
    *   tree.undo();
    *   tree.Do("C");
    *   tree.undo();
    *   tree.preferYoungerChild();
    *   tree.redo();
    *   tree.Do("D");
    *   tree.Do("E");
    *   System.out.println(tree.toStringVisualCool(true));
    *   System.out.println(tree.toStringVisualCool(false));
    * </pre>
    */
    // TODO: compactify even more if it gets bushy then stringy then bushy, the lower bush can go under the upper bush
    public String toStringVisualCool(boolean stretchOutAlongTimeLine)
    {
        int nNodes = nodes.size();
        //
        // Bottom up, figure out the number of leaves
        // under the node.  That will be the logical width
        // allotted to this node.
        // 
        int widths[] = new int[nNodes]; // zeros
        for (int iNode = nNodes-1; iNode >= 0; iNode--)
        {
            Node node = (Node)nodes.get(iNode);
            for (int iChild = 0; iChild < node.children.length; ++iChild)
            {
                int childIndex = iNode + node.children[iChild];
                widths[iNode] += widths[childIndex];
            }
            if (widths[iNode] == 0)
                widths[iNode] = 1; // leaf
        }


        //
        // Top down, figure out the left and right logical bounds allotted to
        // each node.  Parent decides for each child.
        //
        int xstarts[] = new int[nNodes];
        xstarts[0] = 0;
        for (int iNode = 0; iNode < nNodes; iNode++)
        {
            Node node = (Node)nodes.get(iNode);
            int childStart = xstarts[iNode];
            for (int iChild = 0; iChild < node.children.length; ++iChild)
            {
                int childIndex = iNode + node.children[iChild];
                xstarts[childIndex] = childStart;
                childStart += widths[childIndex];
            }
        }
        //
        // Bottom up, decide the x position within the node's bounds
        // that we will display the node.  We want to display it
        // directly over its preferred child.
        // These are physical, not logical any more.
        //
        int x[] = new int[nNodes];
        for (int iNode = nNodes-1; iNode >= 0; iNode--)
        {
            Node node = (Node)nodes.get(iNode);
            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node); // XXX shouldn't make it if it doesn't exist, that's lame
            if (node.children.length == 0)
            {
                x[iNode] = 2*xstarts[iNode]+1;
            }
            else
            {
                int preferredChildIndex = privateNodeInfo.preferredChildIndex;
                if (preferredChildIndex == -1)
                    preferredChildIndex = node.children.length-1;
                x[iNode] = x[iNode + node.children[preferredChildIndex]];
            }
        }

        int possibleEdgeLengths[] = {3,4,6};
        int edgeLengths[] = new int[nNodes];
        for (int iNode = 0; iNode < nNodes; ++iNode)
            edgeLengths[iNode] = possibleEdgeLengths[(int)(Math.random()*possibleEdgeLengths.length)];

        int y[] = new int[nNodes];
        //
        // Decide the y position
        // where we will display the node.
        //
        if (stretchOutAlongTimeLine)
        {
            // Easy!
            for (int iNode = 0; iNode < nNodes; ++iNode)
                y[iNode] = 2*iNode;
        }
        else
        {
            //
            // Top down, put each child at a level
            // just below its parent.
            // (Well leave one line between them for the edge.)
            //
            y[0] = 0;
            for (int iNode = 0; iNode < nNodes; iNode++)
            {
                Node node = (Node)nodes.get(iNode);
                int childStart = xstarts[iNode];
                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    y[childIndex] = y[iNode] + 2;
                }
            }
        }

        int maxy = 0;
        for (int iNode = 0; iNode < nNodes; iNode++)
            maxy = Math.max(maxy, y[iNode]);

        char buf[][] = new char[maxy+1][1 + 2*widths[0]];
        for (int i = 0; i < buf.length; ++i)
        for (int j = 0; j < buf[i].length; ++j)
            buf[i][j] = ' ';

        //
        // Top down or bottom up, it doesn't matter,
        // draw the stuff into the rectangular buffer.
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            Node node = (Node)nodes.get(iNode);
            buf[y[iNode]][x[iNode]] = (char)('0'+(iNode%10)); // XXX just last digit for now
            if (iNode == currentNodeIndex)
            {
                buf[y[iNode]][x[iNode]-1] = '('; // XXX argh, index out of bounds
                buf[y[iNode]][x[iNode]+1] = ')';
            }
            if (node.children.length > 0)
            {
                if (node.children.length >= 1)
                {
                    int firstChildX = x[iNode+node.children[0]];
                    int lastChildX = x[iNode+node.children[node.children.length-1]];
                    for (int i = firstChildX; i <= lastChildX; ++i)
                        buf[y[iNode]+1][i] = '-';
                }

                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    buf[y[iNode]+1][x[childIndex]] = node.children.length==1 ? '|' : '+';
                    for (int j = y[iNode]+2; j < y[childIndex]; ++j)
                        buf[j][x[childIndex]] = '|';
                }
            }
        }

        //
        // Put annotations into the annotation buffer.
        //
        StringBuffer annotations[] = new StringBuffer[buf.length];
        for (int i = 0; i < annotations.length; ++i)
            annotations[i] = new StringBuffer();
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            Node node = (Node)nodes.get(iNode);
            if (iNode != 0)
            {
                annotations[y[iNode]-1].append(" "+node.itemOnEdgeFromParentToMe);
            }
            if (node.sharedLabel != null)
                annotations[y[iNode]].append(" sharedLabel="+Arrays.toStringCompact(node.sharedLabel));
            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node); // XXX shouldn't make it if it doesn't exist, that's lame
            if (privateNodeInfo.privateLabel != null)
                annotations[y[iNode]].append(" privateLabel="+Arrays.toStringCompact(privateNodeInfo.privateLabel));
        }


        //
        // Put the rectangular buffer on the left,
        // with annotations on the right, into a StringBuffer
        // in preparation for final output.
        //
        String nl = System.getProperty("line.separator");
        StringBuffer sb = new StringBuffer();

        sb.append("+"+repeat("-", buf[0].length+2)+"+"+nl);

        for (int i = 0; i < buf.length; ++i)
        {
            sb.append("| ");
            sb.append(buf[i]);
            sb.append(" |" );
            sb.append(annotations[i]);
            sb.append(nl);
        }
        sb.append("+"+repeat("-", buf[0].length+2)+"+"); // no nl
        return sb.toString();
    } // toStringVisualCool


    /** Static utility function for choosing a nice graphical layout, given the treee relation and edge lengths. The root node will be at y=0, with other y positions depending on the given edge lengths.  The x positions will be integers from 0 to number of branches. */
    // XXX see if I can leverage this in toStringVisualCool?
    public static void chooseNodePositions(int nNodes,
                                           int parents[],
                                           int preferredChildLocal[],
                                           double edgeLengths[],
                                           int currentNodeIndex,
                                           double currentNodeFrac,
                                           float stretchOutAlongTimeLine,
                                           double x[], // output
                                           double y[]) // output
    {
        //
        // Fill in firstChild,nextSibling array so we
        // Fill in a nextSibling array so we can easily traverse top-down
        // as well as bottom-up.
        //
        int firstChild[] = new int[nNodes];
        int nextSibling[] = new int[nNodes];
        for (int iNode = 0; iNode < nNodes; ++iNode)
            firstChild[iNode] = -1;
        for (int iChild = nNodes-1; iChild >= 0; iChild--)
        {
            int iParent = parents[iChild];
            if (iParent != -1)
            {
                nextSibling[iChild] = firstChild[iParent];
                firstChild[iParent] = iChild;
            }
            else
                nextSibling[iChild] = -1;
        }

        //
        // And resolve the preferred child thing...
        // don't-cares should turn into the youngest child.
        //
        int preferredChildGlobal[] = new int[nNodes];
        for (int iParent = 0; iParent < nNodes; ++iParent)
        {
            preferredChildGlobal[iParent] = -1;
            int iChildGlobal = firstChild[iParent];
            for (int iChildLocal = 0; iChildGlobal != -1; iChildLocal++, iChildGlobal = nextSibling[iChildGlobal])
            {
                if (preferredChildLocal[iParent] == -1) // it's a don't-care
                {
                    if (nextSibling[iChildGlobal] == -1)
                    {
                        preferredChildGlobal[iParent] = iChildGlobal;
                        break;
                    }
                }
                else
                {
                    if (iChildLocal == preferredChildLocal[iParent])
                    {
                        preferredChildGlobal[iParent] = iChildGlobal;
                        break;
                    }
                }
            }
            assert((preferredChildGlobal[iParent] == -1)
                == (firstChild[iParent] == -1));
        }


        //
        // Bottom up, figure out the number of leaves
        // under the node.  That will be the logical width
        // allotted to this node.
        // 
        int widths[] = new int[nNodes]; // zeros
        for (int iChild = nNodes-1; iChild >= 0; iChild--)
        {
            if (firstChild[iChild] == -1)
                widths[iChild] = 1;
            if (parents[iChild] != -1)
                widths[parents[iChild]] += widths[iChild];
        }


        //
        // Top down, figure out the left and right logical bounds allotted to
        // each node.  Parent decides for each child.
        //
        int xstarts[] = new int[nNodes];
        xstarts[0] = 0;
        for (int iParent = 0; iParent < nNodes; iParent++)
        {
            int childStart = xstarts[iParent];
            for (int iChild = firstChild[iParent]; iChild != -1; iChild = nextSibling[iChild])
            {
                xstarts[iChild] = childStart;
                childStart += widths[iChild];
            }
        }

        //
        // Bottom up, decide the x position within the node's bounds
        // that we will display the node.  We want to display it
        // directly over its preferred child.
        //
        // SPECIAL CASE:
        //     If we get to the parent of currentNode
        //     and its preferred child is *not* currentNode,
        //     we know we currentNode is moving towards
        //     the new preferred child, in which case linearly
        //     interpolate the parent's horizontal position
        //     between the old and new preferred child.
        //
        for (int iChild = nNodes-1; iChild >= 0; iChild--)
        {
            if (firstChild[iChild] == -1)
                x[iChild] = (double)xstarts[iChild];

            if (iChild == parents[currentNodeIndex]
             && preferredChildGlobal[iChild] != currentNodeIndex)
            {
                // the SPECIAL CASE described above
                x[iChild] = LERP(x[currentNodeIndex], x[iChild], 1.-currentNodeFrac);
            }

            int iParent = parents[iChild];
            if (iParent != -1)
            {
                if (preferredChildGlobal[iParent] == iChild)
                    x[iParent] = x[iChild];
            }
        }

        //
        // Decide the y position
        // where we will display the node.
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            if (parents[iNode] == -1)
                y[iNode] = 0;
            else
                y[iNode] = LERP(y[parents[iNode]], y[iNode-1], stretchOutAlongTimeLine) + edgeLengths[iNode];
        }
    } // chooseNodePositions






    /*
        XXX no this isn't right, we use relative offsets now
        Example:
            {"oh boy a puzzle!" 0 A 1 B "just did B" 2 C
                                    1 D 4 E 5 F
                                                     2 G
                                        4 H "oh boy I solved it"}
        Compact would be:
            {"oh boy a puzzle!" A B "just did B" C u D E F u2 G u3 H I "oh boy I solved it"}
    */

    interface ItemToString
    {
        public String regex();
        public String itemToString(Object item);
    }
    interface ItemFromString
    {
        public String regex();
        public Object itemFromString(String s);
    }
    /**
    * Returns a string something like this:
    * <pre>
    *   { A B (0) u2 C (you are here) u2 D E }
    * </pre>
    * You tell it how to stringify the individual items
    * by passing in an itemToString functor, and a regex that describes
    * what an item string can look like.
    * The result can be turned back into another UndoTree
    * by calling fromString(), so this is suitable for a save/load
    * mechanism.
    * <p>
    * Note that the tokens "u", "u2", "u3" etc. are used
    * to signify branching.  Your individual item regex is not allowed
    * to accept any of these strings (since if it did, it would be
    * impossible to tell whether "u" denoted an item or a branch indicator).
    * <p>
    * Similarly, the tokens "(0)", "(1)", etc. are used to signify
    * the preferred child of a given position (i.e. which edge
    * will be followed by a redo from that position).
    * Your individual item regex is not allowed to accept these either.
    * <p>
    * XXX More salient example coming soon.
    */
    public String toString(ItemToString itemToString,
                           String indentSpaces,
                           String separatorSpaces) // hmm, I guess itemToString isn't needed, it could just use the item's toString... but then where do we get the regex from?
    {
        System.out.println("in UndoTree.toString");
        if (!regex.matches(indentSpaces, "\\s*"))
            throw new IllegalArgumentException("UndoTree.toString given indent string "+Arrays.toStringCompact(indentSpaces)+", should be zero or more spaces");
        if (!regex.matches(separatorSpaces, "\\s+"))
            throw new IllegalArgumentException("UndoTree.toString given separator string "+Arrays.toStringCompact(separatorSpaces)+", should be one or more spaces");
        String itemRegex = itemToString.regex();
        regex.Matcher itemMatcher = regex.Pattern.compile(itemRegex).matcher("dummy");
        // XXX dup code in the other place, should combine
        if (itemMatcher.reset("").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches the empty string, that's messed up!");
        if (itemMatcher.reset("u").matches()
         || itemMatcher.reset("u1").matches()
         || itemMatcher.reset("u10").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches something starting with \"u\", can't do that because it's special!");
        if (itemMatcher.reset("(0)").matches()
         || itemMatcher.reset("(1)").matches()
         || itemMatcher.reset("(10)").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches a parenthesized number something like (2), can't do that because it's special!");

        StringBuffer sb = new StringBuffer();
        sb.append("{");
        sb.append(separatorSpaces);
        int nNodes = nodes.size();
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            sb.append(indentSpaces);
            Node node = (Node)nodes.get(iNode);
            if (iNode != 0)
            {
                String itemString = itemToString.itemToString(node.itemOnEdgeFromParentToMe);
                if (!itemMatcher.reset(itemString).matches())
                {
                    throw new IllegalArgumentException("UndoTree.toString given itemToString functor that produced string "+Arrays.toStringCompact(itemString)+" which does not match its regex pattern "+itemRegex+"!");
                }
                if (node.parent == -1)
                    ; // nothing, this is the default
                else if (node.parent == -2)
                    sb.append("u ");
                else  // -3 -> 2, -4 -> 3, etc.
                    sb.append("u").append(-node.parent-1).append(" ");
                sb.append(itemString).append(" ");
            }

            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node);
            // If printing private label and there's no shared label,
            // print "null" for the shared label

            if (node.sharedLabel != null
             || privateNodeInfo.privateLabel != null)
                sb.append(Arrays.toStringCompact(node.sharedLabel!=null ? node.sharedLabel.toString() : "null")+" ");
            if (privateNodeInfo.privateLabel != null)
                sb.append(Arrays.toStringCompact(privateNodeInfo.privateLabel).toString()+" ");
            if (iNode == currentNodeIndex)
                sb.append("(you are here) ");
            if (privateNodeInfo.preferredChildIndex != -1
             && node.children.length > 1) // XXX a little odd... can go from having a preference of the single child, to having no preference which means can be overridden by someone else making a child... think about this.  it's only an issue if collabarative editing
                sb.append("("+privateNodeInfo.preferredChildIndex+") ");
            while (" \r\n".indexOf(sb.charAt(sb.length()-1)) != -1) // XXX lame test!
                sb.deleteCharAt(sb.length()-1);
            sb.append(separatorSpaces);
        }
        sb.append("}");
        String s = sb.toString();
        System.out.println("out UndoTree.toString");
        return s;
    } // toString

    /** Parses a string that was created by toString(). */
    public static UndoTree fromString(String s, ItemFromString itemFromString)
    {
        String itemRegex = itemFromString.regex();
        regex.Matcher itemMatcher = regex.Pattern.compile(itemRegex).matcher("dummy");
        // XXX dup code in the other place, should combine
        if (itemMatcher.reset("").matches())
            throw new IllegalArgumentException("UndoTree.fromString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches the empty string, that's messed up!");
        if (itemMatcher.reset("u").matches()
         || itemMatcher.reset("u1").matches()
         || itemMatcher.reset("u10").matches())
            throw new IllegalArgumentException("UndoTree.fromString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches something starting with \"u\", can't do that because it's special!");
        if (itemMatcher.reset("(0)").matches()
         || itemMatcher.reset("(1)").matches()
         || itemMatcher.reset("(10)").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches a parenthesized number something like (2), can't do that because it's special!");

        regex.Matcher doubleQuotedStringMatcher = regex.Pattern.compile(
            "\"((\\\\|.)*)\""
        ).matcher("dummy");

        // XXX maybe should retain original s for error messages
        s = s.trim();
        if (s.length() < 2
         || s.charAt(0) != '{'
         || s.charAt(s.length()-1) != '}')
            throw new IllegalArgumentException("UndoTree.fromStringCompact called on string not surrounded by '{'");
        s = s.substring(1, s.length()-1).trim();

        String words[];
        {
            if (true)
            {
                // Brain dead way... works if there are no spaces at all
                // in the items or labels
                words = regex.split(s, "\\s+");
            }
            else
            {
                com.donhatchsw.compat.ArrayList/*<String>*/ wordsVector = new com.donhatchsw.compat.ArrayList();
                unimplemented(); // XXX implement me!
                words = new String[wordsVector.size()];
                wordsVector.toArray(words);
            }
        }

        // XXX ARGH! should save and restore Do times! for now, when reading back in, just label everything with the read-back-in time
        long currentTimeMillis = System.currentTimeMillis();

        // We'll stick these in the created undoTree when we
        // create it at the end
        int currentNodeIndex = -1;
        java.util.Hashtable/*<node, PrivateNodeInfo>*/ privateNodeInfosHashtable = new java.util.Hashtable();

        Node nodes[] = new Node[Math.max(words.length,1)]; // at most this many
        com.donhatchsw.compat.ArrayList/*Node*/ childrens[] = new com.donhatchsw.compat.ArrayList[nodes.length];

        int nNodes = 0;
        nodes[nNodes++] = new Node(-1, null, currentTimeMillis);
        childrens[nNodes-1] = new com.donhatchsw.compat.ArrayList();

        int iWord = 0;
        while (iWord < words.length)
        {
            //
            // optional quoted shared label for this node... or "null"
            // (without the quotes)
            //
            if (words[iWord].equals("null"))
            {
                // just leave it null... this is a placeholder
                // because there's a private label coming
                iWord++;
            }
            else if (doubleQuotedStringMatcher.reset(words[iWord]).matches())
            {
                nodes[nNodes-1].sharedLabel = words[iWord].substring(1,words[iWord].length()-1); // XXX need to unescapify!
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional quoted private label for this node
            //
            if (doubleQuotedStringMatcher.reset(words[iWord]).matches())
            {
                PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, nodes[nNodes-1]);
                privateNodeInfo.privateLabel = words[iWord].substring(1,words[iWord].length()-1); // XXX need to unescapify!
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional (you are here) for this node
            //
            if (words[iWord].equals("(you are here)")
             || (iWord+2 < words.length // XXX this is only needed if doing the brain dead word tokenizing
              && words[iWord].equals("(you")
              && words[iWord+1].equals("are")
              && words[iWord+2].equals("here)")))
            {
                if (currentNodeIndex != -1)
                    throw new IllegalArgumentException("UndoTree.fromString given an undo tree with more than one current node!");
                currentNodeIndex = nNodes-1;
                if (words[iWord].equals("(you"))
                    iWord += 2;
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional parenthesized (<preferredChild>) for this node
            //
            if (regex.matches(words[iWord], "\\(-?\\d+\\)"))
            {
                PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, nodes[nNodes-1]);
                privateNodeInfo.preferredChildIndex = Integer.parseInt(words[iWord].substring(1,words[iWord].length()-1));
                // XXX should bounds check, but have to do that at the end!
                iWord++;
            }
            if (iWord == words.length) break;

            //
            // Not at the end of the input, so there's another node
            //
            nodes[nNodes++] = new Node(-1, null, currentTimeMillis);
            childrens[nNodes-1] = new com.donhatchsw.compat.ArrayList();

            //
            // optional parent offset...
            //      nothing means -1
            //      "u" means -2
            //      "u2" means -3
            // etc.
            //
            if (words[iWord].matches("u\\d*")) // XXX precompile!
            {
                int parentOffset = -1 - 
                    (words[iWord].equals("u") ? 1 :
                                Integer.parseInt(words[iWord].substring(1)));
                if (nNodes-1+parentOffset < 0) // e.g. node 3 can have offset at most 2, which makes its parent node 0
                    throw new IllegalArgumentException("UndoTree.fromString node "+(nNodes-1)+"'s parent offset is "+parentOffset+", which would put the parent at "+(nNodes-1+parentOffset)+"");
                nodes[nNodes-1].parent = parentOffset;
                int parentIndex = nNodes-1+parentOffset;
                iWord++;
            }
            childrens[nNodes-1 + nodes[nNodes-1].parent].add(new Integer(-nodes[nNodes-1].parent));

            if (iWord == words.length)
                throw new IllegalArgumentException("UndoTree.fromString premature end of input trying to read item at word "+iWord+"");

            //
            // required item from regex
            //
            if (itemMatcher.reset(words[iWord]).matches())
            {
                Object item = itemFromString.itemFromString(words[iWord]);
                nodes[nNodes-1].itemOnEdgeFromParentToMe = item;
                iWord++;
            }
            else
            {
                PRINT(words[iWord]);
                throw new IllegalArgumentException("UndoTree.fromString expected item at word "+iWord+" but got "+Arrays.toStringCompact(words[iWord])+" which does not match regex "+Arrays.toStringCompact(itemRegex)+"");
            }
        } // while (iWord < words.length)

        if (currentNodeIndex == -1)
            throw new IllegalArgumentException("UndoTree.fromString given an undo tree with no current node!");

        //
        // Now go through and hang each child on each parent,
        // and verify that its preferred child index is in bounds
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            nodes[iNode].children = new int[childrens[iNode].size()];
            for (int iChild = 0; iChild < nodes[iNode].children.length; ++iChild)
            {
                nodes[iNode].children[iChild] = ((Integer)childrens[iNode].get(iChild)).intValue();
            }
            PrivateNodeInfo privateNodeInfo = (PrivateNodeInfo)privateNodeInfosHashtable.get(nodes[iNode]);
            if (privateNodeInfo != null
             && (privateNodeInfo.preferredChildIndex < -1 // -1 is always okay
              || privateNodeInfo.preferredChildIndex >= nodes[iNode].children.length))
            {
                throw new IllegalArgumentException("UndoTree.fromString node "+iNode+"'s preferred child is "+privateNodeInfo.preferredChildIndex+" but only has "+nodes[iNode].children.length+" children!");
            }
        }

        UndoTree undoTree = new UndoTree(null);
        undoTree.currentNodeIndex = currentNodeIndex;
        undoTree.privateNodeInfosHashtable = privateNodeInfosHashtable;
        undoTree.nodes = new com.donhatchsw.compat.ArrayList(nNodes);
        for (int iNode = 0; iNode < nNodes; ++iNode)
            undoTree.nodes.add(nodes[iNode]);

        undoTree.checkSane();

        return undoTree;
    } // fromString


        private void checkSane()
        {
            for (int iNode = 0; iNode < nodes.size(); ++iNode)
            {
                Node node = (Node)nodes.get(iNode);
                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    Node child = (Node)nodes.get(childIndex);
                    //System.out.println(""+iNode+"->"+childIndex);
                    assert(childIndex+child.parent == iNode);
                }
            }
        }

        private static String repeat(String s, int n)
        {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < n; ++i)
                sb.append(s);
            return sb.toString();
        }


    /** Test/example program. */
    public static void main(String args[])
    {
        System.out.println("in main");
        UndoTree tree = new UndoTree();
        tree.Do("A");
        tree.Do("B");
        tree.setPrivateLabel("private_before_fork");
        tree.undo();
        tree.undo();
        tree.Do("C");
        tree.setPrivateLabel("shared_before_fork");
        tree.undo();
        tree.preferYoungerChild();
        tree.redo();
        tree.Do("D");
        tree.Do("E");
        UndoTree tree0 = tree;
        UndoTree tree1 = new UndoTree(tree);
        tree0.Do("F0");
        tree1.Do("G1");
        tree0.Do("H0");
        tree0.setPrivateLabel("0_private_after_fork");
        tree1.setPrivateLabel("1_private_after_fork");
        tree0.setSharedLabel("0_shared_after_fork");
        tree1.setSharedLabel("1_shared_after_fork");
        System.out.println("Tree 0:");
        System.out.println(tree0.toStringVisualCool(true));
        System.out.println(tree0.toStringVisualCool(false));
        System.out.println("Tree 1:");
        System.out.println(tree1.toStringVisualCool(true));
        System.out.println(tree1.toStringVisualCool(false));



        UndoTree.ItemToString itemToString = new UndoTree.ItemToString(){
            public String regex()
            {
                //return "-?\\d+"; // ints
                if (false)
                    return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                else
                    return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public String itemToString(Object obj)
            {
                // is this method necessary? could just take the regex
                //return obj.toString(); // ints
                return obj.toString(); // identifiers too
            }
        };
        UndoTree.ItemFromString itemFromString = new UndoTree.ItemFromString(){
            public String regex()
            {
                // return "-?\\d+"; // ints
                if (false)
                    return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                else
                    return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public Object itemFromString(String s)
            {
                //return Integer.valueOf(s); // ints
                return s; // identifiers
            }
        };
        //String indentSpaces = "    ";
        //String separatorSpaces = System.getProperty("line.separator");
        String indentSpaces = "";
        String separatorSpaces = " ";

        String s0 = tree0.toString(itemToString, indentSpaces, separatorSpaces);
        String s1 = tree1.toString(itemToString, indentSpaces, separatorSpaces);

        UndoTree t0 = UndoTree.fromString(s0, itemFromString);
        UndoTree t1 = UndoTree.fromString(s1, itemFromString);

        String u0 = t0.toString(itemToString, indentSpaces, separatorSpaces);
        String u1 = t1.toString(itemToString, indentSpaces, separatorSpaces);
        PRINT(s0);
        PRINT(u0);
        assert(u0.equals(s0));
        assert(u1.equals(s1));

        // XXX maybe should compare the visualcools too?
    } // main
} // class UndoTree
