package com.donhatchsw.util;

import com.donhatchsw.compat.regex;

#include "macros.h"

/**
* Experimenting with the idea of an undo/redo tree.
* <a href="http://www.geocities.com/Hollywood/Set/4159/COULDWRK.WAV">It could work</a>!
*/

public class UndoTree
{
    public interface ItemLengthizer
    {
        /**
        * The length the given edge should be; use 1 for an average edge.
        * For example, in a Rubik's-cube-like puzzle program,
        * where each graph edge represents a puzzle twist
        * through an angle of 90, 120, or 180 degrees,
        * and 90 is the most common,
        * you'd give the edges lengths 1, 4./3., 2 respectively.
        * When using the undo tree for animation,
        * the time it takes to traverse an edge in the tree
        * (i.e. to animate a Do, undo, or redo)
        * will be proportional to the square root of this edge length.
        * I.e. a 180 degree twist will take sqrt(2) times as long
        * as a 90 degree twist.
        */
        double length(Object item);
    }

    /** A listening callback that you can create and install using addListener to listen for changes to the UndoTree. Hears changes to both the shared model (the actual tree, which other views (UndoTrees) might be listening to) and your individual view (i.e. current position and private node labels). */
    public interface Listener
    {
        public void somethingChanged();
    }

    // It's a model/view setup, where UndoTree itself is the view and UndoTree.Model is the model.
    // XXX gah, I hate that privates of subclasses are accessible... I want to make them private so I don't cheat, I should be able to, dammit
    private static class Model
    {
        // A node represents a state of the application;
        // the edges are editing operations that go from node to node.
        // Do, undo, and redo means traversing an edge
        // (although that is a View concept, since the model
        // has no concept of current position).
        public static class Node
        {
            public int parent; // index relative to mine
            public Object itemOnEdgeFromParentToMe;
            public long timeCreated;
            public Object sharedLabel = null; // views might want to share a label or have their own private one
            public int children[] = new int[0]; // indices relative to mine
            public Node(int parent, Object itemOnEdgeFromParentToMe, long timeCreated)
            {
                this.parent = parent;
                this.itemOnEdgeFromParentToMe = itemOnEdgeFromParentToMe;
                this.timeCreated = timeCreated;
            }
        } // Node

        public com.donhatchsw.compat.ArrayList/*<Node>*/ nodes = new com.donhatchsw.compat.ArrayList();
        // The model has listeners (the views),
        // and each view has listeners.
        // Each view installs a listener on the model
        // that simply propagates model change notifications
        // into view change notifications (since every model change
        // is also a view change, for the purposes of someone
        // displaying the view in a viewer, for example).
        // XXX this should be PRIVATE to the view (UndoTree)!
        // XXX I don't have any way
        // XXX of enforcing that because java's privacy semantics are screwed,
        // XXX but there should be no cases where the UndoTree accesses
        // XXX this list directly.
        private com.donhatchsw.compat.ArrayList modelListeners = new com.donhatchsw.compat.ArrayList();

        public Model()
        {
            this.nodes.add(new Node(-1,null,System.currentTimeMillis()));
        }

        public void addListener(Listener listener)
        {
            synchronized(this)
            {
                modelListeners.remove(listener); // XXX should throw IllegalStateException instead
                modelListeners.add(listener);
            }
        }
        public void removeListener(Listener notifier)
        {
            synchronized(this)
            {
                modelListeners.remove(notifier);
            }
        } // removeListener

        public void Clear()
        {
            synchronized(this)
            {
                nodes.clear();
                nodes.add(new Model.Node(-1,null,System.currentTimeMillis()));
            }
            // XXX hmm, idea... should we pass down a callback that lets them ask the old-to-new of any node index they are interested in?  hmm
            notifyListenersSomethingChanged(modelListeners);
        } // Clear

        // caller must be synchronized on this model since it's
        // expecting parentNodeIndex to be valid.
        // returns the index of the newly created child,
        // and its index in the parent.
        public int[] Do(int parentNodeIndex, Object item, long timeStampMillis)
        {
            if (item == null)
                throw new IllegalArgumentException("UndoTree.Do called with null item");
            int newChildIndex = nodes.size();
            Node newChild = new Node(parentNodeIndex-newChildIndex, item, timeStampMillis);
            nodes.add(newChild);

            Node parentNode = (Node)nodes.get(parentNodeIndex);
            int newChildIndexInCurrent = parentNode.children.length;
            parentNode.children = (int[])Arrays.append(parentNode.children, newChildIndex-parentNodeIndex);
            notifyListenersSomethingChanged(modelListeners);
            return new int[]{newChildIndex, newChildIndexInCurrent};
        } // Model.Do

        // The fact that the caller has a node
        // means they are required to be inside a synchronized(model)
        // block, so we don't need to do additional synchronization here.
        public void setNodeLabel(Node node, Object sharedLabel)
        {
            node.sharedLabel = sharedLabel;
            notifyListenersSomethingChanged(modelListeners);
        }

    } // Model

    private Model model; // set in ctor

    private static PrivateNodeInfo getOrMakePrivateNodeInfo(java.util.Hashtable privateNodeInfosHashtable, Model.Node node)
    {
        PrivateNodeInfo info = (PrivateNodeInfo)privateNodeInfosHashtable.get(node);
        if (info == null)
        {
            info = new PrivateNodeInfo();
            privateNodeInfosHashtable.put(node, info);
        }
        return info;
    } // PrivateNodeInfo

    private com.donhatchsw.compat.ArrayList viewListeners = new com.donhatchsw.compat.ArrayList();

    //
    // An UndoTree is actually a view into the nodes (the model).
    // So we don't store view-specific info on the nodes themselves;
    // that way multiple views can look at the same model.
    //
    private static class PrivateNodeInfo
    {
        public Object privateLabel = null;
        public int preferredChildIndex = -1;
    }
    private java.util.Hashtable/*<PrivateNodeInfo>*/ privateNodeInfosHashtable = new java.util.Hashtable(); // XXX get rid of this, make it an array instead?  not sure
    private int currentNodeIndex; // set in ctor
    private SmoothlyVaryingViewingParameter currentNodeFraction = new SmoothlyVaryingViewingParameter(1.); // current fraction of the way from parent to current node

    // XXX these haven't been thought out well... probably should not be here, are not safe... bleah bleah bleah
    public void setCurrentNodeIndex(int currentNodeIndex)
    {
        synchronized(privateNodeInfosHashtable)
        {
            this.currentNodeIndex = currentNodeIndex;
            // Correct the preferred child path from the root // XXX this is more costly than it should be!  there should be an O(1) way to do this! maybe
            {
                int iChild = this.currentNodeIndex;
                Model.Node child = (Model.Node)model.nodes.get(iChild);

                while (iChild != 0)
                {
                    int iParent = iChild + child.parent;
                    Model.Node parent = (Model.Node)model.nodes.get(iParent);
                    int childIndex = Arrays.indexOf(parent.children, -child.parent);
                    PrivateNodeInfo parentInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, parent);
                    parentInfo.preferredChildIndex = childIndex;
                    iChild = iParent;
                    child = parent;
                }
            }
        }
        this.currentNodeFraction.snap(1.);
        notifyListenersSomethingChanged(viewListeners);
    }
    public int getCurrentNodeIndex()
    {
        return currentNodeIndex;
    }
    public double getCurrentNodeFraction()
    {
        return currentNodeFraction.get();
    }
    public Object getItemOnEdgeFromParentToCurrentNode() // XXX definitely shouldn't have to be public... root out the usages of it and see if we can handle it a different way
    {
        synchronized(model.nodes) // XXX should model handle this instead?
        {
            return ((Model.Node)model.nodes.get(currentNodeIndex)).itemOnEdgeFromParentToMe;
        }
    }
    public void setCurrentNodeFraction(double currentNodeFraction)
    {
        this.currentNodeFraction.snap(currentNodeFraction);
        notifyListenersSomethingChanged(viewListeners);
    }

    /**
    * Creates a new view onto an existing undo tree, or a new undo tree (if other is null).
    */
    // CTOR    (for quick find in editor)
    public UndoTree(UndoTree other)
    {
        if (other == null)
        {
            this.model = new Model();
            this.currentNodeIndex = 0;
            this.currentNodeFraction.set(1.);
        }
        else
        {
            this.model = other.model;
            this.currentNodeIndex = other.currentNodeIndex;
            this.currentNodeFraction.snap(other.currentNodeFraction.get());
            this.currentNodeFraction.set(other.currentNodeFraction.getTarget());
            // XXX should copy preferred child indices from the other too! and maybe private labels, but not sure about that. maybe that should be an argument to the constructor?
        }
        // Propagate model change notifications
        // to this view's view change listeners.
        // Note, this could also be accomplished by simply
        // making our addListener(newListener)
        // call model.addListener(newListener)
        // in addition to adding the new listener to our own listeners list,
        // so that the listener would get notified directly...
        // however that would be a mess if the model was ever changed, so
        // I think it's cleaner this way.
        this.model.addListener(new Listener() { // XXX this never gets removed!  should it be a weak reference or something?
            public void somethingChanged()
            {
                if (model.nodes.size() == 1) // it's always at least 1
                {
                    // XXX lock something down?
                    // XXX might deadlock, should we just set a flag
                    // XXX and do this lazily when someone wants something?
                    currentNodeIndex = 0; // XXX hmm, this is destructive, puzzle state needs to be reset if this happens
                    currentNodeFraction.snap(1.);
                    privateNodeInfosHashtable.clear();
                }
                assert(currentNodeIndex < model.nodes.size()); // XXX will need to do something more sophisticated if pruning is implemented; for now, the only destructive operation is Clear which we just handled

                // Regardless of whether we changed our private stuff,
                // every model change is regarded as noteworthy
                // for view listeners, so notify them.
                notifyListenersSomethingChanged(viewListeners);
            }
        });
    } // UndoTree (view) ctor

    /** Creates a new undo tree (view) with a brand new empty tree; equivalent to UndoTree(null). */
    public UndoTree()
    {
        this(null);
    }

    /** Equivalent to Do(item, System.currentTimeMillis()). */
    public void Do(Object item)
    {
        Do(item, System.currentTimeMillis());
    }


    /** Changes the current position to be a newly created child
    * of the current current position,
    * associating the given Object with the newly created transition to the new child.
    * The new child is made to be the preferred child
    * of the former current position.
    * This method actually affects the model, i.e. it modifies the tree
    * (whereas other methods such as undo, and redo
    * only affects the individual view of the model).
    * <p>
    * The time stamp is stored as the creation time of the new child.
    * NOTE this is currently not saved or restored via fromString and toString!
    * (but it should be!)
    */
    public void Do(Object item, long timeStampMillis)
    {
        if (item == null)
            throw new IllegalArgumentException("UndoTree.Do called with null item");
        synchronized(this) // note currentNodeIndex can change while waiting for this lock!  that will make us hang it off the new currentNodeIndex instead.  that's the way the ball bounces.
        {
            currentNodeFraction.snap(1.); // XXX seems safe, didn't think about this much
            synchronized(model) // currentNodeIndex can also change while waiting for *this* lock, since if someone is clearing the model, that will notify us and *we* will set it to zero.  that's the way the ball bounces.
            {
                int newChildIndex_and_newChildIndexInCurrent[] = model.Do(currentNodeIndex, item, timeStampMillis);
                int newChildIndex = newChildIndex_and_newChildIndexInCurrent[0];
                int newChildIndexInCurrent = newChildIndex_and_newChildIndexInCurrent[1];
                PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, (Model.Node)model.nodes.get(currentNodeIndex));
                currentNodeInfo.preferredChildIndex = newChildIndexInCurrent;

                currentNodeIndex = newChildIndex; // XXX could just do a redo?
            }
            notifyListenersSomethingChanged(viewListeners); // XXX hmm... we already notified them inside the model changed callback which got called from inside model.Do, so this is notifying them twice... bleah. wonder if there is a clean way to prevent that.  Ultimately it should just amount to a repaint(), I hope... not sure about that though.
        }
    } // Do

    /** Destroys the entire underlying tree. */
    public void Clear()
    {
        model.Clear();
        // That will notify us that the model changed,
        // which will cause us to update
        // our currentNodeIndex and hash table
        // (and it will make all other views do that too)
        // so we don't need to do that here.
    }

    /** Performs an undo; that is, changes the current position to be one step closer to the root of the tree, returning the Object that was originally passed to Do() when the tree edge was created. */
    public Object undo()
    {
        if (currentNodeIndex != 0)
        {
            Model.Node currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
            Object item = currentNode.itemOnEdgeFromParentToMe;
            currentNodeIndex += currentNode.parent; // relative
            currentNodeFraction.snap(1.);
            notifyListenersSomethingChanged(viewListeners);
            return item;
        }
        else
        {
            return null;
        }
    }
    /** Performs a redo; that is, changes the current position to be the preferred child of the current current position, returning the Object that was originally passed to Do() when that tree edge was created.  If you want to go to a different child, you need to explicitly make that the preferred child first. */
    public Object redo()
    {
        Model.Node currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
        if (currentNode.children.length == 0)
            return null;
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        if (currentNodeInfo.preferredChildIndex == -1)
            currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...
        currentNodeIndex += currentNode.children[currentNodeInfo.preferredChildIndex]; // relative
        currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
        currentNodeFraction.snap(1.);
        notifyListenersSomethingChanged(viewListeners);
        return currentNode.itemOnEdgeFromParentToMe;
    }
    /**
    * Changes the preferred child of the current position (i.e. the path that will be taken by a redo) to the next older child than the current favorite, if there is one.
    */
    public boolean preferOlderChild()
    {
        Model.Node currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        synchronized(currentNode)
        {
            if (currentNodeInfo.preferredChildIndex == -1)
                currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...
            if (currentNodeInfo.preferredChildIndex-1 < 0)
                return false;
            currentNodeInfo.preferredChildIndex--;
        }
        notifyListenersSomethingChanged(viewListeners);
        return true;
    } // preferOlderChild
    /**
    * Changes the preferred child of the current position (i.e. the path that will be taken by a redo) to the next younger child than the current favorite, if there is one.
    */
    public boolean preferYoungerChild()
    {
        Model.Node currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
        PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
        synchronized(currentNode)
        {
            if (currentNodeInfo.preferredChildIndex == -1)
                currentNodeInfo.preferredChildIndex = currentNode.children.length-1; // we didn't create any of currentNode's children nor have we traversed any of them, so we don't have a preference... just take the last one XXX maybe should prefer the preferred one of whoever made it? or of the latest child that *anyone* traversed or has been hanging out in? hmm...

            if (currentNodeInfo.preferredChildIndex+1 >= currentNode.children.length)
                return false;
            currentNodeInfo.preferredChildIndex++;
        }
        notifyListenersSomethingChanged(viewListeners);
        return true;
    } // preferYoungerChild

    /** Oh, and this one updates the model too. Sets a label at the current position that will be seen by other views of this undo tree. */
    public void setSharedLabel(Object sharedLabel)
    {
        synchronized(model) // required whenever getting a node
        {
            // XXX what if some other view has done a clear?
            Model.Node currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
            model.setNodeLabel(currentNode, sharedLabel);
        }
    }

    /** Sets a label at the current position that will not be seen by other views of this undo tree. */
    public void setPrivateLabel(Object privateLabel)
    {
        synchronized(this)
        {
            Model.Node currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
            privateNodeInfo.privateLabel = privateLabel;
        }
        notifyListenersSomethingChanged(viewListeners);
    }

    /** awkward as hell, but incrementViewTowardsOtherView needs to return an int and an Object, so here it is. */
    public class ReturnValueOfIncrementViewTowardsOtherView
    {
        public int dir; /** -1 for undo, 1 for redo */
        public Object item; /** the item to undo (if dir==-1) or redo (if dir==1) */
        private ReturnValueOfIncrementViewTowardsOtherView(int dir,
                                                           Object item)
        {
            this.dir = dir;
            this.item = item;
        }
    } // ReturnValueOfIncrementViewTowardsOtherView

    /**
    * Returns true if a call to incrementViewTowardsOtherView(target) would actually change anything.
    */
    public boolean isMoving(UndoTree target)
    {
        return currentNodeIndex != target.currentNodeIndex
            || currentNodeFraction.get() != target.currentNodeFraction.get();
    }

    /**
    * Moves my current position one step towards the current position of the other view.  Returns a structure describing the discrete state change involved (if any) and the fractional offset from the new integer state that should be used to display the new fractional state.
    */
    // XXX restructure this function to make it clearer
    public ReturnValueOfIncrementViewTowardsOtherView incrementViewTowardsOtherView(UndoTree otherView,
                                                 double referenceTripDistance,
                                                 double referenceTripTime,
                                                 double dt,
                                                 double bounce,
                                                 UndoTree.ItemLengthizer lengthizer)
    {
        boolean debug = false;
        if (debug) System.out.println("in incrementViewTowardsOtherView");
        if (otherView.model.nodes != model.nodes)
            throw new IllegalStateException("UndoTree.incrementViewTowardsOtherView called with a different underlying tree!");
        // XXX need to lock something down while we do this... if someone else changes currentNodeIndex out from under us we are super screwed!!!

        int targetNodeIndex = otherView.currentNodeIndex;
        double targetNodeFraction = otherView.currentNodeFraction.get();
        Model.Node currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
        if (currentNodeIndex == targetNodeIndex)
        {
            if (debug) System.out.println("    home stretch");
            currentNodeFraction.set(targetNodeFraction); // if it wasn't already
            if (!currentNodeFraction.isMoving())
            {
                if (debug) System.out.println("        already there");
                return null;
            }
            //
            // We're on the home stretch,
            // between the target's parent and the target...
            // Just need to redo a little more (or undo if we overshot).
            //
            if (debug) System.out.println("        evolving "+currentNodeFraction.get()+" -> "+currentNodeFraction.getTarget()+"");
            double referenceTripFraction = referenceTripDistance/lengthizer.length(currentNode.itemOnEdgeFromParentToMe);
            currentNodeFraction.evolve(referenceTripFraction,
                                       referenceTripTime,
                                       dt,
                                       bounce);
            notifyListenersSomethingChanged(viewListeners);
            return null; // no discrete state change
        }
        int ancestorIndex = findLowestCommonAncestorIndex(currentNodeIndex,
                                                          targetNodeIndex,
                                                          model.nodes);
        ReturnValueOfIncrementViewTowardsOtherView returnVal = null;
        if (ancestorIndex == currentNodeIndex)
        {
            // Go down in the redo direction
            if (debug) System.out.println("    going in redo direction");
            currentNodeFraction.set(1.); // if it wasn't already
            if (!currentNodeFraction.isMoving())
            {
                if (debug) System.out.println("        already there, transitioning");
                // currentNode = the child on the way towards target node.
                // Note, the following is kind of bogus,
                // since we didn't lock anything down
                // so the other view might have changed its
                // preferred children.  But, we'll assume
                // that there is a clear redo path to the target
                // via other view's preferred children...
                // if we get it wrong,
                // the worst that can happen is we will have to backtrack
                // a little next time,
                // and it will never be noticed by the user.
                // XXX unless someone calls Clear.... then we might be screwed
                PrivateNodeInfo currentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, currentNode);
                synchronized(otherView.privateNodeInfosHashtable) // XXX I'm positive this is the wrong thing
                {
                    PrivateNodeInfo currentNodeInfoInOtherView = (PrivateNodeInfo)otherView.privateNodeInfosHashtable.get(currentNode);
                    if (currentNodeInfoInOtherView == null
                     || currentNodeInfoInOtherView.preferredChildIndex == -1)
                        currentNodeInfo.preferredChildIndex = currentNode.children.length-1;
                    else
                        currentNodeInfo.preferredChildIndex = currentNodeInfoInOtherView.preferredChildIndex;
                }
                currentNodeIndex += currentNode.children[currentNodeInfo.preferredChildIndex];
                currentNodeFraction.snap(0.);
                assert(currentNodeFraction.get() == 0.);
                currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
                returnVal = new ReturnValueOfIncrementViewTowardsOtherView(1, currentNode.itemOnEdgeFromParentToMe/*AFTER we change current node*/);
                // In this case don't evolve... wait for next time around,
                // which will do something or other depending
                // on whether the new one is the target or not.
            }
            else
            {
                if (debug) System.out.println("        evolving "+currentNodeFraction.get()+" -> "+currentNodeFraction.getTarget()+"");

                //
                // Okay, this will be the coolest thing ever
                // if we can pull this off...
                // look ahead to see if there are one or more
                // other redos ahead of us that are identical to this one.
                // If so, set our target to be the end of the stretch
                // of identical redos, so that we don't slow down
                // at the transition.
                // (XXX need to do this for redos too)
                // (XXX need a smarter transition mechanism... !isMoving won't cut it any more)
                //
                {
                    int nodeIndex = currentNodeIndex;
                    Model.Node node = currentNode;
                    Object item = currentNode.itemOnEdgeFromParentToMe;
                    //System.out.println("    Should I add power?");
                    while (true)
                    {
                        if (node.children.length == 0)
                        {
                            //System.out.println("        no, because no children");
                            break;
                        }
                        int preferredChildIndex;
                        if (node.children.length == 1)
                            preferredChildIndex = 0;
                        else
                        {
                            // XXX for now, only do it if there's only one child. that will cover the Do-Do-Do case which is the most important one.  I'll implement the more general thing later.
                            //System.out.println("        no, because more than one child although this will work some day)");
                            break;
                        }
                        int childIndex = nodeIndex + node.children[preferredChildIndex];
                        Model.Node childNode = (Model.Node)model.nodes.get(childIndex); // XXX synch!?
                        Object childItem = childNode.itemOnEdgeFromParentToMe;
                        if (!childItem.equals(item))
                        {
                            //System.out.println("        no, child item is different from this item");
                            break;
                        }
                        currentNodeFraction.set(currentNodeFraction.getTarget()+1.);
                        //System.out.println("            power -> "+currentNodeFraction.getTarget()+" baby!");
                        //System.out.println("        should I add more?");
                        nodeIndex = childIndex;
                        node = childNode;
                    }
                    if (!currentNodeFraction.isMoving())
                    {
                        // this should NOT happen... it will happen
                        // if we get all the way to the target
                        // without doing the switcheroo.
                        System.out.println("SOMEONE STOP THIS THING, I WANT TO GET OFF!");
                    }
                }

                double referenceTripFraction = referenceTripDistance/lengthizer.length(currentNode.itemOnEdgeFromParentToMe);
                currentNodeFraction.evolve(referenceTripFraction,
                                           referenceTripTime,
                                           dt,
                                           bounce);
                //
                // Switch rails here!
                //
                if (currentNodeFraction.getTarget() > 1.
                 && currentNodeFraction.get() > 1.)
                {
                    // Just do one switch even though potentially get()
                    // might be > 2, since we are only capable of returning
                    // one discrete state change to the caller.
                    // We'll get the next one next time around (hopefully).
                    //System.out.println("SWITCHING HORSES, BABY!");
                    currentNodeFraction.warp(currentNodeFraction.get()-1.); // i.e. change position without changing velocity
                    assert(currentNode.children.length == 1); // XXX for now
                    currentNodeIndex += currentNode.children[0]; // XXX should be preferred child index
                    currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
                    assert(returnVal == null); // there shouldn't be any other discrete change we're trying to return
                    returnVal = new ReturnValueOfIncrementViewTowardsOtherView(1, currentNode.itemOnEdgeFromParentToMe/*AFTER we change current node*/);
                }
            }
        }
        else
        {
            // Go up in the undo direction
            if (debug) System.out.println("    going in undo direction");
            currentNodeFraction.set(0.); // if it wasn't already
            if (!currentNodeFraction.isMoving())
            {
                if (debug) System.out.println("        already there, transitioning");
                returnVal = new ReturnValueOfIncrementViewTowardsOtherView(-1, currentNode.itemOnEdgeFromParentToMe/*BEFORE we change current node*/); // tell caller there was a discrete undo
                currentNodeIndex += currentNode.parent;
                currentNodeFraction.snap(1.);
                assert(currentNodeFraction.get() == 1.);
                currentNode = (Model.Node)model.nodes.get(currentNodeIndex);
                // In this case don't evolve... wait for next time around,
                // which will do something or other depending
                // on whether the new one is the target or not.
            }
            else
            {
                if (debug) System.out.println("        evolving "+currentNodeFraction.get()+" -> "+currentNodeFraction.getTarget()+"");
                double referenceTripFraction = referenceTripDistance/lengthizer.length(currentNode.itemOnEdgeFromParentToMe);
                currentNodeFraction.evolve(referenceTripFraction,
                                           referenceTripTime,
                                           dt,
                                           bounce);
            }

            //
            // Hack for beautiful smooth transition as we turn around.
            // If we are about to switch to redos when we hit the parent,
            // then set its preferred child *now* instead of when
            // we get to the parent.
            // (Usually the preferred child is always the branch we are in,
            // so this is nonstandard but I don't think anything depends
            // on that assumption.)
            // Then when the drawing code (actually the chooseNodePositions
            // utility function, down below in this file)
            // sees that the preferred child
            // isn't the one the current node is under,
            // it knows that this is happening and can reposition
            // the parent horizonally in proportion to how far
            // the child has gone so far.
            //
            if (currentNodeIndex != 0)
            {
                Model.Node parentNode = (Model.Node)model.nodes.get(currentNodeIndex+currentNode.parent);
                PrivateNodeInfo parentNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, parentNode);
                synchronized(otherView.privateNodeInfosHashtable) // XXX I'm positive this is the wrong thing
                {
                    PrivateNodeInfo parentNodeInfoInOtherView = (PrivateNodeInfo)otherView.privateNodeInfosHashtable.get(parentNode);
                    if (parentNodeInfoInOtherView == null
                     || parentNodeInfoInOtherView.preferredChildIndex == -1)
                        parentNodeInfo.preferredChildIndex = parentNode.children.length-1;
                    else
                        parentNodeInfo.preferredChildIndex = parentNodeInfoInOtherView.preferredChildIndex;
                }
            }
        }
        notifyListenersSomethingChanged(viewListeners);
        return returnVal;
    } // incrementViewTowardsOtherView

        // XXX this will be made easier and faster in the future,
        // XXX when I'll make each view mark its path
        // XXX from its current node to the root;
        // XXX then we won't have to walk up and down to the root
        // XXX each time.  (actually just marking each node with its depth
        // XXX would suffice-- that would be easy...
        // XXX although it might prevent some local pruning operations
        // XXX from being fast... hmm)
    private static int findLowestCommonAncestorIndex(int i0, int i1, com.donhatchsw.compat.ArrayList nodes)
    {
        // Do the common cases fast...
        if (i0 == i1)
            return i0;
        if (i0 != 0 && i0+((Model.Node)nodes.get(i0)).parent == i1)
            return i1;
        if (i1 != 0 && i1+((Model.Node)nodes.get(i1)).parent == i0)
            return i0;

        // No clue where they are with respect to each other.
        // Figure out the depths...
        int depth0 = 0;
        for (int i = i0; i > 0; i += ((Model.Node)nodes.get(i)).parent)
            depth0++;
        int depth1 = 0;
        for (int i = i1; i > 0; i += ((Model.Node)nodes.get(i)).parent)
            depth1++;

        // Walk up the deeper side til they are at common depth...
        while (depth0 > depth1)
        {
            i0 += ((Model.Node)nodes.get(i0)).parent;
            depth0--;
        }
        while (depth1 > depth0)
        {
            i1 += ((Model.Node)nodes.get(i1)).parent;
            depth1--;
        }
        // Then keep walking up til they are equal.
        while (i0 != i1)
        {
            i0 += ((Model.Node)nodes.get(i0)).parent;
            i1 += ((Model.Node)nodes.get(i1)).parent;
        }
        return i0;
    } // findLowestCommonAncestorIndex


        // This would get moved into Model if Model was to be made autonomous
        private static void notifyListenersSomethingChanged(com.donhatchsw.compat.ArrayList listeners)
        {
            synchronized(listeners)
            {
                for (int i = 0; i < listeners.size(); ++i)
                    ((Listener)listeners.get(i)).somethingChanged();
            }
        }

    /**
    * Installs a callback that will get called after
    * any change is made,
    * that is, when Do or setSharedLabel is called (by any view of the tree)
    * or when one of undo, redo, preferOlderChild, preferYoungerChild, setPrivateLabel
    * is called by this view of the tree.
    */
    public void addListener(Listener notifier)
    {
        synchronized(viewListeners)
        {
            viewListeners.remove(notifier); // should throw IllegalStateException
            viewListeners.add(notifier);
        }
    } // addListener
    /** Removes a callback that was previously installed with addListener(). */
    public void removeListener(Listener notifier)
    {
        synchronized(viewListeners)
        {
            viewListeners.remove(notifier);
        }
    } // removeListener


    public static class Snapshot
    {
        public int nNodes = -1;
        public int currentNode;
        public double currentNodeFraction;
        public int parents[] = null;
        public Object edgeItems[] = null;
        public Object sharedLabels[] = null;
        public Object privateLabels[] = null;
        public int preferredChild[] = null;
    } // Snapshot

    /** Take a snapshot of the undo tree, locking down the shared data structures for as short a time as possible. */
    public void takeSnapshot(Snapshot snapshot)
    {
        // Don't lock down while allocating,
        // just re-do the allocations if something changed,
        // which will almost never happen.
        // Note also, we do need to lock down even the private stuff
        // since other threads might be accessing it
        // (private here doesn't mean thread-local, it means
        // "view-local"-- it's all relative)
        while (true)
        {
            int nNodes = model.nodes.size();
            snapshot.nNodes = nNodes;
            if (snapshot.parents == null
             || snapshot.parents.length < nNodes)
                snapshot.parents = new int[nNodes];
            if (snapshot.edgeItems == null ||
                snapshot.edgeItems.length < nNodes)
                snapshot.edgeItems = new Object[nNodes];
            if (snapshot.sharedLabels == null ||
                snapshot.sharedLabels.length < nNodes)
                snapshot.sharedLabels = new String[nNodes];
            if (snapshot.privateLabels == null ||
                snapshot.privateLabels.length < nNodes)
                snapshot.privateLabels = new String[nNodes];
            if (snapshot.preferredChild == null ||
                snapshot.preferredChild.length < nNodes)
                snapshot.preferredChild = new int[nNodes];
            synchronized(model.nodes) // model.nodes.size can change while waiting for this lock... and our currentNodeIndex might change with it due to our listener being called
            {
                if (model.nodes.size() != nNodes)
                {
                    continue; // someone changed something! try allocations again
                }
                for (int iNode = 0; iNode < nNodes; ++iNode)
                {
                    Model.Node node = (Model.Node)model.nodes.get(iNode);
                    PrivateNodeInfo privateNodeInfo = (PrivateNodeInfo)privateNodeInfosHashtable.get(node);
                    snapshot.parents[iNode] = iNode + node.parent; // change relative to absolute
                    snapshot.edgeItems[iNode] = node.itemOnEdgeFromParentToMe;
                    snapshot.sharedLabels[iNode] = node.sharedLabel;

                    int preferredChildLocalIndex;
                    if (privateNodeInfo != null)
                    {
                        //System.out.println("CARED, "+iNode+" prefers "+(iNode + privateNodeInfo.preferredChildIndex));
                        snapshot.privateLabels[iNode] = privateNodeInfo.privateLabel;
                        preferredChildLocalIndex = privateNodeInfo.preferredChildIndex;
                        snapshot.preferredChild[iNode] = privateNodeInfo.preferredChildIndex==-1 ? -1 : iNode + privateNodeInfo.preferredChildIndex; // change relative to absolute
                    }
                    else
                    {
                        //System.out.println("DIDN'T CARE, "+iNode+" doesn't really prefer "+(iNode-1));
                        snapshot.privateLabels[iNode] = null;
                        preferredChildLocalIndex = -1;
                    }
                    if (preferredChildLocalIndex == -1)
                        preferredChildLocalIndex = node.children.length-1;
                    snapshot.preferredChild[iNode] = node.children.length == 0 ? -1 : iNode+node.children[preferredChildLocalIndex]; // change relative to absolute
                }
                snapshot.currentNode = currentNodeIndex;
                snapshot.currentNodeFraction = currentNodeFraction.get();
                break;
            } // synchronized(model.nodes)
        }
        // we could nicify it here if we want... perhaps putting in the children pointers as well, we're in no hurry any more
        assert(snapshot.currentNode >= 0);
        assert(snapshot.currentNode < snapshot.nNodes);
    } // takeSnapshot // takeSnapshot


    /**
    * Returns a string something like this if stretchOutAlongTimeLine is true:
    * <pre>
    *   +---------+
    *   |    0    |
    *   |    +-+  | A
    *   |    1 |  |
    *   |  +-+ |  | B
    *   |  2 | |  |
    *   |    | |  | C
    *   |    | 3  |
    *   |    |    | D
    *   |    4    |
    *   |    |    | E
    *   |   (5)   |
    *   +---------+
    * </pre>
    * and something like this if stretchOutAlongTimeLine is false:
    * <pre>
    *   +---------+
    *   |    0    |
    *   |    +-+  | A C
    *   |    1 3  |
    *   |  +-+    | B D
    *   |  2 4    |
    *   |    |    | E
    *   |   (5)   |
    *   +---------+
    * </pre>
    * These were created by executing the following commands:
    * <pre>
    *   UndoTree tree = new UndoTree();
    *   tree.Do("A");
    *   tree.Do("B");
    *   tree.undo();
    *   tree.undo();
    *   tree.Do("C");
    *   tree.undo();
    *   tree.preferYoungerChild();
    *   tree.redo();
    *   tree.Do("D");
    *   tree.Do("E");
    *   System.out.println(tree.toStringVisualCool(true));
    *   System.out.println(tree.toStringVisualCool(false));
    * </pre>
    */
    // TODO: compactify even more if it gets bushy then stringy then bushy, the lower bush can go under the upper bush
    public String toStringVisualCool(boolean stretchOutAlongTimeLine)
    {
        // XXX should use chooseNodePositions instead of this code
        // FROM ABOUT HERE ==============================================

        int nNodes = model.nodes.size();
        //
        // Bottom up, figure out the number of leaves
        // under the node.  That will be the logical width
        // allotted to this node.
        // 
        int widths[] = new int[nNodes]; // zeros
        for (int iNode = nNodes-1; iNode >= 0; iNode--)
        {
            Model.Node node = (Model.Node)model.nodes.get(iNode);
            for (int iChild = 0; iChild < node.children.length; ++iChild)
            {
                int childIndex = iNode + node.children[iChild];
                widths[iNode] += widths[childIndex];
            }
            if (widths[iNode] == 0)
                widths[iNode] = 1; // leaf
        }


        //
        // Top down, figure out the left and right logical bounds allotted to
        // each node.  Parent decides for each child.
        //
        int xstarts[] = new int[nNodes];
        xstarts[0] = 0;
        for (int iNode = 0; iNode < nNodes; iNode++)
        {
            Model.Node node = (Model.Node)model.nodes.get(iNode);
            int childStart = xstarts[iNode];
            for (int iChild = 0; iChild < node.children.length; ++iChild)
            {
                int childIndex = iNode + node.children[iChild];
                xstarts[childIndex] = childStart;
                childStart += widths[childIndex];
            }
        }
        //
        // Bottom up, decide the x position within the node's bounds
        // that we will display the node.  We want to display it
        // directly over its preferred child.
        // These are physical, not logical any more.
        //
        int x[] = new int[nNodes];
        for (int iNode = nNodes-1; iNode >= 0; iNode--)
        {
            Model.Node node = (Model.Node)model.nodes.get(iNode);
            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node); // XXX shouldn't make it if it doesn't exist, that's lame
            if (node.children.length == 0)
            {
                x[iNode] = 2*xstarts[iNode]+1;
            }
            else
            {
                int preferredChildIndex = privateNodeInfo.preferredChildIndex;
                if (preferredChildIndex == -1)
                    preferredChildIndex = node.children.length-1;
                x[iNode] = x[iNode + node.children[preferredChildIndex]];
            }
        }
        // TO ABOUT HERE ==============================================

        int possibleEdgeLengths[] = {3,4,6};
        int edgeLengths[] = new int[nNodes];
        for (int iNode = 0; iNode < nNodes; ++iNode)
            edgeLengths[iNode] = possibleEdgeLengths[(int)(Math.random()*possibleEdgeLengths.length)];

        int y[] = new int[nNodes];
        //
        // Decide the y position
        // where we will display the node.
        //
        if (stretchOutAlongTimeLine)
        {
            // Easy!
            for (int iNode = 0; iNode < nNodes; ++iNode)
                y[iNode] = 2*iNode;
        }
        else
        {
            //
            // Top down, put each child at a level
            // just below its parent.
            // (Well leave one line between them for the edge.)
            //
            y[0] = 0;
            for (int iNode = 0; iNode < nNodes; iNode++)
            {
                Model.Node node = (Model.Node)model.nodes.get(iNode);
                int childStart = xstarts[iNode];
                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    y[childIndex] = y[iNode] + 2;
                }
            }
        }

        int maxy = 0;
        for (int iNode = 0; iNode < nNodes; iNode++)
            maxy = Math.max(maxy, y[iNode]);

        char buf[][] = new char[maxy+1][1 + 2*widths[0]];
        for (int i = 0; i < buf.length; ++i)
        for (int j = 0; j < buf[i].length; ++j)
            buf[i][j] = ' ';

        //
        // Top down or bottom up, it doesn't matter,
        // draw the stuff into the rectangular buffer.
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            Model.Node node = (Model.Node)model.nodes.get(iNode);
            buf[y[iNode]][x[iNode]] = (char)('0'+(iNode%10)); // XXX just last digit for now
            if (iNode == currentNodeIndex)
            {
                buf[y[iNode]][x[iNode]-1] = '('; // XXX argh, index out of bounds
                buf[y[iNode]][x[iNode]+1] = ')';
            }
            if (node.children.length > 0)
            {
                if (node.children.length >= 1)
                {
                    int firstChildX = x[iNode+node.children[0]];
                    int lastChildX = x[iNode+node.children[node.children.length-1]];
                    for (int i = firstChildX; i <= lastChildX; ++i)
                        buf[y[iNode]+1][i] = '-';
                }

                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    buf[y[iNode]+1][x[childIndex]] = node.children.length==1 ? '|' : '+';
                    for (int j = y[iNode]+2; j < y[childIndex]; ++j)
                        buf[j][x[childIndex]] = '|';
                }
            }
        }

        //
        // Put annotations into the annotation buffer.
        //
        StringBuffer annotations[] = new StringBuffer[buf.length];
        for (int i = 0; i < annotations.length; ++i)
            annotations[i] = new StringBuffer();
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            Model.Node node = (Model.Node)model.nodes.get(iNode);
            if (iNode != 0)
            {
                annotations[y[iNode]-1].append(" "+node.itemOnEdgeFromParentToMe);
            }
            if (node.sharedLabel != null)
                annotations[y[iNode]].append(" sharedLabel="+Arrays.toStringCompact(node.sharedLabel));
            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node); // XXX shouldn't make it if it doesn't exist, that's lame
            if (privateNodeInfo.privateLabel != null)
                annotations[y[iNode]].append(" privateLabel="+Arrays.toStringCompact(privateNodeInfo.privateLabel));
        }


        //
        // Put the rectangular buffer on the left,
        // with annotations on the right, into a StringBuffer
        // in preparation for final output.
        //
        String nl = System.getProperty("line.separator");
        StringBuffer sb = new StringBuffer();

        sb.append("+"+repeat("-", buf[0].length+2)+"+"+nl);

        for (int i = 0; i < buf.length; ++i)
        {
            sb.append("| ");
            sb.append(buf[i]);
            sb.append(" |" );
            sb.append(annotations[i]);
            sb.append(nl);
        }
        sb.append("+"+repeat("-", buf[0].length+2)+"+"); // no nl
        return sb.toString();
    } // toStringVisualCool


    /** Static utility function for choosing a nice graphical layout, given the treee relation and edge lengths. The root node will be at y=0, with other y positions depending on the given edge lengths (if stretchOutAlongTimeLine is true, the y position will be the sum of the edge lengths that preceded this node in time; otherwise it will be the sum of the edge lengths from the root to this node).  The x positions will be integers from 0 to number of leaf nodes minus 1: each node will have the same x position as the leaf that would be reached by following its preferred children. */
    // XXX see if I can leverage this in toStringVisualCool?  currently it duplicates this code I think
    public static void chooseNodePositions(int nNodes,
                                           int parents[],
                                           int preferredChild[],
                                           double edgeLengths[],
                                           int currentNodeIndex,
                                           double currentNodeFrac,
                                           double stretchOutAlongTimeLine,
                                           double x[], // output
                                           double y[]) // output
    {
        //
        // Fill in firstChild,nextSibling array so we
        // Fill in a nextSibling array so we can easily traverse top-down
        // as well as bottom-up.
        //
        int firstChild[] = new int[nNodes];
        int nextSibling[] = new int[nNodes];
        for (int iNode = 0; iNode < nNodes; ++iNode)
            firstChild[iNode] = -1;
        for (int iChild = nNodes-1; iChild >= 0; iChild--)
        {
            int iParent = parents[iChild];
            if (iParent != -1)
            {
                nextSibling[iChild] = firstChild[iParent];
                firstChild[iParent] = iChild;
            }
            else
                nextSibling[iChild] = -1;
        }

        //
        // Bottom up, figure out the number of leaves
        // under the node.  That will be the logical width
        // allotted to this node.
        // 
        int widths[] = new int[nNodes]; // zeros
        for (int iChild = nNodes-1; iChild >= 0; iChild--)
        {
            if (firstChild[iChild] == -1)
                widths[iChild] = 1;
            if (parents[iChild] != -1)
                widths[parents[iChild]] += widths[iChild];
        }


        //
        // Top down, figure out the left and right logical bounds allotted to
        // each node.  Parent decides for each child.
        //
        int xstarts[] = new int[nNodes];
        xstarts[0] = 0;
        for (int iParent = 0; iParent < nNodes; iParent++)
        {
            int childStart = xstarts[iParent];
            for (int iChild = firstChild[iParent]; iChild != -1; iChild = nextSibling[iChild])
            {
                xstarts[iChild] = childStart;
                childStart += widths[iChild];
            }
        }

        //
        // Bottom up, decide the x position within the node's bounds
        // that we will display the node.  We want to display it
        // directly over its preferred child.
        //
        // SPECIAL CASE:
        //     If we get to the parent of currentNode
        //     and its preferred child is *not* currentNode,
        //     we know currentNode is moving towards
        //     the new preferred child, in which case linearly
        //     interpolate the parent's horizontal position
        //     between the old and new preferred child.
        //
        for (int iChild = nNodes-1; iChild >= 0; iChild--)
        {
            if (firstChild[iChild] == -1)
                x[iChild] = (double)xstarts[iChild];

            if (iChild == parents[currentNodeIndex]
             && preferredChild[iChild] != currentNodeIndex)
            {
                // the SPECIAL CASE described above
                if (false)
                {
                    OUT("SPECIAL CASE");
                    PRINT(x.length);
                    PRINT(iChild);
                    PRINT(currentNodeIndex);
                }
                x[iChild] = LERP(x[currentNodeIndex], x[iChild], 1.-currentNodeFrac);
            }

            int iParent = parents[iChild];
            if (iParent != -1)
            {
                if (preferredChild[iParent] == iChild)
                    x[iParent] = x[iChild];
            }
        }

        //
        // Decide the y position
        // where we will display the node.
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            if (parents[iNode] == -1)
                y[iNode] = 0;
            else
                y[iNode] = LERP(y[parents[iNode]], y[iNode-1], stretchOutAlongTimeLine) + edgeLengths[iNode];
        }
    } // chooseNodePositions




    /*
        XXX no this isn't right, we use relative offsets now
        Example:
            {"oh boy a puzzle!" 0 A 1 B "just did B" 2 C
                                    1 D 4 E 5 F
                                                     2 G
                                        4 H "oh boy I solved it"}
        Compact would be:
            {"oh boy a puzzle!" A B "just did B" C u D E F u2 G u3 H I "oh boy I solved it"}
    */

    public interface ItemToString
    {
        public String regex();
        public String itemToString(Object item);
    }
    public interface ItemFromString
    {
        public String regex();
        public Object itemFromString(String s);
    }
    /**
    * Returns a string something like this:
    * <pre>
    *   { A B (0) u2 C (you are here) u2 D E }
    * </pre>
    * You tell it how to stringify the individual items
    * by passing in an itemToString functor, and a regex that describes
    * what an item string can look like.
    * The result can be turned back into another UndoTree
    * by calling fromString(), so this is suitable for a save/load
    * mechanism.
    * <p>
    * Note that the tokens "u", "u2", "u3" etc. are used
    * to signify branching.  Your individual item regex is not allowed
    * to accept any of these strings (since if it did, it would be
    * impossible to tell whether "u" denoted an item or a branch indicator).
    * <p>
    * Similarly, the tokens "(0)", "(1)", etc. are used to signify
    * the preferred child of a given position (i.e. which edge
    * will be followed by a redo from that position).
    * Your individual item regex is not allowed to accept these either.
    * <p>
    * XXX More salient example coming soon.
    */
    public String toString(ItemToString itemToString,
                           String indentSpaces,
                           String separatorSpaces) // hmm, I guess itemToString isn't needed, it could just use the item's toString... but then where do we get the regex from?
    {
        System.out.println("in UndoTree.toString");
        if (!regex.matches(indentSpaces, "\\s*"))
            throw new IllegalArgumentException("UndoTree.toString given indent string "+Arrays.toStringCompact(indentSpaces)+", should be zero or more spaces");
        if (!regex.matches(separatorSpaces, "\\s+"))
            throw new IllegalArgumentException("UndoTree.toString given separator string "+Arrays.toStringCompact(separatorSpaces)+", should be one or more spaces");
        String itemRegex = itemToString.regex();
        regex.Matcher itemMatcher = regex.Pattern.compile(itemRegex).matcher("dummy");
        // XXX dup code in the other place, should combine
        if (itemMatcher.reset("").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches the empty string, that's messed up!");
        if (itemMatcher.reset("u").matches()
         || itemMatcher.reset("u1").matches()
         || itemMatcher.reset("u10").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches something starting with \"u\", can't do that because it's special!");
        if (itemMatcher.reset("(0)").matches()
         || itemMatcher.reset("(1)").matches()
         || itemMatcher.reset("(10)").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches a parenthesized number something like (2), can't do that because it's special!");

        StringBuffer sb = new StringBuffer();
        sb.append("{");
        sb.append(separatorSpaces);
        int nNodes = model.nodes.size();
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            sb.append(indentSpaces);
            Model.Node node = (Model.Node)model.nodes.get(iNode);
            if (iNode != 0)
            {
                String itemString = itemToString.itemToString(node.itemOnEdgeFromParentToMe);
                if (!itemMatcher.reset(itemString).matches())
                {
                    throw new IllegalArgumentException("UndoTree.toString given itemToString functor that produced string "+Arrays.toStringCompact(itemString)+" which does not match its regex pattern "+itemRegex+"!");
                }
                if (node.parent == -1)
                    ; // nothing, this is the default
                else if (node.parent == -2)
                    sb.append("u ");
                else  // -3 -> 2, -4 -> 3, etc.
                    sb.append("u").append(-node.parent-1).append(" ");
                sb.append(itemString).append(" ");
            }

            PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, node);
            // If printing private label and there's no shared label,
            // print "null" for the shared label

            if (node.sharedLabel != null
             || privateNodeInfo.privateLabel != null)
                sb.append(Arrays.toStringCompact(node.sharedLabel!=null ? node.sharedLabel.toString() : "null")+" ");
            if (privateNodeInfo.privateLabel != null)
                sb.append(Arrays.toStringCompact(privateNodeInfo.privateLabel).toString()+" ");
            if (iNode == currentNodeIndex)
                sb.append("(you are here) ");
            if (privateNodeInfo.preferredChildIndex != -1
             && node.children.length > 1) // XXX a little odd... can go from having a preference of the single child, to having no preference which means can be overridden by someone else making a child... think about this.  it's only an issue if collabarative editing
                sb.append("("+privateNodeInfo.preferredChildIndex+") ");
            while (" \r\n".indexOf(sb.charAt(sb.length()-1)) != -1) // XXX lame test!
                sb.deleteCharAt(sb.length()-1);
            sb.append(separatorSpaces);
        }
        sb.append("}");
        String s = sb.toString();
        System.out.println("out UndoTree.toString");
        return s;
    } // toString

    /** Parses a string that was created by toString(). */
    public static UndoTree fromString(String s, ItemFromString itemFromString)
    {
        String itemRegex = itemFromString.regex();
        regex.Matcher itemMatcher = regex.Pattern.compile(itemRegex).matcher("dummy");
        // XXX dup code in the other place, should combine
        if (itemMatcher.reset("").matches())
            throw new IllegalArgumentException("UndoTree.fromString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches the empty string, that's messed up!");
        if (itemMatcher.reset("u").matches()
         || itemMatcher.reset("u1").matches()
         || itemMatcher.reset("u10").matches())
            throw new IllegalArgumentException("UndoTree.fromString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches something starting with \"u\", can't do that because it's special!");
        if (itemMatcher.reset("(0)").matches()
         || itemMatcher.reset("(1)").matches()
         || itemMatcher.reset("(10)").matches())
            throw new IllegalArgumentException("UndoTree.toString given item regex "+Arrays.toStringCompact(itemRegex)+" which matches a parenthesized number something like (2), can't do that because it's special!");

        regex.Matcher doubleQuotedStringMatcher = regex.Pattern.compile(
            "\"((\\\\|.)*)\""
        ).matcher("dummy");

        // XXX maybe should retain original s for error messages
        s = s.trim();
        if (s.length() < 2
         || s.charAt(0) != '{'
         || s.charAt(s.length()-1) != '}')
            throw new IllegalArgumentException("UndoTree.fromStringCompact called on string not surrounded by '{'");
        s = s.substring(1, s.length()-1).trim();

        String words[];
        {
            if (true)
            {
                // Brain dead way... works if there are no spaces at all
                // in the items or labels
                words = regex.split(s, "\\s+");
            }
            else
            {
                com.donhatchsw.compat.ArrayList/*<String>*/ wordsVector = new com.donhatchsw.compat.ArrayList();
                unimplemented(); // XXX implement me!
                words = new String[wordsVector.size()];
                wordsVector.toArray(words);
            }
        }

        // XXX ARGH! should save and restore Do times! for now, when reading back in, just label everything with the read-back-in time
        long currentTimeMillis = System.currentTimeMillis();

        // We'll stick these in the created undoTree when we
        // create it at the end
        int currentNodeIndex = -1;
        java.util.Hashtable/*<node, PrivateNodeInfo>*/ privateNodeInfosHashtable = new java.util.Hashtable();

        Model.Node nodes[] = new Model.Node[Math.max(words.length,1)]; // at most this many
        com.donhatchsw.compat.ArrayList/*Model.Node*/ childrens[] = new com.donhatchsw.compat.ArrayList[nodes.length];

        int nNodes = 0;
        nodes[nNodes++] = new Model.Node(-1, null, currentTimeMillis);
        childrens[nNodes-1] = new com.donhatchsw.compat.ArrayList();

        int iWord = 0;
        while (iWord < words.length)
        {
            //
            // optional quoted shared label for this node... or "null"
            // (without the quotes)
            //
            if (words[iWord].equals("null"))
            {
                // just leave it null... this is a placeholder
                // because there's a private label coming
                iWord++;
            }
            else if (doubleQuotedStringMatcher.reset(words[iWord]).matches())
            {
                nodes[nNodes-1].sharedLabel = words[iWord].substring(1,words[iWord].length()-1); // XXX need to unescapify!
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional quoted private label for this node
            //
            if (doubleQuotedStringMatcher.reset(words[iWord]).matches())
            {
                PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, nodes[nNodes-1]);
                privateNodeInfo.privateLabel = words[iWord].substring(1,words[iWord].length()-1); // XXX need to unescapify!
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional (you are here) for this node
            //
            if (words[iWord].equals("(you are here)")
             || (iWord+2 < words.length // XXX this is only needed if doing the brain dead word tokenizing
              && words[iWord].equals("(you")
              && words[iWord+1].equals("are")
              && words[iWord+2].equals("here)")))
            {
                if (currentNodeIndex != -1)
                    throw new IllegalArgumentException("UndoTree.fromString given an undo tree with more than one current node!");
                currentNodeIndex = nNodes-1;
                if (words[iWord].equals("(you"))
                    iWord += 2;
                iWord++;
            }
            if (iWord == words.length) break;
            //
            // optional parenthesized (<preferredChild>) for this node
            //
            if (regex.matches(words[iWord], "\\(-?\\d+\\)"))
            {
                PrivateNodeInfo privateNodeInfo = getOrMakePrivateNodeInfo(privateNodeInfosHashtable, nodes[nNodes-1]);
                privateNodeInfo.preferredChildIndex = Integer.parseInt(words[iWord].substring(1,words[iWord].length()-1));
                // XXX should bounds check, but have to do that at the end!
                iWord++;
            }
            if (iWord == words.length) break;

            //
            // Not at the end of the input, so there's another node
            //
            nodes[nNodes++] = new Model.Node(-1, null, currentTimeMillis);
            childrens[nNodes-1] = new com.donhatchsw.compat.ArrayList();

            //
            // optional parent offset...
            //      nothing means -1
            //      "u" means -2
            //      "u2" means -3
            // etc.
            //
            if (words[iWord].matches("u\\d*")) // XXX precompile!
            {
                int parentOffset = -1 - 
                    (words[iWord].equals("u") ? 1 :
                                Integer.parseInt(words[iWord].substring(1)));
                if (nNodes-1+parentOffset < 0) // e.g. node 3 can have offset at most 2, which makes its parent node 0
                    throw new IllegalArgumentException("UndoTree.fromString node "+(nNodes-1)+"'s parent offset is "+parentOffset+", which would put the parent at "+(nNodes-1+parentOffset)+"");
                nodes[nNodes-1].parent = parentOffset;
                int parentIndex = nNodes-1+parentOffset;
                iWord++;
            }
            childrens[nNodes-1 + nodes[nNodes-1].parent].add(new Integer(-nodes[nNodes-1].parent));

            if (iWord == words.length)
                throw new IllegalArgumentException("UndoTree.fromString premature end of input trying to read item at word "+iWord+"");

            //
            // required item from regex
            //
            if (itemMatcher.reset(words[iWord]).matches())
            {
                Object item = itemFromString.itemFromString(words[iWord]);
                nodes[nNodes-1].itemOnEdgeFromParentToMe = item;
                iWord++;
            }
            else
            {
                PRINT(words[iWord]);
                throw new IllegalArgumentException("UndoTree.fromString expected item at word "+iWord+" but got "+Arrays.toStringCompact(words[iWord])+" which does not match regex "+Arrays.toStringCompact(itemRegex)+"");
            }
        } // while (iWord < words.length)

        if (currentNodeIndex == -1)
            throw new IllegalArgumentException("UndoTree.fromString given an undo tree with no current node!");

        //
        // Now go through and hang each child on each parent,
        // and verify that its preferred child index is in bounds
        //
        for (int iNode = 0; iNode < nNodes; ++iNode)
        {
            nodes[iNode].children = new int[childrens[iNode].size()];
            for (int iChild = 0; iChild < nodes[iNode].children.length; ++iChild)
            {
                nodes[iNode].children[iChild] = ((Integer)childrens[iNode].get(iChild)).intValue();
            }
            PrivateNodeInfo privateNodeInfo = (PrivateNodeInfo)privateNodeInfosHashtable.get(nodes[iNode]);
            if (privateNodeInfo != null
             && (privateNodeInfo.preferredChildIndex < -1 // -1 is always okay
              || privateNodeInfo.preferredChildIndex >= nodes[iNode].children.length))
            {
                throw new IllegalArgumentException("UndoTree.fromString node "+iNode+"'s preferred child is "+privateNodeInfo.preferredChildIndex+" but only has "+nodes[iNode].children.length+" children!");
            }
        }

        UndoTree undoTree = new UndoTree(null);
        undoTree.currentNodeIndex = currentNodeIndex;
        undoTree.privateNodeInfosHashtable = privateNodeInfosHashtable;
        undoTree.model.nodes = new com.donhatchsw.compat.ArrayList(nNodes);
        for (int iNode = 0; iNode < nNodes; ++iNode)
            undoTree.model.nodes.add(nodes[iNode]);

        undoTree.checkSane();

        return undoTree;
    } // fromString


        private void checkSane()
        {
            for (int iNode = 0; iNode < model.nodes.size(); ++iNode)
            {
                Model.Node node = (Model.Node)model.nodes.get(iNode);
                for (int iChild = 0; iChild < node.children.length; ++iChild)
                {
                    int childIndex = iNode + node.children[iChild];
                    Model.Node child = (Model.Node)model.nodes.get(childIndex);
                    //System.out.println(""+iNode+"->"+childIndex);
                    assert(childIndex+child.parent == iNode);
                }
            }
        }

        private static String repeat(String s, int n)
        {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < n; ++i)
                sb.append(s);
            return sb.toString();
        }


    /** Test/example program. */
    public static void main(String args[])
    {
        System.out.println("in main");
        UndoTree tree = new UndoTree();
        tree.Do("A");
        tree.Do("B");
        tree.setPrivateLabel("private_before_fork");
        tree.undo();
        tree.undo();
        tree.Do("C");
        tree.setPrivateLabel("shared_before_fork");
        tree.undo();
        tree.preferYoungerChild();
        tree.redo();
        tree.Do("D");
        tree.Do("E");
        UndoTree tree0 = tree;
        UndoTree tree1 = new UndoTree(tree);
        tree0.Do("F0");
        tree1.Do("G1");
        tree0.Do("H0");
        tree0.setPrivateLabel("0_private_after_fork");
        tree1.setPrivateLabel("1_private_after_fork");
        tree0.setSharedLabel("0_shared_after_fork");
        tree1.setSharedLabel("1_shared_after_fork");
        System.out.println("Tree 0:");
        System.out.println(tree0.toStringVisualCool(true));
        System.out.println(tree0.toStringVisualCool(false));
        System.out.println("Tree 1:");
        System.out.println(tree1.toStringVisualCool(true));
        System.out.println(tree1.toStringVisualCool(false));



        UndoTree.ItemToString itemToString = new UndoTree.ItemToString(){
            public String regex()
            {
                //return "-?\\d+"; // ints
                if (false)
                    return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                else
                    return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public String itemToString(Object obj)
            {
                // is this method necessary? could just take the regex
                //return obj.toString(); // ints
                return obj.toString(); // identifiers too
            }
        };
        UndoTree.ItemFromString itemFromString = new UndoTree.ItemFromString(){
            public String regex()
            {
                // return "-?\\d+"; // ints
                if (false)
                    return "[.0-9_a-zA-Z]+"; // make sure this gets rejected because it accepts 'u'
                else
                    return "[.0-9_a-tv-zA-Z]+"; // identifiers and numbers and stuff... but can't start with a 'u'!
            }
            public Object itemFromString(String s)
            {
                //return Integer.valueOf(s); // ints
                return s; // identifiers
            }
        };
        //String indentSpaces = "    ";
        //String separatorSpaces = System.getProperty("line.separator");
        String indentSpaces = "";
        String separatorSpaces = " ";

        String s0 = tree0.toString(itemToString, indentSpaces, separatorSpaces);
        String s1 = tree1.toString(itemToString, indentSpaces, separatorSpaces);

        UndoTree t0 = UndoTree.fromString(s0, itemFromString);
        UndoTree t1 = UndoTree.fromString(s1, itemFromString);

        String u0 = t0.toString(itemToString, indentSpaces, separatorSpaces);
        String u1 = t1.toString(itemToString, indentSpaces, separatorSpaces);
        PRINT(s0);
        PRINT(u0);
        assert(u0.equals(s0));
        assert(u1.equals(s1));

        // XXX maybe should compare the visualcools too?
    } // main
} // class UndoTree
