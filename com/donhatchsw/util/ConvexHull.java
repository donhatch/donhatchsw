// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// !!! THIS FILE WAS AUTOMATICALLY GENERATED BY javacpp; DO NOT EDIT !!!
// 102 # 1 "com/donhatchsw/util/ConvexHull.prejava"
// 103 # 1 "<built-in>"
// 104 # 1 "<command-line>"
// 105 # 1 "com/donhatchsw/util/ConvexHull.prejava"
/* vim: set filetype=java: */
// 107 # 1 "com/donhatchsw/util/macros.h" 1
//
// macros.h
//
// 111 # 14 "com/donhatchsw/util/macros.h"
// NOTE: this causes a,b to be evaluated twice on failure, so is not ideal. might be better to do a block... ?
// 113 # 30 "com/donhatchsw/util/macros.h"
// Note: the additional "(a)==(b)||" is to make it work correctly for infinities...
// and causes the args to be evaluated twice.
// 116 # 67 "com/donhatchsw/util/macros.h"
// XXX ... what a mess
// 118 # 3 "com/donhatchsw/util/ConvexHull.prejava" 2
package com.donhatchsw.util;
/**
* http://www.cse.unsw.edu.au/~lambert/java/3d/quickhull.html
*/
import com.donhatchsw.compat.ArrayList;
import com.donhatchsw.compat.IntArrayList;
import com.donhatchsw.compat.DoubleArrayList;

public class ConvexHull
{
    private ConvexHull() {} // uninstantiatable

    /**
    * Caller can set this for debugging, although it's not thread-safe.
    * 0: nothing, 1: function in/out, 2: phases, 3: detail
    */
    public static int debugLevel = 0;

    /**
    * Computes the convex hull in d dimensions,
    * using the QuickHull algorithm
    * (i.e. the incremental algorithm, but always
    * choosing the next point farthest from the current hull).
    * Returns three lists: a list of (d-1)-dimensional simplices
    * (each consisting of d vert indices),
    * a list of adjacencies among them
    * (each consisting of d facet indices),
    * and a list of back-indices
    * (each consisting of the d indices where the facet occurs
    * in each of its neighbors' neighbors list).
    * <p>
    * For example, if the input is a triangle in two dimensions,
    * given in CCW order, then the output will be:
    * <pre>
    *     {{{0,1},{1,2},{2,0}},  // the facets themselves
    *      {{1,2},{2,0},{0,1}},  // e.g. the first 0 says facet 1's neighbor opposite vertex 2 is facet 0
    *      {{1,0},{1,0},{1,0}}}  // and the 0 below it says facet 1 occurs at index 0 in facet 0's neighbors
    * </pre>
    * <p>
    * WARNING: no attempt is made to correct topological faults.
    * WARNING: assumes general position.  It'll work otherwise only if you're lucky.
    */
    public static int[/*3*/][][/*d*/] convexHull(double verts[][/*d*/],
                                                 double tol)
    {
        if (debugLevel >= 1)
        {
            System.out.println("    in convexHull");
            System.out.println("        " + "verts" + " = " + VecMath.toString(verts));
            {System.out.print("        "); System.out.println("tol" + " = " + (tol));};
        }
        int nVerts = verts.length;
        if (nVerts == 0)
        {
            if (debugLevel >= 1)
                System.out.println("    out convexHull (nVerts==0, returning new int[2][0][])");
            return new int[3][0][];
        }
        int d = verts[0].length;
        if (d == 0)
        {
            if (debugLevel >= 1)
                System.out.println("    out convexHull (d==0, returning new int[2][0][d])");
            return new int[3][0][d]; // not sure what the hell's going on here
        }
        if (d == 1)
        {
            // In this case expressing the sidedness of a facet
            // is problematic.  So just do it the trivial way,
            // returning the lowest and highest vertex.
            int iVertMin = 0;
            int iVertMax = 0;
            for (int iVert = 1; iVert < nVerts; ++iVert) // skip 0
            {
                if (verts[iVert][0] < verts[iVertMin][0]) // < so prefer first index
                    iVertMin = iVert;
                if (verts[iVert][0] >= verts[iVertMax][0]) // >= so prefer last index
                    iVertMax = iVert;
            }
            int answer[][][] = new int[][][] {
                {{iVertMin},{iVertMax}},
                {{1},{0}}, // neighbor of facet 0 is facet 1 and vice versa
                {{0},{0}}, // only choice for back index is 0
            };
            if (debugLevel >= 1)
            {
                System.out.println("        " + "answer" + " = " + VecMath.toString(answer));
                System.out.println("    out convexHull (d==1, returning lowest and highest vertex)");
            }
            return answer;
        }

        if (nVerts < d)
        {
            if (debugLevel >= 1) System.out.println("    out convexHull (nVerts<d, returning new int[2][0][d])");
            return new int[3][0][d]; // not enough vertices to make a facet out of
        }

        do { if (!(nVerts >= d && d >= 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+101 +"): " + "nVerts >= d && d >= 2" + ""); } while (false);

        if (debugLevel >= 2) System.out.println("        choosing a non-degenerate (d-1)-dimensional simplex");

        // Start with any non-degenerate (d-1)-dimensional simplex
        // (if there is any).
        // (The paper starts with a d-dimensional simplex
        // but I don't see advantage of that.)

        int firstHullFacet[] = VecMath.fillvec(d, -1);
        double biggestContentSquared = -1.;
        for (int i = 0; (i) < (d); ++i)
        {
            if (i == 0)
            {
                firstHullFacet[i] = 0;
                biggestContentSquared = 1.;
            }
            else
            {
                int bestVert = -1;
                biggestContentSquared = -1.;
                for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                {
                    if (debugLevel >= 2) System.out.println("            considering vert "+iVert);

                    if (Arrays.indexOf(i, firstHullFacet, iVert) != -1)
                    {
                        if (debugLevel >= 2) System.out.println("                (already on facet)");
                        continue; // this vertex is already on the facet
                    }
                    firstHullFacet[i] = iVert; // speculatively
                    double thisContentSquared = calcParallelotopeContentSquared(verts,
                                                                                firstHullFacet,
                                                                                i+1);
                    //PRINT(thisContentSquared);
                    do { if (!(thisContentSquared >= 0.)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+137 +"): " + "thisContentSquared >= 0." + ""); } while (false);
                    if (thisContentSquared > biggestContentSquared)
                    {
                        biggestContentSquared = thisContentSquared;
                        bestVert = iVert;
                    }
                }
                do { if (!(bestVert != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+144 +"): " + "bestVert != -1" + ""); } while (false);
                firstHullFacet[i] = bestVert;
            }
            if (debugLevel >= 3)
                System.out.println("            "+firstHullFacet[i]);
        }
        if (debugLevel >= 2) System.out.println("        " + "firstHullFacet" + " = " + Arrays.toStringCompact(firstHullFacet));
        double firstFacetUnsignedArea = Math.sqrt(biggestContentSquared);
        if (firstFacetUnsignedArea <= Math.pow(tol, d-1))
        {
            if (debugLevel >= 1) System.out.println("    out convexHull (firstFacetUnsignedArea = "+firstFacetUnsignedArea+" <= tol ^ d-1, returning empty)");
            return new int[3][0][d]; // XXX throw?
        }
        double firstFacetUnitNormal[] = calcUnitNormal(verts, firstHullFacet);
        VecMath.normalize(firstFacetUnitNormal, firstFacetUnitNormal);

        // Second hull facet is opposite of first
        int secondHullFacet[] = VecMath.copyvec(firstHullFacet);
        Arrays.swap(secondHullFacet, 0, secondHullFacet, 1);


        // As long as result so far is coplanar,
        // we need to symbolically perturb each new vertex
        // out of that plane,
        // so that it appears to be on a consistent side
        // of what's been seen so far.
        double symbolicPerturbation[] = firstFacetUnitNormal;

        if (debugLevel >= 2) System.out.println("        initializing queue");

        IndexBinaryHeapKeyed queue = new IndexBinaryHeapKeyed(nVerts);

        IntArrayList vertsAboveOrOnFirstHullFacetPlane = new IntArrayList();
        IntArrayList vertsBelowFirstHullFacetPlane = new IntArrayList();

        // use knowledge of how second facet was constructed from first...
        int firstAndSecondFacetNeighborsIndexOfMe[] = VecMath.identityperm(d);
        firstAndSecondFacetNeighborsIndexOfMe[0] = 1;
        firstAndSecondFacetNeighborsIndexOfMe[1] = 0;


        Facet firstHullFacetStruct = new Facet(firstHullFacet,
                                               firstFacetUnitNormal,
                                               vertsAboveOrOnFirstHullFacetPlane,
                                               new Facet[d], // neighbors to be filled in momentarily
                                               firstAndSecondFacetNeighborsIndexOfMe);
        Facet secondHullFacetStruct = new Facet(secondHullFacet,
                                                VecMath.sxv(-1., firstFacetUnitNormal),
                                                vertsBelowFirstHullFacetPlane,
                                                new Facet[d], // neighbors to be filled in momentarily
                                                firstAndSecondFacetNeighborsIndexOfMe);
        Arrays.fill(firstHullFacetStruct.neighbors, secondHullFacetStruct); // all neighbors of [0] are [1]
        Arrays.fill(secondHullFacetStruct.neighbors, firstHullFacetStruct); // all neighbors of [1] are [0]

        FacetArrayList hullFacets = new FacetArrayList();
        hullFacets.add(firstHullFacetStruct);
        hullFacets.add(secondHullFacetStruct);

        Facet hoveringVertToFacet[] = new Facet[nVerts]; // all null initially

        double scratchVec[] = new double[d];
        for (int iVert = 0; (iVert) < (nVerts); ++iVert)
        {
            if (debugLevel >= 3) System.out.println("            considering vert "+iVert+"/"+nVerts+" for possible addition to queue");
            // QUADRATIC ALERT if first facet has a lot of verts. Use alternate data structure?
            if (Arrays.indexOf(firstHullFacet, iVert) != -1)
            {
                if (debugLevel >= 3) System.out.println("                (already part of first facet of hull)");
                continue; // this vertex is already part of the hull
            }

            VecMath.vmv(scratchVec, verts[iVert], verts[firstHullFacet[0]]);
            double height = VecMath.dot(firstFacetUnitNormal, scratchVec);
            double perturbedHeight = height;

            if (symbolicPerturbation != null)
            {
                if (!((((height)-(0.)) <= (tol)) && (((0.)-(height)) <= (tol))))
                {
                    if (debugLevel >= 3)
                        System.out.println("                                vert is out of initial plane, killing symbolicPerturbation");
                    symbolicPerturbation = null; // no need for it any more
                }
                else
                {
                    if (debugLevel >= 3)
                    {
                        System.out.println("                symbolically perturbing new vert out of initial plane!");
                        System.out.println("        " + "symbolicPerturbation" + " = " + Arrays.toStringCompact(symbolicPerturbation));
                    }

                    perturbedHeight = VecMath.dot(d, firstFacetUnitNormal, symbolicPerturbation);
                    do { if (!(!((((perturbedHeight)-(0.)) <= (tol)) && (((0.)-(perturbedHeight)) <= (tol))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+236 +"): " + "!EQ(perturbedHeight, 0., tol)" + ""); } while (false);
                }
            }

            if (perturbedHeight >= 0.)
            {
                firstHullFacetStruct.hoveringVerts.add(iVert);
                hoveringVertToFacet[iVert] = firstHullFacetStruct;
                if (debugLevel >= 3) System.out.println("                vertex "+iVert+" is hovering at height "+height+" over firstHullFacet "+Arrays.toStringCompact(firstHullFacet));
            }
            else
            {
                height = -height;
                secondHullFacetStruct.hoveringVerts.add(iVert);
                hoveringVertToFacet[iVert] = secondHullFacetStruct;
                if (debugLevel >= 3) System.out.println("                vertex "+iVert+" is hovering at height "+height+" over secondHullFacet "+Arrays.toStringCompact(secondHullFacet));
            }
            do { if (!((((0.)-(height)) <= (tol)))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+253 +"): " + "GEQ(height, 0., tol)" + ""); } while (false);
            if (debugLevel >= 3) System.out.println("                adding vert "+iVert+" to heap at priority "+(-height));
            queue.add(iVert, -height); // reverse sense so we can extract max height item as min item
        }






        //
        // All of the following are scratch, logically local to loop body below.
        //
        ArrayList visibleFacets = new ArrayList();

        int scratchRidge[] = new int[d-1];

        ArrayList visibleBoundaryFacets = new ArrayList();
        IntArrayList visibleBoundaryNeighborIndex = new IntArrayList();
        ArrayList facetSearchList = new ArrayList();


        if (debugLevel >= 2)
        {
            System.out.println("        servicing the queue");
        }
        while (!queue.isEmpty())
        {
            int iVert = queue.extractMin();
            if (debugLevel >= 3)
            {
                System.out.println("            extracted vertex "+iVert);
                System.out.println("                hull was "+hullFacets.toStringCompact());
            }
            int nFacetsBefore = hullFacets.size();
            visibleFacets.clear();
            visibleBoundaryFacets.clear();
            visibleBoundaryNeighborIndex.clear();



            // Figure out visible facets,
            // the smart way-- do a search
            // outwards from the one,
            // using the facet neighbors adjacency structure.
            facetSearchList.clear();
            hoveringVertToFacet[iVert].isVisible = 1;
            visibleFacets.add(hoveringVertToFacet[iVert]);
            facetSearchList.add(hoveringVertToFacet[iVert]);
            if (debugLevel >= 3)
                System.out.println("                initializing visible facets set to {"+Arrays.toStringCompact(hoveringVertToFacet[iVert].vertInds)+"}");
            for (int iFacetInSearchList = 0; (iFacetInSearchList) < (facetSearchList.size()); ++iFacetInSearchList) // while it's growing
            {
                Facet facet = (Facet)facetSearchList.get(iFacetInSearchList);
                if (debugLevel >= 3)
                    System.out.println("                    got to facet "+Arrays.toStringCompact(facet.vertInds)+" ("+(facet.isVisible==1?"visible":facet.isVisible==0?"invisible":"???")+")");
                do { if (!(facet.isVisible != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+309 +"): " + "facet.isVisible != -1" + ""); } while (false);
                if (facet.isVisible == 1)
                {
                    for (int iNeighbor = 0; (iNeighbor) < (d); ++iNeighbor)
                    {
                        Facet neighbor = facet.neighbors[iNeighbor];
                        if (debugLevel >= 3)
                            System.out.println("                        neighbor "+Arrays.toStringCompact(neighbor.vertInds)+" through ridge "+Arrays.toStringCompact(Arrays.delete(facet.vertInds, iNeighbor)));
                        if (neighbor.isVisible == -1)
                        {
                            if (debugLevel >= 3)
                                System.out.println("                                (not in list, computing visibility)");
                            VecMath.vmv(scratchVec, verts[iVert], verts[neighbor.vertInds[0]]);
                            double height = VecMath.dot(scratchVec, neighbor.unitNormal);
                            double perturbedHeight = height;
                            if (symbolicPerturbation != null)
                            {
                                if (!((((height)-(0.)) <= (tol)) && (((0.)-(height)) <= (tol))))
                                {
                                    if (debugLevel >= 3)
                                        System.out.println("                                vert is out of initial plane, killing symbolicPerturbation");
                                    symbolicPerturbation = null; // no need for it any more
                                }
                                else
                                {
                                    if (debugLevel >= 3)
                                    {
                                        System.out.println("                                symbolically perturbing new vert out of initial plane!");
                                        System.out.println("        " + "symbolicPerturbation" + " = " + Arrays.toStringCompact(symbolicPerturbation));
                                    }

                                    perturbedHeight = VecMath.dot(d, neighbor.unitNormal, symbolicPerturbation);
                                    do { if (!(!((((perturbedHeight)-(0.)) <= (tol)) && (((0.)-(perturbedHeight)) <= (tol))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+341 +"): " + "!EQ(perturbedHeight, 0., tol)" + ""); } while (false);
                                }
                            }
                            if (debugLevel >= 3)
                                System.out.println("                                (height="+height+")");
                            neighbor.isVisible = ((((0.)-(perturbedHeight)) <= (tol)) ? 1 : 0); // whether neighbor is visible or borderline visible from vertex
                            facetSearchList.add(neighbor);

                            if (neighbor.isVisible == 1)
                                visibleFacets.add(neighbor);
                        }
                        else
                        {
                            if (debugLevel >= 3)
                                System.out.println("                                (already in list)");
                        }
                        if (neighbor.isVisible == 0)
                        {
                            if (debugLevel >= 3)
                                System.out.println("                            invisible, adding boundary ridge");
                            visibleBoundaryFacets.add(facet);
                            visibleBoundaryNeighborIndex.add(iNeighbor);
                        }
                        else
                        {
                            if (debugLevel >= 3)
                                System.out.println("                        visible");
                        }
                    }
                }
            }
            // add new facets forming a cone from the visible boundary
            // to the vertex.
            for (int iVisibleBoundary = (visibleBoundaryFacets.size())-1; (iVisibleBoundary) >= 0; --iVisibleBoundary)
            {
                Facet oldFacet = (Facet)visibleBoundaryFacets.get(iVisibleBoundary);
                int iNeighbor = visibleBoundaryNeighborIndex.get(iVisibleBoundary);

                int newFacetVertInds[] = VecMath.copyvec(oldFacet.vertInds);
                newFacetVertInds[iNeighbor] = iVert;

                Facet newFacet = new Facet(newFacetVertInds,
                                           calcUnitNormal(verts, newFacetVertInds),
                                           new IntArrayList(), // hoveringVerts
                                           new Facet[d], // neighbors
                                           VecMath.fillvec(d, -1)); // neighborsIndexOfMe
                newFacet.isVisible = 2; // "new" (XXX should maybe be a legit bitfield?)
                Facet invisibleNeighbor = oldFacet.neighbors[iNeighbor];
                int invisibleNeighborsIndexOfMe = oldFacet.neighborsIndexOfMe[iNeighbor];
                newFacet.neighbors[iNeighbor] = invisibleNeighbor; // only one known so far
                newFacet.neighborsIndexOfMe[iNeighbor] = invisibleNeighborsIndexOfMe;
                invisibleNeighbor.neighbors[invisibleNeighborsIndexOfMe] = newFacet;
                do { if (!((invisibleNeighbor.neighborsIndexOfMe[invisibleNeighborsIndexOfMe])==(iNeighbor))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+393 +"): (" + "invisibleNeighbor.neighborsIndexOfMe[invisibleNeighborsIndexOfMe]" + ")" + "==" + "(" + "iNeighbor" + ") ("+(invisibleNeighbor.neighborsIndexOfMe[invisibleNeighborsIndexOfMe])+" vs. "+(iNeighbor)+")"); } while (false);
                hullFacets.add(newFacet);
            }

            if (d == 2)
            {
                // The general sewing method would work fine,
                // but in this case it would be incredibly inefficient...
                // the "peak" would be (-1)-dimensional,
                // and it would be walking around the entire invisible back side.
                // In this case the answer is trivial, so just do it.
                // XXX TODO: argh, it's still inefficient for a cone with large polygonal base, for example.  go back to hash table? bleah!
                if (debugLevel >= 3)
                {
                    System.out.println("                sewing up cone the trivial way");
                    {System.out.print("        "); System.out.println("visibleBoundaryFacets.size()" + " = " + (visibleBoundaryFacets.size()));};
                }
                do { if (!((visibleBoundaryFacets.size())==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+410 +"): (" + "visibleBoundaryFacets.size()" + ")" + "==" + "(" + "2" + ") ("+(visibleBoundaryFacets.size())+" vs. "+(2)+")"); } while (false);
                Facet oldFacet0 = (Facet)visibleBoundaryFacets.get(0);
                Facet oldFacet1 = (Facet)visibleBoundaryFacets.get(1);
                int iInvisibleNeighbor0 = visibleBoundaryNeighborIndex.get(0);
                int iInvisibleNeighbor1 = visibleBoundaryNeighborIndex.get(1);
                Facet invisibleNeighbor0 = oldFacet0.neighbors[iInvisibleNeighbor0];
                Facet invisibleNeighbor1 = oldFacet1.neighbors[iInvisibleNeighbor1];
                int invisibleNeighborsIndexOfMe0 = oldFacet0.neighborsIndexOfMe[iInvisibleNeighbor0];
                int invisibleNeighborsIndexOfMe1 = oldFacet1.neighborsIndexOfMe[iInvisibleNeighbor1];
                Facet newFacet0 = invisibleNeighbor0.neighbors[invisibleNeighborsIndexOfMe0];
                Facet newFacet1 = invisibleNeighbor1.neighbors[invisibleNeighborsIndexOfMe1];
                if (debugLevel >= 3)
                {
                    System.out.println("                    looking at oldFacet0="+Arrays.toStringCompact(oldFacet0.vertInds)+", newFacet0="+Arrays.toStringCompact(newFacet0.vertInds)+", invisibleNeighbor0 = "+Arrays.toStringCompact(invisibleNeighbor0.vertInds));
                    System.out.println("                    looking at oldFacet1="+Arrays.toStringCompact(oldFacet1.vertInds)+", newFacet1="+Arrays.toStringCompact(newFacet1.vertInds)+", invisibleNeighbor1 = "+Arrays.toStringCompact(invisibleNeighbor1.vertInds));
                }
                do { if (!(newFacet0 != oldFacet0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+426 +"): " + "newFacet0 != oldFacet0" + ""); } while (false);
                do { if (!(newFacet1 != oldFacet1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+427 +"): " + "newFacet1 != oldFacet1" + ""); } while (false);

                do { if (!((newFacet0.neighbors[1-iInvisibleNeighbor0])==(null))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+429 +"): (" + "newFacet0.neighbors[1-iInvisibleNeighbor0]" + ")" + "==" + "(" + "null" + ") ("+(newFacet0.neighbors[1-iInvisibleNeighbor0])+" vs. "+(null)+")"); } while (false);
                do { if (!((newFacet1.neighbors[1-iInvisibleNeighbor1])==(null))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+430 +"): (" + "newFacet1.neighbors[1-iInvisibleNeighbor1]" + ")" + "==" + "(" + "null" + ") ("+(newFacet1.neighbors[1-iInvisibleNeighbor1])+" vs. "+(null)+")"); } while (false);
                newFacet0.neighbors[1-iInvisibleNeighbor0] = newFacet1;
                newFacet1.neighbors[1-iInvisibleNeighbor1] = newFacet0;
                newFacet0.neighborsIndexOfMe[1-iInvisibleNeighbor0] = 1-iInvisibleNeighbor1;
                newFacet1.neighborsIndexOfMe[1-iInvisibleNeighbor1] = 1-iInvisibleNeighbor0;

                do { if (!((newFacet0.isVisible)==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+436 +"): (" + "newFacet0.isVisible" + ")" + "==" + "(" + "2" + ") ("+(newFacet0.isVisible)+" vs. "+(2)+")"); } while (false); // i.e. "new"
                do { if (!((newFacet1.isVisible)==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+437 +"): (" + "newFacet1.isVisible" + ")" + "==" + "(" + "2" + ") ("+(newFacet1.isVisible)+" vs. "+(2)+")"); } while (false); // i.e. "new"
                newFacet0.isVisible = -1;
                newFacet1.isVisible = -1;
            }
            else // d >= 3
            {
                // to sew up the cone, walk around the invisible part to find the desired neighbors.
                // doesn't require any hash tables.
                if (debugLevel >= 3)
                    System.out.println("                sewing up cone the smart way");
                for (int iVisibleBoundary = (visibleBoundaryFacets.size())-1; (iVisibleBoundary) >= 0; --iVisibleBoundary)
                {
                    Facet oldFacet = (Facet)visibleBoundaryFacets.get(iVisibleBoundary);
                    int iInvisibleNeighbor = visibleBoundaryNeighborIndex.get(iVisibleBoundary);
                    Facet invisibleNeighbor = oldFacet.neighbors[iInvisibleNeighbor];
                    int invisibleNeighborsIndexOfMe = oldFacet.neighborsIndexOfMe[iInvisibleNeighbor];
                    Facet newFacet = invisibleNeighbor.neighbors[invisibleNeighborsIndexOfMe];
                    if (debugLevel >= 3)
                        System.out.println("                    looking at oldFacet="+Arrays.toStringCompact(oldFacet.vertInds)+", newFacet="+Arrays.toStringCompact(newFacet.vertInds)+", invisibleNeighbor = "+Arrays.toStringCompact(invisibleNeighbor.vertInds));
                    // oldFacet still points at the neighbor,
                    // but the neighbor doesn't point back!
                    do { if (!(newFacet != oldFacet)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+458 +"): " + "newFacet != oldFacet" + ""); } while (false);

                    for (int iRidgeThisNewFacet = 0; (iRidgeThisNewFacet) < (d); ++iRidgeThisNewFacet)
                    {
                        if (newFacet.neighbors[iRidgeThisNewFacet] == null)
                        {
                            // Which other new facet
                            // is across the ridge formed by omitting
                            // the iRidgeThisNewFacet'th vertex from newFacet?
                            // Walk around the invisible (i.e. not marked visible) part,
                            // around the peak, til we find another new facet; that's it.
                            //            *-------------*
                            //           / \  (invis)  /                             //          /   \         /                               //         /     \       /                                 //        /       \     /(invis)                            //       /invisible\   /                                     //      / Neighbor  \ /                                       //     *=============*=============*






                            //   i1 \  (vis)    / \   (vis)   /
                            //       \oldFacet /   \         /
                            //        \       /     \       /
                            //         \     /       \     /
                            //          \   /         \   /
                            //           \ /  (invis)  \ /
                            //         i0 *-------------*
                            Facet thisFacet = oldFacet; // next facet will be invisibleNeighbor
                            int i0 = iInvisibleNeighbor;
                            int i1 = iRidgeThisNewFacet;
                            do { if (!((thisFacet.isVisible)==(1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+487 +"): (" + "thisFacet.isVisible" + ")" + "==" + "(" + "1" + ") ("+(thisFacet.isVisible)+" vs. "+(1)+")"); } while (false);

                            if (debugLevel >= 3)
                            {
                                System.out.println("                            thisFacet = "+Arrays.toStringCompact(thisFacet.vertInds));
                                System.out.println("                            thisFacet[i0="+i0+"] = "+thisFacet.vertInds[i0]);
                                System.out.println("                            thisFacet[i1="+i1+"] = "+thisFacet.vertInds[i1]);
                            }

                            while (true)
                            {
                                // TODO: which of the following new pics do I like better?
                                //            i0           i1
                                //            *-------------* j0
                                //           / \  (invis)  /                                 //          /   \thisFacet/                                   //         /     \       /                                     //        /       \     /(invis)                                //       /         \   /nextFacet                                //      /           \ /           \ j1





                                //     *=============*=============*
                                //      \           : :           /
                                //       \newFacet :   :other new/
                                //        \       :     :       /
                                //         \     :       :     /
                                //          \   :<--sew-->:   /
                                //           \ :           : /
                                //            *             *
                                //
                                //            i0           i1
                                //            *-------------* j0
                                //           / \  (invis)  /                                 //          /   \thisFacet/                                   //         /     \       /                                     //        /       \     /(invis)                                //       /         \   /nextFacet                                //      /           \ /           \ j1





                                //     *=============*=============*
                                //      \           : :           /
                                //       \ newFacet : : other new/
                                //        \         : :         /
                                //         \        : :        /
                                Facet nextFacet = thisFacet.neighbors[i0];
                                int j0 = Arrays.indexOf(nextFacet.vertInds, thisFacet.vertInds[i1]);
                                int j1 = thisFacet.neighborsIndexOfMe[i0];

                                thisFacet = nextFacet;
                                i0 = j0;
                                i1 = j1;

                                if (debugLevel >= 3)
                                {
                                    System.out.println("                        advancing...");
                                    System.out.println("                            thisFacet = "+Arrays.toStringCompact(thisFacet.vertInds));
                                    System.out.println("                            thisFacet[i0="+i0+"] = "+thisFacet.vertInds[i0]);
                                    System.out.println("                            thisFacet[i1="+i1+"] = "+thisFacet.vertInds[i1]);
                                }

                                do { if (!(thisFacet.isVisible == -1 /* was not traversed; implicitly invisible */ || thisFacet.isVisible == 0 /* was marked invisible */ || thisFacet.isVisible == 2)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+545 +"): " + "thisFacet.isVisible == -1 /* was not traversed; implicitly invisible */ || thisFacet.isVisible == 0 /* was marked invisible */ || thisFacet.isVisible == 2" + ""); } while (false)

                                                                ; /* new */
                                if (thisFacet.isVisible == 2) // it's the desired new one!
                                    break;
                            }

                            // sew newFacet to thisFacet
                            newFacet.neighbors[iRidgeThisNewFacet] = thisFacet;
                            newFacet.neighborsIndexOfMe[iRidgeThisNewFacet] = i0;
                            thisFacet.neighbors[i0] = newFacet;
                            thisFacet.neighborsIndexOfMe[i0] = iRidgeThisNewFacet;
                        }
                    } // for iRidgeThisNewFacet

                    // done sewing up this new facet,
                    // and no other new facet will need this one any more,
                    // so we can clear the "new" flag,
                    // and also disconnect it from the invisible neighbor. (XXX not doing that, probably doesn't matter)
                    do { if (!((newFacet.isVisible)==(2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+564 +"): (" + "newFacet.isVisible" + ")" + "==" + "(" + "2" + ") ("+(newFacet.isVisible)+" vs. "+(2)+")"); } while (false); // i.e. "new"
                    newFacet.isVisible = -1;

                } // for iVisibleBoundary
            } // d >= 3


            // clear visibility flags of original search list
            // (visibility flag of new cone has already been cleared...
            // actually it was conceptually different)
            for (int iFacetInSearchList = (facetSearchList.size())-1; (iFacetInSearchList) >= 0; --iFacetInSearchList)
                ((Facet)facetSearchList.get(iFacetInSearchList)).isVisible = -1;

            // make sure we filled in everything properly in the new facets
            for (int iVisibleBoundary = (visibleBoundaryFacets.size())-1; (iVisibleBoundary) >= 0; --iVisibleBoundary)
            {
                Facet newFacet = hullFacets.get(hullFacets.size()-1-iVisibleBoundary);
                // make sure it's all filled in properly,
                // and that the "new" flag is cleared.
                for (int iNeighbor = 0; (iNeighbor) < (d); ++iNeighbor)
                {
                    do { if (!(newFacet.neighbors[iNeighbor] != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+585 +"): " + "newFacet.neighbors[iNeighbor] != null" + ""); } while (false);
                    do { if (!(newFacet.neighborsIndexOfMe[iNeighbor] != -1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+586 +"): " + "newFacet.neighborsIndexOfMe[iNeighbor] != -1" + ""); } while (false);
                    do { if (!((newFacet.neighbors[iNeighbor].neighborsIndexOfMe[newFacet.neighborsIndexOfMe[iNeighbor]])==(iNeighbor))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+587 +"): (" + "newFacet.neighbors[iNeighbor].neighborsIndexOfMe[newFacet.neighborsIndexOfMe[iNeighbor]]" + ")" + "==" + "(" + "iNeighbor" + ") ("+(newFacet.neighbors[iNeighbor].neighborsIndexOfMe[newFacet.neighborsIndexOfMe[iNeighbor]])+" vs. "+(iNeighbor)+")"); } while (false);
                    do { if (!((newFacet.isVisible)==(-1))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+588 +"): (" + "newFacet.isVisible" + ")" + "==" + "(" + "-1" + ") ("+(newFacet.isVisible)+" vs. "+(-1)+")"); } while (false);
                }
            }



            int nVisibleFacets = visibleFacets.size();
            do { if (!(nVisibleFacets >= 1)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+595 +"): " + "nVisibleFacets >= 1" + ""); } while (false); // the facet that iVert was hovering over, at least

            int nFacetsAfterAdding = hullFacets.size();
            if (debugLevel >= 3)
            {
                {System.out.print("        "); System.out.println("nFacetsBefore" + " = " + (nFacetsBefore));};
                {System.out.print("        "); System.out.println("nFacetsAfterAdding" + " = " + (nFacetsAfterAdding));};
            }
            do { if (!(nFacetsAfterAdding > nFacetsBefore)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+603 +"): " + "nFacetsAfterAdding > nFacetsBefore" + ""); } while (false); // added at least one, and didn't delete any yet

            // Transfer the hovering vertices
            // from the visible facets (which are about to be deleted)
            // to the facets that just got created
            for (int iVisibleFacet = 0; (iVisibleFacet) < (nVisibleFacets); ++iVisibleFacet)
            {
                // For each vertex that was hovering over this visible facet...
                Facet visibleFacet = (Facet)visibleFacets.get(iVisibleFacet);
                IntArrayList hoverers = visibleFacet.hoveringVerts;
                int nHoverers = hoverers.size();
                for (int iHoverer = 0; (iHoverer) < (nHoverers); ++iHoverer)
                {
                    int jVert = hoverers.get(iHoverer);
                    if (jVert == iVert)
                        continue; // don't transfer iVert, we're done with it

                    int theNewFacetIndex = -1;
                    double highestHeight = Double.NEGATIVE_INFINITY;
                    for (int iNewFacet = nFacetsBefore; iNewFacet < nFacetsAfterAdding; ++iNewFacet)
                    {
                        Facet newFacetStruct = hullFacets.get(iNewFacet);
                        int newFacet[] = newFacetStruct.vertInds;
                        double facetUnitNormal[] = newFacetStruct.unitNormal;
                        VecMath.vmv(scratchVec, verts[jVert], verts[newFacet[0]]);
                        double height = VecMath.dot(d, scratchVec, facetUnitNormal);
                        double perturbedHeight = height;
                        if (symbolicPerturbation != null)
                        {
                            if (!((((height)-(0.)) <= (tol)) && (((0.)-(height)) <= (tol))))
                            {
                                if (debugLevel >= 3)
                                    System.out.println("                        vert is out of initial plane, killing symbolicPerturbation");
                                symbolicPerturbation = null; // no need for it any more
                            }
                            else
                            {
                                if (debugLevel >= 3)
                                    System.out.println("                        symbolically perturbing new vert out of initial plane");

                                perturbedHeight = VecMath.dot(d, symbolicPerturbation, facetUnitNormal);
                                do { if (!(!((((perturbedHeight)-(0.)) <= (tol)) && (((0.)-(perturbedHeight)) <= (tol))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+644 +"): " + "!EQ(perturbedHeight, 0., tol)" + ""); } while (false);
                            }
                        }

                        if (height > highestHeight
                         && perturbedHeight >= -tol)
                        {
                            highestHeight = height;
                            theNewFacetIndex = iNewFacet;
                        }
                    }
                    if (theNewFacetIndex != -1)
                    {
                        Facet theNewFacet = hullFacets.get(theNewFacetIndex);
                        if (debugLevel >= 3)
                            System.out.println("        transferring vertex "+jVert+" from facet "+Arrays.toStringCompact(visibleFacet.vertInds)+" to hovering at height "+highestHeight+" above facet "+Arrays.toStringCompact(theNewFacet.vertInds)+"");
                        theNewFacet.hoveringVerts.add(jVert);
                        hoveringVertToFacet[jVert] = theNewFacet;
                        queue.adjust(jVert, -highestHeight);
                    }
                    else
                    {
                        // Nothing was >= -tol.
                        // So jVert is inside the hull, so it should
                        // be ignored.
                        if (debugLevel >= 3)
                            System.out.println("        transferring vertex "+jVert+" from facet "+Arrays.toStringCompact(visibleFacet.vertInds)+" to the void because it's inside the hull");
                        hoveringVertToFacet[jVert] = null;
                        queue.remove(jVert);
                    }
                }
            } // FORI (iVisibleFacet, nVisibleFacets)

            // Remove the visible facets from the hull
            for (int iVisibleFacet = 0; (iVisibleFacet) < (nVisibleFacets); ++iVisibleFacet)
                hullFacets.fastRemove((Facet)visibleFacets.get(iVisibleFacet));

            if (debugLevel >= 3)
            {
                int nFacetsAfterRemoving = hullFacets.size();
                {System.out.print("        "); System.out.println("nFacetsAfterRemoving" + " = " + (nFacetsAfterRemoving));};
                System.out.println("                hull is now "+hullFacets.toStringCompact());
            }
        } // while queue not empty


        if (d == 2)
        {
            // re-order nicely, starting with smallest index vert

            int nFacets = hullFacets.size();
            Facet firstFacet = hullFacets.get(0);
            for (int iFacet = 0; (iFacet) < (nFacets); ++iFacet)
            {
                Facet facet = hullFacets.get(iFacet);
                if (facet.vertInds[0] < firstFacet.vertInds[0])
                    firstFacet = facet;
            }

            FacetArrayList hullFacetsReordered = new FacetArrayList();
            hullFacets.fastRemove(firstFacet);
            hullFacetsReordered.add(firstFacet);
            for (Facet facet = firstFacet.neighbors[0];
                 facet != firstFacet;
                 facet = facet.neighbors[0])
            {
                hullFacets.fastRemove(facet);
                hullFacetsReordered.add(facet);
            }
            do { if (!((hullFacets.size())==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+713 +"): (" + "hullFacets.size()" + ")" + "==" + "(" + "0" + ") ("+(hullFacets.size())+" vs. "+(0)+")"); } while (false);
            do { if (!((hullFacetsReordered.size())==(nFacets))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+714 +"): (" + "hullFacetsReordered.size()" + ")" + "==" + "(" + "nFacets" + ") ("+(hullFacetsReordered.size())+" vs. "+(nFacets)+")"); } while (false);
            hullFacets = hullFacetsReordered;
        }


        int hullFacetsArray[][] = new int[hullFacets.size()][];
        int hullAdjacenciesArray[][] = new int[hullFacets.size()][d];
        int backIndsArray[][] = new int[hullFacets.size()][d];
        for (int iFacet = 0; (iFacet) < (hullFacetsArray.length); ++iFacet)
        {
            Facet facet = hullFacets.get(iFacet);
            hullFacetsArray[iFacet] = facet.vertInds;
            for (int i = 0; (i) < (d); ++i)
                hullAdjacenciesArray[iFacet][i] = facet.neighbors[i].myIndex;
            backIndsArray[iFacet] = facet.neighborsIndexOfMe;
        }
        if (debugLevel >= 1)
        {
            System.out.println("        "+hullFacetsArray.length+" facets");
            System.out.println("        " + "hullFacetsArray" + " = " + Arrays.toStringCompact(hullFacetsArray));
            System.out.println("    out convexHull");
        }
        return new int[/*3*/][/*nFacets*/][/*d*/] {hullFacetsArray, hullAdjacenciesArray, backIndsArray};
    } // convexHull

    private static class Facet
    {
        public int myIndex;
        public int vertInds[/*d*/];
        public double unitNormal[/*d*/];
        public IntArrayList hoveringVerts;
        public Facet neighbors[/*d*/];
        public int neighborsIndexOfMe[/*d*/];

        public int isVisible; // scratch for current traversal. 1 means visible, 0 means not visible, -1 means not visited

        Facet(int vertInds[],
              double unitNormal[],
              IntArrayList hoveringVerts,
              Facet neighbors[],
              int neighborsIndexOfMe[])
        {
            this.vertInds = vertInds;
            this.unitNormal = unitNormal;
            this.hoveringVerts = hoveringVerts;
            this.neighbors = neighbors;
            this.neighborsIndexOfMe = neighborsIndexOfMe;

            this.myIndex = -1;
            this.isVisible = -1;
        }

    } // class Facet


    // ArrayList of Facet,
    // that manages each Facet's myIndex
    private static class FacetArrayList
    {
        public int size()
        {
            return facetArrayList.size();
        }
        public Facet get(int i)
        {
            Facet facet = (Facet)facetArrayList.get(i);
            do { if (!((facet.myIndex)==(i))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+780 +"): (" + "facet.myIndex" + ")" + "==" + "(" + "i" + ") ("+(facet.myIndex)+" vs. "+(i)+")"); } while (false);
            return facet;
        }
        public void add(Facet facet)
        {
            facet.myIndex = facetArrayList.size();
            facetArrayList.add(facet);
        }
        public void set(int i, Facet facet)
        {
            facet.myIndex = i;
            facetArrayList.set(i, facet);
        }
        public void fastRemove(Facet facet)
        {
            fastRemove(facet.myIndex);
        }
        public void fastRemove(int i)
        {
            int n = facetArrayList.size();
            if (i != n-1)
                set(i, get(n-1));
            facetArrayList.remove(n-1);
        }
        public String toStringCompact()
        {
            ArrayList scratchArrayList = new ArrayList();
            int n = size();
            for (int i = 0; (i) < (n); ++i)
                scratchArrayList.add(get(i).vertInds);
            int scratchArray[][] = new int[scratchArrayList.size()][];
            scratchArrayList.toArray(scratchArray);
            return Arrays.toStringCompact(scratchArray);
        }
        private ArrayList facetArrayList = new ArrayList();

    } // class FacetArrayList



    //
    // Little private utilities...
    //
        private static double calcParallelotopeContentSquared(
                                    double verts[][/*d*/],
                                    int points[/*1<= <=d+1*/],
                                    int nPoints)
        {
            // This was formerly done by taking a matrix times its transpose,
            // but that wasn't robust (was returning negative numbers).
            // The VecMath.relativeOrthotopeContent functions are robust.
            double simpleVerts[][] = new double[nPoints][];
            for (int i = 0; (i) < (nPoints); ++i)
                simpleVerts[i] = verts[points[i]];
            int dim = simpleVerts[0].length;
            double sqrtAnswer = VecMath.relativeOrthotopeContent(nPoints, dim, simpleVerts, false);
            return sqrtAnswer*sqrtAnswer;
        } // calcParallelotopeContentSquared

        private static double[] calcUnitNormal(
                                    double verts[/*d*/][/*d*/],
                                    int points[/*d*/])
        {
            int d = points.length;
            double M[][] = new double[d-1][d];
            for (int iRow = 0; (iRow) < (d-1); ++iRow)
            {
                if (false)
                {
                    // subtract first vert from the others
                    VecMath.vmv(M[iRow],
                                verts[points[iRow+1]],
                                verts[points[0]]);
                }
                else
                {
                    // subtract last vert from the others.
                    // this only matters in even dimensions.
                    // in 2d, this seems to make the final convex hull result come out CCW, which is good.
                    VecMath.vmv(M[iRow],
                                verts[points[iRow]],
                                verts[points[points.length-1]]);
                }
            }
            double normal[] = VecMath.crossprod(M);
            VecMath.normalize(normal, normal);
            return normal;
        }


        // only used for sanityCheckConvexHull, not used in actual implementation
        private static class IntArrayHashKey
        {
            private int item[];
            IntArrayHashKey(int item[]) // NOTE modifying contents will modify behavior accordingly! caller uses this fact
            {
                this.item = item;
            }
            public int hashCode()
            {
                int hash = 47;
                for (int i = 0; i < item.length; ++i)
                    hash = hash*31 + item[i];
                return hash;
            }
            public boolean equals(Object that)
            {
                return VecMath.equals(this.item, ((IntArrayHashKey)that).item);
            }
        } // class IntArrayHashKey


        // sort the list,
        // and return the parity (0 or 1) of the permutation
        // (i.e. number of swaps needed).
        // works by bubble sort.
        private static int sortAndExtractParity(int order[])
        {
            int n = order.length;
            int nSwaps = 0;
            for (int k = (n)-1; (k) >= 0; --k)
            {
                for (int i = 0; (i) < (k); ++i)
                {
                    if (order[i] > order[i+1])
                    {
                        Arrays.swap(order, i, order, i+1);
                        nSwaps++;
                    }
                }
            }
            for (int i = 0; (i) < (n-1); ++i)
                do { if (!(order[i] < order[i+1])) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+912 +"): " + "order[i] < order[i+1]" + ""); } while (false);
            return nSwaps % 2;
        }


    public static void sanityCheckConvexHull(int d, double verts[][], int hull[][], double tol)
    {
        if (verts.length < d)
        {
            do { if (!((hull.length)==(0))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+921 +"): (" + "hull.length" + ")" + "==" + "(" + "0" + ") ("+(hull.length)+" vs. "+(0)+")"); } while (false);
        }
        else
        {
            //
            // Make sure it's boundaryless (i.e. has no
            // boundary ridges).
            // Actually stronger than that: each ridge
            // occuring on a facet of the hull
            // must appear on exactly one other facet of the hull,
            // in the opposite orientation.
            // TODO: assert connected, too.
            // TODO: and that each ridge is locally convex... maybe?
            //
            {
                // ridgeParityToFacets maps a canonical-order ridge
                // to an array of two arrays:
                // the facets containing the ridge with parity 0,
                // and the facets containing the ridge with parity 1.
                java.util.HashMap<IntArrayHashKey,int[][]> ridgeParityToFacets = new java.util.HashMap<IntArrayHashKey,int[][]>();
                for (int iFacet = 0; (iFacet) < (hull.length); ++iFacet)
                {
                    int facet[] = hull[iFacet];
                    do { if (!((facet.length)==(d))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+944 +"): (" + "facet.length" + ")" + "==" + "(" + "d" + ") ("+(facet.length)+" vs. "+(d)+")"); } while (false);

                    // assert all verts on facet are distinct
                    {
                        int sortedFacet[] = VecMath.copyvec(facet);
                        SortStuff.sort(sortedFacet);
                        for (int i = 0; (i) < (d-1); ++i)
                            do { if (!(sortedFacet[i+1] != sortedFacet[i])) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+951 +"): " + "sortedFacet[i+1] != sortedFacet[i]" + ""); } while (false);
                    }

                    for (int iRidgeThisFacet = 0; (iRidgeThisFacet) < (d); ++iRidgeThisFacet)
                    {
                        int ridge[] = new int[d-1]; // must be unique array since ownership will be transferred to the IntArrayHashKey
                        for (int i = 0; (i) < (d-1); ++i)
                            ridge[i] = facet[i>=iRidgeThisFacet ? i+1 : i];
                        if (d-1 >= 2 && iRidgeThisFacet % 2 == 1)
                            Arrays.swap(ridge, 0, ridge, 1);
                        int parity = (d-1==0 ? iFacet :
                                      d-1==1 ? iRidgeThisFacet : sortAndExtractParity(ridge));

                        // ridge is now in canonical order, as required

                        IntArrayHashKey ridgeKey = new IntArrayHashKey(ridge);

                        int parityToFacets[][] = ridgeParityToFacets.get(ridgeKey);
                        if (parityToFacets == null)
                        {
                            parityToFacets = new int[3][0];
                            parityToFacets[2] = ridge; // smuggle in ridge itself
                            ridgeParityToFacets.put(ridgeKey, parityToFacets);
                        }
                        parityToFacets[parity] = Arrays.append(parityToFacets[parity],
                                                               iFacet);
                    }
                }
                boolean okSoFar = true;
                for (java.util.Map.Entry<IntArrayHashKey,int[][]> entry : ridgeParityToFacets.entrySet()) {
                    IntArrayHashKey ridgeKey = entry.getKey();
                    int value[][] = entry.getValue();

                    do { if (!((value.length)==(3))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+984 +"): (" + "value.length" + ")" + "==" + "(" + "3" + ") ("+(value.length)+" vs. "+(3)+")"); } while (false);
                    int ridge[] = value[2];
                    if (value[0].length != 1
                     || value[1].length != 1)
                    {
                        if (value[0].length+value[1].length == 2)
                            System.out.println("HEY! both occurrences of ridge "+Arrays.toStringCompact(ridge)+" have same orientation!");
                        else
                            System.out.println("HEY! ridge "+Arrays.toStringCompact(ridge)+" occurs "+(value[0].length+value[1].length)+" times, should be 2");
                        for (int parity = 0; (parity) < (2); ++parity)
                        {
                            System.out.println("    occurrences with parity "+parity+":");
                            for (int iFacetThisParity = 0; (iFacetThisParity) < (value[parity].length); ++iFacetThisParity)
                            {
                                int iFacet = value[parity][iFacetThisParity];
                                System.out.println("        facet "+iFacet+" = "+Arrays.toStringCompact(hull[iFacet]));
                            }
                        }
                        okSoFar = false;
                    }
                }
                do { if (!(okSoFar)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1005 +"): " + "okSoFar" + ""); } while (false);
            }

            //
            // Make sure it bounds the hull
            // (note, this is O(n^2) )
            //
            if (true)
            {
                double vertsCenter[] = VecMath.average(verts);

                double facetVerts[][] = new double[d][];
                double facetPlaneVecs[][] = new double[((d-1)>=(0)?(d-1):(0))][d];
                double facetNormal[] = new double[d];
                double facetCenter[] = new double[d];
                double facetCenterToVert[] = new double[d];

                int sign = 0;

                for (int iFacet = 0; (iFacet) < (hull.length); ++iFacet)
                {
                    for (int i = 0; (i) < (d); ++i)
                        facetVerts[i] = verts[hull[iFacet][i]];
                    //System.out.println("        making sure facet plane of facet "+iFacet+": "+Arrays.toStringCompact(hull[iFacet])+": "+Arrays.toStringCompact(facetVerts)+" bounds");
                    for (int i = 0; (i) < (d-1); ++i)
                        VecMath.vmv(facetPlaneVecs[i], facetVerts[i+1], facetVerts[0]);
                    VecMath.crossprod(facetNormal, facetPlaneVecs);
                    // special case for d==1 --
                    // in this case cross product always
                    // returns {+1} and so gives no information
                    if (d == 1)
                        facetNormal[0] = facetVerts[0][0] - vertsCenter[0];
                    VecMath.normalize(facetNormal, facetNormal);
                    // XXX need to deal with degeneracy here maybe
                    do { if (!(((((VecMath.normsqrd(facetNormal))-(1.)) <= (2*tol)) && (((1.)-(VecMath.normsqrd(facetNormal))) <= (2*tol))))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1039 +"): " + "EQ(VecMath.normsqrd(facetNormal), 1., 2*tol)" + ""); } while (false);
                    VecMath.average(facetCenter, facetVerts);


                    for (int iVert = 0; (iVert) < (verts.length); ++iVert)
                    {
                        //System.out.println("            comparing against vert "+iVert+": "+Arrays.toStringCompact(verts[iVert]));
                        double vert[] = verts[iVert];
                        VecMath.vmv(facetCenterToVert,
                                    vert, facetCenter);
                        double foo = VecMath.dot(facetNormal, facetCenterToVert);
                        int thisSign = ((((0)-(foo)) > (tol)) ? -1 : (((foo)-(0)) > (tol)) ? 1 : 0);
                        if (sign == 0)
                            sign = thisSign; // might still be 0
                        if (! (sign * thisSign >= 0))
                        {
                            {System.out.print("        "); System.out.println("(((0)-(foo)) > (tol))" + " = " + ((((0)-(foo)) > (tol))));};
                            {System.out.print("        "); System.out.println("(((foo)-(0)) > (tol))" + " = " + ((((foo)-(0)) > (tol))));};
                            {System.out.print("        "); System.out.println("tol" + " = " + (tol));};
                            {System.out.print("        "); System.out.println("foo" + " = " + (foo));};
                            {System.out.print("        "); System.out.println("thisSign" + " = " + (thisSign));};
                            {System.out.print("        "); System.out.println("sign" + " = " + (sign));};
                        }
                        do { if (!(sign * thisSign >= 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1062 +"): " + "sign * thisSign >= 0" + ""); } while (false);
                    }
                }
                // TODO: can't we assert something about the sign, for god's sake?? argh! this is insane!
                if (d == 3)
                    do { if (!(sign <= 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1067 +"): " + "sign <= 0" + ""); } while (false);
                if (d == 4)
                    do { if (!(sign >= 0)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1069 +"): " + "sign >= 0" + ""); } while (false);
            }
        }
    } // sanityCheckConvexHull


    private static int[][] testTheseVerts(int d, double verts[][])
    {
        {System.out.print("        "); System.out.println("d" + " = " + (d));};
        System.out.println("        " + "verts" + " = " + Arrays.toStringCompact(verts));
        for (int iVert = 0; (iVert) < (verts.length); ++iVert)
            do { if (!((verts[iVert].length)==(d))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1080 +"): (" + "verts[iVert].length" + ")" + "==" + "(" + "d" + ") ("+(verts[iVert].length)+" vs. "+(d)+")"); } while (false);

        long t0 = System.currentTimeMillis();

        // argh! 1e-12 made it fail in real life with brute force method (test case below), 1e-9 made it fail randomized confidence test, 1e-10 and coarser made it fail in real life using either method (test case below).
        // update now that I'm revisiting:
        //   there's an explicit 5d test case that succeeds with 1e-39 and fails with 1e-40 (got it from 5d coplanar)
        // but some other coplanar stress tests are failing even with comparatively low tol.
        // Also tol<=1e-9 seems to make sanity check fail in lots of places even with larts sanityCheckTol.
        // Blech.

        //double hullTol = 1e-40;
        //double hullTol = 1e-39;
        double hullTol = 1e-39;
        double sanityCheckTol = 1e-9;

        int answer[][][] = convexHull(verts, hullTol);
        long t1 = System.currentTimeMillis();
        do { if (!(answer != null)) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1098 +"): " + "answer != null" + ""); } while (false);
        do { if (!((answer.length)==(3))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1099 +"): (" + "answer.length" + ")" + "==" + "(" + "3" + ") ("+(answer.length)+" vs. "+(3)+")"); } while (false);
        int hull[][] = answer[0];
        int adjs[][] = answer[1];
        int back[][] = answer[2];
        do { if (!((hull.length)==(adjs.length))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1103 +"): (" + "hull.length" + ")" + "==" + "(" + "adjs.length" + ") ("+(hull.length)+" vs. "+(adjs.length)+")"); } while (false);
        System.err.println("convex hull of "+verts.length+" verts in "+d+"d returned "+hull.length+" simplices in "+(t1-t0)/1000.+" secs.");

        System.out.println("        " + "hull" + " = " + Arrays.toStringCompact(hull));
        System.out.println("        " + "adjs" + " = " + Arrays.toStringCompact(adjs));
        System.out.println("        " + "back" + " = " + Arrays.toStringCompact(back));
        // TODO: pass in adjs and back indices, and sanity check them
        try
        {
            sanityCheckConvexHull(d, verts, hull, sanityCheckTol);
        }
        //catch (AssertionError e)
        //catch (Exception e)
        catch (Error e)
        {
            System.out.println("Oh no!!!!!!!!!!!!!! CHECK happening in sanity check; here's the verts");
            System.out.println("        " + "verts" + " = " + Arrays.toStringCompact(verts));
            throw e;
        }
        System.out.println("======================");
        return hull; // caller usually ignores
    } // testTheseVerts


    /**
    * Little confidence test program.
    */
    public static void main(String args[])
    {
        if (true)
        {
            // See what a 4d cross polytope goes through.
            double[][] allVerts = {
                {1,0,0,0},
                {0,1,0,0},
                {0,0,1,0},
                {0,0,0,1},
                {-1,0,0,0},
                {0,-1,0,0},
                {0,0,-1,0},
                {0,0,0,-1},
            };
            for (int nVerts = 5; nVerts <= allVerts.length; ++nVerts) {
                System.out.println("  nVerts = "+nVerts);
                double[][] verts = (double[][])Arrays.subarray(allVerts, 0, nVerts);
                testTheseVerts(4, verts);
            }
            if (false)
            {
                System.err.println("EXITING EARLY");
                System.exit(33);
            }
        }
        if (true)
        {
            // this was failing at one time.
            // it was a problem with perturbed heights persisting and being compared wrongly with actual heights.
            //debugLevel = 3;
            testTheseVerts(2, new double[][] {
                {1.0,-1.0},
                {-1.0,-0.5643178129536277},
                {1.0,-1.0},{-1.0,-1.0},
            });
        }
        if (true)
        {
            // this was failing at one time
            //debugLevel = 3;
            testTheseVerts(2, new double[][] {
                {1.0,0},
                {1.0,1.0},
                {0.9999999999999997,1.0},
            });
        }
        if (false)
        {
            // Hmm, as of this writing, this one fails with tol=1e-40, passes with tol=1e-39:
            // assert okSoFar.
            // Check fail is in sanityCheck but doesn't seem to depend on sanityCheckTol,
            // so is actually a topological consistency violation.
            // This is from the first set of coplanar stress tests in 5d below (sometimes commented out).
            debugLevel = 3;
            testTheseVerts(5, new double[][] {
              {1.0,0.0,0.0,0.0,0.0},
              {1.0,1.0,1.0,1.0,1.0},
              {0.0625,0.125,0.25,0.5,1.0},
              {0.012345679012345678,0.03703703703703703,0.1111111111111111,0.3333333333333333,1.0},
              {0.0039062499999999996,0.015624999999999998,0.06249999999999999,0.24999999999999997,0.9999999999999999},
              {0.0015999999999999999,0.007999999999999998,0.039999999999999994,0.2,1.0},
              {7.716049382716049E-4,0.004629629629629629,0.027777777777777776,0.16666666666666666,1.0},
              {4.1649312786339027E-4,0.0029154518950437317,0.02040816326530612,0.14285714285714285,1.0},
              {2.4414062499999997E-4,0.0019531249999999998,0.015624999999999998,0.12499999999999999,0.9999999999999999},
              {1.5241579027587258E-4,0.0013717421124828533,0.01234567901234568,0.11111111111111112,1.0},
              {1.0E-4,0.0010000000000000002,0.01,0.10000000000000002,1.0},
              {6.830134553650708E-5,7.513148009015778E-4,0.008264462809917357,0.09090909090909091,1.0},
            });
        }
        if (false)
        {
            // Similar, from 2nd set of coplanar stress tests in 5d.
            // This one passes with 1e-38, fails with 1e-39.
            debugLevel = 3;
            testTheseVerts(5, new double[][] {
                {1.0,0.0,0.0,0.0,0.0},
                {0.8944271909999157,0.8944271909999157,0.8944271909999157,0.8944271909999157,0.8944271909999157},
                {0.10830607221477648,0.21661214442955296,0.4332242888591059,0.8664485777182118,1.0},
                {0.023279432715071997,0.069838298145216,0.20951489443564797,0.6285446833069439,1.0},
                {0.007564424205060763,0.03025769682024305,0.1210307872809722,0.4841231491238888,1.0},
                {0.00313534703129224,0.0156767351564612,0.07838367578230601,0.39191837891153003,1.0},
                {0.001521625471198608,0.00912975282719165,0.05477851696314989,0.3286711017788994,1.0},
                {8.244425825595157E-4,0.00577109807791661,0.04039768654541627,0.2827838058179139,1.0},
                {4.844515342339992E-4,0.0038756122738719937,0.03100489819097595,0.2480391855278076,1.0},
                {3.029440604000662E-4,0.002726496543600596,0.024538468892405362,0.22084622003164825,1.0},
                {1.9899748743127386E-4,0.0019899748743127384,0.019899748743127388,0.19899748743127385,1.0},
            });
        }



        if (true)
        {
            // Do a regular polygon in 2d.
            //debugLevel = 3;
            //for (int nVerts = 2; nVerts <= 100; ++nVerts)
            for (int nVerts = 5000; nVerts <= 5000; ++nVerts)
            {
                {System.out.print("        "); System.out.println("nVerts" + " = " + (nVerts));};
                int d = 2;
                double verts[][] = new double[nVerts][d];
                for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                {
                    double angle = iVert * (2*Math.PI/nVerts);
                    verts[iVert][0] = Math.cos(angle);
                    verts[iVert][1] = Math.sin(angle);
                }
                int hull[][] = testTheseVerts(d, verts);
                do { if (!((hull.length)==(nVerts))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1239 +"): (" + "hull.length" + ")" + "==" + "(" + "nVerts" + ") ("+(hull.length)+" vs. "+(nVerts)+")"); } while (false);
            }
        }
        if (true)
        {
            // Regular tet in 3d. Simple.
            //debugLevel = 3;
            double verts[][] = {
                {1,-1,-1},
                {-1,1,-1},
                {-1,-1,1},
                {1,1,1},
            };
            int hull[][] = testTheseVerts(3, verts);
            do { if (!((hull.length)==(4))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1253 +"): (" + "hull.length" + ")" + "==" + "(" + "4" + ") ("+(hull.length)+" vs. "+(4)+")"); } while (false);
        }
        if (true)
        {
            // Regular pentagon in 3d was omitting a point.
            // Test regular polygons in 3d, 2 to 100 sides.
            //debugLevel = 3;
            for (int nVerts = 2; nVerts <= 100; ++nVerts)
            {
                {System.out.print("        "); System.out.println("nVerts" + " = " + (nVerts));};
                int d = 3;
                double verts[][] = new double[nVerts][d];
                for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                {
                    double angle = iVert * (2*Math.PI/nVerts);
                    verts[iVert][0] = Math.cos(angle);
                    verts[iVert][1] = Math.sin(angle);
                    verts[iVert][2] = 0.;
                    //verts[iVert][2] = Math.random();
                }
                int hull[][] = testTheseVerts(d, verts);
                do { if (!((hull.length)==((nVerts-2)*2))) throw new Error("CHECK failed at "+"com/donhatchsw/util/ConvexHull.prejava"+"("+1274 +"): (" + "hull.length" + ")" + "==" + "(" + "(nVerts-2)*2" + ") ("+(hull.length)+" vs. "+((nVerts-2)*2)+")"); } while (false);
            }
        }
        if (true)
        {
            //debugLevel = 3;
            testTheseVerts(2, new double[][] {{1,1},{-1,1},{-1,-1}}); // just a triangle in 2d
            testTheseVerts(2, new double[][] {{1,1},{-1,1},{-1,-1},{1,-1}}); // just a square in 2d
            testTheseVerts(2, new double[][] {{0,0},{1,1},{-1,1},{-1,-1}}); // right triangle with vert in middle of diagonal
            testTheseVerts(2, new double[][] {{0,0},{1,1},{-1,1},{-1,-1},{1,-1}}); // just a square in 2d with one in the middle
        }
        if (true)
        {
            // This one is currently failing the test with tol=1e-10:
            // there's a ridge that occurs 4 times.
            // (fixed apparently)
            //debugLevel = 3;
            testTheseVerts(3, new double[][] {
                {.2,-1.,.6},
                {1.,-0.8,-0.348},
                {.9999999999907109,-0.75,-0.07},
                {1,-0.67,0.185},
                {1,-0.5833333333337675,0.407},
                {1,-0.5,0.6},
                {.999,0.8333333333349515,-0.348},
                {1,.9,-0.66},
                {-1,1,1},
                {1,1,-1},
            });
        }
        if (true)
        {
            // This one is currently failing the test with tol=1e-9 and tol=1e-10:
            // there's a ridge that occurs 4 times.
            // (fixed apparently)
            //debugLevel = 3;
            testTheseVerts(3, new double[][] {
                {0.19999999999752163,-1.0,-0.0608695652201183},
                {0.19999999999751436,-0.9166666666666868,0.13913043478051065},
                {0.33333333333282594,-0.9166666666689404,0.026086956515650562},
                {0.8666666666602593,-0.8333333333320317,-0.4173913043485713},
                {1.0,-0.8333333333356353,-0.6173913043580689},
                {0.866666666661337,-0.7499999999994108,-0.2521739130452495},
                {0.9999999999907109,-0.7499999999977524,-0.4521739130414001},
                {-0.2000000000010617,-0.6666666666676166,0.8695652173907314},
                {-0.06666666666832106,-0.6666666666670459,0.8086956521736584},
                {0.8666666666634107,-0.6666666666671198,-0.10434782609068219},
                {0.9999999999995162,-0.6666666666683736,-0.3043478260948236},
                {-0.200000000001057,-0.5833333333342121,0.9999999999999999},
                {-0.06666666666827076,-0.5833333333337624,0.9391304347827705},
                {0.8666666666662302,-0.5833333333348921,0.026086956515653622},
                {0.999999999996486,-0.5833333333337675,-0.17391304348220885},
                {0.9999999999956884,-0.5000000000001696,-0.0608695652201183},
                {0.9999999999999829,0.8333333333349515,-0.6173913043580528},
                {0.9999999999980657,0.9166666666673757,-0.8000000000085122},
                {-0.9999999999999999,1.0,0.1739130434753577},
                {0.9999999999920242,0.9999999999970313,-1.0000000000000002}
            });
        }

        if (true)
        {
            // these failed with tol=1e-12.
            // that's not entirely surprising, since they are flirting with tol.
            // changed test tol to 1e-9 as a result.
            testTheseVerts(3, new double[][] {
                {1, .5, 1},
                {-0.9999999999988493, 1, -1},
                {-0.9999999999985804, .5, -0.64},
                {-1, 0, -0.38},
                {-1, -.5, -0.25},
                {-1, -1, -0.25},
            });
            testTheseVerts(3, new double[][] {
                {-0.9999999999989534,-1.0,-0.17948717948721649},
                {-0.9999999999994659,-0.4999999999998996,-0.230769230769602},
                {-1.0,3.7423153752734264E-13,-0.3846153846161367},
                {-0.9999999999985804,0.4999999999998616,-0.6410256410254186},
                {1.0,0.5000000000002361,1.0000000000000002},
                {-0.9999999999988493,1.0,-1.0},
            });
        }
        if (true)
        {
            testTheseVerts(3, new double[][] {{1,1,0},{-1,1,0},{-1,-1,0},{.5,-.5,.1}}); // not coplanar, not problematic
            testTheseVerts(3, new double[][] {{1,-1,0},{-1,-1,0},{-1,1,0},{.5,.5,0}}); // four coplanar was problematic
            testTheseVerts(3, new double[][] {{1,-1,0},{-1,-1,0},{-1,1,0},{1,1,.1}});
        }
        if (true)
        {
            // Some problematic cases that are no longer...
            // Note that coords are huge, so not sure how much we care.
            testTheseVerts(3, new double[][] {{-1.0,0.6049382716049382,-0.710306904419669},{1.0,1.0,-0.5235452788122057},{-0.01562500000000001,-1.0,-0.22752077864939793}}); // succeeds
            testTheseVerts(3, new double[][] {{-1.0,0.6049382716049382,-0.710306904419669},{1.0,1.0,-0.5235452788122057},{-0.01562500000000001,-1.0,-0.22752077864939793}}); // succeeds
            testTheseVerts(3, new double[][] {{-1.0,0.6049382716049382,-1.023660131220196E16},{1.0,1.0,-7.545082632224744E15},{-0.015625000000000024,-1.0,-3.278919980622317E15}}); // assert-failed "bestVert!=-1" when was using non-robust calcParallelotopeContentSquared
            testTheseVerts(3, new double[][] {{-1.0,1.0,-8.011042245140311E15},{-0.553030303030303,-1.0,-2.335983685036597E15},{1.0,0.811023622047244,-1.3737616349472596E16}}); // returns null (fixed I guess)
        }


        if (true)
        {
            java.util.Random rng = new java.util.Random(0);
            int minDim = 0;
            int maxDim = 5;
            int minVerts = 0;
            int maxVerts = 20;
            int nTestsPerSize = 10;
            for (int d = minDim; d <= maxDim; ++d)
            {
                for (int nVerts = minVerts; nVerts <= maxVerts; ++nVerts)
                {
                    for (int iTest = 0; (iTest) < (nTestsPerSize); ++iTest)
                    {
                        System.out.println("======================");
                        System.out.println("    Testing d="+d+" nVerts="+nVerts+" iTest="+iTest+"/"+nTestsPerSize+"");
                        double verts[][] = new double[nVerts][];
                        if (iTest == 0)
                        {
                            double invScale = Math.pow(nVerts, d); // if nVerts is 0 we'll never use it
                            for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                            {
                                verts[iVert] = new double[d];
                                for (int i = 0; (i) < (d); ++i)
                                    verts[iVert][i] = Math.pow(iVert, i+1)/invScale;
                            }
                        }
                        else
                            for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                                verts[iVert] = VecMath.random(d, rng);

                        testTheseVerts(d, verts);

                        // move all verts to sphere and do it again
                        for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                            VecMath.normalize(verts[iVert], verts[iVert]);
                        testTheseVerts(d, verts);

                        if (false)
                        {
                            // stress test with lots of co(hyper)planar verts:
                            // move all verts to cube
                            if (d >= 1)
                            {
                                for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                                    VecMath.vxs(verts[iVert], verts[iVert], 1./Math.abs(verts[iVert][VecMath.maxabsi(verts[iVert])]));
                                testTheseVerts(d, verts);

                                if (true)
                                {
                                    // rotate randomly,
                                    // and do it again
                                    double rot[][] = new double[d][d];
                                    for (int iRow = 0; (iRow) < (d-1); ++iRow)
                                        for (int iCol = 0; (iCol) < (d); ++iCol)
                                            rot[iRow][iCol] = Math.random();
                                    VecMath.extendAndOrthogonalize(d-1, d, rot, rot);

                                    for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                                        verts[iVert] = VecMath.vxm(verts[iVert], rot);

                                    testTheseVerts(d, verts);

                                    // rotate back
                                    for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                                        verts[iVert] = VecMath.mxv(rot, verts[iVert]);
                                }
                            }
                        }

                        if (false)
                        {
                            // another stress test with even more co(hyper)linear verts:
                            // scale by 2, clamp back to cube, and do it again
                            // (using same verts from previous, not that it matters since this
                            // clamps them down more)
                            for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                                for (int i = 0; (i) < (d); ++i)
                                    verts[iVert][i] = ((2*verts[iVert][i])<=(-1.)?(-1.):(2*verts[iVert][i])>=(1.)?(1.):(2*verts[iVert][i]));
                            testTheseVerts(d, verts);

                            if (true)
                            {
                                // rotate randomly,
                                // and do it again
                                double rot[][] = new double[d][d];
                                for (int iRow = 0; (iRow) < (d-1); ++iRow)
                                    for (int iCol = 0; (iCol) < (d); ++iCol)
                                        rot[iRow][iCol] = Math.random();
                                VecMath.extendAndOrthogonalize(d-1, d, rot, rot);

                                for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                                    verts[iVert] = VecMath.vxm(verts[iVert], rot);

                                testTheseVerts(d, verts);

                                // rotate back
                                for (int iVert = 0; (iVert) < (nVerts); ++iVert)
                                    verts[iVert] = VecMath.mxv(rot, verts[iVert]);
                            }
                        }
                    }
                }
            }
        }
    } // main

} // class ConvexHull
