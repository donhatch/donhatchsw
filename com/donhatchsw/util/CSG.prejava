/*
* Copyright (c) 2005,2006 Don Hatch Software
*/

//
// CSG.prejava
//
// Contains functions for doing boolean operations (union, intersection, diff)
// on polytopes (i.e. polygons or polyhedra or ...).
//
// Depends on:
//      VecMath.prejava
//      SortStuff.prejava
//
/*
    Bugs to fix:
        - fix signs like I said I would (what did I say? I can't recall)
        Was:
            -dim=1: A&A arrayIndexOutOfBounds: -1, in SortStuff.swap
            -dim=1: A-A arrayIndexOutOfBounds, same
            -dim=1: A|A arrayIndexOutOfBounds, same

            -dim=2: A&A Assertion failed at CSG.prejava(1240): Arrays.indexOf(slicee.p.contributingHyperplanes, hyperplane) == -1
            -dim=2: A-A same assertion failure
            -dim=2: A|A same assertion failure
        Now:
            -dim=1: A&A gives bogus bombed-out structure
            -dim=2: A&A Assumption failed at CSG.prejava(2392): n == list.length
            and simlarly for the other tests listed above
        Bleah, looking it over again, it seems like the algorithm
        can't handle A&A-- it computes the boundary of the intersection
        of A&B as bd(A)&B union A&bd(B), which is null...
        need a fundamental insight to fix this.

    To consider:
        - Should try to explain what the signs mean.  Some things
          to maybe mention...
            - note, the sum of signed vertices on an edge
              is actually the directed length of the edge
            - going back over an edge (or face) in the opposite
              direction means erasing it
            - for a proper edge, the sum of all vert's signs must be 0
              (otherwise it's a ray or something)
            - for a closed loop or surface, the boundary must have
              no boundary, i.e. the sum of the boundary of the boundary
              must be zero.
            - intersection is really min, union is really max,
              complement is really 1-.  The allowed polytopes
              are those that are constant density outside
              a bounded region; that constant density
              is called "initialDensity".
              The most common ones are finite and cofinite (i.e.
              those that are density 1 on a finite region and 0 elsewhere,
              and vice-versa.)
              (Might also allow more some day, but not at the moment.)
            - hmm, assuming the a.e. constant density restriction,
              this means all but top level polytopes
              must have initial density 0.
            - interesting, if we have a varying-positive-density
              polytope and we want the density-1 version,
              just intersect (i.e. min) it with 1.

        - does initialDensity have a meaning for vertices? (should it be 1? -1?)
        - make params X,Y instead of A,B? (since A,B are typical
              arguments; this might make debugging less confusing)
              But then I'll have to think of an alternative
              for alpha,beta that is not confusing...
              yamma, zigga? yalpha, zeta?
              ha, my humor is above everyone's head.
*/

package com.donhatchsw.util;

#include "macros.h"


/**
*  Contains functions for doing n-dimensional Constructive Solid Geometry (CSG),
*  that is, boolean operations (union, intersection, diff)
*  on polytopes (i.e polygons or polyhedra or ...).
*  <p>
*  The objects that the boolean operators operate on
*  are CSG.Polytope and CSG.SPolytope (signed polytope).
*  The simplest way to create a CSG.Polytope
*  is probably by using the PolyCSG class.
*  Some primitive CSG.SPolytopes can also be made using makePolygon(),
*  makeSimplex(), and makeHypercube().
*  <p>
*  Caveats: not at all robust about concident or coplanar elements;
*  really only works reliably if everything is in general position.
*  <p>
*  Depends on classes:
*  <ul>
*       <li> Arrays </li>
*       <li> VecMath </li>
*       <li> SortStuff </li>
*       <li> FuzzyPointHashTable </li>
*  </ul>
*/
public final class CSG
{
    private CSG() {} // uninstantiatable
    //
    // Debugging setting...
    // I just set this appropriately and recompile.
    // XXX note, not final so that it can be changed in main.
    // XXX this should maybe be a compile-time option,
    // XXX since making it final gets rid of a lot of code.
    //
    //public static int verboseLevel = 2; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    //public static int verboseLevel = 1; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    //public static int verboseLevel = 0; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    public static int verboseLevel = -1; // 3 = show gory details (XXX which are really gory and I should probably do away with)

    //
    // Data structures...
    //

        private static long nIds = 0; // so we can give a unique integer id to everything ever created
        private static Object nIdsLock = new Object(); // for synchronization
        private static java.util.Random randomGenerator = new java.util.Random(0);

        /**
        *  A hyperplane is the set of all
        *  points p such that (p dot normal) = offset.
        *  The closed halfspace it bounds is the set of all points p
        *  such that (p dot normal) <= offset.
        */
        public static class Hyperplane
        {
            public long id;
            public double normal[];
            public double offset;
            public double spanningPoints[][]; // optional; avoids recalculation of points (and resulting roundoff error) when points was the original representation.  XXX this idea seems to be lacking... e.g. if there are more than dim(plane)+1 points on the polygon, then we have to omit some.  think about this :-( )
            /** Creates a Hyperplane from a plane equation. */
            public Hyperplane(double normal[], double offset)
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.normal = normal;
                this.offset = offset;
                this.spanningPoints = null;
            } // Hyperplane from plane equation
            /** Creates a Hyperplane from a set of dim spanning points. */
            public Hyperplane(double spanningPoints[][])
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.spanningPoints = spanningPoints;

                assert(false); // XXX implement me! normal should be cross product of points vectors
                this.offset = VecMath.dot(this.normal,
                                          this.spanningPoints[0]);
            } // Hyperplane from spanning points

            public String toString()
            {
                return VecMath.toString(normal) + " " + offset;
            }
        } // class Hyperplane

        /**
        *  Unsigned (unoriented) polytope,
        *  defined by its boundary.
        *  <p>
        *  Note, the "dim" member wasn't stored here originally since
        *  it can be inferred as (dim of planes[0].normal) - (# of planes),
        *  except when (# of planes) == 0, in which case we can still infer
        *  it (recursively) as (dim of facets)+1, unless there
        *  are no facets... This was giving me a headache,
        *  so I'm just storing it explicitly here.
        *  <p>
        *  Similarly for "fullDim", only more so.
        */
        public static class Polytope
        {
            public long id;
            public int dim;     // dimension of the polytope
            public int fullDim; // dimension of the space it lives in
            public SPolytope facets[];
            public Hyperplane contributingHyperplanes[]; // the hyperplanes whose intersection is the space of this Polytope, in sorted order. // XXX sigh, should probably be a HashableSortedArray so we don't have to keep creating and destorying them every time we want to look it up... but that means this definition is getting more and more obscured
            public Object aux; // user data; creator can set this if desired
            private double _coords[];      // if vertex, null otherwise.  XXX should probably calculate only on demand, but then need a way to differentiate between dirty and nonexistent (for example, this is needed in getBBox below). XXX ctually not currently calculated at all.
            private double _bbox[/*2*/][]; // bounding box of all vertices, so it can be finite even if the polytope is infinite (co-finite).  calculated Lazily via getBBox().
            private Polytope[/*dim+1*/][] _allElements; // sorted lists of vertices, edges, ..., ridges, facets, calculated lazily via getAllElements()
            private int[/*dim+1*/][][/*dim+1*/][] _allIncidences; // calculated lazily via getAllElements

            public Polytope(int dim,
                            int fullDim,
                            SPolytope facets[],
                            Hyperplane contributingHyperplanes[],
                            Object aux)
            {
                if (verboseLevel >= 3)
                    System.out.println("in Polytope ctor");
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.dim = dim;
                this.fullDim = fullDim;
                this.facets = facets;
                this.contributingHyperplanes = contributingHyperplanes;
                this.aux = aux;
                this._coords = null;
                this._bbox = null;
                this._allElements = null;

                if (verboseLevel >= 3)
                {
                    System.out.print("    making "+this.id+": [");
                    if (facets == null)
                        System.out.println("(null)");
                    else
                        FORI (iFacet, facets.length)
                        {
                            System.out.print(" "
                                           + (facets[iFacet].sign==1?"+":facets[iFacet].sign==-1?"-":facets[iFacet].sign==0?"!":"?")
                                           + facets[iFacet].p.id);
                        }
                    System.out.println(" ]");
                }

                if (facets != null) // XXX maybe shouldn't be allowed, but makeHyperCube does it
                {
                    int nFacets = facets.length;
                    FORI (iFacet, nFacets)
                    {
                        Polytope facet = facets[iFacet].p;
                        assert(facet.fullDim == fullDim);
                        assert(facet.dim == dim-1);
                    }
                }

                if (verboseLevel >= 3)
                    System.out.println("out Polytope ctor");
            }

            // Note this just copies the pointer,
            // so don't give it a scratch buffer that you will overwrite!
            // (should take a const double[]).
            public void setCoords(double coords[])
            {
                _coords = coords;
            }

            // Returns a pointer to coords.
            // It is illegal to modify the contents
            // (should return const double[]).
            public double[] getCoords()
            {
                if (_coords == null)
                {
                    assert(dim == 0); // must be a vertex
                    _coords = intersectHyperplanes(contributingHyperplanes);
                }
                assert(_coords != null); // XXX not sure if I'm preventing this
                return _coords;
            } // getCoords

            //
            // When this is called, it is assumed
            // that the coords and connectivity
            // will not henceforth change.
            // XXX well I'm not completely firm on that, but if they do change, the bbox will have to be marked dirty, probably by setting it to null.
            //
            public double[/*2*/][] getBBox()
            {
                if (_bbox == null)
                {
                    // XXX should maybe say "if it's a vertex", i.e. if contributingHyperplanes.length == contributingHyperplanes[0].normal.length
                    if (dim == 0)
                    {
                        double coords[] = getCoords();
                        _bbox = new double[/*2*/][] {coords, coords};
                    }
                    else
                    {
                        _bbox = new double[2][fullDim];
                        VecMath.fillvec(_bbox[0], Double.POSITIVE_INFINITY);
                        VecMath.fillvec(_bbox[1], Double.NEGATIVE_INFINITY);
                        FORI (iFacet, facets.length)
                        {
                            double facetBBox[][] = facets[iFacet].p.getBBox();
                            FORI (iDim, _bbox[0].length)
                            {
                                _bbox[0][iDim] = MIN(_bbox[0][iDim], facetBBox[0][iDim]);
                                _bbox[1][iDim] = MAX(_bbox[1][iDim], facetBBox[1][iDim]);
                            }
                        }
                    }
                }
                return _bbox;
            } // getBBox

            /**
            * Get a list of all verts, edges, faces, ..., ridges, facets, self
            * of this polytope.
            * getAllElements()[iDim] is the list of iDim-dimensional sub-polytopes.
            */
            public Polytope[/*dim+1*/][] getAllElements()
            {
                if (_allElements == null)
                {
                    class VisitedAux
                    {
                        public Object savedAux;
                        public VisitedAux(Object savedAux)
                        {
                            this.savedAux = savedAux;
                        }
                    }

                    java.util.Vector lists[] = new java.util.Vector[dim+1];
                    {
                        FORI (iDim, dim+1)
                            lists[iDim] = new java.util.Vector();
                        java.util.Vector flatList = new java.util.Vector();

                        this.aux = new VisitedAux(this.aux); // mark it visited when queued
                        flatList.addElement(this);
                        FORI (flatIndex, flatList.size()) // while flatList.size() is increasing!
                        {
                            Polytope elt = (Polytope)flatList.get(flatIndex);
                            lists[elt.dim].addElement(elt);
                            FORI (iFacet, elt.facets.length)
                            {
                                Polytope facet = elt.facets[iFacet].p;
                                if (!(facet.aux instanceof VisitedAux)) // save even when elt.aux is null
                                {
                                    facet.aux = new VisitedAux(facet.aux); // mark it visited when queued
                                    flatList.addElement(facet);
                                }
                            }
                        }
                    }

                    _allElements = new Polytope[dim+1][];
                    FORI (iDim, dim+1)
                    {
                        _allElements[iDim] = new Polytope[lists[iDim].size()];
                        lists[iDim].copyInto(_allElements[iDim]);
                        SortStuff.sort(_allElements[iDim],
                                       new SortStuff.Comparator() {
                                           public int compare(Object _a, Object _b)
                                           {
                                               Polytope a = (Polytope)_a;
                                               Polytope b = (Polytope)_b;
                                               return a.id < b.id ? -1 :
                                                      a.id > b.id ? 1 : 0;
                                           }
                                       });
                        FORI (iElt, _allElements[iDim].length)
                        {
                            Polytope elt = _allElements[iDim][iElt];
                            elt.aux = ((VisitedAux)elt.aux).savedAux;
                        }
                    }
                } // if _allElements == null
                return _allElements;
            } // getAllElements()

            /**
            * Get a list of all the incidences between elements
            * occurring inside this polytope.
            *     getAllIndices()[iDim][iElt][jDim]
            * is the list of all indices (into getAllElements()[jDim])
            * of jDim-dimensional elements
            * that are incident on iDim-dimensional element
            *     getAllElements()[iDim][iElt].
            * The result of this function gets cached, so it is not time-consuming
            * to call it multiple times.
            */
            public int[/*dim+1*/][][/*dim+1*/][] getAllIncidences()
            {
                if (_allIncidences == null)
                {
                    Polytope allElts[][] = getAllElements();

                    java.util.Vector lists[][][] = new java.util.Vector[allElts.length][][];
                    FORI (iDim, dim+1)
                    {
                        lists[iDim] = new java.util.Vector[allElts[iDim].length][];
                        FORI (iElt, allElts[iDim].length)
                        {
                            lists[iDim][iElt] = new java.util.Vector[dim+1];
                            FORI (jDim, dim+1)
                                lists[iDim][iElt][jDim] = new java.util.Vector();
                        }
                    }

                    // Mark each element temporarily with its index in allElts,
                    // so we don't have to do time consuming searches...
                    class GlobalIndexAux
                    {
                        public int globalIndex;
                        public Object savedAux;
                        public GlobalIndexAux(int globalIndex, Object savedAux)
                        {
                            this.globalIndex = globalIndex;
                            this.savedAux = savedAux;
                        }
                    }
                    FORI (iDim, dim+1)
                    FORI (iElt, allElts[iDim].length)
                    {
                        Polytope elt = allElts[iDim][iElt];
                        elt.aux = new GlobalIndexAux(iElt, elt.aux);
                    }


                    FORI (iDim, dim+1)
                    FORI (iElt, allElts[iDim].length)
                    {
                        Polytope elt = allElts[iDim][iElt];
                        Polytope allEltsOfElt[][] = elt.getAllElements();
                        FORI (jDim, elt.dim+1)
                        FORI (jEltLocal, allEltsOfElt[jDim].length)
                        {
                            Polytope eltElt = allEltsOfElt[jDim][jEltLocal];
                            int jEltGlobal = ((GlobalIndexAux)eltElt.aux).globalIndex;
                            if (false)
                                System.out.println("    elt "+dimToPrefix(iDim)+elt.id
                                         +"("+iDim+")"
                                         +" has eltElt "+dimToPrefix(jDim)+eltElt.id
                                         +"("+jEltGlobal+")"
                                         );
                            lists[jDim][jEltGlobal][iDim].addElement(new Integer(iElt));
                            if (jDim != iDim)
                                lists[iDim][iElt][jDim].addElement(new Integer(jEltGlobal));
                        }
                    }

                    // restore old auxs...
                    FORI (iDim, dim+1)
                    FORI (iElt, allElts[iDim].length)
                    {
                        Polytope elt = allElts[iDim][iElt];
                        elt.aux = ((GlobalIndexAux)elt.aux).savedAux;
                    }


                    _allIncidences = new int[lists.length][][][];
                    FORI (iDim, dim+1)
                    {
                        _allIncidences[iDim] = new int[lists[iDim].length][][];
                        FORI (iElt, allElts[iDim].length)
                        {
                            Polytope allEltsOfElt[][] = allElts[iDim][iElt].getAllElements();
                            _allIncidences[iDim][iElt] = new int[lists[iDim][iElt].length][];
                            FORI (jDim, dim+1)
                            {
                                java.util.Vector list = lists[iDim][iElt][jDim];
                                int array[] = new int[list.size()];
                                // list.copyInto(array); // argh, copyInto won't do it into an int[], how lame!
                                FORI (jElt, array.length)
                                    array[jElt] = ((Integer)list.get(jElt)).intValue();
                                SortStuff.sort(array); // since _allIncidences[iDim][iElt][jDim] is a list of indices into allElts[jDim], we just need the indices in increasing order.
                                _allIncidences[iDim][iElt][jDim] = array;
                            }
                        }
                    }

                    if (false)
                    {
                        System.out.println("All incidences:");
                        PRINTARRAY(_allIncidences);
                        FORI (iDim, _allIncidences.length)
                        {
                            FORI (iElt, _allIncidences[iDim].length)
                            {
                                Polytope elt = allElts[iDim][iElt];
                                System.out.println("    "+dimToPrefix(iDim)+elt.id+":");
                                FORI (jDim, _allIncidences[iDim][iElt].length)
                                {
                                    System.out.print("    ");
                                    FORI (jElt, _allIncidences[iDim][iElt][jDim].length)
                                    {
                                        Polytope inc = allElts[jDim][_allIncidences[iDim][iElt][jDim][jElt]];
                                        System.out.print(" "+dimToPrefix(jDim)+inc.id);
                                    }
                                    System.out.println("    ");
                                }
                            }
                            System.out.println();
                        }
                    }
                }
                return _allIncidences;
            } // getAllIncidences

            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails,
                                   java.util.Hashtable printedAlready)
            {
                String nl = System.getProperty("line.separator");
                if (printedAlready == null)
                    printedAlready = new java.util.Hashtable();

                StringBuffer sb = new StringBuffer();
                if (showGoryDetails)
                {
                    sb.append("Polytope "+id+" {" + nl);
                    if (printedAlready.containsKey(this))
                    {
                        sb.append(indentString + "    (printed already)" + nl);
                    }
                    else
                    {
                        printedAlready.put(this,this);

                        if (showAux)
                            sb.append(indentString + "    (aux="+aux+")");
                        sb.append(indentString + "    "+facets.length+" facet"+(facets.length==1?"":"s")+": {" + nl);
                        FORI (iFacet, facets.length)
                        {
                            sb.append(indentString + "        " + facets[iFacet].toString(indentString+"        ", showAux, showGoryDetails, printedAlready) + nl);
                        }
                        sb.append(indentString + "    }" + nl);

                        sb.append(indentString + "    "+contributingHyperplanes.length+" contributing hyperplane"+(contributingHyperplanes.length==1?"":"s")+": {" + nl);
                        FORI (iHyperplane, contributingHyperplanes.length)
                        {
                            sb.append(indentString + "        " + contributingHyperplanes[iHyperplane] + nl);
                        }
                        sb.append(indentString + "    }" + nl);

                        sb.append(indentString + "    _coords = " + VecMath.toString(_coords) + nl);
                        sb.append(indentString + "    _bbox = " + VecMath.toString(_bbox) + nl);
                    }
                    sb.append(indentString + "}");
                }
                else
                {
                    sb.append(dimToPrefix(dim));
                    sb.append(id);

                    if (showAux)
                    {
                        sb.append(" (aux="+aux+")");
                    }

                    //sb.append("[");
                    if (printedAlready.containsKey(this))
                    {
                        if (true)
                            sb.append(" (see above)");
                    }
                    else
                    {
                        printedAlready.put(this,this);
                        FORI (iHyperplane, contributingHyperplanes.length)
                        {
                            sb.append("  (" + contributingHyperplanes[iHyperplane] + ")");
                        }
                        if (dim == 0)
                        {
                            if (_coords != null)
                            {
                                sb.append("  :  " + VecMath.toString(_coords));
                                // XXX Should probably do the below anyway,
                                // XXX and also keep track
                                // XXX of whether coords have been
                                // XXX computed or set explicitly
                            }
                            else
                            {
                                // Find explicit coords of the vertex.
                                // We want column vector c
                                // such that
                                //    normal0 dot c == offset0
                                //    normal1 dot c == offset1
                                //    normal2 dot c == offset2
                                // etc.
                                // so c = inv(normalsMatrix) * offsetsColumnVector.

                                int nRows = contributingHyperplanes.length;
                                double normalsMatrix[][] = new double[nRows][nRows];
                                double offsetsColumnVector[][] = new double[nRows][1];
                                FORI (iRow, nRows)
                                {
                                    VecMath.copyvec(normalsMatrix[iRow], contributingHyperplanes[iRow].normal);
                                    offsetsColumnVector[iRow][0] = contributingHyperplanes[iRow].offset;
                                }
                                // replace normalsMatrix by its inverse,
                                // replace the offsets in c by the solution
                                try {
                                    VecMath.gaussj(normalsMatrix, nRows,
                                                   offsetsColumnVector, 1);
                                    double c[] = VecMath.getcolumn(offsetsColumnVector, 0);

                                    sb.append("  ->  " + VecMath.toString(c));
                                }
                                catch (Exception e)
                                {
                                    sb.append("  -> !!!!!!!!!!!!!!!!!! singular matrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                                }
                            }
                        }
                        FORI (iFacet, facets.length)
                        {
                            sb.append(nl + indentString + "    ");
                            assert(facets[iFacet] != null);
                            sb.append(facets[iFacet].toString(indentString+"    ", showAux, false, printedAlready));
                            if (iFacet+1 < facets.length)
                                sb.append(" ");
                        }
                    }
                    //sb.append("]");
                }
                return sb.toString();
            } // Polytope.toString
            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails)
            {
                return toString(indentString,
                                showAux,
                                showGoryDetails,
                                null);
            }
            public String toString(String indentString,
                                   boolean showAux)
            {
                return toString(indentString,
                                showAux,
                                false);
            }
            public String toString(String indentString)
            {
                return toString(indentString,
                                false);
            }
            public String toString(boolean showAux)
            {
                return toString("",
                                showAux);
            }
            public String toString()
            {
                return toString("",
                                false);
            }

            /** Parses a polytope from a string the "pcalc" program's format. */
            // XXX should really do this from a reader, then fromString... could just hook up a StringReader and go
            public static Polytope fromStringInPcalcFormat(String s)
            {
                //System.out.println("scanning...");
                //System.out.flush();
                Polytope answer = null;
                {
                    int fullDim = -1;
                    Polytope facets[] = null;

                    String lines[] = s.trim().split("\\s*\n\\s*");
                    int iLine = 0;
                    for (int iDim = 0; ; iDim++)
                    {
                        if (iLine >= lines.length)
                            break;
                        String line = lines[iLine++];
                        // scan "%d %d-cel%*[^:]:", &nCells, &shouldBeIDim
                        java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("(\\d+) (\\d+)-cell[^:]*:").matcher(line);
                        if (!matcher.matches())
                            throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected number of "+iDim+"-cells, got \""+line+"\"!");
                        int nCells = Integer.parseInt(matcher.group(1));
                        int shouldBeIDim = Integer.parseInt(matcher.group(2));

                        if (shouldBeIDim != iDim)
                            throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cells, got "+shouldBeIDim+"-cells!");
                        if (nCells == 0)
                            continue;
                        Polytope cells[] = new Polytope[nCells];

                        FORI (iCell, nCells)
                        {
                            if (iLine >= lines.length)
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: premature end-of-string expecting "+iDim+"-cell "+iCell+"!");
                            line = lines[iLine++];
                            // Read the index and colon.  This is for human-readability
                            // and sanity checking.
                            // scan "%d:", &shouldBeICell
                            matcher = java.util.regex.Pattern.compile("(\\d+):(.*)").matcher(line);
                            if (!matcher.matches())
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cell "+iCell+", got \""+line+"\"!");
                            int shouldBeICell = Integer.parseInt(matcher.group(1));
                            String rest = matcher.group(2);

                            if (shouldBeICell != iCell)
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cell "+iCell+", got "+shouldBeICell+"!");
                            String tokens[] = rest.trim().split("\\s+");
                            if (iDim == 0)
                            {
                                //
                                // Read vertex coords from tokens on this line.
                                //
                                if (fullDim == -1)
                                    fullDim = tokens.length;
                                else
                                    if (tokens.length != fullDim)
                                    {
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: inconsistent vertex dimensions "+fullDim+", "+tokens.length+"!");
                                    }
                                double coords[] = new double[fullDim];
                                FORI (iCoord, fullDim)
                                    coords[iCoord] = Double.parseDouble(tokens[iCoord]);
                                cells[iCell] = new Polytope(iDim,
                                                            fullDim,
                                                            new SPolytope[0],
                                                            new Hyperplane[0], // contributing hyperplanes will get filled out later
                                                            null); // no aux
                                cells[iCell].setCoords(coords);
                            }
                            else
                            {
                                //
                                // Read signed facet indices from tokens on this line.
                                //
                                SPolytope mySignedFacets[] = new SPolytope[tokens.length];
                                FORI (iToken, tokens.length)
                                {
                                    String token = tokens[iToken];
                                    int sign = 0;
                                    if (token.startsWith("-"))
                                        sign = -1;
                                    else if (token.startsWith("+"))
                                        sign = 1;
                                    else if (token.startsWith("!"))
                                        sign = 0;
                                    else
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: bad facet specification "+token+" in "+iDim+"-cell "+iCell+"!");
                                    token = token.substring(1);
                                    int iFacet = Integer.parseInt(token);
                                    if (iFacet < 0 || iFacet >= facets.length)
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: out-of-range facet specification "+token+" in "+iDim+"-cell "+iCell+"! (there are only "+facets.length+" possible facets)");
                                    mySignedFacets[iToken] = new SPolytope(0,sign,
                                                                           facets[iFacet]);
                                }
                                cells[iCell] = new Polytope(iDim,
                                                            fullDim,
                                                            mySignedFacets,
                                                            new Hyperplane[0], // contributing hyperplanes will get filled out later
                                                            null); // no aux
                            }
                        }

                        facets = cells;
                    }
                    if (facets == null || facets.length == 0)
                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: premature end-of-string or something");
                    answer = facets[0];
                }

                // Now we have to go through
                // and set the planes defining every element,
                // starting with the facets.
                if (answer.dim != answer.fullDim)
                    throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: dimension "+answer.dim+" does not match dimension of vertices "+answer.fullDim+"!");
                answer.contributingHyperplanes = new Hyperplane[0];
                FORI (iFacet, answer.facets.length)
                {
                    SPolytope facet = answer.facets[iFacet];
                    double normal[] = new double[answer.fullDim];
                    areaNormal(normal, facet); // get area normal of facet
                    VecMath.normalize(normal,normal);
                    Polytope someVertexOnFacet = facet.p;
                    while (someVertexOnFacet.dim > 0)
                        someVertexOnFacet = someVertexOnFacet.facets[0].p;
                    double offset = VecMath.dot(normal, someVertexOnFacet.getCoords());
                    Hyperplane hyperplane = new Hyperplane(normal, offset);
                    Hyperplane hyperplanes[] = {hyperplane};

                    //
                    // Add this hyperplane as a contributing
                    // hyperplane to every cell of this facet
                    // (including this facet itself).
                    //
                    Polytope allElements[][] = facet.p.getAllElements();
                    FORI (i, allElements.length)
                    FORI (j, allElements[i].length)
                    {
                        Polytope e = allElements[i][j];
                        e.contributingHyperplanes = unionOfHyperplanesAndSort(e.contributingHyperplanes, hyperplanes);
                    }
                }

                //System.out.println("done.");
                //System.out.flush();
                return answer;
            } // fromStringInPcalcFormat
        } // class Polytope

        /**
        *  Signed (oriented) polytope.
        *  <br>
        *  InitialDensity is the "density at (-inf,-inf,...)",
        *  which is 0 for finite polytopes and 1 for cofinite ones
        *  (the concept simply breaks down for polytopes
        *  that are neither finite nor cofinite).
        *  <p>
        *  Representing both finite and cofinite polytopes
        *  in this way eases our job in implementing CSG:
        *  we need only implement intersection;
        *  then the other operations are expressible trivially:
        *  <pre>
        *       union(A,B) = -intersect(-A,-B)
        *       diff(A,B)  = intersect(A,-B)
        *  </pre>
        */
        public static class SPolytope
        {
            public long id;
            public int initialDensity; // 0 or 1
            public int sign;           // +1 or -1
            public Polytope p;
            public SPolytope(int initialDensity,
                             int sign,
                             Polytope p)
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.initialDensity = initialDensity;
                this.sign = sign;
                this.p = p;
            }

            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails,
                                   java.util.Hashtable printedAlready)
            {
                String nl = System.getProperty("line.separator");
                if (printedAlready == null)
                    printedAlready = new java.util.Hashtable();

                StringBuffer sb = new StringBuffer();
                if (showGoryDetails)
                {
                    sb.append("SPolytope "+id+" {" + nl);
                    if (printedAlready.containsKey(this))
                    {
                        sb.append(indentString + "    (printed already)" + nl);
                    }
                    else
                    {
                        printedAlready.put(this,this);

                        sb.append(indentString + "    initialDensity = " + initialDensity + nl);
                        sb.append(indentString + "    sign = " + sign + nl);
                        sb.append(indentString + "    p = " + p.toString(indentString+"    ", showAux, showGoryDetails, printedAlready) + nl);
                    }
                    sb.append(indentString + "}");
                }
                else
                {
                    if (initialDensity != 0)
                        sb.append(initialDensity);
                    sb.append(signToString(sign) + p.toString(indentString, showAux, showGoryDetails, printedAlready));
                }
                return sb.toString();
            } // SPolytope.toString
            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails)
            {
                return toString(indentString,
                                showAux,
                                showGoryDetails,
                                null);
            }
            public String toString(String indentString,
                                   boolean showAux)
            {
                return toString(indentString, showAux, false);
            }
            public String toString(String indentString)
            {
                return toString(indentString, false);
            }
            public String toString(boolean showAux)
            {
                return toString("", showAux);
            }
            public String toString()
            {
                return toString("", false);
            }

            /** Parses a signed polytope from a string the "pcalc" program's format. */
            public static SPolytope fromStringInPcalcFormat(String s)
            {
                SPolytope answer = new SPolytope(0,1,Polytope.fromStringInPcalcFormat(s));
                //PRINT(volume(answer));
                double vol = volume(answer);
                if (vol < 0)
                    answer.sign *= -1; // XXX should do the push-down-sign thing?
                //PRINT(volume(answer));
                return answer;
            }

        } // class SPolytope



    //
    // Some primitive SPolytopes...
    //
        /** Makes a polygon from the given vertices in n dimensions. */
        public static SPolytope makePolygon(double verts[][])
        {
            int dim = 2;
            int fullDim = verts[0].length;
            assert(fullDim == 2); // XXX could try to do it in higher dimensions; would require getting a hyperplane basis for the othogonal complement space, I think
            int nVerts = verts.length;

            //
            // Create the hyperplanes...
            //
            Hyperplane hyperplanes[] = new Hyperplane[nVerts];
            {
                // scratch for loop... note edgeNormal can't be reused
                /// since the hyperplane stores a pointer to it.
                double edgeBackwards[] = new double[fullDim];
                FORI (i, nVerts)
                {
                    VecMath.vmv(edgeBackwards, verts[i], verts[(i+1)%nVerts]);
                    double edgeNormal[] = VecMath.xv2(edgeBackwards);
                    hyperplanes[i] = new Hyperplane(edgeNormal,
                                                    VecMath.dot(edgeNormal,
                                                                verts[i]));
                }
            }
            //
            // Create a polytope for each vertex...
            //
            Polytope vertPolytopes[] = new Polytope[nVerts];
            {
                FORI (i, nVerts)
                {
                    Hyperplane subHyperplanes[] = {hyperplanes[i],
                                                   hyperplanes[(i-1+nVerts)%nVerts]};
                    vertPolytopes[i] = new Polytope(0,
                                                    fullDim,
                                                    new SPolytope[0],
                                                    subHyperplanes,
                                                    null); // no aux
                }
            }
            //
            // Create a polytope for each edge...
            //
            SPolytope edgeSPolytopes[] = new SPolytope[nVerts];
            {
                FORI (i, nVerts)
                {
                    Hyperplane subHyperplanes[] = {hyperplanes[i]};
                    SPolytope vertsThisEdge[] = {
                        new SPolytope(0,-1,vertPolytopes[i]),
                        new SPolytope(0,1, vertPolytopes[(i+1)%nVerts]),
                    };
                    edgeSPolytopes[i] = new SPolytope(0,1,
                                         new Polytope(1,
                                                      fullDim,
                                                      vertsThisEdge,
                                                      subHyperplanes,
                                                      null)); // no aux
                }
            }
            SPolytope faceSPolytope = new SPolytope(0,1,
                                          new Polytope(2,
                                                       fullDim,
                                                       edgeSPolytopes,
                                                       new Hyperplane[0],
                                                       null)); // no aux
            return faceSPolytope;
        } // makePolygon

        /**
        * Makes a regular (n/d)-gon of edge length 2, centered at the origin,
        * with a face pointing in the +X axis direction.
        */
        public static SPolytope makeRegularPolygon(int n, int d)
        {
            double verts[][] = new double[n][2];
            double R = 1./Math.sin(Math.PI*d/n); // circumradius
            FORI (i, n)
            {
                double ang = 2*Math.PI*d/n*(i+.5); // so a face points in the x axis dir
                verts[i][0] = R * Math.cos(ang);
                verts[i][1] = R * Math.sin(ang);
            }
            return makePolygon(verts);
        }

        /** Makes an n-dimensional simplex with edge length 2, centered at the origin. */
        public static SPolytope makeSimplex(int nDims)
        {
            // XXX stopgap special cases for now
            if (nDims == 2)
                return makeRegularPolygon(3,1);
            else if (nDims == 3)
                return SPolytope.fromStringInPcalcFormat(pcalcString33);
            else if (nDims == 4)
                return SPolytope.fromStringInPcalcFormat(pcalcString333);

            double verts[][] = new double[nDims+1][nDims];
            FORI (iVert, nDims+1)
                FORI (iAx, nDims)
                    if (iVert == 0)
                        verts[iVert][iAx] = Math.sqrt((double)(iAx+2)/(2*iAx+2)) / (iAx+2);
                    else if (iVert <= iAx)
                        verts[iVert][iAx] = verts[0][iAx];
                    else if (iVert == iAx+1)
                        verts[iVert][iAx] = -(iAx+1) * verts[iAx][iAx];
                    else
                        verts[iVert][iAx] = 0.;

            // We treat verts as dual verts,
            // to exercise the makeConvexPolytopeFromIntersectionOfHalfspaces function
            double dualVerts[][] = verts;
            verts = null;

            double dualCircumRadius = VecMath.norm(dualVerts[0]);
            double primalInRadius = 1./dualCircumRadius;
            // XXX edge length is wrong-- fix this! what do do with primal inRadius?

            //SPolytope result = makeConvexPolytopeFromIntersectionOfHalfspaces(nDims, dualVerts, VecMath.fillvec(nDims+1, 1.));
            //return result;
            unimplemented();
            return null;
        } // makeSimplex


        /** Makes an n-dimensional hypercube with given center and in-radius. */
        public static SPolytope makeHypercube(double center[],
                                              double inRadius)
        {
            int fullDim = center.length;
            int dim = fullDim;
            if (verboseLevel >= 1)
                System.out.println("in makeHypercube, dim="+dim);

            int nVerts = 1<<dim;
            int totalNumberOfPolytopes = intpow(3, dim);

            //
            // Create the hyperplanes...
            //
            Hyperplane hyperplanes[][] = new Hyperplane[dim][2];
            {
                FORI (iDim, dim)
                    FORI (iDir, 2)
                    {
                        double normal[] = VecMath.zerovec(dim);
                        normal[iDim] = (iDir == 0 ? -1. : 1.);
                        hyperplanes[iDim][iDir] = new Hyperplane(
                                normal,
                                VecMath.dot(normal, center) + inRadius);
                    }
            }

            //
            // Create a mondo array of Polytopes...
            //
            Polytope array[] = new Polytope[totalNumberOfPolytopes];
            {
                FORI (i, totalNumberOfPolytopes)
                {
                    // dimension of polytope
                    // is number of 1's in its base 3 representation...
                    int subDim = 0;
                    FORI (j, dim)
                        if (digit(i,j,3) == 1)
                            ++subDim;
                    int nSubHyperplanes = dim - subDim;
                    Hyperplane subHyperplanes[] = new Hyperplane[nSubHyperplanes];
                    int iSubHyperplane = 0;
                    FORI (j, dim)
                    {
                        int digit = digit(i,j,3);
                        if (digit(i,j,3) != 1) // if it's 0 or 2
                            subHyperplanes[iSubHyperplane++] = hyperplanes[j][digit/2];
                    }
                    assert(iSubHyperplane == nSubHyperplanes);
                    array[i] = new Polytope(subDim,
                                            fullDim,
                                            null, // placeholder for facets
                                            subHyperplanes,
                                            null); // no aux
                }
            }

            //
            // For each polytope, assign to it
            // all of its facets.
            //
            {
                FORI (i, totalNumberOfPolytopes)
                {
                    Polytope p = array[i];
                    int subDim = p.dim;
                    int iFacet = 0, nFacets = 2 * subDim;
                    SPolytope facets[] = new SPolytope[nFacets];
                    FORI (j, dim)
                        if (digit(i, j, 3) == 1)
                        {
                            int dist = intpow(3,j);
                            int sign;
                            {
                                //
                                // If there are no 0's or 2's
                                // in higher-order places than j,
                                // then sign is +.
                                // If there is one of them,
                                // then sign is -.
                                // If there are two of them,
                                // then sign is +.
                                // Etc.
                                // Don't ask me why this works.
                                // it took me years of pain
                                // before I discovered it.
                                //
                                sign = 1;
                                for (int k = j+1; k < dim; ++k)
                                    if (digit(i, k, 3) != 1)
                                        sign = -sign;
                            }
                            facets[iFacet++] = new SPolytope(0,-sign, array[i - dist]);
                            facets[iFacet++] = new SPolytope(0,sign, array[i + dist]);
                        }
                    assert(iFacet == nFacets);
                    p.facets = facets;
                }
            }

            //
            // Set coords.
            // (This isn't really necessary; I'm debating
            // whether it should be done.)
            // (XXX Note however that without it,
            // I can't print out the result if dim >= 4,
            // since the print routine attempts
            // to compute the coords if they have not been set,
            // which involves inverting a 4x4 matrix
            // which I haven't implemented yet :-() )
            //
            if (true)
            {
                FORI (i, totalNumberOfPolytopes)
                {
                    Polytope p = array[i];
                    if (p.dim == 0)
                    {
                        double coords[] = new double[dim];
                        FORI (iDim, dim)
                        {
                            int sign = digit(i, iDim, 3) - 1;
                            coords[iDim] = center[iDim] + sign * inRadius;
                        }
                        p.setCoords(coords);
                    }
                }
            }

            //
            // The master polytope is the one right in the center of the array.
            // 
            Polytope p = array[(totalNumberOfPolytopes-1)/2];
            if (true)
            {
                if (verboseLevel >= 1)
                    System.out.println("    checking orientations deep...");
                // Make sure we oriented everything consistently...
                assert(isOrientedDeep(p));
            }
            SPolytope sp = new SPolytope(0,1, p);

            // XXX currently, orientDeep does cosmetic stuff.
            // XXX we want that cosmetic stuff...
            if (true)
            {
                orientDeep(sp);
            }

            if (verboseLevel >= 1)
                System.out.println("out makeHypercube");

            return sp;
        } // makeHypercube


        /** Makes an n-dimensional hypercube of in-radius 1, centered at the origin. */
        public static SPolytope makeHypercube(int dim)
        {
            return makeHypercube(VecMath.zerovec(dim), 1.);
        } // makeHypercube(unit inRadius, centered at origin)

        /**
        * Makes a regular polytope of edge length 2, centered at the origin,
        * from its schlafli symbol.
        * Currently not general, only knows about a few.
        * The orientation is pretty much arbitrary (might be face-first,
        * might be edge-first... depends on what you think of as "first", too.
        */
        public static SPolytope makeRegularPolytope(int schlafli[/*nDims-1*/])
        {
            return makeRegularStarPolytope(schlafli, null);
        } // makeRegularPolytope
        public static SPolytope makeRegularStarPolytope(int schlafli[/*nDims-1*/],
                                                        int schlafliDenoms[/*nDims-1*/])
        {
            if (schlafliDenoms == null)
                schlafliDenoms = VecMath.fillvec(schlafli.length, 1);
            assert(schlafli.length == schlafliDenoms.length);
            int nDims = schlafli.length+1;
            if (nDims<2 || schlafli[0]==4 && arrayIsAll(schlafli, 1, schlafli.length-1, 3))
            {
                // {4,3,...,3} -- hypercube
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return null;
                return makeHypercube(nDims);
            }
            else if (arrayIsAll(schlafli, 0, schlafli.length, 3))
            {
                // {3,3,...,3} -- simplex
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return null;
                return makeSimplex(nDims);
            }
            else if (nDims>=2 && arrayIsAll(schlafli, 0, schlafli.length-1, 3) && schlafli[schlafli.length-1] == 4)
            {
                // {3,...,3,4} -- cross
                unimplemented(); // XXX implement me! could do using reciprocation of hypercube
            }
            else if (nDims==2 && schlafli[0] >= 3)
            {
                // {p} -- polygon
                return makeRegularPolygon(schlafli[0], schlafliDenoms[0]);
            }
            else
            {
                // Finite number of special cases
                if (false)
                    ;
                else if (VecMath.equals(schlafli, new int[]{5,3})
                      && VecMath.equals(schlafliDenoms, new int[]{1,1}))
                {
                    // {5,3} -- dodecahedron
                    return SPolytope.fromStringInPcalcFormat(pcalcString53);
                }
                else if (VecMath.equals(schlafli, new int[]{5,3,3})
                      && VecMath.equals(schlafliDenoms, new int[]{1,1,1}))
                {
                    return SPolytope.fromStringInPcalcFormat(pcalcString533);
                }
                else
                {
                    unimplemented(); // XXX need to code up more special cases!
                }
            }
            assert(false); // XXX I think this is unreachable, but compiler is bitching
            return null;
        } // makeRegularStarPolytope

        // Tell whether array[i0]..array[i0+n-1] is all x's.
        private static boolean arrayIsAll(int array[], int i0, int n, int x)
        {
            for (int i = 0; i < n; ++i)
                if (array[i0+i] != x)
                    return false;
            return true;
        } // isAll

        /** Makes a product of regular (star) polytopes. */
        public static SPolytope makeRegularStarPolytopeCrossProduct(int schlaflis[][],
                                                                    int schlafliDenomss[][])
        {
            int nFactors = schlaflis.length;
            assert(schlafliDenomss == null
                || schlafliDenomss.length == nFactors);
            SPolytope product = null;
            FORI (iFactor, nFactors)
            {
                SPolytope factor = makeRegularStarPolytope(schlaflis[iFactor],
                                                           schlafliDenomss==null?null:schlafliDenomss[iFactor]);
                if (product == null)
                    product = factor;
                else
                    product = cross(product, factor);
            }
            // could actually initialize product to the following,
            // but that would just waste some time on the first cross product
            if (product == null)
                return new SPolytope(0,1,new Polytope(0,0,new SPolytope[0],new Hyperplane[0],null));
            return product;
        } // makeRegularStarPolytopeCrossProduct

        /**
        * Makes a product of regular (star) polytopes from a string specification,
        * for example "{4,3}x{}x{5,3,3}x{3}x {3, 3,3,3,3 }x{} x {5/2,5} "
        * '*' can be used in place of 'x' as well.
        */
        public static SPolytope makeRegularStarPolytopeCrossProductFromString(String s)
        {
            String factors[] = s.trim().split("[x*]");
            int schlaflis[][] = new int[factors.length][];
            int schlafliDenomss[][] = new int[factors.length][];
            FORI (iFactor, factors.length)
            {
                String factor = factors[iFactor].trim();
                if (!factor.startsWith("{")
                 || !factor.endsWith("}"))
                    throw new IllegalArgumentException("makeRegularStartPolytopeCrossProductFromString: bad schlafli symbol \""+s+"\"");
                factor = factor.substring(1, factor.length()-1); // trim off { and }
                factor = factor.trim(); // and any white space inside
                String fractions[] = factor.split(",");
                if (factor.equals(""))
                    fractions = new String[0]; // to be safe (I don't trust split)
                schlaflis[iFactor] = new int[fractions.length];
                schlafliDenomss[iFactor] = new int[fractions.length];
                FORI (iFraction, fractions.length)
                {
                    String fraction = fractions[iFraction].trim();
                    String n_and_d[] = fraction.split("/");
                    if (n_and_d.length == 2)
                    {
                        schlaflis[iFactor][iFraction] = Integer.parseInt(n_and_d[0]);
                        schlafliDenomss[iFactor][iFraction] = Integer.parseInt(n_and_d[1]);
                    }
                    else if (n_and_d.length == 1)
                    {
                        schlaflis[iFactor][iFraction] = Integer.parseInt(n_and_d[0]);
                        schlafliDenomss[iFactor][iFraction] = 1;
                    }
                    else
                        throw new IllegalArgumentException("makeRegularStartPolytopeCrossProductFromString: bad schlafli symbol \""+s+"\"");
                }
            }
            //PRINTARRAY(s);
            //PRINTARRAY(schlaflis);
            //PRINTARRAY(schlafliDenomss);
            return makeRegularStarPolytopeCrossProduct(schlaflis, schlafliDenomss);
        } // makeRegularStarPolytopeCrossProductFromString


    //
    // Utilities...
    //
        //
        // A polytope is "binary"
        // if all densities are 0 or 1.
        // XXX also checks whether it's finite-or-cofinite,
        // XXX so isBinary is a misnomer.
        //
        public static boolean isBinaryDensityShallow(Polytope p)
        {
            if (p.dim == 1)
            {
                int nPluses = 0, nMinuses = 0; // and counting
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                FORI (iFacet, nFacets)
                {
                    SPolytope facet = facets[iFacet];

                    if (facet.initialDensity != 0)
                        return false; // only top-level can have nonzero initial density in a finite-or-cofinite polytope

                    int sign = facet.sign;
                    if (sign == 1)
                        nPluses++;
                    else if (sign == -1)
                        nMinuses++;
                    else
                        return false;
                }
                if (nPluses != nMinuses)
                    return false;
            }
            // XXX else!?
            return true;
        } // isBinaryDensityShallow

        public static boolean isBinaryDensityDeep(SPolytope sp)
        {
            if (sp.initialDensity != 0
             && sp.initialDensity != 1)
                return false;
            Polytope allElements[][] = sp.p.getAllElements();
            int dim = sp.p.dim;
            FORI (iDim, dim+1)
            {
                Polytope ofDim[] = allElements[iDim];
                int nOfDim = ofDim.length;
                FORI (iOfDim, nOfDim)
                    if (!isBinaryDensityShallow(ofDim[iOfDim]))
                        return false;
            }
            return true;
        } // isBinaryDensityDeep



        //
        // Do one level of orientedness checking.
        // XXX This is O(n^2); should use a hash table
        // XXX instead of an array for boundaryRidges
        //
        public static boolean isOrientedShallow(Polytope p)
        {
            final boolean verbose = false;
            //
            // A polytope is considered oriented
            // if the summation of the signed facets of its
            // signed facets is zero.
            //
            SPolytope facets[] = p.facets;
            int nFacets = facets.length;
            int maxRidges;
            {
                maxRidges = 0; // and counting
                FORI (iFacet, nFacets)
                    maxRidges += facets[iFacet].p.facets.length;
            }
            SPolytope boundaryRidges[] = new SPolytope[maxRidges];
            int nBoundaryRidges = 0; // and counting
            {
                FORI (iFacet, nFacets)
                {
                    SPolytope facet = facets[iFacet];
                    SPolytope ridgesThisFacet[] = facet.p.facets;
                    int nRidgesThisFacet = ridgesThisFacet.length;
                    FORI (iRidgeThisFacet, nRidgesThisFacet)
                    {
                        SPolytope ridge = ridgesThisFacet[iRidgeThisFacet];
                        int sign = facet.sign * ridge.sign;
                        // Add boundaryRidge to boundaryRidges.
                        {
                            if (verbose)
                                System.out.println("Adding "
                                                   +signToString(facet.sign)
                                                   +signToString(ridge.sign)
                                                   +"="
                                                   +signToString(sign)
                                                   +ridge.p.id);
                            int iBoundaryRidge;
                            FOR (iBoundaryRidge, nBoundaryRidges)
                            {
                                if (boundaryRidges[iBoundaryRidge].p
                                 == ridge.p)
                                {
                                    // Found it!  Add the new coefficient.
                                    if ((boundaryRidges[iBoundaryRidge].sign
                                       += sign) == 0)
                                    {
                                        // New coefficient for this ridge is 0;
                                        // remove the ridge from the list.

                                        boundaryRidges[iBoundaryRidge--] = boundaryRidges[--nBoundaryRidges]; // subtle-- decrement iBoundaryRidges too, so that the test after this loop will still be valid
                                        if (verbose)
                                            System.out.println("    (poof!)");
                                    }
                                    else
                                    {
                                        //
                                        // It's an unusual polytope
                                        // in which the cumulative sign
                                        // can ever be other than
                                        // 0, -1, or +1; as of this writing
                                        // I don't think I've provided a way
                                        // to make one.  But it's
                                        // theoretically possible.
                                        //
                                        if (verbose)
                                            System.out.println("    (SURPRISE, cumulative sign is "+signToString(boundaryRidges[iBoundaryRidge].sign)+")");
                                    }
                                    break;
                                }
                            }
                            if (iBoundaryRidge == nBoundaryRidges)
                            {
                                // Didn't find it; add it
                                boundaryRidges[nBoundaryRidges++] = new SPolytope(0, sign, ridge.p);
                                if (verbose)
                                    System.out.println("    (truly)");
                            }
                        }
                    }
                }
            }
            return nBoundaryRidges == 0;
        } // isOrientedShallow


        public static boolean isOrientedDeep(Polytope p)
        {
            Polytope allElements[][] = p.getAllElements();
            int dim = p.dim;
            FORI (i, dim+1)
            {
                Polytope elementsOfDim[] = allElements[i];
                int nElementsOfDim = elementsOfDim.length;
                FORI (j, nElementsOfDim)
                    if (!isOrientedShallow(elementsOfDim[j]))
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println("isOrientedDeep returning false because element "+j+"/"+nElementsOfDim+" of dimension "+i+" is not oriented shallow:");
                            PRINTSUBSUB(allElements, i, j);
                        }
                        return false;
                    }
            }
            return true;
        } // isOrientedDeep


        /**
        *  Count up number of vertices, edges, ...
        *  and return the counts in an array.
        */
        public static int[] counts(Polytope p)
        {
            return (int[])Arrays.arrayLengths(p.getAllElements(), 1, 1);
        }  // counts

        private static boolean contains(Polytope p, Polytope q)
        {
            Polytope eltsOfDim[] = p.getAllElements()[q.dim];
            // XXX shouldn't have to keep making comparator...
            int index = SortStuff.bsearch(eltsOfDim, q, 
                               new SortStuff.Comparator() {
                                   public int compare(Object _a, Object _b)
                                   {
                                       Polytope a = (Polytope)_a;
                                       Polytope b = (Polytope)_b;
                                       return a.id < b.id ? -1 :
                                              a.id > b.id ? 1 : 0;
                                   }
                               });
            return index != -1;
        } // contains


        /**
        * calculates the order of the group of symmetries
        * that are rotations in the 3-space containing cell3d,
        * about the axis through cell3d's center and subCell's center.
        * subCell's center must be different from cell3d's center
        * (which rules out some non-convex uniform polyhedra
        * that have faces or edges crossing the origin).
        *
        * returnUsefulMat is filled in with an orthogonal matrix
        * the last two rows of which are in the plane of the rotation.
        * So a rotation of any angle in that plane can be computed as:
        *        Take the rows of mat to the canonical basis vectors e[0]..e[n-1]
        *        rotate e[n-2] towards e[n-1]
        *        take the canonical basis vectors back to the original rows
        * I.e. rotMat = VecMath.mxmxm(VecMath.transpose(mat),
        *                             VecMath.makeRowRotMat(nDims,nDims-2,nDims-1, angle,
        *                             mat);
        * XXX isn't there a version of makeRowRotMat that does something like this?  check it out.  it looks overly complicated though, and assumes nDims==3 which is lame, should have a look at it
        *
        * Returns 0 when subCell is cell3d itself (and zeros out returnUselMat).
        */
        public static int calcRotationGroupOrder(Polytope p,
                                                 Polytope cell3d,
                                                 Polytope subCell,
                                                 double returnUsefulMat[][])
        {
            int nDims = p.fullDim;
            assert(cell3d.dim == 3);

            Polytope cell3dAllElements[][] = cell3d.getAllElements();

            int maxPossibleOrder;
            {
                if (subCell.dim == 0)
                {
                    // number of edges in cell3d that are incident on this vertex
                    maxPossibleOrder = 0; // and counting
                    Polytope edges[] = cell3dAllElements[1];
                    FORI (iEdge, edges.length)
                    {
                        Polytope edge = edges[iEdge];
                        FORI (iVertOnEdge, edge.facets.length)
                            if (edge.facets[iVertOnEdge].p == subCell)
                                maxPossibleOrder++;
                    }
                }
                else if (subCell.dim == 1)
                    maxPossibleOrder = 2; // assumes two faces meet here, and two vertices
                else if (subCell.dim == 2)
                    maxPossibleOrder = subCell.facets.length; // gonality of the face
                else
                {
                    VecMath.zeromat(returnUsefulMat); // nothing better to do
                    return 0; // no rotation possible here at all
                }
            }

            //
            // Compute a rotation matrix
            // that rotates by 2pi/maxPossibleOrder
            // around the line through cell3d and subCell.
            //
            double maxPossibleOrderMat[][];
            {
                double pCenter[] = new double[nDims]; cgOfVerts(pCenter, p);
                double cell3dCenter[] = new double[nDims]; cgOfVerts(cell3dCenter, cell3d);
                double subCellCenter[] = new double[nDims]; cgOfVerts(subCellCenter, subCell);
                // Make the centers relative (so they are now vectors)
                VecMath.vmv(subCellCenter, subCellCenter, cell3dCenter);
                VecMath.vmv(cell3dCenter, cell3dCenter, pCenter);

                //
                // We want two orthogonal unit vectors
                // in the 3-space of cell3d
                // that are orthogonal to the line between
                // cell3d's center and CGsubCell's center.
                // We can get this by taking two random vectors
                // and gram-schmidting them against the normals
                // of all the hyperplanes defining cell3d's space,
                // and then against that line,
                // and then against each other.
                // XXX should try to do this without randomization!
                double mat[][] = new double[nDims][nDims];
                int iRow = 0;
                FOR (iRow, cell3d.contributingHyperplanes.length)
                    VecMath.copyvec(mat[iRow], cell3d.contributingHyperplanes[iRow].normal);
                VecMath.copyvec(mat[iRow++], subCellCenter);
                java.util.Random generator = new java.util.Random(3); // same every time
                VecMath.random(mat[iRow++], generator);
                VecMath.random(mat[iRow++], generator);
                assert(iRow == mat.length);
                if (VecMath.det(mat) < 0.)
                    VecMath.vxs(mat[mat.length-1], mat[mat.length-1], -1.);

                // Gram-Schmidt (XXX should be a function)
                {
                    FORI (i, mat.length)
                    {
                        FORI (j, i)
                        {
                            // mat[j] is already unit length...
                            // mat[i] -= (mat[i] dot mat[j])*mat[j]
                            VecMath.vpsxv(mat[i],
                                          mat[i],
                                          -VecMath.dot(mat[i],mat[j]),
                                          mat[j]);
                        }
                        VecMath.normalize(mat[i], mat[i]);
                    }
                }
                assert(VecMath.det(mat) > .9); // should be 1

                //
                // Okay, mat is now orthogonal
                // and the last two rows are the vectors we want to turn.
                // So the rotation we want to describe is:
                //    Take the rows of mat to the canonical basis vectors e[0]..e[n-1]
                //    rotate e[n-2] towards e[n-1]
                //    take the canonical basis vectors back to the original rows
                maxPossibleOrderMat = VecMath.mxmxm(VecMath.transpose(mat),
                                                    VecMath.makeRowRotMat(nDims,nDims-2,nDims-1, 2*Math.PI/maxPossibleOrder),
                                                    mat);
                //
                // So caller can do the same thing...
                //
                VecMath.copymat(returnUsefulMat, mat);
            }

            FuzzyPointHashTable hashTable = new FuzzyPointHashTable(1e-11,
                                                                    1e-9,
                                                                    1./512);
            Polytope verts[] = p.getAllElements()[0];
            int nVerts = verts.length;
            {
                Object something = new Object();
                FORI (iVert, nVerts)
                    hashTable.put(verts[iVert].getCoords(), something);
            }

            // The actual order will be some factor of maxPossibleOrder.
            // Try all possibilities, from big to little.
            //PRINT(maxPossibleOrder);
            for (int order = maxPossibleOrder; order >= 1; order--)
            {
                //System.err.println("(Trying order "+order+"/"+maxPossibleOrder+")");
                if (maxPossibleOrder % order != 0)
                    continue;
                double mat[][];
                {
                    // XXX should have VecMath.pow(double[][], int) that does it the smart way so it's only O(sqrt(n)) matrix multiplies
                    mat = VecMath.identitymat(nDims);
                    FORI (i, maxPossibleOrder/order)
                        mat = VecMath.mxm(mat, maxPossibleOrderMat);
                }

                double scratchVert[] = new double[nDims];
                int iVert = 0;
                FOR (iVert, nVerts)
                {
                    VecMath.vxm(scratchVert, verts[iVert].getCoords(), mat);
                    if (hashTable.get(scratchVert) == null)
                    {
                        //System.err.print("(HEY! order "+order+"/"+maxPossibleOrder+" didn't work!)");
                        break; // no good!
                    }
                }
                if (iVert == nVerts) // everything was good!
                {
                    return order; // everything was good!
                }
            }
            // order 1 should have succeeded, so we can't get here.
            // Actually we could have just returned 1 if all larger orders failed,
            // but we tested it anyway as a sanity check-- it better have succeeded.
            assert(false);
            return 1;
        } // calcRotationPeriod



        // XXX comment me!!
        public static void calcDensity(SPolytope sp,
                                       double point[],
                                       double eps,
                                       int result[/*2*/]) // interval arithmetic
        {
            //System.out.println("    in calcDensity (dim="+sp.p.dim+")");
            Polytope p = sp.p;
            int dim = p.dim;

            if (dim == 0)
            {
                // XXX logically should probably be something else, but this will do for now...
                result[0] = 1;
                result[1] = 1;
                //System.out.println("    out calcDensity (dim="+sp.p.dim+"), returning "+result[0]+","+result[1]+"");
                return;
            }

            // dir = a random vector in the space spanned by this polytope.
            // We get it by taking all the plane normals,
            // augmenting by random vectors if necessary to get
            // dim-1 vectors, and taking the cross product.
            double dir[];
            {
                int nContributingHyperplanes = p.contributingHyperplanes.length;
                int fullDim = sp.p.fullDim;
                assert(nContributingHyperplanes < fullDim);
                double M[][] = new double[fullDim-1][fullDim];
                int iRow;
                FOR (iRow, nContributingHyperplanes)
                    VecMath.copyvec(M[iRow], p.contributingHyperplanes[iRow].normal);
                for (; iRow < fullDim-1; ++iRow)
                    VecMath.random(M[iRow], randomGenerator);
                dir = VecMath.crossprod(M);
                VecMath.normalize(dir, dir); // XXX not necessary if we want to be clever
            }
            double pointDotDir = VecMath.dot(point, dir);

            int densityMin = sp.initialDensity; // and counting
            int densityMax = sp.initialDensity; // and counting

            if (p.dim == 1)
            {
                SPolytope vertices[] = p.facets;
                int nVertices = vertices.length;
                FORI (iVertex, nVertices)
                {
                    SPolytope v = vertices[iVertex];
                    int a = 0, b = 0;
                    double vDotDir = VecMath.dot(v.p.getCoords(),
                                                 dir);

                    if (GEQ(vDotDir, pointDotDir, eps))
                        a = v.sign;
                    if (GT(vDotDir, pointDotDir, eps))
                        b = v.sign;
                    if (a > b)
                    {
                        int temp;
                        SWAP(a,b,temp);
                    }
                    densityMin += a;
                    densityMax += b;
                }
            }
            else
            {
                assumpt(p.dim >= 2); // XXX never ask for density of a point
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                double qoint[] = new double[point.length]; // scratch for loop
                FORI (iFacet, nFacets)
                {
                    SPolytope facet = facets[iFacet];

                    // We want qoint = intersection of point+t*dir with plane
                    //                   of the facet.
                    // So we want t such that
                    //          (point+t*dir) dot hyperplane.normal
                    //                          = hyperplane.offset
                    //          point dot hyperplane.normal + t*dir dot hyperplane.normal = hyperplane.offset
                    //  t = (hyperplane.offset - (point dot hyperplane.normal)) / (dir dot hyperplane.normal)
                    {
                        Hyperplane hyperplane = (Hyperplane)itemOfAThatsNotInB(facet.p.contributingHyperplanes, p.contributingHyperplanes);
                        double t = (hyperplane.offset - VecMath.dot(point, hyperplane.normal)) / VecMath.dot(dir, hyperplane.normal);
                        VecMath.vpsxv(qoint, point, t, dir);
                    }

                    double qointDotDir = VecMath.dot(qoint, dir);

                    int a = 0, b = 0;
                    if (GEQ(qointDotDir, pointDotDir, eps))
                        a = facet.sign;
                    if (GT(qointDotDir, pointDotDir, eps))
                        b = facet.sign;
                    if (a > b)
                    {
                        int temp;
                        SWAP(a,b,temp);
                    }

                    if (verboseLevel >= 2 && a != b)
                    {
                        System.out.println("uh oh,,,,,,,,,,,,,,,,,,,,,,,,,,");
                        PRINT(p);
                        PRINTVEC(point);
                        PRINTVEC(qoint);
                        PRINT(a);
                        PRINT(b);
                    }
                    if (a != 0 || b != 0)
                    {
                        calcDensity(facet, qoint, eps, result); // using result as temporary
                        densityMin += a * result[0];
                        densityMax += b * result[1];
                    }
                }
            }

            if (verboseLevel >= 2 && densityMin != densityMax)
            {
                System.out.println("Uh oh................");
                PRINT(p);
                PRINTVEC(point);
                PRINT(densityMin);
                PRINT(densityMax);
            }

            result[0] = densityMin;
            result[1] = densityMax;

            //System.out.println("    out calcDensity (dim="+sp.p.dim+"), returning "+result[0]+","+result[1]+"");
        } // calcDensity


         // simplicallySubdivide
        private static double[/*nSimplices*/][/*k+1*/][/*n*/] simpliciallySubdivide(Polytope p)
        {
            int k = p.dim;
            int n = p.fullDim;

            if (k == 0)
            {
                return new double[][][] {
                    {p.getCoords()},
                };
            }
            if (p.facets.length == 0)
            {
                return new double[0][k+1][n];
            }


            Polytope v0; // first vertex
            {
                v0 = p;
                while (v0.dim > 0)
                    v0 = v0.facets[0].p;
            }
            double v0coords[] = v0.getCoords();

            // XXX it looks to me like Vector behavior is O(n^2) !?? stupid!
            java.util.Vector simplicesList = new java.util.Vector();
            {
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                double simplex[][] = new double[k+1][/*n*/];

                if (k == 1) // XXX this case is not really necessary, but it is optimized a bit
                {
                    FORI (iFacet, nFacets)
                    {
                        if (iFacet == 0)
                            continue;
                        SPolytope facet = facets[iFacet];
                        simplex[0] = v0coords;
                        simplex[1] = facet.p.getCoords();
                        if (facet.sign < 0)
                        {
                            // swap last two vertices on the simplex.
                            double temp[];
                            SWAP(simplex[k-1], simplex[k], temp);
                        }
                        FORIDOWN (i, ABS(facet.sign))
                            simplicesList.addElement(VecMath.copymat(simplex));
                    }
                }
                else // k > 1
                {

                    FORI (iFacet, nFacets)
                    {
                        if (iFacet == 0)
                            continue; // facet 0 definitely contains v0
                        SPolytope facet = facets[iFacet];
                        if (contains(facet.p, v0))
                            continue;
                        double facetSimplices[][][] = simpliciallySubdivide(facet.p);
                        int nFacetSimplices = facetSimplices.length;
                        FORI (iFacetSimplex, nFacetSimplices)
                        {
                            simplex[0] = v0coords;
                            System.arraycopy(facetSimplices[iFacetSimplex], 0,
                                             simplex, 1,
                                             k);
                            if (facet.sign < 0)
                            {
                                // swap last two vertices on the simplex.
                                double temp[];
                                SWAP(simplex[k-1], simplex[k], temp);
                            }
                            FORIDOWN (i, ABS(facet.sign))
                                simplicesList.addElement(VecMath.copymat(simplex));
                        }
                    }
                }
            }
            double array[][][] = new double[simplicesList.size()][k+1][n];
            simplicesList.copyInto(array);
            return array;
        } // simplicallySubdivide

        // This will be the actual (signed) volume
        // if all the hyperplanes are orthogonal and unit length
        // (which includes the case when there are no hyperplanes,
        // i.e. when sp.p.dim is the full dimension of the space).
        // Otherwise it will be scaled by the volume
        // of the parallelepiped spanned by those normals.
        private static double volume(SPolytope sp)
        {
            int nNormals = sp.p.contributingHyperplanes.length;
            double simplices[][][] = simpliciallySubdivide(sp.p);
            int nSimplices = simplices.length;
            if (nSimplices == 0)
                return 0.;
            int k = simplices[0].length-1;  // dimension of each simplex
            int n = simplices[0][0].length; // full dimension of space

            assert(k + nNormals == n);
            double sum = 0.;
            double M[][] = new double[n][n];
            FORI (iSimplex, nSimplices)
            {
                double simplex[][] = simplices[iSimplex];
                FORI (iRow, k)
                    VecMath.vmv(M[iRow], simplex[iRow+1], simplex[0]);
                FORI (iNormal, nNormals)
                    VecMath.copyvec(M[k+iNormal],
                                    sp.p.contributingHyperplanes[iNormal].normal);
                sum += VecMath.detDestructive(M);
            }
            return sum * sp.sign / factorial(k);
        } // volume

        // Get the normal of the n-1-dimensional polytope sp,
        // with length equal to the hyper-area of sp.
        private static void areaNormal(double result[], SPolytope sp)
        {
            VecMath.zerovec(result);
            double simplices[][][] = simpliciallySubdivide(sp.p);
            int nSimplices = simplices.length;
            if (nSimplices == 0)
                return;
            int k = simplices[0].length-1; // dimension of each simplex
            int n = simplices[0][0].length; // full dimension of space
            assert(k == sp.p.dim);

            assert(k == n-1);
            assert(result.length == n); // make sure they passed in the right dimension result
            double M[][] = new double[k][n];
            double simplexNormal[] = new double[n];
            FORI (iSimplex, nSimplices)
            {
                double simplex[][] = simplices[iSimplex];
                FORI (iRow, k)
                    VecMath.vmv(M[iRow], simplex[iRow+1], simplex[0]);
                VecMath.crossprod(simplexNormal, M);
                VecMath.vpv(result, result, simplexNormal);
            }
            VecMath.vxs(result, result, (double)sp.sign/(double)factorial(k));
        } // areaNormal

        public static void cgOfVerts(double result[], Polytope p)
        {
            Polytope vertPolytopes[] = p.getAllElements()[0];
            VecMath.zerovec(result);
            FORI (i, vertPolytopes.length)
                VecMath.vpv(result, result, vertPolytopes[i].getCoords());
            assert(vertPolytopes.length != 0);
            VecMath.vxs(result, result, 1./vertPolytopes.length);
        } // cgOfVerts

        private static SPolytope cross(SPolytope A,
                                       SPolytope B)
        {
            SPolytope AB = new SPolytope(A.initialDensity*B.initialDensity,
                                         A.sign*B.sign,
                                         _cross(A.p,
                                                B.p,
                                                new java.util.Hashtable(),
                                                ""));

            // If I was smart, _cross would simply get the signs right
            // as it goes.  Something like,
            // negate everything whose dimensional contribution
            // from C is odd...
            // But I have never been able to figure it out.
            // So, just orient after the fact.  Sigh.
            //
            if (true)
                orientDeep(AB);

            return AB;
        } // cross

        // recursive work function used by cross().
        // doesn't even try to get the signs right.
        private static Polytope _cross(Polytope A,
                                       Polytope B,
                                       java.util.Hashtable ocean, // hashtable of crossings already done
                                       String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._cross");
                subIndentString = indentString + "        ";
            }
            HashablePair key = new HashablePair(A, B);
            Polytope AB = (Polytope)ocean.get(key);
            if (AB == null)
            {
                SPolytope facets[] = new SPolytope[A.facets.length + B.facets.length];
                {
                    int iFacet = 0;
                    FORI (iFacetA, A.facets.length)
                    {
                        Polytope a = A.facets[iFacetA].p;
                        Polytope aB = _cross(a, B, ocean, subIndentString);
                        facets[iFacet++] = new SPolytope(0,1,aB); // sign arbitrary, will be fixed later
                    }
                    FORI (iFacetB, B.facets.length)
                    {
                        Polytope b = B.facets[iFacetB].p;
                        Polytope Ab = _cross(A, b, ocean, subIndentString);
                        facets[iFacet++] = new SPolytope(0,1,Ab); // sign arbitrary, will be fixed later
                    }
                    assert(iFacet == facets.length);
                }

                Hyperplane contributingHyperplanes[] = new Hyperplane[A.contributingHyperplanes.length + B.contributingHyperplanes.length];
                {

                    double leftZero[] = new double[A.fullDim];
                    double rightZero[] = new double[B.fullDim];

                    int iPlane = 0;

                    FORI (iPlaneA, A.contributingHyperplanes.length)
                    {
                        Hyperplane a = A.contributingHyperplanes[iPlaneA];
                        Hyperplane a_zero = new Hyperplane((double[])Arrays.concat(a.normal,
                                                                                   rightZero),
                                                           a.offset);
                        // XXX need to look up a_zero in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                        contributingHyperplanes[iPlane++] = a_zero;
                    }
                    FORI (iPlaneB, B.contributingHyperplanes.length)
                    {
                        Hyperplane b = B.contributingHyperplanes[iPlaneB];
                        Hyperplane zero_b = new Hyperplane((double[])Arrays.concat(leftZero,
                                                                                   b.normal),
                                                           b.offset);
                        // XXX need to look up zero_b in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                        contributingHyperplanes[iPlane++] = zero_b;
                    }
                    assert(iPlane == contributingHyperplanes.length);
                }

                AB = new Polytope(A.dim+B.dim,
                                  A.fullDim+B.fullDim,
                                  facets,
                                  contributingHyperplanes,
                                  null); // loses aux
                ocean.put(key, AB);
            }

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG._cross");
            return AB;
        } // _cross


        /**
         * Slices up a signed polytope into 3 parts: above, below, and on
         * the hyperplane.
         *    if any part of slicee is strictly above the hyperplane,
         *        returnAbove[0] will be set to that part, of dimension slicee.dim;
         *        otherwise it will be set to null.
         *    if any part of slicee is strictly below the hyperplane,
         *        returnBelow[0] will be set to that part, of dimension slicee.dim;
         *        otherwise it will be set to null.
         *    if slicee lies partly strictly above and partly strictly below
         *        the hyperplane, then returnOn[0] will be set to
         *        the cross-section polytope, of dimension slicee.dim-1;
         *        otherwise it will be set to null.
         * You can pass null in as any or all of returnAbove, returnOn,
         * or returnBelow, if you are not interested in them.
         */
        private static void slice(SPolytope slicee,
                                  Hyperplane hyperplane,
                                  Object aux, // to be put in the aux field of all new elements
                                  SPolytope returnAbove[/*1*/],
                                  SPolytope returnBelow[/*1*/],
                                  SPolytope returnOn[/*1*/])
        {
            SPolytope aboveBelowOn[/*3*/] = _slice(slicee,
                                                   hyperplane,
                                                   aux,
                                                   new java.util.Hashtable(),
                                                   "");
            assert(aboveBelowOn != null);
            if (returnAbove != null)
                returnAbove[0] = aboveBelowOn[0];
            if (returnBelow != null)
                returnBelow[0] = aboveBelowOn[1];
            if (returnOn != null)
                returnOn[0] = aboveBelowOn[2];
        } // slice

        /**
         * Slices up the boundary of a signed polytope,
         * returning a new signed polytope.
         * XXX this is actually not a great way to do this,
         * XXX since often we make a bunch of parallel cuts
         * XXX and we know the stuff on a particular side of the first cut
         * XXX isn't going to be affected by the next cut
         */
        public static SPolytope sliceFacets(SPolytope slicee,
                                            Hyperplane hyperplane,
                                            Object aux) // to be put in the aux field of all new elements
        {
            if (verboseLevel >= 1)
            {
                System.out.println("in CSG.slice");
                PRINT(hyperplane);
            }
            java.util.Hashtable ocean = new java.util.Hashtable();

            SPolytope newFacets[] = new SPolytope[2*slicee.p.facets.length]; // at most
            int nNewFacets = 0;
            FORI (iFacet, slicee.p.facets.length)
            {
                SPolytope facetStuff[] = _slice(slicee.p.facets[iFacet], hyperplane, aux, ocean, "        ");
                if (facetStuff[0] != null)
                    newFacets[nNewFacets++] = facetStuff[0];
                if (facetStuff[1] != null)
                    newFacets[nNewFacets++] = facetStuff[1];
            }
            if (nNewFacets == slicee.p.facets.length)
                return slicee;
            newFacets = (SPolytope[])Arrays.subarray(newFacets, 0, nNewFacets); // resize
            SPolytope result = new SPolytope(slicee.initialDensity,
                                             slicee.sign,
                                             new Polytope(slicee.p.dim,
                                                          slicee.p.fullDim,
                                                          newFacets,
                                                          slicee.p.contributingHyperplanes,
                                                          null)); // aux gets lost
            if (verboseLevel >= 1)
                System.out.println("out CSG.slice");
            return result;
        } // sliceFacets

        // recursive work function used by slice() and sliceFacets().
        // returns an array {above,below,on}.
        private static SPolytope[/*3*/] _slice(SPolytope slicee,
                                               Hyperplane hyperplane,
                                               Object aux,
                                               java.util.Hashtable ocean, // hashtable of slicings already done
                                               String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._slice (slicee dim = "+slicee.p.dim+")");
                subIndentString = indentString + "        ";
            }
            SPolytope aboveBelowOn[/*3*/] = (SPolytope[])ocean.get(slicee.p);
            if (aboveBelowOn == null)
            {
                // Not already in the ocean... need to calculate it
                SPolytope above = null, below = null, on = null;
                if (slicee.p.dim == 0)
                {
                    double coords[] = slicee.p.getCoords();
                    double height = VecMath.dot(coords, hyperplane.normal) - hyperplane.offset;
                    if (height > 0.) // XXX need to make this fuzzy
                        above = slicee;
                    else if (height < 0.) // XXX need to make this fuzzy
                        below = slicee;
                    else
                        unimplemented(); // vertices on the plane mess everything hup later
                }
                else if (slicee.p.dim == 1)
                {
                    //
                    // Slicee is a 1-dimensional polytope,
                    // i.e. a (multi-)segment.  Note that
                    // it may have more than two vertices:
                    // e.g. when a hatchet-chop is taken out of the
                    // edge of a regular polyhedron, the resulting pieces of the
                    // chopped edge are still considered to be part
                    // of a single edge, which now has 4 vertices
                    // (with signs -, +, -, + in order).
                    //

                    //
                    // Calculate the cumulative sign
                    // of all vertices lying above and below the plane...
                    //
                    SPolytope facetStuffs[][] = new SPolytope[slicee.p.facets.length][];
                    int nAbove = 0, nBelow = 0;
                    int totalSignAbove = 0;
                    int totalSignBelow = 0;
                    FORI (iFacet, slicee.p.facets.length)
                    {
                        facetStuffs[iFacet] = _slice(slicee.p.facets[iFacet], hyperplane, aux, ocean, subIndentString);
                        if (facetStuffs[iFacet][0] != null)
                        {
                            nAbove++;
                            totalSignAbove += slicee.p.facets[iFacet].sign;
                        }
                        if (facetStuffs[iFacet][1] != null)
                        {
                            nBelow++;
                            totalSignBelow += slicee.p.facets[iFacet].sign;
                        }
                        if (facetStuffs[iFacet][2] != null)
                        {
                            unimplemented();
                        }
                    }
                    totalSignAbove = 1; // XXX FUDGE
                    totalSignBelow = -1; // XXX FUDGE
                    assumpt(totalSignAbove + totalSignBelow == 0);

                    if (nAbove != 0 && nBelow != 0)
                    {
                        SPolytope facetsAbove[] = new SPolytope[nAbove + (totalSignAbove!=0 ? 1 : 0)];
                        SPolytope facetsBelow[] = new SPolytope[nBelow + (totalSignBelow!=0 ? 1 : 0)];
                        {
                            int iAbove = 0, iBelow = 0;
                            FORI (iFacet, slicee.p.facets.length)
                            {
                                if (facetStuffs[iFacet][0] != null)
                                    facetsAbove[iAbove++] = facetStuffs[iFacet][0];
                                if (facetStuffs[iFacet][1] != null)
                                    facetsBelow[iBelow++] = facetStuffs[iFacet][1];
                            }
                            assert(iAbove == nAbove);
                            assert(iBelow == nBelow);
                            if (totalSignAbove != 0) // i.e. if totalSignBelow != 0
                            {
                                // Need to make a new cutpoint.
                                // Note that we don't need to set the coords on it,
                                // that will be computed lazily
                                // from its hyperplanes
                                // the first time anyone calls getCoords() on it.
                                Polytope cutPoint = new Polytope(slicee.p.dim-1,
                                                                 slicee.p.fullDim,
                                                                 new SPolytope[0], // result vertex has no facets
                                                                 addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                                 aux);
                                facetsAbove[iAbove++] = new SPolytope(0, // initialDensity always 0 for vertices, I think
                                                                      -totalSignAbove,
                                                                      cutPoint);
                                facetsBelow[iBelow++] = new SPolytope(0, // initialDensity always 0 for vertices, I think
                                                                      -totalSignBelow,
                                                                      cutPoint);
                                on = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initialDensity?  maybe initialDensity isn't meaningful except for top-level polytopes?
                                                   1, // XXX arbitrary-- I think signs are completely messed up, will fix later
                                                   cutPoint);
                            }
                            assert(iAbove == facetsAbove.length);
                            assert(iBelow == facetsBelow.length);
                        }

                        above = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsAbove,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                        below = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsBelow,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                    }
                    else if (nAbove != 0)
                        above = slicee;
                    else if (nBelow != 0)
                        below = slicee;
                    else
                        assumpt(false);
                } // slicee.p.dim == 1
                else // slicee.p.dim >= 2
                {
                    assert(slicee.p.dim >= 2);

                    SPolytope facetStuffs[][] = new SPolytope[slicee.p.facets.length][];
                    int nAbove = 0, nBelow = 0, nOn = 0;
                    FORI (iFacet, slicee.p.facets.length)
                    {
                        facetStuffs[iFacet] = _slice(slicee.p.facets[iFacet], hyperplane, aux, ocean, subIndentString);
                        if (facetStuffs[iFacet][0] != null)
                            nAbove++;
                        if (facetStuffs[iFacet][1] != null)
                            nBelow++;
                        if (facetStuffs[iFacet][2] != null)
                            nOn++;
                    }
                    if (nAbove != 0 && nBelow != 0)
                    {
                        SPolytope facetsAbove[] = new SPolytope[nAbove + (nOn!=0 ? 1 : 0)];
                        SPolytope facetsBelow[] = new SPolytope[nBelow + (nOn!=0 ? 1 : 0)];
                        SPolytope ridgesOn[] = new SPolytope[nOn];
                        {
                            int iAbove = 0, iBelow = 0, iOn = 0;
                            FORI (iFacet, slicee.p.facets.length)
                            {
                                if (facetStuffs[iFacet][0] != null)
                                    facetsAbove[iAbove++] = facetStuffs[iFacet][0];
                                if (facetStuffs[iFacet][1] != null)
                                    facetsBelow[iBelow++] = facetStuffs[iFacet][1];
                                if (facetStuffs[iFacet][2] != null)
                                    ridgesOn[iOn++] = facetStuffs[iFacet][2];
                            }
                            assert(iAbove == nAbove);
                            assert(iBelow == nBelow);
                            assert(iOn == nOn);
                            // XXX can some ridges occur multiple times?
                            // XXX I don't think so, since On is only *new* stuff... but if I'm wrong, will need to sort ridgesOn and combine

                            if (nOn != 0)
                            {
                                Polytope cutPoint = new Polytope(slicee.p.dim-1,
                                                                 slicee.p.fullDim,
                                                                 ridgesOn,
                                                                 addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                                 aux);
                                facetsAbove[iAbove++] = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initial density? maybe initialDensity isn't meaningful except for top-level polytopes?
                                                                      +1,
                                                                      cutPoint);
                                facetsBelow[iBelow++] = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initialDensity?  maybe initialDensity isn't meaningful except for top-level polytopes?
                                                                      -1,
                                                                      cutPoint);
                                on = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initialDensity?  maybe initialDensity isn't meaningful except for top-level polytopes?
                                                   1, // XXX arbitrary-- I think signs are completely messed up, will fix later
                                                   cutPoint);
                            }
                            assert(iAbove == facetsAbove.length);
                            assert(iBelow == facetsBelow.length);
                            assert(iOn == ridgesOn.length);
                        }

                        above = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsAbove,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                        below = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsBelow,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                                              
                    }
                    else if (nAbove != 0)
                        above = slicee;
                    else if (nBelow != 0)
                        below = slicee;
                    else
                        assumpt(false);
                } // slicee.p.dim >= 2
                aboveBelowOn = new SPolytope[] {above, below, on};
                ocean.put(slicee.p, aboveBelowOn);
            }
            else
            {
                if (verboseLevel >= 1)
                    System.out.println(indentString+"    (found it in the ocean)");
            }
            if (true)
            {
                // XXX make sure we are not sharing!
                // XXX I think maybe we should be just working unsigned
                // XXX and then orient afterwards.
                // XXX bleah, unfortunately this doesn't seem to make any difference, the bugs must be elsewhere.
                FORI(i,3)
                {
                    if (aboveBelowOn[i] != null)
                        aboveBelowOn[i] = new SPolytope(aboveBelowOn[i].initialDensity,
                                                        aboveBelowOn[i].sign,
                                                        aboveBelowOn[i].p);
                }
            }
            if (verboseLevel >= 1)
            {
                PRINTARRAY(slicee);
                PRINTARRAY(aboveBelowOn);
                System.out.println(indentString+"out CSG._slice (slicee dim = "+slicee.p.dim+")");
            }
            return aboveBelowOn;
        } // _slice

        //
        // XXX OLD-- look through for signs of intelligence and then delete
        // Slice a signed polytope by a plane.
        // Returns a slicee.dim-1 dimensional signed polytope.
        //
        private static SPolytope oldSlice(SPolytope slicee,
                                          Hyperplane hyperplane,
                                          Object aux,
                                          String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG.oldSlice");
                subIndentString = indentString + "    ";
            }
            if (verboseLevel >= 2)
                System.out.println(subIndentString + "slicee = " + slicee.toString(subIndentString+"         ", false, false, null));
            if (verboseLevel >= 3)
                System.out.println(subIndentString + "slicee = " + slicee.toString(subIndentString, true, true, null));
            if (verboseLevel >= 2)
            {
                System.out.println(subIndentString + "hyperplane: " + hyperplane);
            }

            assert(slicee.p.dim >= 1);
            assert(Arrays.indexOfUsingEqualsSymbol(slicee.p.contributingHyperplanes, hyperplane) == -1);

            SPolytope result;
            if (slicee.p.dim == 1)
            {
                //
                // Slicee is a 1-dimensional polytope,
                // i.e. a (multi-)segment.  Note that
                // it may have more than two vertices:
                // e.g. when a hatchet-chop is taken out of the
                // edge of a regular polyhedron, the resulting pieces of the
                // chopped edge are still considered to be part
                // of a single edge, which now has 4 vertices
                // (with signs -, +, -, + in order).
                //

                //
                // Calculate the cumulative sign
                // of all vertices lying above the plane...
                //

                int minNumVertsAbovePlane = 0;
                int maxNumVertsAbovePlane = 0;

                int signOfVertsStrictlyAbovePlane = 0;
                int signOfVertsOnOrAbovePlane = 0;
                SPolytope vertices[] = slicee.p.facets;
                int iVertex, nVertices = vertices.length;
                FOR (iVertex, nVertices)
                {
                    SPolytope vertex = vertices[iVertex];
                    double vertexCoords[] = vertex.p.getCoords();
                    double heightOfVertexAbovePlane = VecMath.dot(hyperplane.normal, vertexCoords) - hyperplane.offset;
                    // XXX need to use an epsilon test!
                    if (heightOfVertexAbovePlane >= 0.)
                    {
                        maxNumVertsAbovePlane++;
                        if (heightOfVertexAbovePlane > 0.)
                            minNumVertsAbovePlane++;
                    }
                }
                // XXX use even-odd rule since I don't seem to be smart enough for anything else
                if (minNumVertsAbovePlane != maxNumVertsAbovePlane
                 || slicee.initialDensity == (minNumVertsAbovePlane & 1))
                {
                    // Plane doesn't cross this segment
                    // (or crosses it just barely, so we can say it doesn't).
                    result = null;
                }
                else
                {
                    result = new SPolytope(0, // XXX initialDensity always 0 for vertices, I think-- think about it.  could just follow example of >1 case and set it to slicee.initialDensity, but I'd like to understand what I'm doing
                                           1, // XXX using even-odd rule, anything nonzero is 1.  top-level caller will fix.
                                           new Polytope(slicee.p.dim-1, // == 0
                                                        slicee.p.fullDim,
                                                        new SPolytope[0], // result vertex has no facets
                                                        addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                        aux));
                }
            } // slicee.p.dim == 1
            else
            {
                assert(slicee.p.dim > 1);

                //
                // The facets of (slicee sliced)
                // are (facets of slicee) sliced.
                //
                int iFacet, nFacets = slicee.p.facets.length;

                int maxSlicedFacets = nFacets;
                SPolytope slicedFacets[] = new SPolytope[maxSlicedFacets];
                int nSlicedFacets = 0;

                FOR (iFacet, nFacets)
                {
                    SPolytope slicedFacet = oldSlice(slicee.p.facets[iFacet],
                                                  hyperplane,
                                                  aux,
                                                  subIndentString);
                    if (slicedFacet != null)
                        slicedFacets[nSlicedFacets++] = slicedFacet;
                }
                if (nSlicedFacets == 0
                 && slicee.initialDensity == 0)
                {
                    // No facets and initialDensity == 0
                    // and dim != 0
                    // and  so we are nothing.
                    assert(slicee.initialDensity == 0); // XXX bad, should go off
                    result = null;
                }
                else
                {
                    slicedFacets = (SPolytope[])Arrays.subarray(slicedFacets, 0, nSlicedFacets); // resize

                    result = new SPolytope(slicee.initialDensity,
                                           1, // XXX assuming even-odd rule; will fix later
                                           new Polytope(slicee.p.dim-1,
                                                        slicee.p.fullDim,
                                                        slicedFacets,
                                                        addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                        slicee.p.aux));
                }
            } // slicee.p.dim > 1

            if (verboseLevel >= 2)
                System.out.println(subIndentString + "result = " + (result==null?"(null)":result.toString(subIndentString+"         ", false, false, null)));
            if (verboseLevel >= 3)
                System.out.println(subIndentString + "result = " + (result==null?"(null)":result.toString(subIndentString, true, true, null)));

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG.oldSlice");

            return result;
        } // oldSlice

        // recursive work function used by intersect()
        private static SPolytope _intersect(SPolytope A,
                                            SPolytope B,
                                            java.util.Hashtable ocean, // hashtable of intersection polytopes created, keyed by contributing hyperplanes
                                            String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._intersect");
                subIndentString = indentString + "        ";
            }
            if (verboseLevel >= 2)
                System.out.println(indentString+"    A = "+A.toString(indentString+"        ", false, false, null));
            if (verboseLevel >= 2)
                System.out.println(indentString+"    B = "+B.toString(indentString+"        ", false, false, null));
            if (verboseLevel >= 2
             && (A.p.facets.length > 0
              || B.p.facets.length > 0))
                System.out.println();

            int fullDim = A.p.fullDim;
            assert(fullDim == B.p.fullDim);

            if (true)
            {
                //
                // Bounding box test for quick rejection.
                // Intersect bounding boxes of vertices...
                //
                double bboxA[][] = A.p.getBBox();
                double bboxB[][] = B.p.getBBox();
                double bbox[][] = new double[2][fullDim];
                VecMath.bboxIntersect(bbox, bboxA, bboxB);
                boolean bboxIsEmpty = false; // and counting
                FORI (iDim, fullDim)
                    if (bbox[0][iDim] > bbox[1][iDim]) // XXX should be fuzzy I think
                        bboxIsEmpty = true;
                if (bboxIsEmpty)
                {
                    if (A.initialDensity == 0
                     && B.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox with both initial densities 0, returning null");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return null;
                    }
                    else if (A.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, A's initial density is 0, B's is not, returning A");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return A;
                    }
                    else if (B.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, B's initial density is 0, A's is not, returning B");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return B;
                    }
                    else
                    {
                        // Both A and B have nonzero initial density.
                        // XXX Could optimize by simply concatenating
                        // XXX the arrays together, so to speak,
                        // XXX but I don't think this happens enough in
                        // XXX the current application to be worth worrying about.
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, both initial densities nonzero, but not smart enough to do anything about it yet :-(");
                        }
                    }
                }
            }


            Hyperplane contributingHyperplanes[] = unionOfHyperplanesAndSort(A.p.contributingHyperplanes, B.p.contributingHyperplanes);
            HashableSortedArray key = new HashableSortedArray(contributingHyperplanes);

            int resultDim = fullDim - contributingHyperplanes.length;

            if (resultDim < 0)
            {
                if (verboseLevel >= 1)
                {
                    System.out.println(indentString+"    too many hyperplanes! returning null");
                    System.out.println(indentString+"out CSG.intersect");
                }
                return null;
            }

            // Look in the ocean for already computed...
            {
                Object flotsam = ocean.get(key);
                if (flotsam != null)
                {
                    // Found it in the ocean, so it was previously computed.
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"        found it in the ocean");
                    if (flotsam instanceof Polytope)
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString+"        and it was good");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return new SPolytope(0, // XXX initial density always 0 in this case?
                                             1, // XXX probably not right, fix later
                                             (Polytope)flotsam);
                    }
                    else
                    {
                        // It was previously computed and came out null.
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"        and it was null");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return null;
                    }
                }
            } // looked in the ocean

            SPolytope result;
            if (resultDim == 0)
            {
                double coords[];
                if (A.p.dim == 0)
                    coords = A.p.getCoords();
                else if (B.p.dim == 0)
                    coords = B.p.getCoords();
                else
                    coords = intersectHyperplanes(contributingHyperplanes);

                {
                    // XXX could use something smaller than union
                    // XXX in various cases of initialDensity? think about it
                    double unionBBox[][] = VecMath.bboxUnion(A.p.getBBox(),
                                                             B.p.getBBox());
                    double bigEps = 1e-3; // need not be very exact; the bigger the safer 
                    if (coords != null
                     && !VecMath.closedBBoxContains(unionBBox, coords, bigEps))
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString + "        HA! No way! coords were out of there!");
                        }
                        coords = null;
                    }

                    // XXX research question: can something like this
                    // XXX be done even if resultDim > 0?
                }

                if (coords != null)
                {
                    boolean inA;
                    {
                        double eps = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                        int densityMinMax[] = new int[2];
                        calcDensity(A,
                                    coords,
                                    eps,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        if (density != densityMinMax[1])
                        {
                            if (verboseLevel >= 0)
                            {
                                System.out.println("WARNING:");
                                PRINT(A);
                                PRINTVEC(coords);
                                PRINT(densityMinMax[0]);
                                PRINT(densityMinMax[1]);
                            }
                            //assert(false);
                        }
                        inA = ((density&1) == 1); // XXX even-odd rule for now
                    }
                    boolean inB = false; // shut up compiler
                    if (inA) // otherwise inB doesn't matter
                    {
                        double eps = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                        int densityMinMax[] = new int[2];
                        calcDensity(B,
                                    coords,
                                    eps,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        if (density != densityMinMax[1])
                        {
                            if (verboseLevel >= 0)
                            {
                                System.out.println("WARNING:");
                                PRINT(B);
                                PRINTVEC(coords);
                                PRINT(densityMinMax[0]);
                                PRINT(densityMinMax[1]);
                            }
                            //assert(false);
                        }
                        inB = ((density&1) == 1); // XXX even-odd rule for now
                    }
                    if (inA && inB)
                    {
                        if (A.p.dim == 0)
                            result = A;
                        else if (B.p.dim == 0)
                            result = B;
                        else
                        {
                            result = new SPolytope(
                                            0, 1, // XXX nonsense, will straighten out later
                                            new Polytope(0,
                                                         fullDim,
                                                         new SPolytope[0],
                                                         contributingHyperplanes,
                                                         null)); // no aux, since it's not a full-dimensional subset of any existing polytope
                            result.p.setCoords(coords); // so they won't need to be recalculated
                        }
                    }
                    else
                        result = null;
                }
                else
                    result = null;
            }
            else // resultDim > 0
            {
                //
                // Trying to maybe get it right
                // in the case of flush stuff
                // (e.g. A&A of dim 1 or 2 in test program).
                // I don't know if this will work,
                // and it's certainly WAY more compute intensive...
                // I think maybe the union-of-hyperplanes logic
                // isn't right though :-(
                // Also, need to do this first
                // so that we won't get a "found it in the ocean and it was
                // null".
                // NOTE, we really only need to do this
                // when a's subspace contains b's subspace (i.e.
                // one set of hyperplanes contains the other).
                // XXX need to think about whether there's an efficient
                // XXX way of enumerating all pairs for which this is true
                //
                int nMoreFacets = 0;
                SPolytope moreFacets[] = null;
                if (false) // maybe pursue this some other time
                {
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"    Trying more expensive boundary stuff...");
                    moreFacets = new SPolytope[A.p.facets.length
                                             * B.p.facets.length];
                    FORI (i, A.p.facets.length)
                    FORI (j, B.p.facets.length)
                    {
                        SPolytope a = A.p.facets[i];
                        SPolytope b = B.p.facets[j];
                        // Only proceed if a's subspace contains b's subspace
                        // or vice-versa.
                        {
                            Hyperplane unionOfHyperplanes[] = unionOfHyperplanesAndSort(a.p.contributingHyperplanes, b.p.contributingHyperplanes);
                            if (unionOfHyperplanes.length
                             != MIN(a.p.contributingHyperplanes.length,
                                    b.p.contributingHyperplanes.length))
                                continue;
                        }
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString+"            a = "+a.toString(indentString+"            ", false, false));
                            System.out.println(indentString+"            b = "+b.toString(indentString+"            ", false, false));
                        }
                        SPolytope a_intersect_b = _intersect(a, b, ocean, subIndentString);
                        if (a_intersect_b != null)
                            moreFacets[nMoreFacets++] = a_intersect_b;
                    }
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"    Found "+nMoreFacets+"/"+moreFacets.length+" more facets");
                }


                int nFacets = 0;
                SPolytope facets[] = new SPolytope[A.p.facets.length
                                                 + B.p.facets.length]; // max possible

                FORI (i, A.p.facets.length)
                {
                    SPolytope a = A.p.facets[i];
                    if (verboseLevel >= 2)
                        System.out.println(indentString+"        a = "+a.toString(indentString+"            ", false, false));
                    SPolytope a_intersect_B = _intersect(a, B, ocean, subIndentString);
                    if (a_intersect_B != null)
                        facets[nFacets++] = a_intersect_B;
                }
                FORI (i, B.p.facets.length)
                {
                    SPolytope b = B.p.facets[i];
                    if (verboseLevel >= 2)
                        System.out.println(indentString+"        b = "+b.toString(indentString+"            ", false, false));
                    SPolytope A_intersect_b = _intersect(A, b, ocean, subIndentString);
                    if (A_intersect_b != null)
                        facets[nFacets++] = A_intersect_b;
                }

                facets = (SPolytope[])Arrays.subarray(facets, 0, nFacets); // resize

                if (nMoreFacets > 0)
                {
                    moreFacets = (SPolytope[])Arrays.subarray(moreFacets, 0, nMoreFacets); // resize
                    facets = (SPolytope[])Arrays.concat(facets, moreFacets);
                }

                result = new SPolytope(
                                       MIN(A.initialDensity, B.initialDensity), // XXX is this right? have to think about it
                                       A.sign, // XXX probably completely irrelevant
                                       new Polytope(resultDim,
                                                    fullDim,
                                                    facets,
                                                    contributingHyperplanes,
                                                    resultDim==A.p.dim ? A.p.aux : resultDim==B.p.dim ? B.p.aux : null)); // XXX prefers A's aux. probably not much better we can do, unless we want to combine the auxes somehow, but that's probably too much trouble and the current application doesn't need it
                //
                // Hack after the fact:
                // if it's equal to A or B, return A or B instead
                // (XXX should detect that earlier and save lots of work
                // and unnecessary allocations, maybe)
                // XXX this may be defunct,
                // XXX have to think about it
                //
                {
                    if (result.p.dim == A.p.dim
                     && VecMath.equalsUsingEqualsSymbol(result.p.facets, A.p.facets))
                    {
                        result = new SPolytope(result.initialDensity,
                                               result.sign,
                                               A.p);
                    }
                    else if (result.p.dim == B.p.dim
                     && VecMath.equalsUsingEqualsSymbol(result.p.facets, B.p.facets))
                    {
                        result = new SPolytope(result.initialDensity,
                                               result.sign,
                                               B.p);
                    }
                }
            }

            if (result != null
             && result.p.dim >= 1
             && result.initialDensity == 0
             && result.p.facets.length == 0)
                result = null;

            if (result != null)
                ocean.put(key, result.p);
            else
                ocean.put(key, new Object()); // means null when fished out

            if (verboseLevel >= 2)
                System.out.println(indentString+"    result = "+(result==null?"(null)":result.toString(indentString+"             ", false, false, null)));

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG._intersect");
            return result;
        } // _intersect

        /** Computes the intersection of two signed polytopes. */
        public static SPolytope intersect(SPolytope A,
                                          SPolytope B)
        {
            SPolytope result = _intersect(A, B,
                                          new java.util.Hashtable(),
                                          "");

            // _intersect returns an empty polytope
            // as null for efficiency, but the rest of the world
            // can't be expected to handle it.
            if (result == null)
            {
                int fullDim = A.p.fullDim;
                assert(fullDim == B.p.fullDim);
                int dim = fullDim - ((fullDim-A.p.dim)
                                   + (fullDim-B.p.dim));
                result = new SPolytope(0,1,
                                       new Polytope(dim,
                                                    fullDim,
                                                    new SPolytope[0],
                                                    new Hyperplane[0], // XXX uh oh, zero hyperplanes isn't really right, maybe should do the hyperplane union thing in case someone actually looks at this
                                                    null));
            }

            orientDeep(result); // XXX get rid of this when I get intersect to not fuck up the orientations to begin with
            return result;
        } // intersect

        /** Computes the complement of a signed polytope. */
        public static SPolytope complement(SPolytope sp)
        {
            return new SPolytope(1-sp.initialDensity,
                                 -sp.sign,
                                 sp.p);
        } // complement

        /** Computes the union of two signed polytopes. */
        public static SPolytope union(SPolytope A, SPolytope B)
        {
            return complement(intersect(complement(A), complement(B)));
        } // union

        /** Computes the difference of two signed polytopes. */
        private static SPolytope diff(SPolytope A, SPolytope B)
        {
            return intersect(A, complement(B));
        } // diff


        //
        // Assign signs to a (non-yet-finished)
        // n-dimensional polytope P,
        // its facets, and the facets of the facets, etc., recursively
        // in such a way that, for every flag:
        //      P, facet F, ridge R, ..., face f, edge e, vertex v,
        // the product of the signs of P, F, R, ..., f, e, v
        // should be the same as the sign of the volume of the simplex
        // whose vertices are the respective centers of those n+1 elements,
        // in order.
        // I.e. it should be equal to the sign of the determinant of the matrix
        // whose rows are the n vectors
        // i(F)-i(P), i(R)-(P), ..., i(f)-i(P), i(e)-i(P), i(v)-i(P)
        // where i() denotes any interior point of the respective polytope.
        //
        // So, in particular,
        //    If n==1:  From left to right,
        //              segment starts are -, segment ends are +
        //    If n==2:  Walking CCW around a contour
        //              (i.e. with inside on the left and outside on the right),
        //              e.sign * initialVertex.sign is -
        //              and e.sign * finalVertex.sign is +
        //    If n==3: Walking on the surface
        //              along an edge e CCW around a face f,
        //              f.sign * e.sign * initialVertex.sign is -
        //              f.sign * e.sign * finalVertex.sign is +
        // etc.
        //
        // XXX should split this up into functional stuff
        // XXX and cosmetic stuff,
        // XXX and cosmetic stuff should be applied even to hypercubes
        // XXX and stuff.
        //

        public static void orientDeep(SPolytope sp) // XXX should not be public!  change back to private after PolytopePuzzleDescription doesn't need it any more!
        {
            if (verboseLevel >= 1)
                System.out.println("in orientDeep");
            if (verboseLevel >= 2)
            {
                System.out.println("    Before anything:");
                System.out.println("        "+sp.toString("        "));
            }

            int dim = sp.p.dim;

            Polytope allElements[][] = sp.p.getAllElements();

            if (true)
            {
                FORI (iDim, dim+1)
                {
                    Polytope ofDim[] = allElements[iDim];
                    int nOfDim = ofDim.length;
                    FORI (iOfDim, nOfDim)
                        orientFacetsConsistently(ofDim[iOfDim]);
                }

                if (verboseLevel >= 2)
                {
                    System.out.println("    After recursively orienting everyone consistently:");
                    System.out.println("        "+sp.toString("        "));
                }
            }

            if (false)
            {
                //
                // If total sign is wrong
                // (along some arbitrary flag),
                // then reverse the sign of sp so it becomes right.
                //
                System.out.println("WARNING: orientDeep global orientation not implemented yet"); // XXX
                if (verboseLevel >= 2)
                {
                    System.out.println("    After fixing global sign if it was wrong:");
                    System.out.println("        "+sp.toString("        "));
                }
            }


            if (true)
            {
                if (dim >= 1)
                {
                    //
                    // Push sign of sp down into facets,
                    // making sign of sp +1.
                    //
                    int mySign = sp.sign;
                    SPolytope facets[] = sp.p.facets;
                    int nFacets = facets.length;
                    FORI (iFacet, nFacets)
                        facets[iFacet].sign *= mySign;
                    sp.sign = 1;

                    if (verboseLevel >=2)
                    {
                        System.out.println("    After pushing sign down into facets:");
                        System.out.println("        "+sp.toString("        "));
                    }

                    //
                    // Push sign of facet down into ridges,
                    // making the signs of all facets +1.
                    // Note this only makes sense when dim > 1.
                    // Also, it's pointless to do this any further:
                    // we can't make all ridge signs +,
                    // since they occur on multiple facets,
                    // in opposite-signed pairs.
                    //
                    if (dim >= 2)
                    {
                        FORI (iFacet, nFacets)
                        {
                            SPolytope facet = facets[iFacet];
                            int facetSign = facet.sign;
                            if (facetSign != 1)
                            {
                                SPolytope ridgesThisFacet[] = facet.p.facets;
                                int nRidgesThisFacet = ridgesThisFacet.length;
                                FORI (iRidgeThisFacet, nRidgesThisFacet)
                                    ridgesThisFacet[iRidgeThisFacet].sign *= facetSign;
                                facet.sign = 1;
                            }
                        }

                        if (verboseLevel >= 2)
                        {
                            System.out.println("    After pushing facet signs down into ridges:");
                            System.out.println("        "+sp.toString("        "));
                        }
                    }
                }
            }

            //
            // Edge cosmetic tweak:
            // for each edge, put the - vertex first and the + one second.
            // (If there are more than two vertices on the edge,
            // then don't worry about it.)
            //
            if (true)
            {
                if (dim >= 1)
                {
                    Polytope edges[] = sp.p.getAllElements()[1];
                    int nEdges = edges.length;
                    FORI (iEdge, nEdges)
                    {
                        Polytope edge = edges[iEdge];
                        SPolytope vertsThisEdge[] = edge.facets;
                        if (vertsThisEdge.length == 2
                         && vertsThisEdge[0].sign == 1
                         && vertsThisEdge[1].sign == -1)
                        {
                            SPolytope temp;
                            SWAP(vertsThisEdge[0],vertsThisEdge[1],temp);
                        }
                    }
                }

                if (verboseLevel >= 2)
                {
                    System.out.println("    After edge cosmetic tweak:");
                    System.out.println("        "+sp.toString("        "));
                }
            }


            //
            // Face cosmetic tweak:
            // for each 2-d face, put the edges on each contour in order.
            // This requires that the edge cosmetic tweak (above)
            // was done first.
            // XXX this is O(n^2) where n is face size,
            // XXX so can be time-consuming
            // XXX for huge faces.
            //
            if (true)
            {
                if (dim >= 2)
                {
                    Polytope faces[] = sp.p.getAllElements()[2];
                    int nFaces = faces.length;
                    FORI (iFace, nFaces)
                    {
                        Polytope p = faces[iFace];
                        SPolytope edges[] = p.facets;
                        int nEdges = edges.length;

                        int contourStart = 0;
                        #define INITIAL(sign) ((sign)==1?0:1)
                        #define FINAL(sign) ((sign)==1?1:0)
                        Polytope initialVertexOnContour = null; // initialization not necessary, but to shut up compiler
                        if (contourStart < nEdges)
                        {
                            assumpt(edges[contourStart].p.facets.length >= 2); // XXX can't we have an edge that's all of the line!? think about this (also same below)
                            initialVertexOnContour = edges[contourStart].p.facets[INITIAL(edges[contourStart].sign)].p;
                        }


                        //
                        // See whether this face has any multi-edges.
                        // If it does, it's no use trying to cosmeticize
                        // this face.
                        //
                        {
                            int iEdge;
                            FOR (iEdge, nEdges)
                            {
                                SPolytope sedgeI = edges[iEdge];
                                Polytope edgeI = sedgeI.p;
                                if (edgeI.facets.length != 2
                                 || edgeI.facets[0].sign != -1
                                 || edgeI.facets[1].sign != 1)
                                    break;
                            }
                            if (iEdge < nEdges)
                                continue; // this face has a multi-edge or something, so it's hopeless
                        }

                        FORI (iEdge, nEdges)
                        {
                            SPolytope sedgeI = edges[iEdge];
                            Polytope edgeI = sedgeI.p;
                            assert(edgeI.facets.length == 2
                             && edgeI.facets[0].sign == -1
                             && edgeI.facets[1].sign == 1);
                            Polytope finalVertexOnEdgeI = edgeI.facets[FINAL(sedgeI.sign)].p;
                            if (finalVertexOnEdgeI
                             == initialVertexOnContour)
                            {
                                // iEdge is the last edge on this contour.
                                contourStart = iEdge+1;
                                if (contourStart < nEdges)
                                {
                                    assumpt(edges[contourStart].p.facets.length >= 2); // XXX can't we have an edge that's all of the line!? think about this. (also same above)
                                    initialVertexOnContour = edges[contourStart].p.facets[INITIAL(edges[contourStart].sign)].p;
                                }
                            }
                            else
                            {
                                // iEdge is not the last edge on this contour;
                                // find the next one.
                                int jEdge;
                                for (jEdge = iEdge+1; jEdge < nEdges; jEdge++)
                                {
                                    SPolytope sedgeJ = edges[jEdge];
                                    Polytope edgeJ = sedgeJ.p;
                                    Polytope initialVertexOnEdgeJ = edgeJ.facets[INITIAL(sedgeJ.sign)].p;
                                    if (initialVertexOnEdgeJ == finalVertexOnEdgeI)
                                        break; // found next
                                }
                                assert(jEdge < nEdges); // found next
                                if (jEdge > iEdge+1)
                                {
                                    SPolytope temp;
                                    SWAP(edges[iEdge+1], edges[jEdge], temp);
                                }
                            }
                        }
                    }
                }
                if (verboseLevel >= 2)
                {
                    System.out.println("    After face cosmetic tweak:");
                    System.out.println("        "+sp.toString("        "));
                }
            } // face cosmetic tweak

            //
            // XXX One more potential nice cosmetic tweak:
            // XXX prefer nice orderings for earlier facets.
            //
            {
            }

            if (verboseLevel >= 1)
                System.out.println("out orientDeep");
        } // orientDeep



        //
        // p is an unfinished polytope (meaning we can and do
        // change it in place).
        // Assumes all facets' facets, etc. are already consistently oriented;
        // i.e. this must be called in a bottom-up order.
        //
        private static void orientFacetsConsistently(Polytope p)
        {
            if (verboseLevel >= 2)
            {
                System.out.println("in orientFacetsConsistently("+dimToPrefix(p.dim)+p.id+")");
                if (verboseLevel >= 3)
                    PRINT(p);
            }
            SPolytope facets[] = p.facets;
            int nFacets = facets.length;

            if (nFacets == 0)
            {
                if (verboseLevel >= 2)
                    System.out.println("out orientFacetsConsistently, boy that was hard :-)");
                return;
            }

            if (p.dim == 1)
            {
                if (nFacets > 2) // XXX maybe should do this anyway, for testing?
                {
                    //
                    // Take the farthest vertex from v0,
                    // and call it b.  Take the farthest vertex from b,
                    // and call it a.
                    // 
                    double a[], b[];
                    {
                        double from[] = facets[0].p.getCoords();
                        double farthest[] = null;
                        {
                            double farthestDistSqrd = Double.NEGATIVE_INFINITY;
                            FORI (iFacet, nFacets)
                            {
                                double thisCoords[] = facets[iFacet].p.getCoords();
                                double thisDistSqrd = VecMath.distsqrd(from, thisCoords);
                                if (thisDistSqrd > farthestDistSqrd)
                                {
                                    farthest = thisCoords;
                                    farthestDistSqrd = thisDistSqrd;
                                }
                            }
                            assert(farthest != null);
                        }
                        b = farthest;
                        from = b;
                        {
                            double farthestDistSqrd = Double.NEGATIVE_INFINITY;
                            FORI (iFacet, nFacets)
                            {
                                double thisCoords[] = facets[iFacet].p.getCoords();
                                double thisDistSqrd = VecMath.distsqrd(from, thisCoords);
                                if (thisDistSqrd > farthestDistSqrd)
                                {
                                    farthest = thisCoords;
                                    farthestDistSqrd = thisDistSqrd;
                                }
                            }
                            assert(farthest != null);
                        }
                        a = farthest;
                    }

                    final double dir[] = VecMath.vmv(b, a);

                    //
                    // Sort along dir...
                    //
                    SortStuff.sort(facets,
                                   new SortStuff.Comparator() {
                                       public int compare(Object _a, Object _b)
                                       {
                                           SPolytope a = (SPolytope)_a;
                                           SPolytope b = (SPolytope)_b;
                                           double aDot = VecMath.dot(a.p.getCoords(), dir);
                                           double bDot = VecMath.dot(b.p.getCoords(), dir);
                                           return aDot < bDot ? -1 :
                                                  aDot > bDot ? 1 : 0;
                                       }
                                   });
                } // if (nFacets > 2)

                int sign = -1;
                FORI (iFacet, nFacets)
                {
                    facets[iFacet].sign = sign;
                    sign = -sign;
                }
                if (verboseLevel >= 2)
                    System.out.println("out orientFacetsConsistently, edges are easy");
                return;
            }

            //
            // facetNeighbors[iFacet][iRidgeOnFacet][0] is the index
            // of the other facet sharing that ridge, and
            // facetNeighbors[iFacet][iRidgeOnFacet][1]
            // is the index of the ridge in the neighbor facet's facet list.
            // XXX perhaps finished polytopes should always have these tables
            // XXX so we don't have to recalculate them?
            //
            int facetNeighbors[][][] = new int[nFacets][][/*2*/];
            {
                FORI (iFacet, nFacets)
                    facetNeighbors[iFacet] = new int[facets[iFacet].p.facets.length][/*2*/];
                java.util.Hashtable firstFacetContainingRidge = new java.util.Hashtable();
                FORI (iFacet, nFacets)
                {
                    Polytope facet = facets[iFacet].p;
                    SPolytope ridgesThisFacet[] = facet.facets;
                    int nRidgesThisFacet = ridgesThisFacet.length;
                    FORI (iRidgeThisFacet, nRidgesThisFacet)
                    {
                        Polytope ridge = ridgesThisFacet[iRidgeThisFacet].p;
                        int myInfo[] = {iFacet, iRidgeThisFacet};
                        int neighborInfo[] = (int[])firstFacetContainingRidge.remove(ridge);
                        if (neighborInfo == null)
                        {
                            firstFacetContainingRidge.put(ridge, myInfo);
                        }
                        else
                        {
                            facetNeighbors[iFacet][iRidgeThisFacet] = neighborInfo;
                            facetNeighbors[neighborInfo[0]][neighborInfo[1]] = myInfo;
                        }
                    }
                }
                assert(firstFacetContainingRidge.size() == 0); // everything matched XXX change this assert to failure I think
            } // facetNeighbors

            int signOfFirstFacet = 1; // arbitrarily XXX is there a better choice?
            boolean isSigned[] = new boolean[nFacets];
            FORI (iFacet, nFacets)
                isSigned[iFacet] = false;

            SPolytope contours[][] = new SPolytope[nFacets][]; // worst case
            int nContours = 0; // and counting
            SPolytope currentContour[] = new SPolytope[nFacets];

            int stackHeight = 0;
            int stack[] = new int[nFacets];
            FORI (contourStart, nFacets)
            {
                if (!isSigned[contourStart])
                {
                    int currentContourSize = 0;
                    {
                        int iFacet = contourStart;
                        SPolytope facet = facets[iFacet];
                        facet.sign = signOfFirstFacet;
                        isSigned[iFacet] = true;
                        stack[stackHeight++] = iFacet; // push iFacet on to stack
                        currentContour[currentContourSize++] = facets[iFacet];
                    }
                    while (stackHeight != 0)
                    {
                        int iFacet = stack[--stackHeight]; // pop iFacet off of stack
                        SPolytope facet = facets[iFacet];
                        SPolytope ridgesThisFacet[] = facet.p.facets;
                        int nRidgesThisFacet = ridgesThisFacet.length;
                        FORI (iRidgeThisFacet, nRidgesThisFacet)
                        {
                            int neighborInfo[/*2*/] = facetNeighbors[iFacet][iRidgeThisFacet];
                            int iNeighbor = neighborInfo[0];
                            int iRidgeNeighborFacet = neighborInfo[1];

                            if (!isSigned[iNeighbor])
                            {
                                //System.out.println(""+iFacet+" -> "+iNeighbor+"");
                                SPolytope neighborFacet = facets[iNeighbor];
                                SPolytope ridgesNeighborFacet[] = neighborFacet.p.facets;

                                // Want facets[iFacet].sign
                                //          * ridgesThisFacet[iRidgeThisFacet].sign
                                //  = - facets[iNeighbor].sign
                                //          * ridgesNeighborFacet[iRidgeNeighborFacet].sign.
                                int signOfRidgeOnNeighbor = ridgesNeighborFacet[iRidgeNeighborFacet].sign;
                                assumpt(signOfRidgeOnNeighbor == 1
                                     || signOfRidgeOnNeighbor == -1); // otherwise should be / instead of * below, and I'm not sure what it means if it doesn't divide evenly, have to think about it some day

                                neighborFacet.sign = -facet.sign
                                                   * ridgesThisFacet[iRidgeThisFacet].sign
                                                   * signOfRidgeOnNeighbor;
                                isSigned[iNeighbor] = true;
                                stack[stackHeight++] = iNeighbor; // push iNeighbor on to stack
                                currentContour[currentContourSize++] = facets[iNeighbor];
                            }
                            else
                            {
                                //System.out.println("("+iFacet+" -> "+iNeighbor+")");
                            }
                        }
                    } // while (stackHeight != 0)
                    contours[nContours++] = (SPolytope[])Arrays.subarray(currentContour, 0, currentContourSize);
                }
            } // for contourStart
            FORI (iFacet, nFacets)
                assert(isSigned[iFacet]);

            //
            // Make temporary SPolytopes out of the contours...
            // XXX should avoid this if only one contour
            //
            SPolytope contourSPolytopes[] = new SPolytope[nContours];
            {
                FORI (iContour, nContours)
                    contourSPolytopes[iContour] = new SPolytope(0,1,
                                        new Polytope(p.dim,
                                                     p.fullDim,
                                                     contours[iContour],
                                                     p.contributingHyperplanes,
                                                     p.aux));
            }

            contours = null; // make sure we don't use it by accident after this

            //
            // Find the coordinate axis in which the bbox is the largest,
            // and sort the contour list according to
            // minimum coordinate along this coordinate axis.
            // Then an item in the sorted list
            // cannot contain any earlier item.
            //
            double bbox[][] = p.getBBox();
            double bboxSize[] = VecMath.vmv(bbox[1], bbox[0]);
            final int ax = VecMath.maxi(bboxSize);
            SortStuff.sort(contourSPolytopes,
                   new SortStuff.Comparator() {
                       public int compare(Object _a, Object _b)
                       {
                           SPolytope a = (SPolytope)_a;
                           SPolytope b = (SPolytope)_b;
                           double aDot = a.p.getBBox()[0][ax];
                           double bDot = b.p.getBBox()[0][ax];
                           return aDot < bDot ? -1 :
                                  aDot > bDot ? 1 : 0;
                       }
                   });


            if (verboseLevel >= 2
             && nContours > 1)
            {
                System.out.println("The contours:\n");
                FORI (iContour, nContours)
                {
                    System.out.println("    "+iContour+":");
                    System.out.println(contourSPolytopes[iContour]);
                }
            }


            //
            // Make a tree whose nodes are the contours,
            // ordered by contour inclusion.
            //
            int root = 0;
            int firstChild[] = VecMath.fillvec(nContours, -1);
            int nextSibling[] = VecMath.fillvec(nContours, -1);
            {
                double eps = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                // scratch for loop...
                    int densityMinMax[] = new int[2];

                for (int iContour = 1; iContour < nContours; ++iContour) // skip 0, it's already on the tree as the root
                {
                    double anyCoordsOnContour[];
                    {
                        // v = any vertex on contour iContour
                        Polytope v = contourSPolytopes[iContour].p;
                        while (v.dim > 0)
                            v = v.facets[0].p;
                        anyCoordsOnContour = v.getCoords();
                    }

                    // Hang iContour on the tree.
                    // Walk down the tree starting with root...
                    for (int iNode = root; ;)
                    {
                        SPolytope nodeSPolytope = contourSPolytopes[iNode];
                        calcDensity(nodeSPolytope,
                                    anyCoordsOnContour,
                                    eps,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        assumpt(density == densityMinMax[1]); // must be unambiguous
                        boolean isContainedInNode = (density&1) == 1;
                        if (isContainedInNode)
                        {
                            // proceed on to children
                            if (firstChild[iNode] == -1)
                            {
                                firstChild[iNode] = iContour;
                                break;
                            }
                            iNode = firstChild[iNode];
                        }
                        else
                        {
                            // proceed on to next sibling
                            if (nextSibling[iNode] == -1)
                            {
                                nextSibling[iNode] = iContour;
                                break;
                            }
                            iNode = nextSibling[iNode];
                        }
                    }
                }
            }
            if (verboseLevel >= 2
             && nContours > 1)
            {
                PRINTMAT(firstChild);
                PRINTMAT(nextSibling);
            }

            double normals[][] = new double[p.contributingHyperplanes.length][];
            {
                FORI (iHyperplane, normals.length)
                    normals[iHyperplane] = p.contributingHyperplanes[iHyperplane].normal;
            }

            //
            // Start by orienting all the contours in the same direction
            // (e.g. all counterclockwise).
            //
            {
                FORI (iContour, nContours)
                {
                    SPolytope contourSPolytope = contourSPolytopes[iContour];
                    double volume = volume(contourSPolytope);
                    if (volume < 0)
                    {
                        SPolytope facetsThisContour[] = contourSPolytope.p.facets;
                        int nFacetsThisContour = facetsThisContour.length;
                        FORI (iFacetThisContour, nFacetsThisContour)
                        {
                            SPolytope facet = facetsThisContour[iFacetThisContour];
                            facet.sign = -facet.sign;
                        }
                    }
                }
            }

            //
            // Reverse the signs of alternate levels of contours.
            // We use each contourSPolytope's sign to store +-1
            // depending on whether we are reversing it or not.
            // (the final value of its sign doesn't matter
            // since it is getting thrown away).
            //
            {
                FORI (iContour, nContours)
                {
                    SPolytope contourSPolytope = contourSPolytopes[iContour];
                    int sign = contourSPolytope.sign;
                    if (sign < 0)
                    {
                        SPolytope facetsThisContour[] = contourSPolytope.p.facets;
                        int nFacetsThisContour = facetsThisContour.length;
                        FORI (iFacetThisContour, nFacetsThisContour)
                        {
                            SPolytope facet = facetsThisContour[iFacetThisContour];
                            facet.sign = -facet.sign;
                        }
                    }
                    if (firstChild[iContour] != -1)
                        contourSPolytopes[firstChild[iContour]].sign = -sign;
                    if (nextSibling[iContour] != -1)
                        contourSPolytopes[nextSibling[iContour]].sign = sign;
                }
            }

            if (verboseLevel >= 2)
                System.out.println("out orientFacetsConsistently("+dimToPrefix(p.dim)+p.id+")");
        } // orientFacetsConsistently


// XXX I think PolyCSG should deal with SPolytopes, not Polytopes...
// XXX then this won't be necessary.  At least I think that's what I think.
#define SOON_TO_BE_DEFUNCT
#ifdef SOON_TO_BE_DEFUNCT
        /** Computes the union of two unsigned polytopes. */
        public static Polytope union(Polytope A, Polytope B)
        {
            return union(new SPolytope(0,1,A),
                         new SPolytope(0,1,B)).p;
        } // union of unsigned Polytopes
        /** Computes the intersection of two unsigned polytopes. */
        public static Polytope intersect(Polytope A, Polytope B)
        {
            return intersect(new SPolytope(0,1,A),
                             new SPolytope(0,1,B)).p;
        } // intersect of unsigned Polytopes
        /** Computes the difference of two unsigned polytopes. */
        public static Polytope diff(Polytope A, Polytope B)
        {
            return diff(new SPolytope(0,1,A),
                        new SPolytope(0,1,B)).p;
        } // diff of unsigned Polytopes
#endif // SOON_TO_BE_DEFUNCT

        private static String signToString(int sign)
        {
            return sign ==  1 ? "+" :
                   sign == -1 ? "-" :
                   sign ==  0 ? "!" :
                   "(sign="+sign+")";
        } // signToString

        private static String dimToPrefix(int dim)
        {
            if (dim <= 4)
                return "vefch".substring(dim,dim+1);
            else
                return "(" + dim + "d)"; // sort of lame but it's the best I can think of at the moment, and it doesn't seem to look too bad
        } // dimToPrefix

        // XXX this is really lame, should maybe restructure so we don't need it
        private static Object itemOfAThatsNotInB(Object A[], Object B[])
        {
            int iA, nA = A.length;
            int iB, nB = B.length;
            FOR (iA, nA)
            {
                FOR (iB, nB)
                    if (A[iA] == B[iB])
                        break;
                if (iB == nB) // A[iA] was not in B
                    return A[iA];
            }
            assert(false);
            return null;
        } // itemOfAThatsNotInB

        // XXX used by slice, remove if I get rid of slice
        private static Hyperplane[] addOneHyperplaneAndSort(Hyperplane[] list, Hyperplane last)
        {
            list = (Hyperplane[])Arrays.append(list, last);
            SortStuff.sort(list,
                           new SortStuff.Comparator() {
                               public int compare(Object _a, Object _b)
                               {
                                   Hyperplane a = (Hyperplane)_a;
                                   Hyperplane b = (Hyperplane)_b;
                                   return a.id < b.id ? -1 :
                                          a.id > b.id ? 1 : 0;
                               }
                           });
            return list;
        } // addOneHyperplaneAndSort

        private static Hyperplane[] unionOfHyperplanesAndSort(Hyperplane[] these, Hyperplane[] those)
        {
            Hyperplane list[] = (Hyperplane[])Arrays.concat(these, those);
            SortStuff.Comparator comparator =
               new SortStuff.Comparator() {
                   public int compare(Object _a, Object _b)
                   {
                       Hyperplane a = (Hyperplane)_a;
                       Hyperplane b = (Hyperplane)_b;
                       return a.id < b.id ? -1 :
                              a.id > b.id ? 1 : 0;
                   }
               };

            SortStuff.sort(list, comparator);
            int n = SortStuff.nodup(list, list.length, comparator);
            list = (Hyperplane[])Arrays.subarray(list, 0, n);
            return list;
        } // unionOfHyperplanesAndSort

        // return the point that is the intersection of n hyperplanes in n dimensions.
        private static double[] intersectHyperplanes(Hyperplane hyperplanes[])
        {
            int nHyperplanes = hyperplanes.length;
            if (nHyperplanes == 0)
                return new double[0];
            int iHyperplane;
            FOR (iHyperplane, nHyperplanes)
                if (hyperplanes[iHyperplane].spanningPoints == null)
                    break; // this hyperplane is not defined by spanning points
            if (iHyperplane == nHyperplanes)
            {
                //
                // All hyperplanes
                // are from spanning points.
                // We just need to find the one point
                // that is in the spanning set of all of them.
                //
                assert(nHyperplanes > 0); // we would have returned early above
                int iSpanningPoint, nSpanningPoints = hyperplanes[0].spanningPoints.length;
                FOR (iSpanningPoint, nSpanningPoints)
                {
                    double point[] = hyperplanes[0].spanningPoints[iSpanningPoint];
                    for (iHyperplane = 1; iHyperplane < nHyperplanes; ++iHyperplane)
                        if (Arrays.indexOfUsingEqualsSymbol(hyperplanes[iHyperplane].spanningPoints, point) == -1)
                            break; // it's not in this one
                    if (iHyperplane == nHyperplanes)
                    {
                        // It's in all of them!
                        return point;
                    }
                }
                assert(false); // XXX not sure if this can happen or not, so flag it for now and think about it if it goes off
            }

            //
            // Calculate explicit coords of the vertex.
            // We want column vector c
            // such that
            //    normal0 dot c == offset0
            //    normal1 dot c == offset1
            //    normal2 dot c == offset2
            //    ...
            // so c = inv(normalsMatrix) * offsetsColumnVector.
            //

#ifdef DEFUNCT
            int nRows = hyperplanes.length;
            double normalsMatrix[][] = new double[nRows][nRows];
            double offsetsColumnVector[][] = new double[nRows][1];

            double c[] = new double[nRows];
            FORI (iRow, nRows)
            {
                VecMath.copyvec(normalsMatrix[iRow], hyperplanes[iRow].normal);
                offsetsColumnVector[iRow][0] = hyperplanes[iRow].offset;
            }
            // replace normalsMatrix by its inverse,
            // replace offsetsColumnVector by the solution
            try
            {
                VecMath.gaussj(normalsMatrix, nRows,
                               offsetsColumnVector, 1);
            }
            catch (Exception e) // XXX singular matrix-- should figure out a cleaner way to do this
            {
                return null;
            }
            return VecMath.getcolumn(offsetsColumnVector, 0);
#endif // DEFUNCT

            int nRows = hyperplanes.length;
            double normalsMatrix[][] = new double[nRows][nRows];
            double offsetsColumnVector[] = new double[nRows];
            FORI (iRow, nRows)
            {
                VecMath.copyvec(normalsMatrix[iRow], hyperplanes[iRow].normal);
                offsetsColumnVector[iRow] = hyperplanes[iRow].offset;
            }
            double c[] = VecMath.invmxv(normalsMatrix, offsetsColumnVector);

            // XXX not an adequate test, I don't think
            if (c.length > 0
             && (Double.isInfinite(c[0])
              || Double.isNaN(c[0])))
                return null;

            return c;
        } // intersectHyperplanes



        //
        // Wrapper for a sorted array,
        // allowing it to be used as a hash key and value.
        // Equality is based on equality of the component items.
        // The hash code is the xor of all the component items' hash codes.
        // XXX should use sum, like some java structures do? think about it
        //
        private static class HashableSortedArray
        {
            private Object array[];
            public HashableSortedArray(Object array[])
            {
                this.array = array;
            }
            public int hashCode()
            {
                int hashCode = 0;
                int n = array.length;
                FORI (i, n)
                    hashCode ^= array[i].hashCode();
                return hashCode;
            } // equals
            public boolean equals(Object _that)
            {
                HashableSortedArray that = (HashableSortedArray)_that;
                Object[] these = this.array;
                Object[] those = that.array;
                int nThese = these.length, nThose = those.length;
                if (nThese != nThose)
                    return false;
                FORI (i, nThese)
                    if (!these[i].equals(those[i]))
                        return false;
                return true;
            } // equals
        } // class HashableSortedArray

        private static class HashablePair
        {
            private Object first, second;
            public HashablePair(Object first, Object second)
            {
                this.first = first;
                this.second = second;
            }
            public int hashCode()
            {
                return 3*first.hashCode() + second.hashCode();
            }
            public boolean equals(Object _that)
            {
                HashablePair that = (HashablePair)_that;
                return this.first.equals(that.first)
                    && this.second.equals(that.second);
            }
        } // class HashablePair


        private static int factorial(int n)
        {
            return n==0 ? 1 : n*factorial(n-1);
        }
        private static int intpow(int a, int b)
        {
            return b==0 ? 1 : intpow(a, b-1) * a;
        }
        private static int digit(int x, int i, int base)
        {
            return x / intpow(base,i) % base;
        }
        private static String intToString(int x, int base)
        {
            return (x>base ? intToString(x/base,base) : "") + x%base;
        }

        private static int numOccurancesOf(String str, String substr)
        {
            int numOccurances = 0;
            int i = -1;
            while ((i = str.indexOf(substr, i+1)) != -1)
                numOccurances++;
            return numOccurances;
        } // numOccurancesOf


    private static final boolean evalVerbose = false;
    /**
    *  Evaluate an expression such as "<code>(-((A-B) i (A i D))) u C</code>"
    *  from the beginning of a string,
    *  leaving the unparsed remainder of the string in the "rest" parameter.
    */
    public static SPolytope eval(
                String expr,     // XXX term, really... sorry for the confusion
                int dim,
                int fullDim,
                String varNames[/*1*/][], // array is passed by ref so can be resized
                SPolytope varValues[/*1*/][], // array is passed by ref so can be resized
                String rest[/*1*/]) // unparsed remainder of string is returned here
        throws java.text.ParseException
    {
        SPolytope result = null;
        String orig_expr = expr; // for error messages

        expr = expr.trim();
        if (expr.length() == 0)
            throw new java.text.ParseException("Empty expression \""+expr+"\"", orig_expr.length()-expr.length());
        char firstChar = expr.charAt(0);
        expr = expr.substring(1);

        if (firstChar == '0')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> 0");
            result = new SPolytope(0,1,
                                   new Polytope(dim,
                                                fullDim,
                                                new SPolytope[0], // no facets
                                                new Hyperplane[0], // no hyperplanes
                                                null)); // no aux // XXX use substring?
        }
        else if (firstChar == '1')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> 1");
            result = new SPolytope(1,1,
                                   new Polytope(dim,
                                                fullDim,
                                                new SPolytope[0], // no facets
                                                new Hyperplane[0], // no hyperplanes
                                                null)); // no aux // XXX use substring?
        }
        else if ("-~".indexOf(firstChar) != -1)
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> -expr");
            SPolytope operand = eval(expr,
                                     dim,
                                     fullDim,
                                     varNames,
                                     varValues,
                                     rest);
            expr = rest[0];
            result = complement(operand);
        }
        else if (firstChar == 's'
              && expr.startsWith("can(\""))
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> scan(\"quoted_string\")");
            int endQuoteIndex = expr.indexOf("\"", 5);
            if (endQuoteIndex < 0)
                throw new java.text.ParseException("bad bad bad expression \""+orig_expr+"\"", orig_expr.length()-expr.length());
            String fileName = expr.substring(5, endQuoteIndex);

            expr = expr.substring(endQuoteIndex+1);
            if (!expr.startsWith(")"))
                throw new java.text.ParseException("bad bad bad expression \""+orig_expr+"\"", orig_expr.length()-expr.length());
            expr = expr.substring(1);

            try {
                java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader(fileName));
                StringBuffer sb = new StringBuffer();
                char buf[] = new char[1024];
                int numRead = 0;
                while ((numRead = reader.read(buf)) > -1)
                    sb.append(String.valueOf(buf, 0, numRead));
                reader.close();
                String fileContents = sb.toString();
                result = SPolytope.fromStringInPcalcFormat(fileContents);
                // XXX LAME!  should be a method that reads from a Reader instead of having to slurp the whole file!
            }
            catch (java.io.IOException e)
            {
                throw new java.text.ParseException("Fooey, something went wrong reading file \""+fileName+"\": "+e, orig_expr.length()-expr.length());
            }
        }
        else if (firstChar == '(')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (something)  (not sure))");
            SPolytope LHS = eval(expr,
                                 dim,
                                 fullDim,
                                 varNames,
                                 varValues,
                                 rest);
            expr = rest[0];
            expr = expr.trim(); // XXX actually only need to trim at beginning
            if (expr.length() == 0)
                throw new java.text.ParseException("Premature end of expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
            char operatorChar = expr.charAt(0);
            expr = expr.substring(1);

            if (operatorChar == ')')
            {
                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr)  (now I'm sure)");
                result = LHS;
            }
            else
            {
                SPolytope RHS = eval(expr,
                                     dim,
                                     fullDim,
                                     varNames,
                                     varValues,
                                     rest);
                expr = rest[0];
                if (expr.length() == 0)
                    throw new java.text.ParseException("Unmatched left paren in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                char shouldBeCloseParen = expr.charAt(0);
                expr = expr.substring(1);
                if (shouldBeCloseParen != ')')
                    throw new java.text.ParseException("Expected ')', got '"+shouldBeCloseParen+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());

                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr binop expr)  (now I'm sure)");

                if ("i&".indexOf(operatorChar) != -1)
                    result = intersect(LHS, RHS);
                else if ("u|".indexOf(operatorChar) != -1)
                    result = union(LHS, RHS);
                else if ("dm-\\".indexOf(operatorChar) != -1)
                    result = diff(LHS, RHS);
                else if ("*x".indexOf(operatorChar) != -1)
                    result = cross(LHS, RHS);
                else
                    throw new java.text.ParseException("Unknown binary operation '"+operatorChar+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr "+operatorChar+" expr)");
            }
        }
        else if (Character.isJavaIdentifierStart(firstChar))
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> varName and maybe assignment, not sure");
            String varName = ""+firstChar;
            while (expr.length() > 0
                && Character.isJavaIdentifierPart(firstChar = expr.charAt(0)))
            {
                varName += firstChar;
                expr = expr.substring(1);
            }

            int iVar, nVars = varNames[0].length;
            FOR (iVar, nVars)
                if (varName.equals(varNames[0][iVar]))
                    break;

            // XXX grammar is violated here... we are making varName=value
            // XXX into a term when it should be an expression;
            // XXX e.g.  A - B = C  is legal
            // XXX and is equivalent to A - (B = C),
            // XXX when it shouldn't be legal :-(
            // XXX also A=B-C gets evaluated as (A=B)-C :-( :-(
            // XXX really need to fix this
            expr = expr.trim();
            if (expr.length() >= 1
             && expr.charAt(0) == '=')
            {
                expr = expr.substring(1);

                expr = expr.trim(); // XXX should be only at beginning
                if (expr.length() == 0
                 || expr.startsWith(")"))
                {
                    // unset the variable-- that is, crunch it out
                    // of both arrays, keeping the arrays in order.
                    if (iVar < nVars)
                    {
                        varNames[0] = (String[])Arrays.concat(
                            Arrays.subarray(varNames[0],0,iVar),
                            Arrays.subarray(varNames[0],iVar+1,nVars-(iVar+1)));
                        varValues[0] = (SPolytope[])Arrays.concat(
                            Arrays.subarray(varValues[0],0,iVar),
                            Arrays.subarray(varValues[0],iVar+1,nVars-(iVar+1)));
                    }

                    result = null;
                }
                else
                {
                    SPolytope RHS = eval(expr,
                                         dim,
                                         fullDim,
                                         varNames,
                                         varValues,
                                         rest);
                    expr = rest[0];

                    if (iVar == nVars)
                    {
                        // append the new name,value pair
                        varNames[0] = (String[])Arrays.append(varNames[0], varName);
                        varValues[0] = (SPolytope[])Arrays.append(varValues[0], RHS);
                    }
                    else
                    {
                        // replace old value
                        varValues[0][iVar] = RHS;
                    }

                    result = RHS;
                }
            }
            else
            {
                if (iVar == nVars)
                    throw new java.text.ParseException("Undefined variable \""+varName+"\" in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                result = varValues[0][iVar];
            }
        }
        else
        {
            throw new java.text.ParseException("Unexpected first char '"+firstChar+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
        }

        rest[0] = expr;
        return result;
    } // eval

    /**
    *  Evaluate an expression such as "<code>(-((A-B) i (A i D))) u C</code>".
    *  The grammar is:
    *  <pre>
    * 
    *           expr -&gt; term
    *           expr -&gt; term [i&amp;^*] term // intersect(LHS,RHS)
    *           expr -&gt; term [u|+] term  // union(LHS,RHS)
    *           expr -&gt; term [-\dm] term // diff(LHS,RHS)
    *           expr -&gt; varName = expr   // sets varName's value to value of expr
    *           term -&gt; "0"              // empty set
    *           term -&gt; "1"              // all of space
    *           term -&gt; varName          // corresponding varValue
    *           term -&gt; [~-] term        // complement(RHS)
    *           term -&gt; "(" expr ")"
    *           term -&gt; scan "(" quoted_string ")"
    *  </pre>
    * 
    *  Note all the alternative operator chars; I'm wishy washy.
    *  The ones that are letters must be separated from adjacent variable names
    *  by spaces.
    * 
    *  XXX need a way to unset a variable
    */
    public static SPolytope eval(
                String expr,
                int dim,
                int fullDim,
                String varNames[/*1*/][], // array is passed by ref so can be resized
                SPolytope varValues[/*1*/][]) // array is passed by ref so can be resized
        throws java.text.ParseException
    {
        String rest[] = new String[1];
        String term = "("+expr+")";


        // XXX hack that my little brain seems to want...
        // XXX add as many parens at beginning as necessary
        while (numOccurancesOf(term, "(")
             < numOccurancesOf(term, ")"))
        {
            term = "(" + term;
        }


        SPolytope result = eval(term,
                                dim,
                                fullDim,
                                varNames,
                                varValues,
                                rest);
        if (rest[0].length() != 0)
        {
            int errorOffsetInTerm = term.length() - rest[0].length();
            throw new java.text.ParseException("Trailing garbage \""+rest[0]+"\" in expression \""+term+"\"",errorOffsetInTerm);
        }

        if (!isOrientedDeep(result.p))
        {
            System.out.println("WARNING: top-level eval returning a badly oriented polytope!");
        }
        return result;
    } // eval



    /**
    *  A little test program...
    *  Take two hypercubes, and do union, intersection, and difference.
    */
    public static void main(String args[])
        throws java.io.IOException
    {
        System.out.println("in main");

        if (args.length < 1)
        {
            System.err.println("Usage: CSG <dim> [<expr>]");
            System.exit(1);
        }

        int fullDim = Integer.parseInt(args[0]);
        int dim = fullDim;

        if (false)
        {
            // just test simplex
            PRINT(makeSimplex(dim));
            return;
        }

        SPolytope A = makeHypercube(VecMath.fillvec(dim, -1.), 2.);
        SPolytope B = makeHypercube(VecMath.fillvec(dim,  1.), 2.);
        SPolytope C = makeHypercube(VecMath.fillvec(dim,  0.), 2.);
        //SPolytope simplex = makeSimplex(dim);
        SPolytope simplex = A; // XXX not ready yet

#ifdef DEFUNCT_BUT_NOTE // XXX can probably get rid of this now... but need to transfer the isOriented stuff somewhere in the shell!
        PRINT(A);
        PRINT(B);
        PRINT(C);

        if (false)
        {
            SPolytope AiB = intersect(A,B);
            PRINT(A);
            PRINT(B);
            PRINT(AiB);
            assert(isOrientedDeep(AiB.p));
        }
        if (false)
        {
            SPolytope AuB = union(A,B);
            PRINT(A);
            PRINT(B);
            PRINT(AuB);
            assert(isOrientedDeep(AuB.p));
        }
        if (false)
        {
            SPolytope AmB = diff(A,B);
            PRINT(A);
            PRINT(B);
            PRINT(AmB);
            assert(isOrientedDeep(AmB.p));
        }

        // Make a polytope with a cavity
        if (false)
        {
            SPolytope AiB = intersect(A,B);
            SPolytope Cm_AiB = diff(C, AiB);
            PRINT(A);
            PRINT(B);
            PRINT(C);
            PRINT(AiB);
            PRINT(Cm_AiB);
            assert(isOrientedDeep(Cm_AiB.p));
        }
#endif // DEFUNCT_BUT_NOTE

        if (args.length >= 2)
        {
            //
            // Evaluate given input expression
            //
            String expr = args[1];
            String varNames[][]     = {{"A","B","C","simplex"}};
            SPolytope varValues[][] = {{ A,  B,  C,  simplex }};
            SPolytope result = null;
            try
            {
                result = eval(expr,
                              dim,
                              fullDim,
                              varNames,
                              varValues);
            }
            catch (java.text.ParseException e)
            {
                System.err.println("Exception parsing expression \""+expr+"\": "+e);
            }
            PRINT(expr);
            PRINT(result);
        }
        else
        {
            //
            // Do a command shell.  Woohoo!
            //
            java.io.BufferedReader reader =
                new java.io.BufferedReader(
                    new java.io.InputStreamReader(System.in));

            // XXX hellacious hack for one-time-only pushback.
            // XXX it doesn't work anyway; the newline doesn't seem to make it.
            // XXX why not???
            if (false)
            {
                String nl = System.getProperty("line.separator");
                java.io.PushbackReader pushbackReader = new java.io.PushbackReader(new java.io.InputStreamReader(System.in), 100);
                pushbackReader.unread(("help"+nl).toCharArray());
                reader = new java.io.BufferedReader(pushbackReader);
            }

            String prompt = "yeah? ";

            String varNames[][]     = {{"A","B","C","simplex"}};
            SPolytope varValues[][] = {{ A,  B,  C,  simplex }};

            {
                System.out.println("Current variables:");
                FORI (iVar, varNames[0].length)
                {
                    System.out.print("    " + varNames[0][iVar] + " = ");
                    System.out.println(varValues[0][iVar].toString("        "));
                }
            }

            while (true)
            {
                System.out.print(prompt);
                String line = reader.readLine();
                if (line == null)
                    break;
                line = line.trim();
                if (line.equals(""))
                    continue;

                //
                // Special variables...
                //
                if (line.startsWith("v=")
                 || line.startsWith("v ="))
                {
                    verboseLevel = Integer.parseInt(line.substring(line.indexOf('=')+1));
                    PRINT(verboseLevel);
                    continue;
                }
                if (line.startsWith("d=")
                 || line.startsWith("d =")
                 || line.startsWith("dim=")
                 || line.startsWith("dim ="))
                {
                    fullDim = Integer.parseInt(line.substring(line.indexOf('=')+1));
                    dim = fullDim;
                    PRINT(dim);
                    System.out.println("WARNING: polytopes of different dimensions will act strangely when mixed");
                    continue;
                }
                if (line.equals("q")
                 || line.equals("quit")
                 || line.equals("exit"))
                {
                    break;
                }
                if (line.equals("help"))
                {
                    {
                        System.out.println("Current variables:");
                        FORI (iVar, varNames[0].length)
                        {
                            System.out.print("    " + varNames[0][iVar] + " = ");
                            System.out.println(varValues[0][iVar].toString("        "));
                        }
                    }
                    continue;
                }

                SPolytope result = null;
                try
                {
                    result = eval(
                                 line,
                                 dim,
                                 fullDim,
                                 varNames,
                                 varValues);
                }
                catch (java.text.ParseException pe)
                {
                    System.err.println("Parse error in expression \""+line+"\": ");
                    System.err.println("    "+pe.getLocalizedMessage()+", position "+pe.getErrorOffset());
                }
                if (result != null)
                {
                    System.out.println(result);
                    PRINTVEC(counts(result.p));
                    PRINT(volume(result));

                    FORI (iFacet, result.p.facets.length)
                    {
                        double areaNormalOfFacet[] = new double[dim];
                        areaNormal(areaNormalOfFacet, result.p.facets[iFacet]);
                        System.out.println("areaNormal(facets["+iFacet+"]) = "+ VecMath.toString(areaNormalOfFacet));
                        System.out.println("volume(facets["+iFacet+"]) = "+ volume(result.p.facets[iFacet]));
                    }

                    if (!isOrientedDeep(result.p))
                        System.out.println("WARNING: that was badly oriented!");
                    if (!isBinaryDensityDeep(result))
                        System.out.println("WARNING: that didn't have binary density!  Or something!");
                }
            }
        }

        System.out.println("out main");
    } // main


    //
    // Some special purpose polytope specifications,
    // pending getting a fully general makeRegularPolytope working.
    // These were generated using the commands:
    //    pcalc "{3,3}"
    //    pcalc "{5,3}"
    //    pcalc "{3,3,3}"
    //    pcalc "{5,3,3}"
    private static String pcalcString33 = ""
        +"4 0-cells:\n"
        +" 0:     0.5 0.28867513459481287 0.20412414523193151\n"
        +" 1:     0 0 -0.61237243569579447\n"
        +" 2:     0 -0.57735026918962573 0.20412414523193151\n"
        +" 3:     -0.5 0.28867513459481287 0.20412414523193151\n"
        +"6 1-cells:\n"
        +" 0:    -0 +1\n"
        +" 1:    -2 +1\n"
        +" 2:    -0 +2\n"
        +" 3:    -3 +1\n"
        +" 4:    -3 +2\n"
        +" 5:    -0 +3\n"
        +"4 2-cells:\n"
        +" 0:    +0 -1 -2\n"
        +" 1:    +1 -3 +4\n"
        +" 2:    -0 +5 +3\n"
        +" 3:    +2 -4 -5\n"
        +"1 3-cell:\n"
        +" 0:    +0 +1 +2 +3\n"
        ;
    private static String pcalcString333 = ""
        +"5 0-cells:\n"
        +" 0:     0.5 0.28867513459481287 0.20412414523193151 0.15811388300841897\n"
        +" 1:     0 0 0 -0.63245553203367588\n"
        +" 2:     0 0 -0.61237243569579447 0.15811388300841897\n"
        +" 3:     0 -0.57735026918962573 0.20412414523193151 0.15811388300841897\n"
        +" 4:     -0.5 0.28867513459481287 0.20412414523193151 0.15811388300841897\n"
        +"10 1-cells:\n"
        +" 0:    -0 +1\n"
        +" 1:    -2 +1\n"
        +" 2:    -0 +2\n"
        +" 3:    -3 +1\n"
        +" 4:    -3 +2\n"
        +" 5:    -0 +3\n"
        +" 6:    -4 +1\n"
        +" 7:    -4 +3\n"
        +" 8:    -0 +4\n"
        +" 9:    -4 +2\n"
        +"10 2-cells:\n"
        +" 0:    +0 -1 -2\n"
        +" 1:    +1 -3 +4\n"
        +" 2:    +0 -3 -5\n"
        +" 3:    +2 -4 -5\n"
        +" 4:    +3 -6 +7\n"
        +" 5:    +0 -6 -8\n"
        +" 6:    +5 -7 -8\n"
        +" 7:    +4 -9 +7\n"
        +" 8:    +2 -9 -8\n"
        +" 9:    +1 -6 +9\n"
        +"5 3-cells:\n"
        +" 0:    +0 +1 -2 +3\n"
        +" 1:    +2 +4 -5 +6\n"
        +" 2:    -3 -7 +8 -6\n"
        +" 3:    -0 -9 +5 -8\n"
        +" 4:    -1 -4 +9 +7\n"
        +"1 4-cell:\n"
        +" 0:    +0 +1 +2 +3 +4\n"
        ;
    private static String pcalcString53 = ""
        +"20 0-cells:\n"
        +"  0:     1.3090169943749477 0.5 0\n"
        +"  1:     0.80901699437494745 0.80901699437494745 -0.80901699437494745\n"
        +"  2:     0 1.3090169943749477 -0.5\n"
        +"  3:     0 1.3090169943749477 0.5\n"
        +"  4:     0.80901699437494745 0.80901699437494745 0.80901699437494745\n"
        +"  5:     0.5 0 -1.3090169943749477\n"
        +"  6:     -0.5 0 -1.3090169943749477\n"
        +"  7:     -0.80901699437494745 0.80901699437494745 -0.80901699437494745\n"
        +"  8:     1.3090169943749477 -0.5 0\n"
        +"  9:     0.80901699437494745 -0.80901699437494745 -0.80901699437494745\n"
        +" 10:     0 -1.3090169943749477 -0.5\n"
        +" 11:     -0.80901699437494745 -0.80901699437494745 -0.80901699437494745\n"
        +" 12:     -1.3090169943749477 -0.5 0\n"
        +" 13:     -1.3090169943749477 0.5 0\n"
        +" 14:     -0.80901699437494745 0.80901699437494745 0.80901699437494745\n"
        +" 15:     -0.80901699437494745 -0.80901699437494745 0.80901699437494745\n"
        +" 16:     -0.5 0 1.3090169943749477\n"
        +" 17:     0 -1.3090169943749477 0.5\n"
        +" 18:     0.80901699437494745 -0.80901699437494745 0.80901699437494745\n"
        +" 19:     0.5 0 1.3090169943749477\n"
        +"30 1-cells:\n"
        +"  0:    -0  +1\n"
        +"  1:    -2  +1\n"
        +"  2:    -3  +2\n"
        +"  3:    -3  +4\n"
        +"  4:    -0  +4\n"
        +"  5:    -5  +1\n"
        +"  6:    -5  +6\n"
        +"  7:    -6  +7\n"
        +"  8:    -2  +7\n"
        +"  9:    -0  +8\n"
        +" 10:    -8  +9\n"
        +" 11:    -5  +9\n"
        +" 12:    -10 +9\n"
        +" 13:    -10 +11\n"
        +" 14:    -6  +11\n"
        +" 15:    -12 +11\n"
        +" 16:    -13 +12\n"
        +" 17:    -13 +7\n"
        +" 18:    -13 +14\n"
        +" 19:    -3  +14\n"
        +" 20:    -12 +15\n"
        +" 21:    -16 +15\n"
        +" 22:    -16 +14\n"
        +" 23:    -17 +15\n"
        +" 24:    -17 +18\n"
        +" 25:    -19 +18\n"
        +" 26:    -19 +16\n"
        +" 27:    -19 +4\n"
        +" 28:    -8  +18\n"
        +" 29:    -17 +10\n"
        +"12 2-cells:\n"
        +"  0:    +0  -1  -2  +3  -4\n"
        +"  1:    +1  -5  +6  +7  -8\n"
        +"  2:    -0  +9  +10 -11 +5\n"
        +"  3:    -6  +11 -12 +13 -14\n"
        +"  4:    -7  +14 -15 -16 +17\n"
        +"  5:    +2  +8  -17 +18 -19\n"
        +"  6:    +20 -21 +22 -18 +16\n"
        +"  7:    -23 +24 -25 +26 +21\n"
        +"  8:    -3  +19 -22 -26 +27\n"
        +"  9:    +4  -27 +25 -28 -9\n"
        +" 10:    +12 -10 +28 -24 +29\n"
        +" 11:    -13 -29 +23 -20 +15\n"
        +"1 3-cell:\n"
        +" 0:    +0  +1  +2  +3  +4  +5  +6  +7  +8  +9  +10 +11\n"
        ;

    // Similar definition for pcalcString533,
    // too big to include here
    #include "CSGcrap.h"

} // CSG
