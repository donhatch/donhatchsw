/*
* Copyright (c) 2005,2006 Don Hatch Software
*/

//
// CSG.prejava
//
// Contains functions for doing boolean operations (union, intersection, diff)
// on polytopes (i.e. polygons or polyhedra or ...).
//
// Depends on:
//      VecMath.prejava
//      SortStuff.prejava
//
/*
    Bugs to fix:
        - fix signs like I said I would (what did I say? I can't recall)
        Was:
            -dim=1: A&A arrayIndexOutOfBounds: -1, in SortStuff.swap
            -dim=1: A-A arrayIndexOutOfBounds, same
            -dim=1: A|A arrayIndexOutOfBounds, same

            -dim=2: A&A Assertion failed at CSG.prejava(1240): Arrays.indexOf(slicee.p.contributingHyperplanes, hyperplane) == -1
            -dim=2: A-A same assertion failure
            -dim=2: A|A same assertion failure
        Now:
            -dim=1: A&A gives bogus bombed-out structure
            -dim=2: A&A Assumption failed at CSG.prejava(2392): n == list.length
            and simlarly for the other tests listed above
        Bleah, looking it over again, it seems like the algorithm
        can't handle A&A-- it computes the boundary of the intersection
        of A&B as bd(A)&B union A&bd(B), which is null...
        need a fundamental insight to fix this.

    To consider:
        - Should try to explain what the signs mean.  Some things
          to maybe mention...
            - note, the sum of signed vertices on an edge
              is actually the directed length of the edge
            - going back over an edge (or face) in the opposite
              direction means erasing it
            - for a proper edge, the sum of all vert's signs must be 0
              (otherwise it's a ray or something)
            - for a closed loop or surface, the boundary must have
              no boundary, i.e. the sum of the boundary of the boundary
              must be zero.
            - intersection is really min, union is really max,
              complement is really 1-.  The allowed polytopes
              are those that are constant density outside
              a bounded region; that constant density
              is called "initialDensity".
              The most common ones are finite and cofinite (i.e.
              those that are density 1 on a finite region and 0 elsewhere,
              and vice-versa.)
              (Might also allow more some day, but not at the moment.)
            - hmm, assuming the a.e. constant density restriction,
              this means all but top level polytopes
              must have initial density 0.
            - interesting, if we have a varying-positive-density
              polytope and we want the density-1 version,
              just intersect (i.e. min) it with 1.

        - does initialDensity have a meaning for vertices? (should it be 1? -1?)
        - make params X,Y instead of A,B? (since A,B are typical
              arguments; this might make debugging less confusing)
              But then I'll have to think of an alternative
              for alpha,beta that is not confusing...
              yamma, zigga? yalpha, zeta?
              ha, my humor is above everyone's head.
*/

package com.donhatchsw.util;

import com.donhatchsw.compat.regex;

#include "macros.h"


/**
*  Contains functions for doing n-dimensional Constructive Solid Geometry (CSG),
*  that is, boolean operations (union, intersection, diff)
*  on polytopes (i.e polygons or polyhedra or ...).
*  <p>
*  The objects that the boolean operators operate on
*  are CSG.Polytope and CSG.SPolytope (signed polytope).
*  The simplest way to create a CSG.Polytope
*  is probably by using the PolyCSG class.
*  Some primitive CSG.SPolytopes can also be made using makePolygon(),
*  makeSimplex(), and makeHypercube().
*  <p>
*  Caveats: not at all robust about concident or coplanar elements;
*  really only works reliably if everything is in general position.
*  <p>
*  Depends on classes:
*  <ul>
*       <li> Arrays </li>
*       <li> VecMath </li>
*       <li> SortStuff </li>
*       <li> FuzzyPointHashTable </li>
*  </ul>
*/
public final class CSG
{
    private CSG() {} // uninstantiatable
    //
    // Debugging setting...
    // I just set this appropriately and recompile.
    // XXX note, not final so that it can be changed in main.
    // XXX this should maybe be a compile-time option,
    // XXX since making it final gets rid of a lot of code.
    //
    //public static int verboseLevel = 2; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    //public static int verboseLevel = 1; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    //public static int verboseLevel = 0; // 3 = show gory details (XXX which are really gory and I should probably do away with)
    public static int verboseLevel = -1; // 3 = show gory details (XXX which are really gory and I should probably do away with)

    //
    // Data structures...
    //

        private static long nIds = 0; // so we can give a unique integer id to everything ever created
        private static Object nIdsLock = new Object(); // for synchronization
        private static java.util.Random randomGenerator = new java.util.Random(0);

        /**
        *  A hyperplane is the set of all
        *  points p such that (p dot normal) = offset.
        *  The closed halfspace it bounds is the set of all points p
        *  such that (p dot normal) <= offset.
        */
        public static class Hyperplane
        {
            public long id;
            public double normal[];
            public double offset;
            public double spanningPoints[][]; // optional; avoids recalculation of points (and resulting roundoff error) when points was the original representation.  XXX this idea seems to be lacking... e.g. if there are more than dim(plane)+1 points on the polygon, then we have to omit some.  think about this :-( )
            /** Creates a Hyperplane from a plane equation. */
            public Hyperplane(double normal[], double offset)
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.normal = normal;
                this.offset = offset;
                this.spanningPoints = null;
            } // Hyperplane from plane equation
            /** Creates a Hyperplane from a set of dim spanning points. */
            public Hyperplane(double spanningPoints[][])
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.spanningPoints = spanningPoints;

                assert(false); // XXX implement me! normal should be cross product of points vectors
                this.offset = VecMath.dot(this.normal,
                                          this.spanningPoints[0]);
            } // Hyperplane from spanning points

            public String toString()
            {
                return VecMath.toString(normal) + " " + offset;
            }
        } // class Hyperplane

        /**
        *  Unsigned (unoriented) polytope,
        *  defined by its boundary.
        *  <p>
        *  Note, the "dim" member wasn't stored here originally since
        *  it can be inferred as (dim of planes[0].normal) - (# of planes),
        *  except when (# of planes) == 0, in which case we can still infer
        *  it (recursively) as (dim of facets)+1, unless there
        *  are no facets... This was giving me a headache,
        *  so I'm just storing it explicitly here.
        *  <p>
        *  Similarly for "fullDim", only more so.
        */
        public static class Polytope
        {
            public long id;
            public int dim;     // dimension of the polytope
            public int fullDim; // dimension of the space it lives in
            public SPolytope facets[];
            public Hyperplane contributingHyperplanes[]; // the hyperplanes whose intersection is the space of this Polytope, in sorted order. // XXX sigh, should probably be a HashableSortedArray so we don't have to keep creating and destorying them every time we want to look it up... but that means this definition is getting more and more obscured
            public Object aux; // user data; creator can set this if desired
            private double _coords[];      // if vertex, null otherwise.  XXX should probably calculate only on demand, but then need a way to differentiate between dirty and nonexistent (for example, this is needed in getBBox below). XXX ctually not currently calculated at all.
            private double _bbox[/*2*/][]; // bounding box of all vertices, so it can be finite even if the polytope is infinite (co-finite).  calculated Lazily via getBBox().
            private Polytope[/*dim+1*/][] _allElements; // sorted lists of vertices, edges, ..., ridges, facets, calculated lazily via getAllElements()
            private int[/*dim+1*/][][/*dim+1*/][] _allIncidences; // calculated lazily via getAllIncidences

            public Polytope(int dim,
                            int fullDim,
                            SPolytope facets[],
                            Hyperplane contributingHyperplanes[],
                            Object aux)
            {
                if (verboseLevel >= 3)
                    System.out.println("in Polytope ctor");
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.dim = dim;
                this.fullDim = fullDim;
                this.facets = facets;
                this.contributingHyperplanes = contributingHyperplanes;
                this.aux = aux;
                this._coords = null;
                this._bbox = null;
                this._allElements = null;

                if (verboseLevel >= 3)
                {
                    System.out.print("    making "+this.id+": [");
                    if (facets == null)
                        System.out.println("(null)");
                    else
                        FORI (iFacet, facets.length)
                        {
                            System.out.print(" "
                                           + (facets[iFacet].sign==1?"+":facets[iFacet].sign==-1?"-":facets[iFacet].sign==0?"!":"?")
                                           + facets[iFacet].p.id);
                        }
                    System.out.println(" ]");
                }

                if (facets != null) // XXX maybe shouldn't be allowed, but makeHyperCube does it
                {
                    int nFacets = facets.length;
                    FORI (iFacet, nFacets)
                    {
                        Polytope facet = facets[iFacet].p;
                        assert(facet.fullDim == fullDim);
                        assert(facet.dim == dim-1);
                    }
                }

                if (verboseLevel >= 3)
                    System.out.println("out Polytope ctor");
            }

            // Note this just copies the pointer,
            // so don't give it a scratch buffer that you will overwrite!
            // (should take a const double[]).
            public void setCoords(double coords[])
            {
                _coords = coords;
            }

            // Returns a pointer to coords.
            // It is illegal to modify the contents
            // (should return const double[]).
            public double[] getCoords()
            {
                if (_coords == null)
                {
                    assert(dim == 0); // must be a vertex
                    _coords = intersectHyperplanes(contributingHyperplanes);
                }
                assert(_coords != null); // XXX not sure if I'm preventing this
                return _coords;
            } // getCoords

            //
            // When this is called, it is assumed
            // that the coords and connectivity
            // will not henceforth change.
            // XXX well I'm not completely firm on that, but if they do change, the bbox will have to be marked dirty, probably by setting it to null.
            //
            public double[/*2*/][] getBBox()
            {
                if (_bbox == null)
                {
                    // XXX should maybe say "if it's a vertex", i.e. if contributingHyperplanes.length == contributingHyperplanes[0].normal.length
                    if (dim == 0)
                    {
                        double coords[] = getCoords();
                        _bbox = new double[/*2*/][] {coords, coords};
                    }
                    else
                    {
                        _bbox = new double[2][fullDim];
                        VecMath.fillvec(_bbox[0], Double.POSITIVE_INFINITY);
                        VecMath.fillvec(_bbox[1], Double.NEGATIVE_INFINITY);
                        FORI (iFacet, facets.length)
                        {
                            double facetBBox[][] = facets[iFacet].p.getBBox();
                            FORI (iDim, _bbox[0].length)
                            {
                                _bbox[0][iDim] = MIN(_bbox[0][iDim], facetBBox[0][iDim]);
                                _bbox[1][iDim] = MAX(_bbox[1][iDim], facetBBox[1][iDim]);
                            }
                        }
                    }
                }
                return _bbox;
            } // getBBox

            /**
            * Get a list of all verts, edges, faces, ..., ridges, facets, self
            * of this polytope.
            * getAllElements()[iDim] is the list of iDim-dimensional sub-polytopes.
            */
            public Polytope[/*dim+1*/][] getAllElements()
            {
                if (_allElements == null)
                {
                    class VisitedAux
                    {
                        public Object savedAux;
                        public VisitedAux(Object savedAux)
                        {
                            this.savedAux = savedAux;
                        }
                    }

                    java.util.Vector lists[] = new java.util.Vector[dim+1];
                    {
                        FORI (iDim, dim+1)
                            lists[iDim] = new java.util.Vector();
                        java.util.Vector flatList = new java.util.Vector();

                        this.aux = new VisitedAux(this.aux); // mark it visited when queued
                        flatList.addElement(this);
                        FORI (flatIndex, flatList.size()) // while flatList.size() is increasing!
                        {
                            Polytope elt = (Polytope)flatList.elementAt(flatIndex); // not get, for 1.1
                            lists[elt.dim].addElement(elt);
                            FORI (iFacet, elt.facets.length)
                            {
                                Polytope facet = elt.facets[iFacet].p;
                                if (!(facet.aux instanceof VisitedAux)) // save even when elt.aux is null
                                {
                                    facet.aux = new VisitedAux(facet.aux); // mark it visited when queued
                                    flatList.addElement(facet);
                                }
                            }
                        }
                    }

                    _allElements = new Polytope[dim+1][];
                    FORI (iDim, dim+1)
                    {
                        _allElements[iDim] = new Polytope[lists[iDim].size()];
                        lists[iDim].copyInto(_allElements[iDim]);
                        SortStuff.sort(_allElements[iDim],
                                       new SortStuff.Comparator() {
                                           public int compare(Object _a, Object _b)
                                           {
                                               Polytope a = (Polytope)_a;
                                               Polytope b = (Polytope)_b;
                                               return a.id < b.id ? -1 :
                                                      a.id > b.id ? 1 : 0;
                                           }
                                       });
                        FORI (iElt, _allElements[iDim].length)
                        {
                            Polytope elt = _allElements[iDim][iElt];
                            elt.aux = ((VisitedAux)elt.aux).savedAux;
                        }
                    }
                } // if _allElements == null
                return _allElements;
            } // getAllElements()

            /**
            * Get a list of all the incidences between elements
            * occurring inside this polytope.
            *     getAllIncidences()[iDim][iElt][jDim]
            * is the list of all indices (into getAllElements()[jDim])
            * of jDim-dimensional elements
            * that are incident on iDim-dimensional element
            *     getAllElements()[iDim][iElt].
            * The result of this function gets cached,
            * so it is not time-consuming to call it multiple times.
            *
            * TODO:
            *     Should also return the back-indices...
            *     could make getAllIncidences()[iDim][iElt][jDim][index]
            *     be a pair {jElt,backIndex}
            *     such that getAllElements()[jDim][jElt][iDim][backIndex]
            *                                                 = {iElt,index}.
            * That would be useful, for example,
            * for mapping from an {iFacet,iRidgeThisFacet}
            * pair to its twin {jFacet,jRidgeThisFacet}
            * that refers to the same ridge (with opposite sign).
            *
            * Have to think about whether it is useful in general though,
            * or only for ridges... if only ridges, maybe it would be
            * a big waste of space.
            *
            * XXX If I do this, take a look at orientFacetsConsistently,
            * XXX it could use it.
            */
            public int[/*dim+1*/][][/*dim+1*/][] getAllIncidences()
            {
                if (_allIncidences == null)
                {
                    Polytope allElts[][] = getAllElements();

                    //
                    // We don't know how many incidences each element
                    // has beforehand.  We could do this by starting
                    // with a gzillion Vectors and then converting to arrays
                    // at the end... but there are a gzillion of them.
                    // So instead, we do it in two passes--
                    // a counting pass, then allocate arrays
                    // of the right size, then a filling pass.
                    //

                    int counts[][][] = new int[allElts.length][][];
                    FORI (iDim, dim+1)
                    {
                        counts[iDim] = new int[allElts[iDim].length][];
                        FORI (iElt, allElts[iDim].length)
                            counts[iDim][iElt] = new int[dim+1]; // zeros
                    }


                    // Mark each element temporarily with its index in allElts,
                    // so we don't have to do time consuming searches...
                    class GlobalIndexAux
                    {
                        public int globalIndex;
                        public Object savedAux;
                        public GlobalIndexAux(int globalIndex, Object savedAux)
                        {
                            this.globalIndex = globalIndex;
                            this.savedAux = savedAux;
                        }
                    }
                    FORI (iDim, dim+1)
                    FORI (iElt, allElts[iDim].length)
                    {
                        Polytope elt = allElts[iDim][iElt];
                        elt.aux = new GlobalIndexAux(iElt, elt.aux);
                    }

                    FORI (iPass, 2) // iPass=0: count, iPass=1: fill
                    {
                        FORI (iDim, dim+1)
                        FORI (iElt, allElts[iDim].length)
                        {
                            Polytope elt = allElts[iDim][iElt];
                            Polytope allEltsOfElt[][] = elt.getAllElements();
                            FORI (jDim, elt.dim+1)
                            FORI (jEltLocal, allEltsOfElt[jDim].length)
                            {
                                Polytope eltElt = allEltsOfElt[jDim][jEltLocal];
                                int jEltGlobal = ((GlobalIndexAux)eltElt.aux).globalIndex;
                                if (false)
                                    System.out.println("    elt "+dimToPrefix(iDim)+elt.id
                                             +"("+iDim+")"
                                             +" has eltElt "+dimToPrefix(jDim)+eltElt.id
                                             +"("+jEltGlobal+")"
                                             );
                                if (iPass == 1) // if it's the filling pass
                                    _allIncidences[jDim][jEltGlobal][iDim][counts[jDim][jEltGlobal][iDim]] = iElt;
                                counts[jDim][jEltGlobal][iDim]++;
                                if (jDim != iDim)
                                {
                                    if (iPass == 1) // if it's the filling pass
                                        _allIncidences[iDim][iElt][jDim][counts[iDim][iElt][jDim]] = jEltGlobal;
                                    counts[iDim][iElt][jDim]++;
                                }
                            }
                        }
                        if (iPass == 0)
                        {
                            // Got the counts,
                            // do the allocations.
                            _allIncidences = new int[counts.length][][][];
                            FORI (iDim, dim+1)
                            {
                                _allIncidences[iDim] = new int[counts[iDim].length][][];
                                FORI (iElt, allElts[iDim].length)
                                {
                                    _allIncidences[iDim][iElt] = new int[counts[iDim][iElt].length][];
                                    FORI (jDim, dim+1)
                                    {
                                        _allIncidences[iDim][iElt][jDim] = new int[counts[iDim][iElt][jDim]];
                                        counts[iDim][iElt][jDim] = 0;
                                    }
                                }
                            }
                        }
                    }

                    // restore old auxs...
                    FORI (iDim, dim+1)
                    FORI (iElt, allElts[iDim].length)
                    {
                        Polytope elt = allElts[iDim][iElt];
                        elt.aux = ((GlobalIndexAux)elt.aux).savedAux;
                    }

                    if (false)
                    {
                        System.out.println("All incidences:");
                        PRINTARRAY(_allIncidences);
                        FORI (iDim, _allIncidences.length)
                        {
                            FORI (iElt, _allIncidences[iDim].length)
                            {
                                Polytope elt = allElts[iDim][iElt];
                                System.out.println("    "+dimToPrefix(iDim)+elt.id+":");
                                FORI (jDim, _allIncidences[iDim][iElt].length)
                                {
                                    System.out.print("    ");
                                    FORI (jElt, _allIncidences[iDim][iElt][jDim].length)
                                    {
                                        Polytope inc = allElts[jDim][_allIncidences[iDim][iElt][jDim][jElt]];
                                        System.out.print(" "+dimToPrefix(jDim)+inc.id);
                                    }
                                    System.out.println("    ");
                                }
                            }
                            System.out.println();
                        }
                    }
                }
                return _allIncidences;
            } // getAllIncidences

            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails,
                                   java.util.Hashtable printedAlready)
            {
                String nl = System.getProperty("line.separator");
                if (printedAlready == null)
                    printedAlready = new java.util.Hashtable();

                StringBuffer sb = new StringBuffer();
                if (showGoryDetails)
                {
                    sb.append("Polytope "+id+" {" + nl);
                    if (printedAlready.containsKey(this))
                    {
                        sb.append(indentString + "    (printed already)" + nl);
                    }
                    else
                    {
                        printedAlready.put(this,this);

                        if (showAux)
                            sb.append(indentString + "    (aux="+aux+")");
                        sb.append(indentString + "    "+facets.length+" facet"+(facets.length==1?"":"s")+": {" + nl);
                        FORI (iFacet, facets.length)
                        {
                            sb.append(indentString + "        " + facets[iFacet].toString(indentString+"        ", showAux, showGoryDetails, printedAlready) + nl);
                        }
                        sb.append(indentString + "    }" + nl);

                        sb.append(indentString + "    "+contributingHyperplanes.length+" contributing hyperplane"+(contributingHyperplanes.length==1?"":"s")+": {" + nl);
                        FORI (iHyperplane, contributingHyperplanes.length)
                        {
                            sb.append(indentString + "        " + contributingHyperplanes[iHyperplane] + nl);
                        }
                        sb.append(indentString + "    }" + nl);

                        sb.append(indentString + "    _coords = " + VecMath.toString(_coords) + nl);
                        sb.append(indentString + "    _bbox = " + VecMath.toString(_bbox) + nl);
                    }
                    sb.append(indentString + "}");
                }
                else
                {
                    sb.append(dimToPrefix(dim));
                    sb.append(id);

                    if (showAux)
                    {
                        sb.append(" (aux="+aux+")");
                    }

                    //sb.append("[");
                    if (printedAlready.containsKey(this))
                    {
                        if (true)
                            sb.append(" (see above)");
                    }
                    else
                    {
                        printedAlready.put(this,this);
                        FORI (iHyperplane, contributingHyperplanes.length)
                        {
                            sb.append("  (" + contributingHyperplanes[iHyperplane] + ")");
                        }
                        if (dim == 0)
                        {
                            if (_coords != null)
                            {
                                sb.append("  :  " + VecMath.toString(_coords));
                                // XXX Should probably do the below anyway,
                                // XXX and also keep track
                                // XXX of whether coords have been
                                // XXX computed or set explicitly
                            }
                            else
                            {
                                // Find explicit coords of the vertex.
                                // We want column vector c
                                // such that
                                //    normal0 dot c == offset0
                                //    normal1 dot c == offset1
                                //    normal2 dot c == offset2
                                // etc.
                                // so c = inv(normalsMatrix) * offsetsColumnVector.

                                int nRows = contributingHyperplanes.length;
                                double normalsMatrix[][] = new double[nRows][nRows];
                                double offsetsColumnVector[][] = new double[nRows][1];
                                FORI (iRow, nRows)
                                {
                                    VecMath.copyvec(normalsMatrix[iRow], contributingHyperplanes[iRow].normal);
                                    offsetsColumnVector[iRow][0] = contributingHyperplanes[iRow].offset;
                                }
                                // replace normalsMatrix by its inverse,
                                // replace the offsets in c by the solution
                                try {
                                    VecMath.gaussj(normalsMatrix, nRows,
                                                   offsetsColumnVector, 1);
                                    double c[] = VecMath.getcolumn(offsetsColumnVector, 0);

                                    sb.append("  ->  " + VecMath.toString(c));
                                }
                                catch (Exception e)
                                {
                                    sb.append("  -> !!!!!!!!!!!!!!!!!! singular matrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                                }
                            }
                        }
                        FORI (iFacet, facets.length)
                        {
                            sb.append(nl + indentString + "    ");
                            assert(facets[iFacet] != null);
                            sb.append(facets[iFacet].toString(indentString+"    ", showAux, false, printedAlready));
                            if (iFacet+1 < facets.length)
                                sb.append(" ");
                        }
                    }
                    //sb.append("]");
                }
                return sb.toString();
            } // Polytope.toString
            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails)
            {
                return toString(indentString,
                                showAux,
                                showGoryDetails,
                                null);
            }
            public String toString(String indentString,
                                   boolean showAux)
            {
                return toString(indentString,
                                showAux,
                                false);
            }
            public String toString(String indentString)
            {
                return toString(indentString,
                                false);
            }
            public String toString(boolean showAux)
            {
                return toString("",
                                showAux);
            }
            public String toString()
            {
                return toString("",
                                false);
            }

            /** Parses a polytope from a string the "pcalc" program's format. */
            // XXX should really do this from a reader, then fromString... could just hook up a StringReader and go
            // XXX this is private because it does NOT initialize the hyperplanes, the caller does.
            // XXX this should just be gotten rid of.
            private static Polytope fromStringInPcalcFormat(String s)
            {
                //System.out.println("scanning...");
                //System.out.flush();
                Polytope answer = null;
                {
                    int fullDim = -1;
                    Polytope facets[] = null;

                    String lines[] = regex.split(s.trim(), "\\s*\n\\s*");
                    int iLine = 0;
                    for (int iDim = 0; ; iDim++)
                    {
                        if (iLine >= lines.length)
                            break;
                        String line = lines[iLine++];
                        // scan "%d %d-cel%*[^:]:", &nCells, &shouldBeIDim
                        regex.Matcher matcher = regex.Pattern.compile("(\\d+) (\\d+)-cell[^:]*:").matcher(line);
                        if (!matcher.matches())
                            throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected number of "+iDim+"-cells, got \""+line+"\"!");
                        int nCells = Integer.parseInt(matcher.group(1));
                        int shouldBeIDim = Integer.parseInt(matcher.group(2));

                        if (shouldBeIDim != iDim)
                            throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cells, got "+shouldBeIDim+"-cells!");
                        if (nCells == 0)
                            continue;
                        Polytope cells[] = new Polytope[nCells];

                        FORI (iCell, nCells)
                        {
                            if (iLine >= lines.length)
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: premature end-of-string expecting "+iDim+"-cell "+iCell+"!");
                            line = lines[iLine++];
                            // Read the index and colon.  This is for human-readability
                            // and sanity checking.
                            // scan "%d:", &shouldBeICell
                            matcher = regex.Pattern.compile("(\\d+):(.*)").matcher(line);
                            if (!matcher.matches())
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cell "+iCell+", got \""+line+"\"!");
                            int shouldBeICell = Integer.parseInt(matcher.group(1));
                            String rest = matcher.group(2);

                            if (shouldBeICell != iCell)
                                throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: expected "+iDim+"-cell "+iCell+", got "+shouldBeICell+"!");
                            String tokens[] = regex.split(rest.trim(), "\\s+");
                            if (iDim == 0)
                            {
                                //
                                // Read vertex coords from tokens on this line.
                                //
                                if (fullDim == -1)
                                    fullDim = tokens.length;
                                else
                                    if (tokens.length != fullDim)
                                    {
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: inconsistent vertex dimensions "+fullDim+", "+tokens.length+"!");
                                    }
                                double coords[] = new double[fullDim];
                                FORI (iCoord, fullDim)
                                    coords[iCoord] = com.donhatchsw.compat.Double.parseDouble(tokens[iCoord]);
                                cells[iCell] = new Polytope(iDim,
                                                            fullDim,
                                                            new SPolytope[0],
                                                            new Hyperplane[0], // contributing hyperplanes will get filled out later
                                                            null); // no aux
                                cells[iCell].setCoords(coords);
                            }
                            else
                            {
                                //
                                // Read signed facet indices from tokens on this line.
                                //
                                SPolytope mySignedFacets[] = new SPolytope[tokens.length];
                                FORI (iToken, tokens.length)
                                {
                                    String token = tokens[iToken];
                                    int sign = 0;
                                    if (token.startsWith("-"))
                                        sign = -1;
                                    else if (token.startsWith("+"))
                                        sign = 1;
                                    else if (token.startsWith("!"))
                                        sign = 0;
                                    else
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: bad facet specification "+token+" in "+iDim+"-cell "+iCell+"!");
                                    token = token.substring(1);
                                    int iFacet = Integer.parseInt(token);
                                    if (iFacet < 0 || iFacet >= facets.length)
                                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: out-of-range facet specification "+token+" in "+iDim+"-cell "+iCell+"! (there are only "+facets.length+" possible facets)");
                                    mySignedFacets[iToken] = new SPolytope(0,sign,
                                                                           facets[iFacet]);
                                }
                                cells[iCell] = new Polytope(iDim,
                                                            fullDim,
                                                            mySignedFacets,
                                                            new Hyperplane[0], // contributing hyperplanes will get filled out later
                                                            null); // no aux
                            }
                        }

                        facets = cells;
                    }
                    if (facets == null || facets.length == 0)
                        throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: premature end-of-string or something");
                    answer = facets[0];
                }

                // Now we have to go through
                // and set the planes defining every element,
                // starting with the facets.
                if (answer.dim != answer.fullDim)
                    throw new IllegalArgumentException("Polytope.fromStringInPcalcFormat: dimension "+answer.dim+" does not match dimension of vertices "+answer.fullDim+"!");

                answer.contributingHyperplanes = new Hyperplane[0];
                FORI (iFacet, answer.facets.length)
                {
                    SPolytope facet = answer.facets[iFacet];
                    double normal[] = new double[answer.fullDim];
                    areaNormal(normal, facet); // get area normal of facet
                    VecMath.normalize(normal,normal);
                    Polytope someVertexOnFacet = facet.p;
                    while (someVertexOnFacet.dim > 0)
                        someVertexOnFacet = someVertexOnFacet.facets[0].p;
                    double offset = VecMath.dot(normal, someVertexOnFacet.getCoords());
                    if (offset < 0.)
                    {
                        VecMath.vxs(normal, normal, -1.);
                        offset *= -1.;
                    }
                    Hyperplane hyperplane = new Hyperplane(normal, offset);
                    Hyperplane hyperplanes[] = {hyperplane};

                    //
                    // Add this hyperplane as a contributing
                    // hyperplane to every cell of this facet
                    // (including this facet itself).
                    //
                    Polytope allElements[][] = facet.p.getAllElements();
                    FORI (i, allElements.length)
                    FORI (j, allElements[i].length)
                    {
                        Polytope e = allElements[i][j];
                        e.contributingHyperplanes = unionOfHyperplanesAndSort(e.contributingHyperplanes, hyperplanes);
                    }
                }

                //System.out.println("done.");
                //System.out.flush();
                return answer;
            } // fromStringInPcalcFormat
        } // class Polytope

        /**
        *  Signed (oriented) polytope.
        *  <br>
        *  InitialDensity is the "density at (-inf,-inf,...)",
        *  which is 0 for finite polytopes and 1 for cofinite ones
        *  (the concept simply breaks down for polytopes
        *  that are neither finite nor cofinite).
        *  <p>
        *  Representing both finite and cofinite polytopes
        *  in this way eases our job in implementing CSG:
        *  we need only implement intersection;
        *  then the other operations are expressible trivially:
        *  <pre>
        *       union(A,B) = -intersect(-A,-B)
        *       diff(A,B)  = intersect(A,-B)
        *  </pre>
        */
        public static class SPolytope
        {
            public long id;
            public int initialDensity; // 0 or 1
            public int sign;           // +1 or -1
            public Polytope p;
            public SPolytope(int initialDensity,
                             int sign,
                             Polytope p)
            {
                synchronized(nIdsLock)
                {
                    this.id = nIds++;
                }
                this.initialDensity = initialDensity;
                this.sign = sign;
                this.p = p;
            }

            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails,
                                   java.util.Hashtable printedAlready)
            {
                String nl = System.getProperty("line.separator");
                if (printedAlready == null)
                    printedAlready = new java.util.Hashtable();

                StringBuffer sb = new StringBuffer();
                if (showGoryDetails)
                {
                    sb.append("SPolytope "+id+" {" + nl);
                    if (printedAlready.containsKey(this))
                    {
                        sb.append(indentString + "    (printed already)" + nl);
                    }
                    else
                    {
                        printedAlready.put(this,this);

                        sb.append(indentString + "    initialDensity = " + initialDensity + nl);
                        sb.append(indentString + "    sign = " + sign + nl);
                        sb.append(indentString + "    p = " + p.toString(indentString+"    ", showAux, showGoryDetails, printedAlready) + nl);
                    }
                    sb.append(indentString + "}");
                }
                else
                {
                    if (initialDensity != 0)
                        sb.append(initialDensity);
                    sb.append(signToString(sign));
                    if (p != null)
                        sb.append(p.toString(indentString, showAux, showGoryDetails, printedAlready));
                    else
                        sb.append("null");
                }
                return sb.toString();
            } // SPolytope.toString
            public String toString(String indentString,
                                   boolean showAux,
                                   boolean showGoryDetails)
            {
                return toString(indentString,
                                showAux,
                                showGoryDetails,
                                null);
            }
            public String toString(String indentString,
                                   boolean showAux)
            {
                return toString(indentString, showAux, false);
            }
            public String toString(String indentString)
            {
                return toString(indentString, false);
            }
            public String toString(boolean showAux)
            {
                return toString("", showAux);
            }
            public String toString()
            {
                return toString("", false);
            }

            /** Parses a signed polytope from a string the "pcalc" program's format. */
            public static SPolytope fromStringInPcalcFormat(String s)
            {
                SPolytope answer = new SPolytope(0,1,Polytope.fromStringInPcalcFormat(s));
                bootstrapHyperplanes(answer);
                // XXX bleah, figure out whether the bootstrap function should do the following... note that bootstrapHyperplanes already called orientDeep twice :-(
                //PRINT(volume(answer));
                double vol = volume(answer);
                if (vol < 0)
                {
                    answer.sign *= -1;
                    // XXX should do the push-down-sign thing? yes
                    orientDeep(answer); // XXX really only want push-down-sign thing
                    // XXX and it's not even implemented!!! grrr
                }
                //PRINT(volume(answer));
                return answer;
            } // fromStringInPcalcFormat

        } // class SPolytope



    //
    // Some primitive SPolytopes...
    //
        /** Makes a polygon from the given vertices in n dimensions. */
        public static SPolytope makePolygon(double verts[][])
        {
            int dim = 2;
            int fullDim = verts[0].length;
            assert(fullDim == 2); // XXX could try to do it in higher dimensions; would require getting a hyperplane basis for the othogonal complement space, I think
            int nVerts = verts.length;

            //
            // Create the hyperplanes...
            //
            Hyperplane hyperplanes[] = new Hyperplane[nVerts];
            {
                // scratch for loop... note edgeNormal can't be reused
                /// since the hyperplane stores a pointer to it.
                double edgeBackwards[] = new double[fullDim];
                FORI (i, nVerts)
                {
                    VecMath.vmv(edgeBackwards, verts[i], verts[(i+1)%nVerts]);
                    double edgeNormal[] = VecMath.xv2(edgeBackwards);
                    hyperplanes[i] = new Hyperplane(edgeNormal,
                                                    VecMath.dot(edgeNormal,
                                                                verts[i]));
                }
            }
            //
            // Create a polytope for each vertex...
            //
            Polytope vertPolytopes[] = new Polytope[nVerts];
            {
                FORI (i, nVerts)
                {
                    Hyperplane subHyperplanes[] = {hyperplanes[i],
                                                   hyperplanes[(i-1+nVerts)%nVerts]};
                    vertPolytopes[i] = new Polytope(0,
                                                    fullDim,
                                                    new SPolytope[0],
                                                    subHyperplanes,
                                                    null); // no aux
                }
            }
            //
            // Create a polytope for each edge...
            //
            SPolytope edgeSPolytopes[] = new SPolytope[nVerts];
            {
                FORI (i, nVerts)
                {
                    Hyperplane subHyperplanes[] = {hyperplanes[i]};
                    SPolytope vertsThisEdge[] = {
                        new SPolytope(0,-1,vertPolytopes[i]),
                        new SPolytope(0,1, vertPolytopes[(i+1)%nVerts]),
                    };
                    edgeSPolytopes[i] = new SPolytope(0,1,
                                         new Polytope(1,
                                                      fullDim,
                                                      vertsThisEdge,
                                                      subHyperplanes,
                                                      null)); // no aux
                }
            }
            SPolytope faceSPolytope = new SPolytope(0,1,
                                          new Polytope(2,
                                                       fullDim,
                                                       edgeSPolytopes,
                                                       new Hyperplane[0],
                                                       null)); // no aux
            return faceSPolytope;
        } // makePolygon

        /**
        * Makes a regular (n/d)-gon of edge length 2, centered at the origin,
        * with a face pointing in the -Y axis direction.
        * (That makes it so that, when used as the right-hand-side
        * of a product, the result will appear face-first if -W means "first").
        */
        public static SPolytope makeRegularPolygon(int n, int d)
        {
            double verts[][] = new double[n][2];
            double R = 1./Math.sin(Math.PI*d/n); // circumradius
            FORI (i, n)
            {
                double ang = -Math.PI*.5 + 2*Math.PI*d/n*(i+.5); // so a face points in the -Y axis dir
                verts[i][0] = R * Math.cos(ang);
                verts[i][1] = R * Math.sin(ang);
            }
            return makePolygon(verts);
        }

        /** Makes an n-dimensional simplex with edge length 2, centered at the origin. */
        public static SPolytope makeSimplex(int nDims)
        {
            assumpt(nDims >= 1); // should just return a vert I guess
            return makeRegularPolytope(VecMath.fillvec(nDims-1, 3));
        } // makeSimplex



        /** Makes an n-dimensional hypercube of in-radius 1, centered at the origin. */
        public static SPolytope makeHypercube(int nDims)
        {
            assumpt(nDims >= 1); // should just return a vert I guess
            int schlafli[] = VecMath.fillvec(nDims-1, 3);
            if (nDims-1 > 0)
                schlafli[0] = 4;
            return makeRegularPolytope(schlafli);
        } // makeHypercube(unit inRadius, centered at origin)

        /** Makes an n-dimensional hypercube with given center and in-radius. */
        public static SPolytope makeHypercube(double center[],
                                              double inRadius)
        {
            SPolytope answer = makeHypercube(center.length);
            Polytope verts[] = answer.p.getAllElements()[0];
            FORI (iVert, verts.length)
            {
                VecMath.vxs(verts[iVert].getCoords(),
                            verts[iVert].getCoords(),
                            inRadius);
                VecMath.vpsxv(verts[iVert].getCoords(),
                              center,
                              inRadius,
                              verts[iVert].getCoords());
            }
            FORI (iFacet, answer.p.facets.length)
            {
                Hyperplane contributingHyperplanes[] = answer.p.facets[iFacet].p.contributingHyperplanes;
                assert(contributingHyperplanes.length == 1);
                Hyperplane hyperplane = contributingHyperplanes[0];
                assert(hyperplane.offset == 1);
                hyperplane.offset = VecMath.dot(hyperplane.normal, center) + inRadius;
            }
            return answer;
        } // makeHypercube


        /**
        * Makes a regular polytope of edge length 2, centered at the origin,
        * from its schlafli symbol.
        * The orientation is facet-first along the negative last coordinate
        * axis.
        */
        public static SPolytope makeRegularPolytope(int schlafli[/*nDims-1*/])
        {
            return makeRegularStarPolytope(schlafli, null, null);
        } // makeRegularPolytope

        // Calculate the characteristic simplex edge lengths
        // for the characteristic simplex of a {p,q,r,...,z}
        // with edge length 2.
        // The result is:
        //      x[0] = 1 = dist from vertex center to edge center
        //      x[1] = dist from edge center to face center
        //      x[2] = dist from face center to cell center
        //      ...
        //      x[nDims-3] = dist from peak center to ridge center
        //      x[nDims-2] = dist from ridge center to facet center
        //      x[nDims-1] = dist from facet center to whole thing center
        private static void calcCharacteristicSimplexEdgeLengthsSquared(
                        int nDims,
                        int schlafli[/*nDims-1*/],
                        int schlafliDenoms[/*nDims-1*/],
                        double lengthsSquared[/*nDims*/]) // return
        {
            if (nDims == 0)
                return;
            calcCharacteristicSimplexEdgeLengthsSquared(nDims-1, schlafli, schlafliDenoms, lengthsSquared);
            if (nDims == 1)
            {
                lengthsSquared[nDims-1] = 1;
                return;
            }
            if (nDims == 2)
            {
                //double edgeLength = 1./Math.tan(Math.PI*schlafliDenoms[nDims-2]/schlafli[nDims-2]);
                //lengthsSquared[nDims] = edgeLength*edgeLength;
                lengthsSquared[nDims-1]= cotSquaredPiTimes(schlafliDenoms[nDims-2],schlafli[nDims-2]);
                return;
            }
            assert(nDims >= 3);

            // XXX this commentary is wrong, it's from when I was indexing this stuff differently
            // We want x[n] such that,
            // if consider the hypersphere centered at {x[0]..x[n]}
            // passing through the origin,
            // if we project everything away from the center
            // onto the tangent hyperplane at the origin,
            // then the right triangle formed by the three projected points:
            //          projected {x[0]..    x[n-1],0}  (i.e. projected facet center)
            //          projected {x[0]..  x[n-2],0,0}  (i.e. projected ridge center)
            //          projected {x[0]..x[n-3],0,0,0}  (i.e. projected peak center)
            // has angle pi/schlafli[nDims-1] at the projected peak center.
            // 
            // Hmm, I think it will be easier if we think in the translated coord space
            // in which the sphere center is at the origin.
            // We want x[n] such that,
            // if we consider the hypersphere centered at the origin
            // and passing through the vertex -x[0]..-x[n],
            // if we project everything away from the center onto the tangent hyperplane
            // at -x[0]..-x[n], then the right triangle formed by the three projected points:
            //          projected {0,0,...,                0,-x[n]}  (i.e. projected facet center)
            //          projected {0,0,...,        0,-x[n-1],-x[n]}  (i.e. projected ridge center)
            //          projected {0,0,...,0,-x[n-2],-x[n-1],-x[n]}  (i.e. projected peak center)
            // has angle pi/schlafli[nDims-1] at the projected peak center.
            //    sphere center = 0
            //    sphere radius = ||x0..xn||
            //    projected facet center = LERP(sphere center, facet center,  (sphere radius)^2 / ||sphere center - facet center||^2)
            //                           = (facet center) * (sphere radius)^2/||facet center||^2
            //                           = (...0,0,-x[n]) * (sphere radius)^2 / (x[n]^2)
            //    projected ridge center = (...0,-x[n-1],-x[n]) * (sphere radius)^2 / (x[n-1]^2 + x[n]^2)
            //    projected peak center = (...-x[n-2],-x[n-1],-x[n]) * (sphere radius)^2 / (x[n-2]^2 + x[n-1]^2 + x[n]^2)
            //
            // So we want x[n] that makes that right triangle
            // have angle pi/schlafli[nDims-2] at the projected peak center.
            // Note that in all three points, all but the last 3 coords is zero...
            // so we get a similar triangle if we omit all but the last 3 coords
            // and divide by (sphere radius)^2... and negate.
            // So really it all boils down to the 3d case, if we define:
            //         q = schlafli[n-2]
            //        x1 = x[n-2]
            //        x2 = x[n-1]
            //        x3 = x[n]
            //     facet = (0,0,x3) / x3^2
            //     ridge = (0,x2,x3) / (x2^2 + x3^2)
            //      peak = (x1,x2,x3) / (x1^2 + x2^2 + x3^2)
            // So we want x3 such that the following holds (all equivalent):
            //     ||ridge-peak||/||facet-peak|| = cos(pi/q)
            //     ||facet-ridge||/||facet-peak|| = sin(pi/q)
            //     ||facet-ridge||/||ridge-peak|| = tan(pi/q)
            // If q is very big then the angle pi/q will be very small and so
            // sin(pi/q) is the best formulation to use.
            // The other extreme is when q is just barely bigger than 2,
            // in which case pi/q is close to 90 degrees and so cos(pi/q) is the best to use.
            // But I wonder if there is a formula that is accurate for both,
            // that uses both the sin and cos (or uses the sin of the half-angle,
            // which is also accurate for angles in 0..90).
            // I'll just use the sin version for now.
            //
            // Feeding this into mathematica
            // (making my own norm so it doesn't get overly complicated
            // with abses)
            /*
                    facet = {0,0,x3} / (x3^2)
                    ridge = {0,x2,x3} / (x2^2 + x3^2)
                    peak  = {x1,x2,x3} / (x1^2 + x2^2 + x3^2)
                    norm[{a_,b_,c_}] = Sqrt[a^2+b^2+c^2]
                    Solve[norm[facet-ridge]/norm[facet-peak] == S, x3] // Simplify

                    Solve[norm[ridge-peak]/norm[facet-peak] == C, x3]
                    Solve[norm[facet-ridge]/norm[ridge-peak] == T, x3]
            */
            // Ha, got it!
            //      +- sqrt( -(-1+S^2)*x2^2*(x1^2+x2^2) / (-x2^2 + S^2*(x1^2+x2^2) ))
            // But it can probably be simplified...
            // S = sin(pi/q)
            double SS = sinSquaredPiTimes(schlafliDenoms[nDims-2],schlafli[nDims-2]);
            double x0sqrd = lengthsSquared[nDims-3];
            double x1sqrd = lengthsSquared[nDims-2];
            double x2sqrd = (1-SS)*x1sqrd*(x0sqrd+x1sqrd) / (-x1sqrd + SS*(x0sqrd+x1sqrd));
            lengthsSquared[nDims-1] = x2sqrd;
            // XXX this comes out negative for {4/5} for example... should see if I care. {4/9} is okay though
        } // calcCharacteristicSimplexEdgeLengthsSquared

        // greatest common divisor
        private static int gcd(int a, int b)
        {
            return b==0 ? a : gcd(b, a%b);
        }

        // sin(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double sinSquaredPiTimes(int n, int d)
        {
            assert(d != 0);
            int sign = 1;
            if (n < 0)
            {
                n *= -1;
                sign *= -1;
            }
            if (d < 0)
            {
                d *= -1;
                sign *= -1;
            }
            int gcd = gcd(n,d);
            n /= gcd;
            d /= gcd;
            n %= 2*d;
            // so now 0 <= n/d < 2, i.e. in [0..360] degrees
            if (n > d)
            {
                n = 2*d - n;
                sign *= -1;
            }
            // so now 0 <= n/d <= 1, i.e. in [0..180] degrees
            if (2*n > d)
            {
                n = d - n;
            }
            // so now 0 <= n/d <= 1/2, i.e. in [0..90] degrees
            if (4*n > d)
                return sign*(1 - cosSquaredPiTimes(n, d));
            // so now 0 <= n/d <= 1/4, i.e. in [0..45] degrees
            assert(0 <= n && 4*n <= d);
            //System.out.println("    "+n+"/"+d+"");
            if (true)
            {
                // http://mathworld.wolfram.com/TrigonometryAngles.html
                if (n==0)          // 0 degrees
                    return sign * 0;
                if (n==1 && d==12) // 15 degrees
                    return sign * ((2.-Math.sqrt(3.))/4.);
                if (n==1 && d==10) // 18 degrees
                    return sign * ((3.-Math.sqrt(5.))/8.);
                if (n==1 && d==8) // 22.5 degrees
                    return sign * ((2.-Math.sqrt(2.))/4.);
                if (n==1 && d==6)  // 30 degrees
                    return sign * (1./4.);
                if (n==1 && d==5)  // 36 degrees
                    return sign * ((5.-Math.sqrt(5.))/8.);
                if (n==1 && d==4)  // 45 degrees
                    return sign * (1./2.);
            }
            //System.out.println("    "+n+"/"+d+" !!!");
            double s = Math.sin(Math.PI*n/d);
            return sign*s*s;
        } // sinSquaredPiTimes

        // cos(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double cosSquaredPiTimes(int n, int d)
        {
            // cos(pi*n/d) = sin(pi/2 - pi*n/d)
            //             = sin(pi * (1/2 - n/d))
            //             = sin(pi * (1/2 - n/d))
            //             = sin(pi * (d-2*n)/(2*d)
            return sinSquaredPiTimes(d-2*n, 2*d);
        }

        // tan(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double tanSquaredPiTimes(int n, int d)
        {
            double s = sinSquaredPiTimes(n, d);
            return s / (1 - s);
        }
        // cot(pi*n/d) squared, but do it without trig if it's a nice angle
        private static double cotSquaredPiTimes(int n, int d)
        {
            double s = sinSquaredPiTimes(n, d);
            return (1 - s) / s;
        }

        private static String flagToString(Polytope flag[])
        {
            StringBuffer sb = new StringBuffer();
            sb.append("(");
            FORI (i, flag.length)
            {
                sb.append(" "+dimToPrefix(flag[i].dim)+flag[i].id);
            }
            sb.append(" )");
            return sb.toString();
        } // flagToString

        /**
        * Creates a Wythoff polytope from a given polytope.
        * Returns a Wythoff-operator'ed p
        * corresponding to the Coxeter-Dynkin symbol
        * where a 1 in the symbol is a circled node,
        * a 0 in the symbol is a non-circled node,
        * and values between 0 and 1 (or greater than 1)
        * can be used to linearly interpolate.
        * In the general case, there is one facet for
        * each element of any dimension in the original,
        * but there may be less for specific cases
        * (namely when only one node is circled).
        * Assumptions:
        *    p is regular
        *    p is centered at the origin
        *          XXX not sure whether this is really assumed; if it is, it should be fixed.
        *    p is full-dimensional
        *
        * Starts by creating the topology of the full omnitruncated polytope
        * and then squashes out degeneracies.
        */
        public static SPolytope makeWythoffPolytope(SPolytope sp,
                                                    double wythoff[])
        {
            long baseId = nIds; // snapshot
            //System.out.println("in makeWythoffPolytope");
            //PRINTARRAY(wythoff);
            Polytope p = sp.p;
            assert(wythoff != null);
            assert(wythoff.length == p.dim);

            //
            // The vertices of the omni correspond to the flags of p.
            // So enumerate all the flags...
            //
            java.util.Vector/*<Polytope[]>*/ flags = new java.util.Vector();
            {
                java.util.Vector/*<Polytope[]>*/ partialFlags = new java.util.Vector();
                partialFlags.addElement(new Polytope[]{p});
                FORI (iPartialFlag, partialFlags.size()) // while growing
                {
                    Polytope partialFlag[] = (Polytope[])partialFlags.get(iPartialFlag);
                    //System.out.println("    Looking at partial flag "+flagToString(partialFlag));
                    Polytope elt = partialFlag[partialFlag.length-1];
                    FORI (iFacet, elt.facets.length)
                    {
                        Polytope facet = elt.facets[iFacet].p;
                        Polytope superPartialFlag[] = (Polytope[])Arrays.append(partialFlag, facet);
                        if (superPartialFlag.length == p.dim+1)
                        {

                            Polytope flag[] = (Polytope[])Arrays.subarray(superPartialFlag,1,superPartialFlag.length-1); // omit the cell itself
                            //System.out.println("        Adding flag "+flagToString(flag));
                            flags.addElement(flag);
                        }
                        else
                            partialFlags.addElement(superPartialFlag);
                    }
                }
            }
            
            //
            // The vertex of the omni corresponding to a given flag
            // of the original is some weighted sum of the flag
            // element centers.  What are the weights?
            // Well, those element centers form a simplex,
            // and we want the distance from the weighted sum to
            // each of the sides of the simplex to be the corresponding
            // wythoff coefficient.
            // So if normal_i is the inward normal towards element i
            // of the flag, we want
            // I.e. we want a row vector w = [w0 w1 w2]
            // such that:
            //              [   vert    ]
            // [w0 w1 w2] * [edge center] * (normal_i column vector) = wythoff_i
            //              [face center]
            // for each normal_i.
            // Note that normal_i is simply the i'th column
            // of the inverse of the flag mat, normalized.
            // Oh, except wythoff is listed backwards.
            //
            // We are assuming the original is regular,
            // which means we'll get the same weights no matter
            // which flag we use.
            //
            double originalCG[] = new double[p.fullDim];
            cgOfVerts(originalCG, p);
            double weights[] = new double[p.dim];
            {
                int nDims = p.dim;
                assert(p.fullDim == nDims);
                double flagMat[][] = new double[nDims][nDims];
                Polytope[] flag = (Polytope[])flags.get(0); // some flag
                FORI (iDim, nDims)
                {
                    cgOfVerts(flagMat[iDim], flag[iDim]);
                    VecMath.vmv(flagMat[iDim],flagMat[iDim],originalCG);
                }
                double inwardNormalsMat[][] = VecMath.transpose(
                                              VecMath.invertmat(flagMat));
                FORI (iDim, nDims)
                    VecMath.normalize(inwardNormalsMat[iDim], inwardNormalsMat[iDim]);
                double M[][] = VecMath.mxm(flagMat,
                                           VecMath.transpose(inwardNormalsMat));
                double wythoffBackwards[] = (double[])Arrays.reverse(wythoff);
                VecMath.vxinvm(weights, wythoffBackwards, M);
            }
            //PRINTVEC(originalCG);
            //PRINTVEC(wythoff);
            //PRINTVEC(weights);

            //
            // The elements of the omni correspond to chains
            // of elements in p ordered by inclusion,
            // where a single-element chain in p is a facet of the omni,
            // and a maximal chain (i.e. a flag) of p is a vertex of the omni,
            // and the null set chain is the whole omni.
            //
            java.util.Hashtable omniEltsHashTable = new java.util.Hashtable();

            FORI (iFlag, flags.size())
            {
                Polytope flag[] = (Polytope[])flags.get(iFlag);
                Polytope omniVert = new Polytope(0,p.fullDim,new SPolytope[0],new Hyperplane[0],null);
                double coords[] = new double[p.fullDim];
                VecMath.copyvec(coords, originalCG); // start here
                double eltCenter[] = new double[p.fullDim]; // scratch
                for (int iDim = 0; iDim < flag.length; ++iDim)
                {
                    cgOfVerts(eltCenter, flag[iDim]);
                    VecMath.vmv(eltCenter, eltCenter, originalCG); // make it relative
                    VecMath.vpsxv(coords,
                                  coords,
                                  weights[iDim],
                                  eltCenter);
                }
                omniVert.setCoords(coords);
                omniEltsHashTable.put(new HashableSortedArray(flag), omniVert);
            }

            java.util.Vector subFlags = flags;
            flags = null;
            FORI (iSubFlag, subFlags.size()) // while growing
            {
                Polytope subFlag[] = (Polytope[])subFlags.get(iSubFlag);
                //System.out.println("    Looking at subFlag "+flagToString(subFlag));
                Polytope subFlagOmniElt = (Polytope)omniEltsHashTable.get(new HashableSortedArray(subFlag));
                FORI (i, subFlag.length)
                {
                    Polytope subSubFlag[] = (Polytope[])Arrays.delete(subFlag, i);
                    Polytope subSubFlagOmniElt = (Polytope)omniEltsHashTable.get(new HashableSortedArray(subSubFlag));
                    if (subSubFlagOmniElt == null)
                    {
                        subSubFlagOmniElt = new Polytope(p.dim-subSubFlag.length,p.fullDim,new SPolytope[0],new Hyperplane[0],null);
                        omniEltsHashTable.put(new HashableSortedArray(subSubFlag), subSubFlagOmniElt);
                        subFlags.addElement(subSubFlag);
                    }
                    // make subFlagOmniElt a facet of subSubFlagOmniElt
                    subSubFlagOmniElt.facets = (SPolytope[])Arrays.append(subSubFlagOmniElt.facets, new SPolytope(0,1,subFlagOmniElt));
                }
            }

            // The omni itself is the omni elt corresponding to the empty set.
            SPolytope somni = new SPolytope(0,1,(Polytope)omniEltsHashTable.get(new HashableSortedArray(new Polytope[]{})));

            //
            // Get rid of degeneracies:
            //     For each zero-length edge, remove the edge and merge the vertices.
            //     Then for each face with only two edges, remove the face and merge the edges.
            //     Then for each cell with only two faces, remove the cell and merge the faces.
            //     ...
            //
            if (true)
            {
                java.util.Hashtable deadList = new java.util.Hashtable();
                Polytope allElements[][] = somni.p.getAllElements();
                MergeFind mergeFind = new MergeFind((int)(nIds-baseId));
                Polytope bulletinBoard[] = new Polytope[(int)(nIds-baseId)];
                boolean mergedSomething = false;
                FORI (iDim, somni.p.dim)
                {
                    FORI (jElt, allElements[iDim+1].length)
                    {
                        Polytope elt = allElements[iDim+1][jElt];
                        if (iDim == 0)
                        {
                            //
                            // elt is an edge;
                            // if its two endpoints are coincident,
                            // remove the edge and merge the two
                            // vertices.
                            //
                            assert(elt.facets.length == 2);
                            //PRINTVEC(elt.facets[0].p.getCoords());
                            //PRINTVEC(elt.facets[1].p.getCoords());
                            if (VecMath.distsqrd(elt.facets[0].p.getCoords(),
                                                 elt.facets[1].p.getCoords()) <= 1e-6*1e-6) // XXX not completely sure this is right, maybe should be a param
                            {
                                mergedSomething = true;
                                //System.out.println("    MERGING!");
                                // The two vertices are coincident;
                                // merge them
                                mergeFind.merge((int)(elt.facets[0].p.id-baseId),
                                                (int)(elt.facets[1].p.id-baseId));
                                bulletinBoard[(int)(elt.facets[0].p.id-baseId)] = elt.facets[0].p;
                                bulletinBoard[(int)(elt.facets[1].p.id-baseId)] = elt.facets[1].p;
                                // kill this edge
                                deadList.put(elt,elt);
                            }
                            else
                            {
                                //System.out.println("    not merging!");
                            }
                        }
                        else
                        {
                            //
                            // Elt is a polygon or higher.
                            // Compress out the dead facets from
                            // elt's facets list.
                            // There will be 0, or 2, or >=3 facets left.
                            // If there are exactly 2, merge them.
                            // If there were 0 or 2, kill elt.
                            //
                            int nLivingFacets = 0;
                            FORI (kFacet, elt.facets.length)
                            {
                                if (deadList.get(elt.facets[kFacet].p) == null)
                                    elt.facets[nLivingFacets++] = elt.facets[kFacet];
                            }
                            assert(nLivingFacets == 0
                                || nLivingFacets == 2
                                || nLivingFacets >= 3);
                            if (nLivingFacets == 2)
                            {
                                mergedSomething = true;
                                //System.out.println("    MERGING!");
                                // merge them
                                mergeFind.merge((int)(elt.facets[0].p.id-baseId),
                                                (int)(elt.facets[1].p.id-baseId));
                                bulletinBoard[(int)(elt.facets[0].p.id-baseId)] = elt.facets[0].p;
                                bulletinBoard[(int)(elt.facets[1].p.id-baseId)] = elt.facets[1].p;
                            }
                            else
                            {
                                //System.out.println("    not merging!");
                            }
                            if (nLivingFacets <= 2)
                            {
                                //System.out.println("    KILLING ELT!");
                                // kill elt
                                deadList.put(elt, elt);
                            }
                            else
                            {
                                //System.out.println("    not killing elt!");
                                elt.facets = (SPolytope[])Arrays.subarray(elt.facets, 0, nLivingFacets);
                            }
                        }
                    }
                    // Go through the iDim-dimensional elements' facet lists
                    // again and replace any merged facets
                    // with the merged group leader; then all but the leader
                    // will die
                    FORI (jElt, allElements[iDim+1].length)
                    {
                        Polytope elt = allElements[iDim+1][jElt];
                        FORI (kFacet, elt.facets.length)
                        {
                            int key = (int)(elt.facets[kFacet].p.id - baseId);
                            int leader = mergeFind.find(key);
                            if (leader != key)
                                elt.facets[kFacet].p = bulletinBoard[leader];
                        }
                    }
                }


                if (mergedSomething)
                {
                    //System.out.println("CLEARING ALLELEMENTS");
                    // We called allElements (which triggers
                    // all elements to populate their _allElements lists)
                    // and then changed stuff,
                    // so all the element lists are bogus now.
                    // Clear them.
                    FORI (iDim, sp.p.dim+1)
                        FORI (jElt, allElements[iDim].length)
                            allElements[iDim][jElt]._allElements = null;
                }

                // If completely dead (which happens if all the wythoff
                // coeffs were zero), set somni.p to the single merged vertex.
                // Note this is a funny case; somni.p.dim ends up 0
                // but somni.p.fullDim ends up the original dimension.
                if (deadList.get(somni.p) != null)
                    somni.p = bulletinBoard[mergeFind.find((int)(allElements[0][0].id-baseId))];
            }

            //
            // Make the hyperplanes, and orient and everything.
            //
            bootstrapHyperplanes(somni);

            //System.out.println("out makeWythoffPolytope");
            return somni;
        } // makeWythoffPolytope

        private static boolean isLegalSchlafli(int schlafli[/*nDims-1*/],
                                               int schlafliDenoms[/*nDims-1*/])
        {
            assert(schlafliDenoms != null);
            assert(schlafli.length == schlafliDenoms.length);
            if (schlafliDenoms == null)
                schlafliDenoms = VecMath.fillvec(schlafli.length, 1);
            // copy them so we can canonicalize them...
            schlafli = VecMath.copyvec(schlafli);
            schlafliDenoms = VecMath.copyvec(schlafliDenoms);
            FORI (j, schlafli.length)
            {
                int n = schlafli[j];
                int d = schlafliDenoms[j];
                if (n == 0) return false;
                if (n < 0) n *= -1;
                if (d < 0) d *= -1;
                int gcd = gcd(n,d);
                n /= gcd; d /= gcd; // if n/d is legal then (k*n)/(k*d) is legal
                d %= n; // if n/d is legal then n/(k*n+d) is legal
                if (2*d > n)
                    d = n-d; // if n/d is legal then n/(n-d) is legal
                if (d == 0) return false;
                schlafli[j] = n;
                schlafliDenoms[j] = d;
            }
            int nDims = schlafli.length+1;
            if (nDims == 1)
                return true; // {}
            if (nDims == 2)
            {
                // polygon {n/d}
                // XXX note currently 4/5 assert-fails for some reason even though I think it should probably be legal-- I think it has to do with negative char simplex edge lengths
                return true;
            }

            if (arrayIsAll(schlafli, 0, schlafli.length, 3))
            {
                // {3,3,...,3} -- simplex
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return false; // XXX should allow other denominators I think
                return true;
            }
            if (schlafli[0]==4 && arrayIsAll(schlafli, 1, schlafli.length-1, 3))
            {
                // {4,3,...,3} -- hypercube
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return false; // XXX should allow other denominators I think
                return true;
            }
            if (arrayIsAll(schlafli, 0, schlafli.length-1, 3) && schlafli[schlafli.length-1] == 4)
            {
                // {3,...,3,4} -- cross
                if (!arrayIsAll(schlafliDenoms, 0, schlafliDenoms.length, 1))
                    return false; // XXX should allow other denominators I think
                return true;
            }
            // Finite number of special cases
            int specialCases[][][] = {
                {{3},  {5}}, // icosahedron
                {{5},  {3}}, // dodecahedron
                {{5,2},{5}}, // small stellated dodecahedron
                {{5,2},{3}}, // great stellated dodecahedron
                {{5},  {5,2}}, // great dodecahedron
                {{3},  {5,2}}, // great icosahedron
                {{3},  {4},  {3}}, // 24-cell
                {{5},  {3},  {3}}, // 120-cell
                {{3},  {3},  {5}}, // 600-cell
                {{5,2},{5},  {3}},
                {{3},  {5},  {5,2}},
                {{5},  {5,2},{5}},
                {{5,2},{3},  {5}},
                {{5},  {3},  {5,2}},
                {{5,2},{5},  {5,2}},
                {{3},  {5,2},{5}},
                {{5},  {5,2},{3}},
                {{5,2},{3},  {3}},
                {{3},  {3},  {5,2}},
            };

            FORI (i, specialCases.length)
            {
                if (schlafli.length != specialCases[i].length)
                    continue;
                int j;
                FOR (j, schlafli.length)
                {
                    int n = schlafli[j];
                    int d = schlafliDenoms[j];
                    if (n != specialCases[i][j][0])
                        break; // doesn't match this special case
                    if (d != (specialCases[i][j].length==2 ? specialCases[i][j][1] : 1))
                        break; // doesn't match this special case
                }
                if (j == schlafli.length)
                    return true; // matched this special case
            }
            return false;
        } // isLegalSchlafli
        public static SPolytope makeRegularStarPolytope(int schlafli[/*nDims-1*/],
                                                        int schlafliDenoms[/*nDims-1*/],
                                                        double wythoffCoeffs[/*nDims*/])
        {
            boolean verbose = false; // can set to true to debug

            if (schlafliDenoms == null)
                schlafliDenoms = VecMath.fillvec(schlafli.length, 1);
            if (schlafli.length != schlafliDenoms.length)
                throw new IllegalArgumentException("Schlafli numerators "+Arrays.toStringCompact(schlafli)+" does not match schlafli denominators "+Arrays.toStringCompact(schlafliDenoms)+"");
            if (!isLegalSchlafli(schlafli, schlafliDenoms))
            {
                // hack together a visible representation of it real quick
                String s = "{";
                FORI (i, schlafli.length)
                {
                    s += schlafli[i];
                    if (schlafliDenoms[i] != 1)
                        s += "/"+schlafliDenoms[i];
                    if (i+1 < schlafli.length)
                        s += ",";
                }
                s += "}";
                throw new IllegalArgumentException("Schlafli symbol "+s+" is not a regular polytope! Nice try though!");
            }
            int nDims = schlafli.length+1;
            if (nDims==2 && schlafli[0] >= 7)
            {
                // {p} -- polygon. The usual code would work
                // but it's rather inaccurate, so calculate the vertices directly.
                return makeRegularPolygon(schlafli[0], schlafliDenoms[0]);
            }

            //
            // Figure out the edge lengths
            // of the characteristic simplex.
            //
            double characteristicSimplexEdgeLengthsSquared[] = new double[nDims];
            calcCharacteristicSimplexEdgeLengthsSquared(nDims,
                                                        schlafli,
                                                        schlafliDenoms,
                                                        characteristicSimplexEdgeLengthsSquared);
            if (verbose) PRINTARRAY(characteristicSimplexEdgeLengthsSquared);

            //
            // Actually make a characteristic simplex.
            // It will be scaled so that the polytope's edge length is 1.
            //
            double characteristicSimplex[][] = new double[nDims+1][nDims];
            if (nDims > 0)
            {
                double initialVertex[] = characteristicSimplex[0];
                FORI (jDim, nDims)
                    initialVertex[jDim] = -Math.sqrt(characteristicSimplexEdgeLengthsSquared[jDim]);
                FORI (iDim, nDims+1)
                FORI (jDim, nDims)
                    characteristicSimplex[iDim][jDim] = (jDim>=iDim ? initialVertex[jDim] : 0.);
            }
            if (verbose) PRINTMAT(characteristicSimplex);

            double circumRadius = Math.sqrt(VecMath.sum(characteristicSimplexEdgeLengthsSquared));
            if (verbose) PRINT(circumRadius);
            if (verbose) PRINT(VecMath.norm(characteristicSimplex[0]));


            //
            // Make the initial flag.
            // It will be a spherical simplex,
            // consisting of all the vertices of the characteristic simplex
            // except the origin, projected onto the unit sphere.
            // I.e. its vertices will be the projected-to-sphere centers
            // of an incident vertex, edge, face, cell, ..., peak, ridge, facet.
            // XXX hmm, I'm not sure about this normalizing everything to
            // XXX sphere thing...  e.g. for cube, shouldn't everything
            // be in exact arithmetic?
            // 
            double initialFlag[][] = new double[nDims][nDims];
            FORI (iDim, nDims)
                VecMath.normalize(initialFlag[iDim], characteristicSimplex[iDim]);
            if (verbose) PRINTMAT(initialFlag);

            //
            // Figure out the flag normals.
            //
            double initialFlagNormals[][] = VecMath.transpose(
                                            VecMath.invertmat(initialFlag));
            FORI (iDim, nDims)
                VecMath.normalize(initialFlagNormals[iDim], initialFlagNormals[iDim]); // XXX not really necessary, could generate the reflections without this!
            if (verbose) PRINTMAT(initialFlagNormals);

            //
            // The generators for the symmetry group
            // are the reflections in each of the flag normal directions.
            //
            double gens[][][] = new double[nDims][nDims][nDims];
            FORI (iDim, nDims)
            {
                double normal[] = initialFlagNormals[iDim];
                // gens[iDim] = I - 2 normal^T normal
                VecMath.identitymat(gens[iDim]);
                FORI (jDim, nDims)
                FORI (kDim, nDims)
                    gens[iDim][jDim][kDim] -= 2 * normal[jDim]
                                                * normal[kDim];
            }

            //
            // Reflect the initial flag in all possible ways
            // using the generators repeatedly.
            //
            java.util.Vector flagList = new java.util.Vector();
            {
                FuzzyPointHashTable flagHashTable = new FuzzyPointHashTable(1e-9,
                                                                            1e-8,
                                                                            1./512);
                flagList.addElement(initialFlag);
                flagHashTable.put(VecMath.flatten(initialFlag), initialFlag);

                double scratchFlag[][] = new double[nDims][nDims];
                double scratchFlagFlattened[] = new double[nDims*nDims];
                FORI (iFlag, flagList.size()) // while it's growing
                {
                    double flag[][] = (double[][])flagList.elementAt(iFlag); // not get, for 1.1
                    FORI (iGen, nDims)
                    {
                        VecMath.mxm(scratchFlag,
                                    flag, gens[iGen]);
                        // don't let it drift...
                        FORI (iDim, nDims)
                            VecMath.normalize(flag[iDim], flag[iDim]);

                        VecMath.flatten(scratchFlagFlattened, scratchFlag);
                        if (flagHashTable.put(scratchFlagFlattened,
                                              scratchFlag) == null)
                        {
                            //
                            // It wasn't already there... we found a new flag.
                            //
                            flagList.addElement(VecMath.copymat(scratchFlag));

                            // The hash table now owns the scratch flag
                            // and flattened, so we have to make another
                            scratchFlag = new double[nDims][nDims];
                            scratchFlagFlattened = new double[nDims*nDims];
                        }
                    }
                    assert(flagList.size() < 1000*1000); // XXX not right, but for now
                    //assert(flagList.size() < 100); // XXX not right, but for now
                }
            }
            if (verbose) PRINT(flagList.size());

            //
            // Enumerate all the polytope elements.
            // We assume any two elements of the same dimension
            // and same projected-onto-sphere center are the same.
            // (I think this is safe for regular polytopes,
            // but wouldn't be safe in general, e.g. for uniform
            // polytopes some of whose faces pass through the origin).
            //
            Polytope wholeThing = new Polytope(nDims,nDims,new SPolytope[0],new Hyperplane[0],null);
            if (verbose) PRINT(wholeThing.id);
            {
                java.util.Vector elementLists[] = new java.util.Vector[nDims+1];
                FuzzyPointHashTable elementHashTables[] = new FuzzyPointHashTable[nDims+1];

                FORI (iDim, nDims+1)
                {
                    elementLists[iDim] = new java.util.Vector();
                    elementHashTables[iDim] = new FuzzyPointHashTable(1e-9,
                                                                      1e-8,
                                                                      1./512);
                }
                // The whole one, which isn't mentioned explicitly
                // in the flags.  Don't need to put it in the hash table
                // because it's not going to collide with anyone.
                elementLists[nDims].addElement(wholeThing);

                //System.out.println("    starting something I think might be time consuming...");
                Polytope flagElements[] = new Polytope[nDims+1];
                FORI (iFlag, flagList.size())
                {
                    double flag[][] = (double[][])flagList.elementAt(iFlag); // not get, for 1.1
                    FORI (iDim, nDims)
                    {
                        int index;
                        {
                            Integer got = (Integer)elementHashTables[iDim].get(flag[iDim]);
                            if (got != null)
                                index = got.intValue();
                            else
                            {
                                index = elementLists[iDim].size();
                                elementHashTables[iDim].put(flag[iDim], new Integer(index));
                                Polytope elt = new Polytope(iDim,nDims,new SPolytope[0],new Hyperplane[0],null);
                                if (iDim == 0)
                                {
                                    double coords[] = VecMath.vxs(flag[iDim],circumRadius);
                                    // Integerize if it's really close...
                                    FORI (jDim, nDims)
                                    {
                                        double roundedCoord = Math.round(coords[jDim]);
                                        double off = coords[jDim]-roundedCoord;
                                        if (1.+off*off == 1.)
                                            coords[jDim] = roundedCoord;
                                    }
                                    elt.setCoords(coords);
                                }
                                elementLists[iDim].addElement(elt);
                            }
                        }
                        flagElements[iDim] = (Polytope)elementLists[iDim].elementAt(index); // not get, for 1.1
                    }
                    //
                    // For each iDim, make the iDim-dimensional element
                    // a facet of the (iDim+1)-dimensional element,
                    // if it isn't already.
                    //
                    FORI (iDim, nDims)
                    {
                        Polytope littleGuy = flagElements[iDim];
                        Polytope bigGuy = iDim+1==nDims ? wholeThing
                                                        : flagElements[iDim+1];

                        // XXX shouldn't search or build the facets like this, it's O(n^2), argh! need hash table and vectors, or two passes counting first.
                        // XXX although, this doesn't seem to be the bottleneck, for the 120-cell at least, which is surprising
                        {
                            int iFacet;
                            FOR (iFacet, bigGuy.facets.length)
                                if (bigGuy.facets[iFacet].p == littleGuy)
                                    break;
                            if (iFacet == bigGuy.facets.length)
                            {
                                //System.out.println("    adding "+iDim+"-elt "+littleGuy.id+" to "+(iDim+1)+"-elt "+bigGuy.id+"");
                                bigGuy.facets = (SPolytope[])Arrays.append(bigGuy.facets, new SPolytope(0,1,littleGuy)); // XXX shouldn't build the array like this, it's O(n^2), argh!
                            }
                        }
                    }
                }
                //System.out.println("    ending something I think might be time consuming.");
                int elementCounts[] = new int[nDims+1];
                FORI (iDim, nDims+1)
                    elementCounts[iDim] = elementLists[iDim].size();
                if (verbose) PRINTARRAY(elementCounts);
            }

            SPolytope sWholeThing = new SPolytope(0,1,wholeThing);
            if (wythoffCoeffs != null)
            {
                // makeWythoffPolytope doesn't need the hyperplanes,
                // it just looks at the vertices and bootstraps its own hyperplanes
                sWholeThing = makeWythoffPolytope(sWholeThing, wythoffCoeffs);
            }
            else
                bootstrapHyperplanes(sWholeThing);
            return sWholeThing;
        } // makeRegularStarPolytope

        // XXX argh, this is lame
        private static void bootstrapHyperplanes(SPolytope sp)
        {
            FORI (iStupidTimes, 2) // XXX this is stupid, the first time the normal calculation will be wrong, but it will fill the arrays which orientDeep needs
            {
                {
                    // XXX clear the hperplanes, oh my god this is lame
                    Polytope allElements[][] = sp.p.getAllElements();
                    FORI (i, allElements.length)
                    FORI (j, allElements[i].length)
                        allElements[i][j].contributingHyperplanes = new Hyperplane[0];
                }

                // Now we have to go through
                // and set the planes defining every element,
                // starting with the facets.
                // XXX duplicate code in fromStringInPcalcFormat, should make a function
                sp.p.contributingHyperplanes = new Hyperplane[0];
                FORI (iFacet, sp.p.facets.length)
                {
                    SPolytope facet = sp.p.facets[iFacet];
                    double normal[] = new double[sp.p.fullDim];
                    areaNormal(normal, facet); // get area normal of facet
                    VecMath.normalize(normal,normal);
                    Polytope someVertexOnFacet = facet.p;
                    while (someVertexOnFacet.dim > 0)
                        someVertexOnFacet = someVertexOnFacet.facets[0].p;
                    double offset = VecMath.dot(normal, someVertexOnFacet.getCoords());
                    if (offset < 0.)
                    {
                        VecMath.vxs(normal, normal, -1.);
                        offset *= -1.;
                    }
                    Hyperplane hyperplane = new Hyperplane(normal, offset);
                    Hyperplane hyperplanes[] = {hyperplane};

                    //
                    // Add this hyperplane as a contributing
                    // hyperplane to every cell of this facet
                    // (including this facet itself).
                    //
                    Polytope allElements[][] = facet.p.getAllElements();
                    FORI (i, allElements.length)
                    FORI (j, allElements[i].length)
                    {
                        Polytope e = allElements[i][j];
                        e.contributingHyperplanes = unionOfHyperplanesAndSort(e.contributingHyperplanes, hyperplanes);
                    }
                }

                orientDeep(sp);
            }
        } // bootstrapHyperplanes

        // Tell whether array[i0]..array[i0+n-1] is all x's.
        private static boolean arrayIsAll(int array[], int i0, int n, int x)
        {
            for (int i = 0; i < n; ++i)
                if (array[i0+i] != x)
                    return false;
            return true;
        } // isAll

        /** Makes a product of regular (star) polytopes. */
        public static SPolytope makeRegularStarPolytopeProduct(int schlaflis[][],
                                                               int schlafliDenomss[][],
                                                               double wythoffs[][])
        {
            int nFactors = schlaflis.length;
            assert(schlafliDenomss == null
                || schlafliDenomss.length == nFactors);
            SPolytope product = null;
            FORI (iFactor, nFactors)
            {
                SPolytope factor = makeRegularStarPolytope(schlaflis[iFactor],
                                                           schlafliDenomss==null?null:schlafliDenomss[iFactor],
                                                           wythoffs==null?null:wythoffs[iFactor]);
                if (product == null)
                    product = factor;
                else
                    product = cross(product, factor);
            }
            // could actually initialize product to the following,
            // but that would just waste some time on the first cross product
            if (product == null)
                return new SPolytope(0,1,new Polytope(0,0,new SPolytope[0],new Hyperplane[0],null));
            return product;
        } // makeRegularStarPolytopeProduct

        /**
        * Makes a product of regular (star) polytopes from a string specification,
        * for example "{4,3}x{}x{5,3,3}x{3}x {3, 3,3,3,3 }x{} x {5/2,5} "
        * '*' can be used in place of 'x' as well.
        *
        * Also instead of {5,3,3}, any of the following will do:
        *       5,3,3                    (the braces are optional)
        *       (1)5(0)3(0)3(0)
        *       (1)-5-(0)-3-(0)-3-(0)    (dashes are optional, you can insert them for readability)
        *       (1)-5-(0)--(0)--(0)      (3's in the schlafli symbol may be omitted)
        *       (1)5(0)(0)(0)
        *       5,,                     (since the 3's may be omitted)
        * You can put different things inside the parens to get
        * different wythoff variants.  Just don't make them all zero.
        *
        * TODO:
        *       2 = {}
        *       p = {p}  for p>=3
        *       5,, doesn't work yet for some reason
        */
        public static SPolytope makeRegularStarPolytopeProductFromString(String s)
        {
            String factors[] = regex.split(s.trim(), "[x*]");
            int schlaflis[][] = new int[factors.length][];
            int schlafliDenomss[][] = new int[factors.length][];
            double wythoffs[][] = new double [factors.length][];
            FORI (iFactor, factors.length)
            {
                String factor = factors[iFactor].trim();
                /*
                if (!factor.startsWith("{")
                 || !factor.endsWith("}"))
                    throw new IllegalArgumentException("makeRegularStartPolytopeProductFromString: bad schlafli symbol \""+s+"\"");
                */
                if (factor.startsWith("{")
                 && factor.endsWith("}"))
                {
                    factor = factor.substring(1, factor.length()-1); // trim off { and }
                    factor = factor.trim(); // and any white space inside
                }
                if (factor.indexOf("(") != -1)
                {
                    // Extract wythoff stuff
                    factor = regex.replaceAll(factor, ",", "(0)");
                    if (!factor.startsWith("("))
                        factor = "(1)"+factor;
                    if (!factor.endsWith(")"))
                        factor += "(0)";
                    factor = regex.replaceAll(factor, "\\)-*\\(", ")3("); // 3's in the schlafli symbol are implicit

                    String foo = factor;

                    factor = regex.replaceAll(factor, "-",""); // XXX seems unscientific
                    factor = regex.replaceAll(factor, "\\([^)]+\\)", ",");
                    if (factor.startsWith(","))
                        factor = factor.substring(1);
                    if (factor.endsWith(","))
                        factor = factor.substring(0,factor.length()-1);

                    //PRINT(foo);
                    //PRINT(factor);

                    // Now we can destroy foo if we like
                    double wythoff[] = new double[0];
                    while (foo.indexOf("(") != -1)
                    {
                        int open = foo.indexOf("(");
                        int close = foo.indexOf(")", open+1);
                        String coeffString = foo.substring(open+1, close);
                        //PRINT(coeffString);
                        // XXX need to catch
                        double coeff = com.donhatchsw.compat.Double.parseDouble(coeffString);
                        wythoff = (double[])Arrays.append(wythoff, coeff);
                        foo = foo.substring(close+1);
                    }
                    wythoffs[iFactor] = wythoff;
                }

                String fractions[] = regex.split(factor, ",");
                if (factor.equals(""))
                    fractions = new String[0]; // to be safe (I don't trust split)
                schlaflis[iFactor] = new int[fractions.length];
                schlafliDenomss[iFactor] = new int[fractions.length];
                FORI (iFraction, fractions.length)
                {
                    String fraction = fractions[iFraction].trim();
                    String n_and_d[] = regex.split(fraction, "/");
                    if (n_and_d.length == 2)
                    {
                        schlaflis[iFactor][iFraction] = Integer.parseInt(n_and_d[0]);
                        schlafliDenomss[iFactor][iFraction] = Integer.parseInt(n_and_d[1]);
                    }
                    else if (n_and_d.length == 1)
                    {
                        schlaflis[iFactor][iFraction] = Integer.parseInt(n_and_d[0]);
                        schlafliDenomss[iFactor][iFraction] = 1;
                    }
                    else
                        throw new IllegalArgumentException("makeRegularStartPolytopeProductFromString: bad schlafli symbol \""+s+"\"");
                }
            }
            //PRINTARRAY(s);
            //PRINTARRAY(schlaflis);
            //PRINTARRAY(schlafliDenomss);
            SPolytope sp = makeRegularStarPolytopeProduct(schlaflis,
                                                          schlafliDenomss,
                                                          wythoffs);
            return sp;
        } // makeRegularStarPolytopeProductFromString


    //
    // Utilities...
    //
        //
        // A polytope is "binary"
        // if all densities are 0 or 1.
        // XXX also checks whether it's finite-or-cofinite,
        // XXX so isBinary is a misnomer.
        //
        public static boolean isBinaryDensityShallow(Polytope p)
        {
            if (p.dim == 1)
            {
                int nPluses = 0, nMinuses = 0; // and counting
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                FORI (iFacet, nFacets)
                {
                    SPolytope facet = facets[iFacet];

                    if (facet.initialDensity != 0)
                        return false; // only top-level can have nonzero initial density in a finite-or-cofinite polytope

                    int sign = facet.sign;
                    if (sign == 1)
                        nPluses++;
                    else if (sign == -1)
                        nMinuses++;
                    else
                        return false;
                }
                if (nPluses != nMinuses)
                    return false;
            }
            // XXX else!?
            return true;
        } // isBinaryDensityShallow

        public static boolean isBinaryDensityDeep(SPolytope sp)
        {
            if (sp.initialDensity != 0
             && sp.initialDensity != 1)
                return false;
            Polytope allElements[][] = sp.p.getAllElements();
            int dim = sp.p.dim;
            FORI (iDim, dim+1)
            {
                Polytope ofDim[] = allElements[iDim];
                int nOfDim = ofDim.length;
                FORI (iOfDim, nOfDim)
                    if (!isBinaryDensityShallow(ofDim[iOfDim]))
                        return false;
            }
            return true;
        } // isBinaryDensityDeep



        //
        // Do one level of orientedness checking.
        // XXX This is O(n^2); should use a hash table
        // XXX instead of an array for boundaryRidges
        //
        public static boolean isOrientedShallow(Polytope p)
        {
            final boolean verbose = false;
            //
            // A polytope is considered oriented
            // if the summation of the signed facets of its
            // signed facets is zero.
            //
            SPolytope facets[] = p.facets;
            int nFacets = facets.length;
            int maxRidges;
            {
                maxRidges = 0; // and counting
                FORI (iFacet, nFacets)
                    maxRidges += facets[iFacet].p.facets.length;
            }
            SPolytope boundaryRidges[] = new SPolytope[maxRidges];
            int nBoundaryRidges = 0; // and counting
            {
                FORI (iFacet, nFacets)
                {
                    SPolytope facet = facets[iFacet];
                    SPolytope ridgesThisFacet[] = facet.p.facets;
                    int nRidgesThisFacet = ridgesThisFacet.length;
                    FORI (iRidgeThisFacet, nRidgesThisFacet)
                    {
                        SPolytope ridge = ridgesThisFacet[iRidgeThisFacet];
                        int sign = facet.sign * ridge.sign;
                        // Add boundaryRidge to boundaryRidges.
                        {
                            if (verbose)
                                System.out.println("Adding "
                                                   +signToString(facet.sign)
                                                   +signToString(ridge.sign)
                                                   +"="
                                                   +signToString(sign)
                                                   +ridge.p.id);
                            int iBoundaryRidge;
                            FOR (iBoundaryRidge, nBoundaryRidges)
                            {
                                if (boundaryRidges[iBoundaryRidge].p
                                 == ridge.p)
                                {
                                    // Found it!  Add the new coefficient.
                                    if ((boundaryRidges[iBoundaryRidge].sign
                                       += sign) == 0)
                                    {
                                        // New coefficient for this ridge is 0;
                                        // remove the ridge from the list.

                                        boundaryRidges[iBoundaryRidge--] = boundaryRidges[--nBoundaryRidges]; // subtle-- decrement iBoundaryRidges too, so that the test after this loop will still be valid
                                        if (verbose)
                                            System.out.println("    (poof!)");
                                    }
                                    else
                                    {
                                        //
                                        // It's an unusual polytope
                                        // in which the cumulative sign
                                        // can ever be other than
                                        // 0, -1, or +1; as of this writing
                                        // I don't think I've provided a way
                                        // to make one.  But it's
                                        // theoretically possible.
                                        //
                                        if (verbose)
                                            System.out.println("    (SURPRISE, cumulative sign is "+signToString(boundaryRidges[iBoundaryRidge].sign)+")");
                                    }
                                    break;
                                }
                            }
                            if (iBoundaryRidge == nBoundaryRidges)
                            {
                                // Didn't find it; add it
                                boundaryRidges[nBoundaryRidges++] = new SPolytope(0, sign, ridge.p);
                                if (verbose)
                                    System.out.println("    (truly)");
                            }
                        }
                    }
                }
            }
            return nBoundaryRidges == 0;
        } // isOrientedShallow


        public static boolean isOrientedDeep(Polytope p)
        {
            Polytope allElements[][] = p.getAllElements();
            int dim = p.dim;
            FORI (i, dim+1)
            {
                Polytope elementsOfDim[] = allElements[i];
                int nElementsOfDim = elementsOfDim.length;
                FORI (j, nElementsOfDim)
                    if (!isOrientedShallow(elementsOfDim[j]))
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println("isOrientedDeep returning false because element "+j+"/"+nElementsOfDim+" of dimension "+i+" is not oriented shallow:");
                            PRINTSUBSUB(allElements, i, j);
                        }
                        return false;
                    }
            }
            return true;
        } // isOrientedDeep


        /**
        *  Count up number of vertices, edges, ...
        *  and return the counts in an array.
        */
        public static int[] counts(Polytope p)
        {
            return (int[])Arrays.arrayLengths(p.getAllElements(), 1, 1);
        }  // counts

        private static boolean contains(Polytope p, Polytope q)
        {
            Polytope eltsOfDim[] = p.getAllElements()[q.dim];
            // XXX shouldn't have to keep making comparator...
            int index = SortStuff.bsearch(eltsOfDim, q, 
                               new SortStuff.Comparator() {
                                   public int compare(Object _a, Object _b)
                                   {
                                       Polytope a = (Polytope)_a;
                                       Polytope b = (Polytope)_b;
                                       return a.id < b.id ? -1 :
                                              a.id > b.id ? 1 : 0;
                                   }
                               });
            return index != -1;
        } // contains

        /**
        *  usefulMat should be an orthogonal matrix
        *  whose last two rows are in the plane of the desired rotation.
        * So a rotation of any angle in that plane can be computed as:
        *        Take the rows of mat to the canonical basis vectors e[0]..e[n-1]
        *        rotate e[n-2] towards e[n-1]
        *        take the canonical basis vectors back to the original rows
        * I.e. rotMat = VecMath.mxmxm(VecMath.transpose(mat),
        *                             VecMath.makeRowRotMat(nDims,nDims-2,nDims-1, angle,
        *                             mat);
        * XXX isn't there a version of makeRowRotMat that does something like this?  check it out.  it looks overly complicated though, and assumes nDims==3 which is lame, should have a look at it
        */
        public static int calcRotationGroupOrder(Polytope p,
                                                 int maxPossibleOrder,
                                                 double usefulMat[][])
        {
            if (maxPossibleOrder == 0)
                return 0; // XXX maybe the caller should not call in this case... I doubt usefulMat is sane here
            //PRINT(maxPossibleOrder);
            //PRINTMAT(usefulMat);
            int nDims = usefulMat.length;

            //
            // Compute a rotation matrix
            // that rotates by 2pi/maxPossibleOrder
            // in the plane spanned by the last two rows of usefulMat.
            // The rotation we want to describe is:
            //     take the rows of mat to the canonical basis vectors e[0]..e[n-1]
            //     rotate e[n-2] towards e[n-1]
            //     take the canonical basis vectors back to the original rows
            //
            double maxPossibleOrderMat[][] = 
                VecMath.mxmxm(VecMath.transpose(usefulMat),
                              VecMath.makeRowRotMat(nDims,nDims-2,nDims-1, 2*Math.PI/maxPossibleOrder),
                              usefulMat);

            FuzzyPointHashTable hashTable = new FuzzyPointHashTable(1e-9,
                                                                    1e-8,
                                                                    1./512);
            Polytope verts[] = p.getAllElements()[0];
            int nVerts = verts.length;
            {
                Object something = new Object();
                FORI (iVert, nVerts)
                {
                    double vertCoords[] = verts[iVert].getCoords();
                    while (vertCoords.length < nDims)
                        vertCoords = Arrays.append(vertCoords, 0.);
                    hashTable.put(vertCoords, something);
                }
            }

            // The actual order will be some factor of maxPossibleOrder.
            // Try all possibilities, from big to little.
            for (int order = maxPossibleOrder; order >= 1; order--)
            {
                if (maxPossibleOrder % order != 0)
                    continue;
                //System.err.println("(Trying order "+order+"/"+maxPossibleOrder+")");
                double mat[][];
                {
                    // XXX should have VecMath.pow(double[][], int) that does it the smart way so it's only O(sqrt(n)) matrix multiplies
                    mat = VecMath.identitymat(nDims);
                    FORI (i, maxPossibleOrder/order)
                        mat = VecMath.mxm(mat, maxPossibleOrderMat);
                }

                double scratchVert[] = new double[nDims];
                int iVert = 0;
                FOR (iVert, nVerts)
                {
                    double vertCoords[] = verts[iVert].getCoords();
                    while (vertCoords.length < nDims)
                        vertCoords = Arrays.append(vertCoords, 0.);
                    VecMath.vxm(scratchVert, vertCoords, mat);
                    if (hashTable.get(scratchVert) == null)
                    {
                        //System.err.print("(HEY! order "+order+"/"+maxPossibleOrder+" didn't work!)");
                        break; // no good!
                    }
                }
                if (iVert == nVerts) // everything was good!
                {
                    return order; // everything was good!
                }
            }
            // order 1 should have succeeded, so we can't get here.
            // Actually we could have just returned 1 if all larger orders failed,
            // but we tested it anyway as a sanity check-- it better have succeeded.
            PRINT(maxPossibleOrder);
            assert(false);
            return 1;
        } // calcRotationGroupOrder



        // XXX comment me!!
        public static void calcDensity(SPolytope sp,
                                       double point[],
                                       double eps,
                                       int result[/*2*/]) // interval arithmetic
        {
            //System.out.println("    in calcDensity (dim="+sp.p.dim+")");
            Polytope p = sp.p;
            int dim = p.dim;

            if (dim == 0)
            {
                // XXX logically should probably be something else, but this will do for now...
                result[0] = 1;
                result[1] = 1;
                //System.out.println("    out calcDensity (dim="+sp.p.dim+"), returning "+result[0]+","+result[1]+"");
                return;
            }

            // dir = a random vector in the space spanned by this polytope.
            // We get it by taking all the plane normals,
            // augmenting by random vectors if necessary to get
            // dim-1 vectors, and taking the cross product.
            double dir[];
            {
                int nContributingHyperplanes = p.contributingHyperplanes.length;
                int fullDim = sp.p.fullDim;
                assert(nContributingHyperplanes < fullDim);
                double M[][] = new double[fullDim-1][fullDim];
                int iRow;
                FOR (iRow, nContributingHyperplanes)
                    VecMath.copyvec(M[iRow], p.contributingHyperplanes[iRow].normal);
                for (; iRow < fullDim-1; ++iRow)
                    VecMath.random(M[iRow], randomGenerator);
                dir = VecMath.crossprod(M);
                VecMath.normalize(dir, dir); // XXX not necessary if we want to be clever
            }
            double pointDotDir = VecMath.dot(point, dir);

            int densityMin = sp.initialDensity; // and counting
            int densityMax = sp.initialDensity; // and counting

            if (p.dim == 1)
            {
                SPolytope vertices[] = p.facets;
                int nVertices = vertices.length;
                FORI (iVertex, nVertices)
                {
                    SPolytope v = vertices[iVertex];
                    int a = 0, b = 0;
                    double vDotDir = VecMath.dot(v.p.getCoords(),
                                                 dir);

                    if (GEQ(vDotDir, pointDotDir, eps))
                        a = v.sign;
                    if (GT(vDotDir, pointDotDir, eps))
                        b = v.sign;
                    if (a > b)
                    {
                        int temp;
                        SWAP(a,b,temp);
                    }
                    densityMin += a;
                    densityMax += b;
                }
            }
            else
            {
                assumpt(p.dim >= 2); // XXX never ask for density of a point
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                double qoint[] = new double[point.length]; // scratch for loop
                FORI (iFacet, nFacets)
                {
                    SPolytope facet = facets[iFacet];

                    // We want qoint = intersection of point+t*dir with plane
                    //                   of the facet.
                    // So we want t such that
                    //          (point+t*dir) dot hyperplane.normal
                    //                          = hyperplane.offset
                    //          point dot hyperplane.normal + t*dir dot hyperplane.normal = hyperplane.offset
                    //  t = (hyperplane.offset - (point dot hyperplane.normal)) / (dir dot hyperplane.normal)
                    {
                        Hyperplane hyperplane = (Hyperplane)itemOfAThatsNotInB(facet.p.contributingHyperplanes, p.contributingHyperplanes);
                        double t = (hyperplane.offset - VecMath.dot(point, hyperplane.normal)) / VecMath.dot(dir, hyperplane.normal);
                        VecMath.vpsxv(qoint, point, t, dir);
                    }

                    double qointDotDir = VecMath.dot(qoint, dir);

                    int a = 0, b = 0;
                    if (GEQ(qointDotDir, pointDotDir, eps))
                        a = facet.sign;
                    if (GT(qointDotDir, pointDotDir, eps))
                        b = facet.sign;
                    if (a > b)
                    {
                        int temp;
                        SWAP(a,b,temp);
                    }

                    if (verboseLevel >= 2 && a != b)
                    {
                        System.out.println("uh oh,,,,,,,,,,,,,,,,,,,,,,,,,,");
                        PRINT(p);
                        PRINTVEC(point);
                        PRINTVEC(qoint);
                        PRINT(a);
                        PRINT(b);
                    }
                    if (a != 0 || b != 0)
                    {
                        calcDensity(facet, qoint, eps, result); // using result as temporary
                        densityMin += a * result[0];
                        densityMax += b * result[1];
                    }
                }
            }

            if (verboseLevel >= 2 && densityMin != densityMax)
            {
                System.out.println("Uh oh................");
                PRINT(p);
                PRINTVEC(point);
                PRINT(densityMin);
                PRINT(densityMax);
            }

            result[0] = densityMin;
            result[1] = densityMax;

            //System.out.println("    out calcDensity (dim="+sp.p.dim+"), returning "+result[0]+","+result[1]+"");
        } // calcDensity


         // simplicallySubdivide
        private static double[/*nSimplices*/][/*k+1*/][/*n*/] simpliciallySubdivide(Polytope p)
        {
            int k = p.dim;
            int n = p.fullDim;

            if (k == 0)
            {
                return new double[][][] {
                    {p.getCoords()},
                };
            }
            if (p.facets.length == 0)
            {
                return new double[0][k+1][n];
            }


            Polytope v0; // first vertex
            {
                v0 = p;
                while (v0.dim > 0)
                    v0 = v0.facets[0].p;
            }
            double v0coords[] = v0.getCoords();

            // XXX it looks to me like Vector behavior is O(n^2) !?? stupid!
            java.util.Vector simplicesList = new java.util.Vector();
            {
                SPolytope facets[] = p.facets;
                int nFacets = facets.length;
                double simplex[][] = new double[k+1][/*n*/];

                if (k == 1) // XXX this case is not really necessary, but it is optimized a bit
                {
                    FORI (iFacet, nFacets)
                    {
                        if (iFacet == 0)
                            continue;
                        SPolytope facet = facets[iFacet];
                        simplex[0] = v0coords;
                        simplex[1] = facet.p.getCoords();
                        if (facet.sign < 0)
                        {
                            // swap last two vertices on the simplex.
                            double temp[];
                            SWAP(simplex[k-1], simplex[k], temp);
                        }
                        FORIDOWN (i, ABS(facet.sign))
                            simplicesList.addElement(VecMath.copymat(simplex));
                    }
                }
                else // k > 1
                {

                    FORI (iFacet, nFacets)
                    {
                        if (iFacet == 0)
                            continue; // facet 0 definitely contains v0
                        SPolytope facet = facets[iFacet];
                        if (contains(facet.p, v0))
                            continue;
                        double facetSimplices[][][] = simpliciallySubdivide(facet.p);
                        int nFacetSimplices = facetSimplices.length;
                        FORI (iFacetSimplex, nFacetSimplices)
                        {
                            simplex[0] = v0coords;
                            System.arraycopy(facetSimplices[iFacetSimplex], 0,
                                             simplex, 1,
                                             k);
                            if (facet.sign < 0)
                            {
                                // swap last two vertices on the simplex.
                                double temp[];
                                SWAP(simplex[k-1], simplex[k], temp);
                            }
                            FORIDOWN (i, ABS(facet.sign))
                                simplicesList.addElement(VecMath.copymat(simplex));
                        }
                    }
                }
            }
            double array[][][] = new double[simplicesList.size()][k+1][n];
            simplicesList.copyInto(array);
            return array;
        } // simplicallySubdivide

        // This will be the actual (signed) volume
        // if all the hyperplanes are orthogonal and unit length
        // (which includes the case when there are no hyperplanes,
        // i.e. when sp.p.dim is the full dimension of the space).
        // Otherwise it will be scaled by the volume
        // of the parallelepiped spanned by those normals.
        private static double volume(SPolytope sp)
        {
            int nNormals = sp.p.contributingHyperplanes.length;
            double simplices[][][] = simpliciallySubdivide(sp.p);
            int nSimplices = simplices.length;
            if (nSimplices == 0)
                return 0.;
            int k = simplices[0].length-1;  // dimension of each simplex
            int n = simplices[0][0].length; // full dimension of space

            assert(k + nNormals == n);
            double sum = 0.;
            double M[][] = new double[n][n];
            FORI (iSimplex, nSimplices)
            {
                double simplex[][] = simplices[iSimplex];
                FORI (iRow, k)
                    VecMath.vmv(M[iRow], simplex[iRow+1], simplex[0]);
                FORI (iNormal, nNormals)
                    VecMath.copyvec(M[k+iNormal],
                                    sp.p.contributingHyperplanes[iNormal].normal);
                sum += VecMath.detDestructive(M);
            }
            return sum * sp.sign / factorial(k);
        } // volume

        // Get the normal of the n-1-dimensional polytope sp,
        // with length equal to the hyper-area of sp.
        // Uses the vertices but not the hyperplanes,
        // so can be used to build the hyperplanes
        // if only the vertices are known.
        private static void areaNormal(double result[], SPolytope sp)
        {
            VecMath.zerovec(result);
            double simplices[][][] = simpliciallySubdivide(sp.p);
            int nSimplices = simplices.length;
            if (nSimplices == 0)
                return;
            int k = simplices[0].length-1; // dimension of each simplex
            int n = simplices[0][0].length; // full dimension of space
            assert(k == sp.p.dim);

            assert(k == n-1);
            assert(result.length == n); // make sure they passed in the right dimension result
            double M[][] = new double[k][n];
            double simplexNormal[] = new double[n];
            FORI (iSimplex, nSimplices)
            {
                double simplex[][] = simplices[iSimplex];
                FORI (iRow, k)
                    VecMath.vmv(M[iRow], simplex[iRow+1], simplex[0]);
                VecMath.crossprod(simplexNormal, M);
                VecMath.vpv(result, result, simplexNormal);
            }
            VecMath.vxs(result, result, (double)sp.sign/(double)factorial(k));
        } // areaNormal

        public static void cgOfVerts(double result[], Polytope p)
        {
            Polytope vertPolytopes[] = p.getAllElements()[0];
            VecMath.zerovec(result);
            FORI (i, vertPolytopes.length)
                VecMath.vpv(result, result, vertPolytopes[i].getCoords());
            assert(vertPolytopes.length != 0);
            VecMath.vxs(result, result, 1./vertPolytopes.length);
        } // cgOfVerts

        public static SPolytope cross(SPolytope A,
                                      SPolytope B)
        {
            SPolytope AB = new SPolytope(A.initialDensity*B.initialDensity,
                                         A.sign*B.sign,
                                         _cross(A.p,
                                                B.p,
                                                new java.util.Hashtable(),
                                                ""));

            // If I was smart, _cross would simply get the signs right
            // as it goes.  Something like,
            // negate everything whose dimensional contribution
            // from C is odd...
            // But I have never been able to figure it out.
            // So, just orient after the fact.  Sigh.
            //
            if (true)
                orientDeep(AB);

            return AB;
        } // cross

        // recursive work function used by cross().
        // doesn't even try to get the signs right.
        private static Polytope _cross(Polytope A,
                                       Polytope B,
                                       java.util.Hashtable ocean, // hashtable of crossings already done
                                       String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._cross");
                subIndentString = indentString + "        ";
            }
            HashablePair key = new HashablePair(A, B);
            Polytope AB = (Polytope)ocean.get(key);
            if (AB == null)
            {
                SPolytope facets[] = new SPolytope[A.facets.length + B.facets.length];
                {
                    int iFacet = 0;
                    FORI (iFacetA, A.facets.length)
                    {
                        Polytope a = A.facets[iFacetA].p;
                        Polytope aB = _cross(a, B, ocean, subIndentString);
                        facets[iFacet++] = new SPolytope(0,1,aB); // sign arbitrary, will be fixed later
                    }
                    FORI (iFacetB, B.facets.length)
                    {
                        Polytope b = B.facets[iFacetB].p;
                        Polytope Ab = _cross(A, b, ocean, subIndentString);
                        facets[iFacet++] = new SPolytope(0,1,Ab); // sign arbitrary, will be fixed later
                    }
                    assert(iFacet == facets.length);
                }

                Hyperplane contributingHyperplanes[] = new Hyperplane[A.contributingHyperplanes.length + B.contributingHyperplanes.length];
                {

                    double leftZero[] = new double[A.fullDim];
                    double rightZero[] = new double[B.fullDim];

                    int iPlane = 0;

                    FORI (iPlaneA, A.contributingHyperplanes.length)
                    {
                        Hyperplane a = A.contributingHyperplanes[iPlaneA];
                        Hyperplane a_zero = new Hyperplane((double[])Arrays.concat(a.normal,
                                                                                   rightZero),
                                                           a.offset);
                        // XXX need to look up a_zero in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                        contributingHyperplanes[iPlane++] = a_zero;
                    }
                    FORI (iPlaneB, B.contributingHyperplanes.length)
                    {
                        Hyperplane b = B.contributingHyperplanes[iPlaneB];
                        Hyperplane zero_b = new Hyperplane((double[])Arrays.concat(leftZero,
                                                                                   b.normal),
                                                           b.offset);
                        // XXX need to look up zero_b in the ocean to see if it already exists! although it's probably not a functional problem if hyperplane lists get duplicated... maybe
                        contributingHyperplanes[iPlane++] = zero_b;
                    }
                    assert(iPlane == contributingHyperplanes.length);
                }

                AB = new Polytope(A.dim+B.dim,
                                  A.fullDim+B.fullDim,
                                  facets,
                                  contributingHyperplanes,
                                  null); // loses aux
                ocean.put(key, AB);
            }

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG._cross");
            return AB;
        } // _cross


        /**
         * Slices up a signed polytope into 3 parts: above, below, and on
         * the hyperplane.
         *    if any part of slicee is strictly above the hyperplane,
         *        returnAbove[0] will be set to that part, of dimension slicee.dim;
         *        otherwise it will be set to null.
         *    if any part of slicee is strictly below the hyperplane,
         *        returnBelow[0] will be set to that part, of dimension slicee.dim;
         *        otherwise it will be set to null.
         *    if slicee lies partly strictly above and partly strictly below
         *        the hyperplane, then returnOn[0] will be set to
         *        the cross-section polytope, of dimension slicee.dim-1;
         *        otherwise it will be set to null.
         * You can pass null in as any or all of returnAbove, returnOn,
         * or returnBelow, if you are not interested in them.
         */
        private static void slice(SPolytope slicee,
                                  Hyperplane hyperplane,
                                  Object aux, // to be put in the aux field of all new elements
                                  SPolytope returnAbove[/*1*/],
                                  SPolytope returnBelow[/*1*/],
                                  SPolytope returnOn[/*1*/])
        {
            SPolytope aboveBelowOn[/*3*/] = _slice(slicee,
                                                   hyperplane,
                                                   aux,
                                                   new java.util.Hashtable(),
                                                   "");
            assert(aboveBelowOn != null);
            if (returnAbove != null)
                returnAbove[0] = aboveBelowOn[0];
            if (returnBelow != null)
                returnBelow[0] = aboveBelowOn[1];
            if (returnOn != null)
                returnOn[0] = aboveBelowOn[2];
        } // slice

        /**
        * Convenience method for when there is only one slicee
        * and we know there will be only one sliced result
        * XXX this is actually not a great way to do this,
        * XXX since often we make a bunch of parallel cuts
        * XXX and we know the stuff on a particular side of the first cut
        * XXX isn't going to be affected by the next cut
        */
        public static SPolytope sliceElements(SPolytope slicee,
                                              int eltDim,
                                              Hyperplane hyperplane,
                                              Object aux)
        {
            SPolytope slicees[] = {slicee};
            SPolytope results[] = sliceElements(slicees,
                                                eltDim,
                                                hyperplane,
                                                aux);
            assert(results.length == 1); // XXX this is more of an illegal argument thing that we should throw legitimately
            return results[0];
        }
        /**
        * Slice up the eltDim-dimensional elements of the given list
        * of signed polytopes using a single hyperplane,
        * returning a new list of signed polytopes
        * (at most twice the size of the original list).
        */
        public static SPolytope[] sliceElements(SPolytope slicees[],
                                                int eltDim,
                                                Hyperplane hyperplane,
                                                Object aux)
        {
            return _sliceElements(slicees, eltDim, hyperplane, aux,
                                  new java.util.Hashtable());
        } // sliceElements

        private static SPolytope[] _sliceElements(SPolytope slicees[],
                                                  int eltDim,
                                                  Hyperplane hyperplane,
                                                  Object aux,
                                                  java.util.Hashtable ocean)
        {
            SPolytope result[] = new SPolytope[2*slicees.length]; // at most XXX could be smarter about this, if all slicees have dim > eltDim then we only need slicees.length
            int nResult = 0;
            FORI (iSlicee, slicees.length)
            {
                SPolytope slicee = slicees[iSlicee];
                if (slicee.p.dim <= eltDim)
                {
                    // Carve slicee up, replacing slicee with multiple sliceds
                    SPolytope[] aboveBelowOn = _slice(slicee, hyperplane, aux, ocean, "        ");
                    if (aboveBelowOn[0] != null)
                        result[nResult++] = aboveBelowOn[0];
                    if (aboveBelowOn[1] != null)
                        result[nResult++] = aboveBelowOn[1];
                    // can ignore On
                }
                else // slicee.p.dim > eltDim
                {
                    // Carve up facets, replacing slicee with a single sliced
                    SPolytope newFacets[] = _sliceElements(slicee.p.facets, eltDim, hyperplane, aux, ocean);
                    SPolytope sliced = new SPolytope(
                                         slicee.initialDensity,
                                         slicee.sign,
                                         new Polytope(slicee.p.dim,
                                                      slicee.p.fullDim,
                                                      newFacets,
                                                      slicee.p.contributingHyperplanes,
                                                      slicee.p.aux)); // not aux, since this one is a full-dimensional piece of slicee
                    result[nResult++] = sliced;
                }
            }
            result = (SPolytope[])Arrays.subarray(result, 0, nResult);
            return result;
        } // sliceElements

        // recursive work function used by slice() and sliceFacets().
        // returns an array {above,below,on},
        // of dimensions slicee.dim, slicee.dim-1, slicee.dim.
        private static SPolytope[/*3*/] _slice(SPolytope slicee,
                                               Hyperplane hyperplane,
                                               Object aux,
                                               java.util.Hashtable ocean, // hashtable of slicings already done
                                               String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._slice (slicee dim = "+slicee.p.dim+")");
                subIndentString = indentString + "        ";
            }
            SPolytope aboveBelowOn[/*3*/] = (SPolytope[])ocean.get(slicee.p);
            if (aboveBelowOn == null)
            {
                // Not already in the ocean... need to calculate it
                SPolytope above = null, below = null, on = null;
                if (slicee.p.dim == 0)
                {
                    double coords[] = slicee.p.getCoords();
                    double height = VecMath.dot(coords, hyperplane.normal) - hyperplane.offset;
                    if (height > 0.) // XXX need to make this fuzzy
                        above = slicee;
                    else if (height < 0.) // XXX need to make this fuzzy
                        below = slicee;
                    else
                        unimplemented(); // vertices on the plane mess everything up later
                }
                else if (slicee.p.dim == 1)
                {
                    //
                    // Slicee is a 1-dimensional polytope,
                    // i.e. a (multi-)segment.  Note that
                    // it may have more than two vertices:
                    // e.g. when a hatchet-chop is taken out of the
                    // edge of a regular polyhedron, the resulting pieces of the
                    // chopped edge are still considered to be part
                    // of a single edge, which now has 4 vertices
                    // (with signs -, +, -, + in order).
                    //

                    //
                    // Calculate the cumulative sign
                    // of all vertices lying above and below the plane...
                    //
                    SPolytope facetStuffs[][] = new SPolytope[slicee.p.facets.length][];
                    int nAbove = 0, nBelow = 0;
                    int totalSignAbove = 0;
                    int totalSignBelow = 0;
                    FORI (iFacet, slicee.p.facets.length)
                    {
                        facetStuffs[iFacet] = _slice(slicee.p.facets[iFacet], hyperplane, aux, ocean, subIndentString);
                        if (facetStuffs[iFacet][0] != null)
                        {
                            nAbove++;
                            totalSignAbove += slicee.p.facets[iFacet].sign;
                        }
                        if (facetStuffs[iFacet][1] != null)
                        {
                            nBelow++;
                            totalSignBelow += slicee.p.facets[iFacet].sign;
                        }
                        if (facetStuffs[iFacet][2] != null)
                        {
                            unimplemented();
                        }
                    }
                    totalSignAbove = 1; // XXX FUDGE
                    totalSignBelow = -1; // XXX FUDGE
                    assumpt(totalSignAbove + totalSignBelow == 0);

                    if (nAbove != 0 && nBelow != 0)
                    {
                        SPolytope facetsAbove[] = new SPolytope[nAbove + (totalSignAbove!=0 ? 1 : 0)];
                        SPolytope facetsBelow[] = new SPolytope[nBelow + (totalSignBelow!=0 ? 1 : 0)];
                        {
                            int iAbove = 0, iBelow = 0;
                            FORI (iFacet, slicee.p.facets.length)
                            {
                                if (facetStuffs[iFacet][0] != null)
                                    facetsAbove[iAbove++] = facetStuffs[iFacet][0];
                                if (facetStuffs[iFacet][1] != null)
                                    facetsBelow[iBelow++] = facetStuffs[iFacet][1];
                            }
                            assert(iAbove == nAbove);
                            assert(iBelow == nBelow);
                            if (totalSignAbove != 0) // i.e. if totalSignBelow != 0
                            {
                                // Need to make a new cutpoint.
                                // Note that we don't need to set the coords on it,
                                // that will be computed lazily
                                // from its hyperplanes
                                // the first time anyone calls getCoords() on it.
                                Polytope cutPoint = new Polytope(slicee.p.dim-1,
                                                                 slicee.p.fullDim,
                                                                 new SPolytope[0], // result vertex has no facets
                                                                 addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                                 aux);
                                facetsAbove[iAbove++] = new SPolytope(0, // initialDensity always 0 for vertices, I think
                                                                      -totalSignAbove,
                                                                      cutPoint);
                                facetsBelow[iBelow++] = new SPolytope(0, // initialDensity always 0 for vertices, I think
                                                                      -totalSignBelow,
                                                                      cutPoint);
                                on = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initialDensity?  maybe initialDensity isn't meaningful except for top-level polytopes?
                                                   1, // XXX arbitrary-- I think signs are completely messed up, will fix later
                                                   cutPoint);
                            }
                            assert(iAbove == facetsAbove.length);
                            assert(iBelow == facetsBelow.length);
                        }

                        above = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsAbove,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                        below = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsBelow,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                    }
                    else if (nAbove != 0)
                        above = slicee;
                    else if (nBelow != 0)
                        below = slicee;
                    else
                        assumpt(false);
                } // slicee.p.dim == 1
                else // slicee.p.dim >= 2
                {
                    assert(slicee.p.dim >= 2);

                    SPolytope facetStuffs[][] = new SPolytope[slicee.p.facets.length][];
                    int nAbove = 0, nBelow = 0, nOn = 0;
                    FORI (iFacet, slicee.p.facets.length)
                    {
                        facetStuffs[iFacet] = _slice(slicee.p.facets[iFacet], hyperplane, aux, ocean, subIndentString);
                        if (facetStuffs[iFacet][0] != null)
                            nAbove++;
                        if (facetStuffs[iFacet][1] != null)
                            nBelow++;
                        if (facetStuffs[iFacet][2] != null)
                            nOn++;
                    }
                    if (nAbove != 0 && nBelow != 0)
                    {
                        SPolytope facetsAbove[] = new SPolytope[nAbove + (nOn!=0 ? 1 : 0)];
                        SPolytope facetsBelow[] = new SPolytope[nBelow + (nOn!=0 ? 1 : 0)];
                        SPolytope ridgesOn[] = new SPolytope[nOn];
                        {
                            int iAbove = 0, iBelow = 0, iOn = 0;
                            FORI (iFacet, slicee.p.facets.length)
                            {
                                if (facetStuffs[iFacet][0] != null)
                                    facetsAbove[iAbove++] = facetStuffs[iFacet][0];
                                if (facetStuffs[iFacet][1] != null)
                                    facetsBelow[iBelow++] = facetStuffs[iFacet][1];
                                if (facetStuffs[iFacet][2] != null)
                                    ridgesOn[iOn++] = facetStuffs[iFacet][2];
                            }
                            assert(iAbove == nAbove);
                            assert(iBelow == nBelow);
                            assert(iOn == nOn);
                            // XXX can some ridges occur multiple times?
                            // XXX I don't think so, since On is only *new* stuff... but if I'm wrong, will need to sort ridgesOn and combine

                            if (nOn != 0)
                            {
                                Polytope cutPoint = new Polytope(slicee.p.dim-1,
                                                                 slicee.p.fullDim,
                                                                 ridgesOn,
                                                                 addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                                 aux);
                                facetsAbove[iAbove++] = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initial density? maybe initialDensity isn't meaningful except for top-level polytopes?
                                                                      +1,
                                                                      cutPoint);
                                facetsBelow[iBelow++] = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initialDensity?  maybe initialDensity isn't meaningful except for top-level polytopes?
                                                                      -1,
                                                                      cutPoint);
                                on = new SPolytope(slicee.initialDensity, // XXX I think this is wrong-- how the hell are we supposed to get an initialDensity?  maybe initialDensity isn't meaningful except for top-level polytopes?
                                                   1, // XXX arbitrary-- I think signs are completely messed up, will fix later
                                                   cutPoint);
                            }
                            assert(iAbove == facetsAbove.length);
                            assert(iBelow == facetsBelow.length);
                            assert(iOn == ridgesOn.length);
                        }

                        above = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsAbove,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                        below = new SPolytope(slicee.initialDensity,
                                              slicee.sign,
                                              new Polytope(slicee.p.dim,
                                                           slicee.p.fullDim,
                                                           facetsBelow,
                                                           slicee.p.contributingHyperplanes,
                                                           slicee.p.aux));
                                              
                    }
                    else if (nAbove != 0)
                        above = slicee;
                    else if (nBelow != 0)
                        below = slicee;
                    else
                        assumpt(false);
                } // slicee.p.dim >= 2
                aboveBelowOn = new SPolytope[] {above, below, on};
                ocean.put(slicee.p, aboveBelowOn);
            }
            else
            {
                if (verboseLevel >= 1)
                    System.out.println(indentString+"    (found it in the ocean)");
            }
            if (true)
            {
                // XXX make sure we are not sharing!
                // XXX I think maybe we should be just working unsigned
                // XXX and then orient afterwards.
                // XXX bleah, unfortunately this doesn't seem to make any difference, the bugs must be elsewhere.
                FORI(i,3)
                {
                    if (aboveBelowOn[i] != null)
                        aboveBelowOn[i] = new SPolytope(aboveBelowOn[i].initialDensity,
                                                        aboveBelowOn[i].sign,
                                                        aboveBelowOn[i].p);
                }
            }
            if (verboseLevel >= 1)
            {
                PRINTARRAY(slicee);
                PRINTARRAY(aboveBelowOn);
                System.out.println(indentString+"out CSG._slice (slicee dim = "+slicee.p.dim+")");
            }
            return aboveBelowOn;
        } // _slice

        //
        // XXX OLD-- look through for signs of intelligence and then delete
        // Slice a signed polytope by a plane.
        // Returns a slicee.dim-1 dimensional signed polytope.
        //
        private static SPolytope oldSlice(SPolytope slicee,
                                          Hyperplane hyperplane,
                                          Object aux,
                                          String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG.oldSlice");
                subIndentString = indentString + "    ";
            }
            if (verboseLevel >= 2)
                System.out.println(subIndentString + "slicee = " + slicee.toString(subIndentString+"         ", false, false, null));
            if (verboseLevel >= 3)
                System.out.println(subIndentString + "slicee = " + slicee.toString(subIndentString, true, true, null));
            if (verboseLevel >= 2)
            {
                System.out.println(subIndentString + "hyperplane: " + hyperplane);
            }

            assert(slicee.p.dim >= 1);
            assert(Arrays.indexOfUsingEqualsSymbol(slicee.p.contributingHyperplanes, hyperplane) == -1);

            SPolytope result;
            if (slicee.p.dim == 1)
            {
                //
                // Slicee is a 1-dimensional polytope,
                // i.e. a (multi-)segment.  Note that
                // it may have more than two vertices:
                // e.g. when a hatchet-chop is taken out of the
                // edge of a regular polyhedron, the resulting pieces of the
                // chopped edge are still considered to be part
                // of a single edge, which now has 4 vertices
                // (with signs -, +, -, + in order).
                //

                //
                // Calculate the cumulative sign
                // of all vertices lying above the plane...
                //

                int minNumVertsAbovePlane = 0;
                int maxNumVertsAbovePlane = 0;

                int signOfVertsStrictlyAbovePlane = 0;
                int signOfVertsOnOrAbovePlane = 0;
                SPolytope vertices[] = slicee.p.facets;
                int iVertex, nVertices = vertices.length;
                FOR (iVertex, nVertices)
                {
                    SPolytope vertex = vertices[iVertex];
                    double vertexCoords[] = vertex.p.getCoords();
                    double heightOfVertexAbovePlane = VecMath.dot(hyperplane.normal, vertexCoords) - hyperplane.offset;
                    // XXX need to use an epsilon test!
                    if (heightOfVertexAbovePlane >= 0.)
                    {
                        maxNumVertsAbovePlane++;
                        if (heightOfVertexAbovePlane > 0.)
                            minNumVertsAbovePlane++;
                    }
                }
                // XXX use even-odd rule since I don't seem to be smart enough for anything else
                if (minNumVertsAbovePlane != maxNumVertsAbovePlane
                 || slicee.initialDensity == (minNumVertsAbovePlane & 1))
                {
                    // Plane doesn't cross this segment
                    // (or crosses it just barely, so we can say it doesn't).
                    result = null;
                }
                else
                {
                    result = new SPolytope(0, // XXX initialDensity always 0 for vertices, I think-- think about it.  could just follow example of >1 case and set it to slicee.initialDensity, but I'd like to understand what I'm doing
                                           1, // XXX using even-odd rule, anything nonzero is 1.  top-level caller will fix.
                                           new Polytope(slicee.p.dim-1, // == 0
                                                        slicee.p.fullDim,
                                                        new SPolytope[0], // result vertex has no facets
                                                        addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                        aux));
                }
            } // slicee.p.dim == 1
            else
            {
                assert(slicee.p.dim > 1);

                //
                // The facets of (slicee sliced)
                // are (facets of slicee) sliced.
                //
                int iFacet, nFacets = slicee.p.facets.length;

                int maxSlicedFacets = nFacets;
                SPolytope slicedFacets[] = new SPolytope[maxSlicedFacets];
                int nSlicedFacets = 0;

                FOR (iFacet, nFacets)
                {
                    SPolytope slicedFacet = oldSlice(slicee.p.facets[iFacet],
                                                  hyperplane,
                                                  aux,
                                                  subIndentString);
                    if (slicedFacet != null)
                        slicedFacets[nSlicedFacets++] = slicedFacet;
                }
                if (nSlicedFacets == 0
                 && slicee.initialDensity == 0)
                {
                    // No facets and initialDensity == 0
                    // and dim != 0
                    // and  so we are nothing.
                    assert(slicee.initialDensity == 0); // XXX bad, should go off
                    result = null;
                }
                else
                {
                    slicedFacets = (SPolytope[])Arrays.subarray(slicedFacets, 0, nSlicedFacets); // resize

                    result = new SPolytope(slicee.initialDensity,
                                           1, // XXX assuming even-odd rule; will fix later
                                           new Polytope(slicee.p.dim-1,
                                                        slicee.p.fullDim,
                                                        slicedFacets,
                                                        addOneHyperplaneAndSort(slicee.p.contributingHyperplanes, hyperplane),
                                                        slicee.p.aux));
                }
            } // slicee.p.dim > 1

            if (verboseLevel >= 2)
                System.out.println(subIndentString + "result = " + (result==null?"(null)":result.toString(subIndentString+"         ", false, false, null)));
            if (verboseLevel >= 3)
                System.out.println(subIndentString + "result = " + (result==null?"(null)":result.toString(subIndentString, true, true, null)));

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG.oldSlice");

            return result;
        } // oldSlice

        // recursive work function used by intersect()
        private static SPolytope _intersect(SPolytope A,
                                            SPolytope B,
                                            java.util.Hashtable ocean, // hashtable of intersection polytopes created, keyed by contributing hyperplanes
                                            String indentString) // for debugging
        {
            String subIndentString = null;
            if (verboseLevel >= 1)
            {
                System.out.println(indentString+"in CSG._intersect");
                subIndentString = indentString + "        ";
            }
            if (verboseLevel >= 2)
                System.out.println(indentString+"    A = "+A.toString(indentString+"        ", false, false, null));
            if (verboseLevel >= 2)
                System.out.println(indentString+"    B = "+B.toString(indentString+"        ", false, false, null));
            if (verboseLevel >= 2
             && (A.p.facets.length > 0
              || B.p.facets.length > 0))
                System.out.println();

            int fullDim = A.p.fullDim;
            assert(fullDim == B.p.fullDim);

            if (true)
            {
                //
                // Bounding box test for quick rejection.
                // Intersect bounding boxes of vertices...
                //
                double bboxA[][] = A.p.getBBox();
                double bboxB[][] = B.p.getBBox();
                double bbox[][] = new double[2][fullDim];
                VecMath.bboxIntersect(bbox, bboxA, bboxB);
                boolean bboxIsEmpty = false; // and counting
                FORI (iDim, fullDim)
                    if (bbox[0][iDim] > bbox[1][iDim]) // XXX should be fuzzy I think
                        bboxIsEmpty = true;
                if (bboxIsEmpty)
                {
                    if (A.initialDensity == 0
                     && B.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox with both initial densities 0, returning null");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return null;
                    }
                    else if (A.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, A's initial density is 0, B's is not, returning A");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return A;
                    }
                    else if (B.initialDensity == 0)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, B's initial density is 0, A's is not, returning B");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return B;
                    }
                    else
                    {
                        // Both A and B have nonzero initial density.
                        // XXX Could optimize by simply concatenating
                        // XXX the arrays together, so to speak,
                        // XXX but I don't think this happens enough in
                        // XXX the current application to be worth worrying about.
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"    empty bbox, both initial densities nonzero, but not smart enough to do anything about it yet :-(");
                        }
                    }
                }
            }


            Hyperplane contributingHyperplanes[] = unionOfHyperplanesAndSort(A.p.contributingHyperplanes, B.p.contributingHyperplanes);
            HashableSortedArray key = new HashableSortedArray(contributingHyperplanes);

            int resultDim = fullDim - contributingHyperplanes.length;

            if (resultDim < 0)
            {
                if (verboseLevel >= 1)
                {
                    System.out.println(indentString+"    too many hyperplanes! returning null");
                    System.out.println(indentString+"out CSG.intersect");
                }
                return null;
            }

            // Look in the ocean for already computed...
            {
                Object flotsam = ocean.get(key);
                if (flotsam != null)
                {
                    // Found it in the ocean, so it was previously computed.
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"        found it in the ocean");
                    if (flotsam instanceof Polytope)
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString+"        and it was good");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return new SPolytope(0, // XXX initial density always 0 in this case?
                                             1, // XXX probably not right, fix later
                                             (Polytope)flotsam);
                    }
                    else
                    {
                        // It was previously computed and came out null.
                        if (verboseLevel >= 1)
                        {
                            System.out.println(indentString+"        and it was null");
                            System.out.println(indentString+"out CSG.intersect");
                        }
                        return null;
                    }
                }
            } // looked in the ocean

            SPolytope result;
            if (resultDim == 0)
            {
                double coords[];
                if (A.p.dim == 0)
                    coords = A.p.getCoords();
                else if (B.p.dim == 0)
                    coords = B.p.getCoords();
                else
                    coords = intersectHyperplanes(contributingHyperplanes);

                {
                    // XXX could use something smaller than union
                    // XXX in various cases of initialDensity? think about it
                    double unionBBox[][] = VecMath.bboxUnion(A.p.getBBox(),
                                                             B.p.getBBox());
                    double bigEps = 1e-3; // need not be very exact; the bigger the safer 
                    if (coords != null
                     && !VecMath.closedBBoxContains(unionBBox, coords, bigEps))
                    {
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString + "        HA! No way! coords were out of there!");
                        }
                        coords = null;
                    }

                    // XXX research question: can something like this
                    // XXX be done even if resultDim > 0?
                }

                if (coords != null)
                {
                    boolean inA;
                    {
                        double eps = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                        int densityMinMax[] = new int[2];
                        calcDensity(A,
                                    coords,
                                    eps,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        if (density != densityMinMax[1])
                        {
                            if (verboseLevel >= 0)
                            {
                                System.out.println("WARNING:");
                                PRINT(A);
                                PRINTVEC(coords);
                                PRINT(densityMinMax[0]);
                                PRINT(densityMinMax[1]);
                            }
                            //assert(false);
                        }
                        inA = ((density&1) == 1); // XXX even-odd rule for now
                    }
                    boolean inB = false; // shut up compiler
                    if (inA) // otherwise inB doesn't matter
                    {
                        double eps = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                        int densityMinMax[] = new int[2];
                        calcDensity(B,
                                    coords,
                                    eps,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        if (density != densityMinMax[1])
                        {
                            if (verboseLevel >= 0)
                            {
                                System.out.println("WARNING:");
                                PRINT(B);
                                PRINTVEC(coords);
                                PRINT(densityMinMax[0]);
                                PRINT(densityMinMax[1]);
                            }
                            //assert(false);
                        }
                        inB = ((density&1) == 1); // XXX even-odd rule for now
                    }
                    if (inA && inB)
                    {
                        if (A.p.dim == 0)
                            result = A;
                        else if (B.p.dim == 0)
                            result = B;
                        else
                        {
                            result = new SPolytope(
                                            0, 1, // XXX nonsense, will straighten out later
                                            new Polytope(0,
                                                         fullDim,
                                                         new SPolytope[0],
                                                         contributingHyperplanes,
                                                         null)); // no aux, since it's not a full-dimensional subset of any existing polytope
                            result.p.setCoords(coords); // so they won't need to be recalculated
                        }
                    }
                    else
                        result = null;
                }
                else
                    result = null;
            }
            else // resultDim > 0
            {
                //
                // Trying to maybe get it right
                // in the case of flush stuff
                // (e.g. A&A of dim 1 or 2 in test program).
                // I don't know if this will work,
                // and it's certainly WAY more compute intensive...
                // I think maybe the union-of-hyperplanes logic
                // isn't right though :-(
                // Also, need to do this first
                // so that we won't get a "found it in the ocean and it was
                // null".
                // NOTE, we really only need to do this
                // when a's subspace contains b's subspace (i.e.
                // one set of hyperplanes contains the other).
                // XXX need to think about whether there's an efficient
                // XXX way of enumerating all pairs for which this is true
                //
                int nMoreFacets = 0;
                SPolytope moreFacets[] = null;
                if (false) // maybe pursue this some other time
                {
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"    Trying more expensive boundary stuff...");
                    moreFacets = new SPolytope[A.p.facets.length
                                             * B.p.facets.length];
                    FORI (i, A.p.facets.length)
                    FORI (j, B.p.facets.length)
                    {
                        SPolytope a = A.p.facets[i];
                        SPolytope b = B.p.facets[j];
                        // Only proceed if a's subspace contains b's subspace
                        // or vice-versa.
                        {
                            Hyperplane unionOfHyperplanes[] = unionOfHyperplanesAndSort(a.p.contributingHyperplanes, b.p.contributingHyperplanes);
                            if (unionOfHyperplanes.length
                             != MIN(a.p.contributingHyperplanes.length,
                                    b.p.contributingHyperplanes.length))
                                continue;
                        }
                        if (verboseLevel >= 2)
                        {
                            System.out.println(indentString+"            a = "+a.toString(indentString+"            ", false, false));
                            System.out.println(indentString+"            b = "+b.toString(indentString+"            ", false, false));
                        }
                        SPolytope a_intersect_b = _intersect(a, b, ocean, subIndentString);
                        if (a_intersect_b != null)
                            moreFacets[nMoreFacets++] = a_intersect_b;
                    }
                    if (verboseLevel >= 1)
                        System.out.println(indentString+"    Found "+nMoreFacets+"/"+moreFacets.length+" more facets");
                }


                int nFacets = 0;
                SPolytope facets[] = new SPolytope[A.p.facets.length
                                                 + B.p.facets.length]; // max possible

                FORI (i, A.p.facets.length)
                {
                    SPolytope a = A.p.facets[i];
                    if (verboseLevel >= 2)
                        System.out.println(indentString+"        a = "+a.toString(indentString+"            ", false, false));
                    SPolytope a_intersect_B = _intersect(a, B, ocean, subIndentString);
                    if (a_intersect_B != null)
                        facets[nFacets++] = a_intersect_B;
                }
                FORI (i, B.p.facets.length)
                {
                    SPolytope b = B.p.facets[i];
                    if (verboseLevel >= 2)
                        System.out.println(indentString+"        b = "+b.toString(indentString+"            ", false, false));
                    SPolytope A_intersect_b = _intersect(A, b, ocean, subIndentString);
                    if (A_intersect_b != null)
                        facets[nFacets++] = A_intersect_b;
                }

                facets = (SPolytope[])Arrays.subarray(facets, 0, nFacets); // resize

                if (nMoreFacets > 0)
                {
                    moreFacets = (SPolytope[])Arrays.subarray(moreFacets, 0, nMoreFacets); // resize
                    facets = (SPolytope[])Arrays.concat(facets, moreFacets);
                }

                result = new SPolytope(
                                       MIN(A.initialDensity, B.initialDensity), // XXX is this right? have to think about it
                                       A.sign, // XXX probably completely irrelevant
                                       new Polytope(resultDim,
                                                    fullDim,
                                                    facets,
                                                    contributingHyperplanes,
                                                    resultDim==A.p.dim ? A.p.aux : resultDim==B.p.dim ? B.p.aux : null)); // XXX prefers A's aux. probably not much better we can do, unless we want to combine the auxes somehow, but that's probably too much trouble and the current application doesn't need it
                //
                // Hack after the fact:
                // if it's equal to A or B, return A or B instead
                // (XXX should detect that earlier and save lots of work
                // and unnecessary allocations, maybe)
                // XXX this may be defunct,
                // XXX have to think about it
                //
                {
                    if (result.p.dim == A.p.dim
                     && VecMath.equalsUsingEqualsSymbol(result.p.facets, A.p.facets))
                    {
                        result = new SPolytope(result.initialDensity,
                                               result.sign,
                                               A.p);
                    }
                    else if (result.p.dim == B.p.dim
                     && VecMath.equalsUsingEqualsSymbol(result.p.facets, B.p.facets))
                    {
                        result = new SPolytope(result.initialDensity,
                                               result.sign,
                                               B.p);
                    }
                }
            }

            if (result != null
             && result.p.dim >= 1
             && result.initialDensity == 0
             && result.p.facets.length == 0)
                result = null;

            if (result != null)
                ocean.put(key, result.p);
            else
                ocean.put(key, new Object()); // means null when fished out

            if (verboseLevel >= 2)
                System.out.println(indentString+"    result = "+(result==null?"(null)":result.toString(indentString+"             ", false, false, null)));

            if (verboseLevel >= 1)
                System.out.println(indentString+"out CSG._intersect");
            return result;
        } // _intersect

        /** Computes the intersection of two signed polytopes. */
        public static SPolytope intersect(SPolytope A,
                                          SPolytope B)
        {
            SPolytope result = _intersect(A, B,
                                          new java.util.Hashtable(),
                                          "");

            // _intersect returns an empty polytope
            // as null for efficiency, but the rest of the world
            // can't be expected to handle it.
            if (result == null)
            {
                int fullDim = A.p.fullDim;
                assert(fullDim == B.p.fullDim);
                int dim = fullDim - ((fullDim-A.p.dim)
                                   + (fullDim-B.p.dim));
                result = new SPolytope(0,1,
                                       new Polytope(dim,
                                                    fullDim,
                                                    new SPolytope[0],
                                                    new Hyperplane[0], // XXX uh oh, zero hyperplanes isn't really right, maybe should do the hyperplane union thing in case someone actually looks at this
                                                    null));
            }

            orientDeep(result); // XXX get rid of this when I get intersect to not fuck up the orientations to begin with
            return result;
        } // intersect

        /** Computes the complement of a signed polytope. */
        public static SPolytope complement(SPolytope sp)
        {
            return new SPolytope(1-sp.initialDensity,
                                 -sp.sign,
                                 sp.p);
        } // complement

        /** Computes the union of two signed polytopes. */
        public static SPolytope union(SPolytope A, SPolytope B)
        {
            return complement(intersect(complement(A), complement(B)));
        } // union

        /** Computes the difference of two signed polytopes. */
        private static SPolytope diff(SPolytope A, SPolytope B)
        {
            return intersect(A, complement(B));
        } // diff


        //
        // Assign signs to a (non-yet-finished)
        // n-dimensional polytope P,
        // its facets, and the facets of the facets, etc., recursively
        // in such a way that, for every flag:
        //      P, facet F, ridge R, ..., face f, edge e, vertex v,
        // the product of the signs of P, F, R, ..., f, e, v
        // should be the same as the sign of the volume of the simplex
        // whose vertices are the respective centers of those n+1 elements,
        // in order.
        // I.e. it should be equal to the sign of the determinant of the matrix
        // whose rows are the n vectors
        // i(F)-i(P), i(R)-(P), ..., i(f)-i(P), i(e)-i(P), i(v)-i(P)
        // where i() denotes any interior point of the respective polytope.
        //
        // So, in particular,
        //    If n==1:  From left to right,
        //              segment starts are -, segment ends are +
        //    If n==2:  Walking CCW around a contour
        //              (i.e. with inside on the left and outside on the right),
        //              e.sign * initialVertex.sign is -
        //              and e.sign * finalVertex.sign is +
        //    If n==3: Walking on the surface
        //              along an edge e CCW around a face f,
        //              f.sign * e.sign * initialVertex.sign is -
        //              f.sign * e.sign * finalVertex.sign is +
        // etc.
        //
        // XXX should split this up into functional stuff
        // XXX and cosmetic stuff,
        // XXX and cosmetic stuff should be applied even to hypercubes
        // XXX and stuff.
        //

        public static void orientDeep(SPolytope sp) // XXX should not be public!  change back to private after PolytopePuzzleDescription doesn't need it any more!
        {
            if (verboseLevel >= 1)
                System.out.println("in orientDeep");
            if (verboseLevel >= 2)
            {
                System.out.println("    Before anything:");
                System.out.println("        "+sp.toString("        "));
            }

            int dim = sp.p.dim;

            Polytope allElements[][] = sp.p.getAllElements();

            if (true)
            {
                FORI (iDim, dim+1)
                {
                    Polytope ofDim[] = allElements[iDim];
                    int nOfDim = ofDim.length;
                    FORI (iOfDim, nOfDim)
                        orientFacetsConsistently(ofDim[iOfDim]);
                }

                if (verboseLevel >= 2)
                {
                    System.out.println("    After recursively orienting everyone consistently:");
                    System.out.println("        "+sp.toString("        "));
                }
            }

            if (false)
            {
                //
                // If total sign is wrong
                // (along some arbitrary flag),
                // then reverse the sign of sp so it becomes right.
                //
                System.out.println("WARNING: orientDeep global orientation not implemented yet"); // XXX
                if (verboseLevel >= 2)
                {
                    System.out.println("    After fixing global sign if it was wrong:");
                    System.out.println("        "+sp.toString("        "));
                }
            }


            if (true)
            {
                if (dim >= 1)
                {
                    //
                    // Push sign of sp down into facets,
                    // making sign of sp +1.
                    //
                    int mySign = sp.sign;
                    SPolytope facets[] = sp.p.facets;
                    int nFacets = facets.length;
                    FORI (iFacet, nFacets)
                        facets[iFacet].sign *= mySign;
                    sp.sign = 1;

                    if (verboseLevel >=2)
                    {
                        System.out.println("    After pushing sign down into facets:");
                        System.out.println("        "+sp.toString("        "));
                    }

                    //
                    // Push sign of facet down into ridges,
                    // making the signs of all facets +1.
                    // Note this only makes sense when dim > 1.
                    // Also, it's pointless to do this any further:
                    // we can't make all ridge signs +,
                    // since they occur on multiple facets,
                    // in opposite-signed pairs.
                    //
                    if (dim >= 2)
                    {
                        FORI (iFacet, nFacets)
                        {
                            SPolytope facet = facets[iFacet];
                            int facetSign = facet.sign;
                            if (facetSign != 1)
                            {
                                SPolytope ridgesThisFacet[] = facet.p.facets;
                                int nRidgesThisFacet = ridgesThisFacet.length;
                                FORI (iRidgeThisFacet, nRidgesThisFacet)
                                    ridgesThisFacet[iRidgeThisFacet].sign *= facetSign;
                                facet.sign = 1;
                            }
                        }

                        if (verboseLevel >= 2)
                        {
                            System.out.println("    After pushing facet signs down into ridges:");
                            System.out.println("        "+sp.toString("        "));
                        }
                    }
                }
            }

            //
            // Edge cosmetic tweak:
            // for each edge, put the - vertex first and the + one second.
            // (If there are more than two vertices on the edge,
            // then don't worry about it.)
            //
            if (true)
            {
                if (dim >= 1)
                {
                    Polytope edges[] = sp.p.getAllElements()[1];
                    int nEdges = edges.length;
                    FORI (iEdge, nEdges)
                    {
                        Polytope edge = edges[iEdge];
                        SPolytope vertsThisEdge[] = edge.facets;
                        if (vertsThisEdge.length == 2
                         && vertsThisEdge[0].sign == 1
                         && vertsThisEdge[1].sign == -1)
                        {
                            SPolytope temp;
                            SWAP(vertsThisEdge[0],vertsThisEdge[1],temp);
                        }
                    }
                }

                if (verboseLevel >= 2)
                {
                    System.out.println("    After edge cosmetic tweak:");
                    System.out.println("        "+sp.toString("        "));
                }
            }


            //
            // Face cosmetic tweak:
            // for each 2-d face, put the edges on each contour in order.
            // This requires that the edge cosmetic tweak (above)
            // was done first.
            // XXX this is O(n^2) where n is face size,
            // XXX so can be time-consuming
            // XXX for huge faces.
            //
            if (true)
            {
                if (dim >= 2)
                {
                    Polytope faces[] = sp.p.getAllElements()[2];
                    int nFaces = faces.length;
                    FORI (iFace, nFaces)
                    {
                        Polytope p = faces[iFace];
                        SPolytope edges[] = p.facets;
                        int nEdges = edges.length;

                        int contourStart = 0;
                        #define INITIAL(sign) ((sign)==1?0:1)
                        #define FINAL(sign) ((sign)==1?1:0)
                        Polytope initialVertexOnContour = null; // initialization not necessary, but to shut up compiler
                        if (contourStart < nEdges)
                        {
                            assumpt(edges[contourStart].p.facets.length >= 2); // XXX can't we have an edge that's all of the line!? think about this (also same below)
                            initialVertexOnContour = edges[contourStart].p.facets[INITIAL(edges[contourStart].sign)].p;
                        }


                        //
                        // See whether this face has any multi-edges.
                        // If it does, it's no use trying to cosmeticize
                        // this face.
                        //
                        {
                            int iEdge;
                            FOR (iEdge, nEdges)
                            {
                                SPolytope sedgeI = edges[iEdge];
                                Polytope edgeI = sedgeI.p;
                                if (edgeI.facets.length != 2
                                 || edgeI.facets[0].sign != -1
                                 || edgeI.facets[1].sign != 1)
                                    break;
                            }
                            if (iEdge < nEdges)
                                continue; // this face has a multi-edge or something, so it's hopeless
                        }

                        FORI (iEdge, nEdges)
                        {
                            SPolytope sedgeI = edges[iEdge];
                            Polytope edgeI = sedgeI.p;
                            assert(edgeI.facets.length == 2
                             && edgeI.facets[0].sign == -1
                             && edgeI.facets[1].sign == 1);
                            Polytope finalVertexOnEdgeI = edgeI.facets[FINAL(sedgeI.sign)].p;
                            if (finalVertexOnEdgeI
                             == initialVertexOnContour)
                            {
                                // iEdge is the last edge on this contour.
                                contourStart = iEdge+1;
                                if (contourStart < nEdges)
                                {
                                    assumpt(edges[contourStart].p.facets.length >= 2); // XXX can't we have an edge that's all of the line!? think about this. (also same above)
                                    initialVertexOnContour = edges[contourStart].p.facets[INITIAL(edges[contourStart].sign)].p;
                                }
                            }
                            else
                            {
                                // iEdge is not the last edge on this contour;
                                // find the next one.
                                int jEdge;
                                for (jEdge = iEdge+1; jEdge < nEdges; jEdge++)
                                {
                                    SPolytope sedgeJ = edges[jEdge];
                                    Polytope edgeJ = sedgeJ.p;
                                    Polytope initialVertexOnEdgeJ = edgeJ.facets[INITIAL(sedgeJ.sign)].p;
                                    if (initialVertexOnEdgeJ == finalVertexOnEdgeI)
                                        break; // found next
                                }
                                assert(jEdge < nEdges); // found next
                                if (jEdge > iEdge+1)
                                {
                                    SPolytope temp;
                                    SWAP(edges[iEdge+1], edges[jEdge], temp);
                                }
                            }
                        }
                    }
                }
                if (verboseLevel >= 2)
                {
                    System.out.println("    After face cosmetic tweak:");
                    System.out.println("        "+sp.toString("        "));
                }
            } // face cosmetic tweak

            //
            // XXX One more potential nice cosmetic tweak:
            // XXX prefer nice orderings for earlier facets.
            //
            {
            }

            if (verboseLevel >= 1)
                System.out.println("out orientDeep");
        } // orientDeep



        //
        // p is an unfinished polytope (meaning we can and do
        // change it in place).
        // Assumes all facets' facets, etc. are already consistently oriented;
        // i.e. this must be called in a bottom-up order.
        //
        private static void orientFacetsConsistently(Polytope p)
        {
            if (verboseLevel >= 2)
            {
                System.out.println("in orientFacetsConsistently("+dimToPrefix(p.dim)+p.id+")");
                if (verboseLevel >= 3)
                    PRINT(p);
            }
            SPolytope facets[] = p.facets;
            int nFacets = facets.length;

            if (nFacets == 0)
            {
                if (verboseLevel >= 2)
                    System.out.println("out orientFacetsConsistently, boy that was hard :-)");
                return;
            }

            if (p.dim == 1)
            {
                if (nFacets > 2) // XXX maybe should do this anyway, for testing?
                {
                    //
                    // Take the farthest vertex from v0,
                    // and call it b.  Take the farthest vertex from b,
                    // and call it a.
                    // 
                    double a[], b[];
                    {
                        double from[] = facets[0].p.getCoords();
                        double farthest[] = null;
                        {
                            double farthestDistSqrd = Double.NEGATIVE_INFINITY;
                            FORI (iFacet, nFacets)
                            {
                                double thisCoords[] = facets[iFacet].p.getCoords();
                                double thisDistSqrd = VecMath.distsqrd(from, thisCoords);
                                if (thisDistSqrd > farthestDistSqrd)
                                {
                                    farthest = thisCoords;
                                    farthestDistSqrd = thisDistSqrd;
                                }
                            }
                            assert(farthest != null);
                        }
                        b = farthest;
                        from = b;
                        {
                            double farthestDistSqrd = Double.NEGATIVE_INFINITY;
                            FORI (iFacet, nFacets)
                            {
                                double thisCoords[] = facets[iFacet].p.getCoords();
                                double thisDistSqrd = VecMath.distsqrd(from, thisCoords);
                                if (thisDistSqrd > farthestDistSqrd)
                                {
                                    farthest = thisCoords;
                                    farthestDistSqrd = thisDistSqrd;
                                }
                            }
                            assert(farthest != null);
                        }
                        a = farthest;
                    }

                    final double dir[] = VecMath.vmv(b, a);

                    //
                    // Sort along dir...
                    //
                    SortStuff.sort(facets,
                                   new SortStuff.Comparator() {
                                       public int compare(Object _a, Object _b)
                                       {
                                           SPolytope A = (SPolytope)_a;
                                           SPolytope B = (SPolytope)_b;
                                           double aDot = VecMath.dot(A.p.getCoords(), dir);
                                           double bDot = VecMath.dot(B.p.getCoords(), dir);
                                           return aDot < bDot ? -1 :
                                                  aDot > bDot ? 1 : 0;
                                       }
                                   });
                } // if (nFacets > 2)

                int sign = -1;
                FORI (iFacet, nFacets)
                {
                    facets[iFacet].sign = sign;
                    sign = -sign;
                }
                if (verboseLevel >= 2)
                    System.out.println("out orientFacetsConsistently, edges are easy");
                return;
            }

            //
            // facetNeighbors[iFacet][iRidgeOnFacet][0] is the index
            // of the other facet sharing that ridge, and
            // facetNeighbors[iFacet][iRidgeOnFacet][1]
            // is the index of the ridge in the neighbor facet's facet list.
            // XXX perhaps finished polytopes should always have these tables
            // XXX so we don't have to recalculate them?
            // XXX YES, I think I'm on the road to that with getAllIncidences
            //
            int facetNeighbors[][][] = new int[nFacets][][/*2*/];
            {
                FORI (iFacet, nFacets)
                    facetNeighbors[iFacet] = new int[facets[iFacet].p.facets.length][/*2*/];
                java.util.Hashtable firstFacetContainingRidge = new java.util.Hashtable();
                FORI (iFacet, nFacets)
                {
                    Polytope facet = facets[iFacet].p;
                    SPolytope ridgesThisFacet[] = facet.facets;
                    int nRidgesThisFacet = ridgesThisFacet.length;
                    FORI (iRidgeThisFacet, nRidgesThisFacet)
                    {
                        Polytope ridge = ridgesThisFacet[iRidgeThisFacet].p;
                        int myInfo[] = {iFacet, iRidgeThisFacet};
                        int neighborInfo[] = (int[])firstFacetContainingRidge.remove(ridge);
                        if (neighborInfo == null)
                        {
                            firstFacetContainingRidge.put(ridge, myInfo);
                        }
                        else
                        {
                            facetNeighbors[iFacet][iRidgeThisFacet] = neighborInfo;
                            facetNeighbors[neighborInfo[0]][neighborInfo[1]] = myInfo;
                        }
                    }
                }
                assert(firstFacetContainingRidge.size() == 0); // everything matched XXX change this assert to failure I think
            } // facetNeighbors

            int signOfFirstFacet = 1; // arbitrarily XXX is there a better choice?
            boolean isSigned[] = new boolean[nFacets];
            FORI (iFacet, nFacets)
                isSigned[iFacet] = false;

            SPolytope contours[][] = new SPolytope[nFacets][]; // worst case
            int nContours = 0; // and counting
            SPolytope currentContour[] = new SPolytope[nFacets];

            int stackHeight = 0;
            int stack[] = new int[nFacets];
            FORI (contourStart, nFacets)
            {
                if (!isSigned[contourStart])
                {
                    int currentContourSize = 0;
                    {
                        int iFacet = contourStart;
                        SPolytope facet = facets[iFacet];
                        facet.sign = signOfFirstFacet;
                        isSigned[iFacet] = true;
                        stack[stackHeight++] = iFacet; // push iFacet on to stack
                        currentContour[currentContourSize++] = facets[iFacet];
                    }
                    while (stackHeight != 0)
                    {
                        int iFacet = stack[--stackHeight]; // pop iFacet off of stack
                        SPolytope facet = facets[iFacet];
                        SPolytope ridgesThisFacet[] = facet.p.facets;
                        int nRidgesThisFacet = ridgesThisFacet.length;
                        FORI (iRidgeThisFacet, nRidgesThisFacet)
                        {
                            int neighborInfo[/*2*/] = facetNeighbors[iFacet][iRidgeThisFacet];
                            int iNeighbor = neighborInfo[0];
                            int iRidgeNeighborFacet = neighborInfo[1];

                            if (!isSigned[iNeighbor])
                            {
                                //System.out.println(""+iFacet+" -> "+iNeighbor+"");
                                SPolytope neighborFacet = facets[iNeighbor];
                                SPolytope ridgesNeighborFacet[] = neighborFacet.p.facets;

                                // Want facets[iFacet].sign
                                //          * ridgesThisFacet[iRidgeThisFacet].sign
                                //  = - facets[iNeighbor].sign
                                //          * ridgesNeighborFacet[iRidgeNeighborFacet].sign.
                                int signOfRidgeOnNeighbor = ridgesNeighborFacet[iRidgeNeighborFacet].sign;
                                assumpt(signOfRidgeOnNeighbor == 1
                                     || signOfRidgeOnNeighbor == -1); // otherwise should be / instead of * below, and I'm not sure what it means if it doesn't divide evenly, have to think about it some day

                                neighborFacet.sign = -facet.sign
                                                   * ridgesThisFacet[iRidgeThisFacet].sign
                                                   * signOfRidgeOnNeighbor;
                                isSigned[iNeighbor] = true;
                                stack[stackHeight++] = iNeighbor; // push iNeighbor on to stack
                                currentContour[currentContourSize++] = facets[iNeighbor];
                            }
                            else
                            {
                                //System.out.println("("+iFacet+" -> "+iNeighbor+")");
                            }
                        }
                    } // while (stackHeight != 0)
                    contours[nContours++] = (SPolytope[])Arrays.subarray(currentContour, 0, currentContourSize);
                }
            } // for contourStart
            FORI (iFacet, nFacets)
                assert(isSigned[iFacet]);

            //
            // Make temporary SPolytopes out of the contours...
            // XXX should avoid this if only one contour
            //
            SPolytope contourSPolytopes[] = new SPolytope[nContours];
            {
                FORI (iContour, nContours)
                    contourSPolytopes[iContour] = new SPolytope(0,1,
                                        new Polytope(p.dim,
                                                     p.fullDim,
                                                     contours[iContour],
                                                     p.contributingHyperplanes,
                                                     p.aux));
            }

            contours = null; // make sure we don't use it by accident after this

            //
            // Find the coordinate axis in which the bbox is the largest,
            // and sort the contour list according to
            // minimum coordinate along this coordinate axis.
            // Then an item in the sorted list
            // cannot contain any earlier item.
            //
            double bbox[][] = p.getBBox();
            double bboxSize[] = VecMath.vmv(bbox[1], bbox[0]);
            final int ax = VecMath.maxi(bboxSize);
            SortStuff.sort(contourSPolytopes,
                   new SortStuff.Comparator() {
                       public int compare(Object _a, Object _b)
                       {
                           SPolytope a = (SPolytope)_a;
                           SPolytope b = (SPolytope)_b;
                           double aDot = a.p.getBBox()[0][ax];
                           double bDot = b.p.getBBox()[0][ax];
                           return aDot < bDot ? -1 :
                                  aDot > bDot ? 1 : 0;
                       }
                   });


            if (verboseLevel >= 2
             && nContours > 1)
            {
                System.out.println("The contours:\n");
                FORI (iContour, nContours)
                {
                    System.out.println("    "+iContour+":");
                    System.out.println(contourSPolytopes[iContour]);
                }
            }


            //
            // Make a tree whose nodes are the contours,
            // ordered by contour inclusion.
            //
            int root = 0;
            int firstChild[] = VecMath.fillvec(nContours, -1);
            int nextSibling[] = VecMath.fillvec(nContours, -1);
            {
                double eps = 1e-12; // XXX ad-hoc, need to make a coherent scheme
                // scratch for loop...
                    int densityMinMax[] = new int[2];

                for (int iContour = 1; iContour < nContours; ++iContour) // skip 0, it's already on the tree as the root
                {
                    double anyCoordsOnContour[];
                    {
                        // v = any vertex on contour iContour
                        Polytope v = contourSPolytopes[iContour].p;
                        while (v.dim > 0)
                            v = v.facets[0].p;
                        anyCoordsOnContour = v.getCoords();
                    }

                    // Hang iContour on the tree.
                    // Walk down the tree starting with root...
                    for (int iNode = root; ;)
                    {
                        SPolytope nodeSPolytope = contourSPolytopes[iNode];
                        calcDensity(nodeSPolytope,
                                    anyCoordsOnContour,
                                    eps,
                                    densityMinMax);
                        int density = densityMinMax[0];
                        assumpt(density == densityMinMax[1]); // must be unambiguous
                        boolean isContainedInNode = (density&1) == 1;
                        if (isContainedInNode)
                        {
                            // proceed on to children
                            if (firstChild[iNode] == -1)
                            {
                                firstChild[iNode] = iContour;
                                break;
                            }
                            iNode = firstChild[iNode];
                        }
                        else
                        {
                            // proceed on to next sibling
                            if (nextSibling[iNode] == -1)
                            {
                                nextSibling[iNode] = iContour;
                                break;
                            }
                            iNode = nextSibling[iNode];
                        }
                    }
                }
            }
            if (verboseLevel >= 2
             && nContours > 1)
            {
                PRINTMAT(firstChild);
                PRINTMAT(nextSibling);
            }

            double normals[][] = new double[p.contributingHyperplanes.length][];
            {
                FORI (iHyperplane, normals.length)
                    normals[iHyperplane] = p.contributingHyperplanes[iHyperplane].normal;
            }

            //
            // Start by orienting all the contours in the same direction
            // (e.g. all counterclockwise).
            //
            {
                FORI (iContour, nContours)
                {
                    SPolytope contourSPolytope = contourSPolytopes[iContour];
                    double volume = volume(contourSPolytope);
                    if (volume < 0)
                    {
                        SPolytope facetsThisContour[] = contourSPolytope.p.facets;
                        int nFacetsThisContour = facetsThisContour.length;
                        FORI (iFacetThisContour, nFacetsThisContour)
                        {
                            SPolytope facet = facetsThisContour[iFacetThisContour];
                            facet.sign = -facet.sign;
                        }
                    }
                }
            }

            //
            // Reverse the signs of alternate levels of contours.
            // We use each contourSPolytope's sign to store +-1
            // depending on whether we are reversing it or not.
            // (the final value of its sign doesn't matter
            // since it is getting thrown away).
            //
            {
                FORI (iContour, nContours)
                {
                    SPolytope contourSPolytope = contourSPolytopes[iContour];
                    int sign = contourSPolytope.sign;
                    if (sign < 0)
                    {
                        SPolytope facetsThisContour[] = contourSPolytope.p.facets;
                        int nFacetsThisContour = facetsThisContour.length;
                        FORI (iFacetThisContour, nFacetsThisContour)
                        {
                            SPolytope facet = facetsThisContour[iFacetThisContour];
                            facet.sign = -facet.sign;
                        }
                    }
                    if (firstChild[iContour] != -1)
                        contourSPolytopes[firstChild[iContour]].sign = -sign;
                    if (nextSibling[iContour] != -1)
                        contourSPolytopes[nextSibling[iContour]].sign = sign;
                }
            }

            if (verboseLevel >= 2)
                System.out.println("out orientFacetsConsistently("+dimToPrefix(p.dim)+p.id+")");
        } // orientFacetsConsistently


// XXX I think PolyCSG should deal with SPolytopes, not Polytopes...
// XXX then this won't be necessary.  At least I think that's what I think.
#define SOON_TO_BE_DEFUNCT
#ifdef SOON_TO_BE_DEFUNCT
        /** Computes the union of two unsigned polytopes. */
        public static Polytope union(Polytope A, Polytope B)
        {
            return union(new SPolytope(0,1,A),
                         new SPolytope(0,1,B)).p;
        } // union of unsigned Polytopes
        /** Computes the intersection of two unsigned polytopes. */
        public static Polytope intersect(Polytope A, Polytope B)
        {
            return intersect(new SPolytope(0,1,A),
                             new SPolytope(0,1,B)).p;
        } // intersect of unsigned Polytopes
        /** Computes the difference of two unsigned polytopes. */
        public static Polytope diff(Polytope A, Polytope B)
        {
            return diff(new SPolytope(0,1,A),
                        new SPolytope(0,1,B)).p;
        } // diff of unsigned Polytopes
#endif // SOON_TO_BE_DEFUNCT

        private static String signToString(int sign)
        {
            return sign ==  1 ? "+" :
                   sign == -1 ? "-" :
                   sign ==  0 ? "!" :
                   "(sign="+sign+")";
        } // signToString

        private static String dimToPrefix(int dim)
        {
            if (dim <= 4)
                return "vefch".substring(dim,dim+1);
            else
                return "(" + dim + "d)"; // sort of lame but it's the best I can think of at the moment, and it doesn't seem to look too bad
        } // dimToPrefix

        // XXX this is really lame, should maybe restructure so we don't need it
        private static Object itemOfAThatsNotInB(Object A[], Object B[])
        {
            int iA, nA = A.length;
            int iB, nB = B.length;
            FOR (iA, nA)
            {
                FOR (iB, nB)
                    if (A[iA] == B[iB])
                        break;
                if (iB == nB) // A[iA] was not in B
                    return A[iA];
            }
            assert(false);
            return null;
        } // itemOfAThatsNotInB

        // XXX used by slice, remove if I get rid of slice
        private static Hyperplane[] addOneHyperplaneAndSort(Hyperplane[] list, Hyperplane last)
        {
            list = (Hyperplane[])Arrays.append(list, last);
            SortStuff.sort(list,
                           new SortStuff.Comparator() {
                               public int compare(Object _a, Object _b)
                               {
                                   Hyperplane a = (Hyperplane)_a;
                                   Hyperplane b = (Hyperplane)_b;
                                   return a.id < b.id ? -1 :
                                          a.id > b.id ? 1 : 0;
                               }
                           });
            return list;
        } // addOneHyperplaneAndSort

        private static Hyperplane[] unionOfHyperplanesAndSort(Hyperplane[] these, Hyperplane[] those)
        {
            Hyperplane list[] = (Hyperplane[])Arrays.concat(these, those);
            SortStuff.Comparator comparator =
               new SortStuff.Comparator() {
                   public int compare(Object _a, Object _b)
                   {
                       Hyperplane a = (Hyperplane)_a;
                       Hyperplane b = (Hyperplane)_b;
                       return a.id < b.id ? -1 :
                              a.id > b.id ? 1 : 0;
                   }
               };

            SortStuff.sort(list, comparator);
            int n = SortStuff.nodup(list, list.length, comparator);
            list = (Hyperplane[])Arrays.subarray(list, 0, n);
            return list;
        } // unionOfHyperplanesAndSort

        // return the point that is the intersection of n hyperplanes in n dimensions.
        private static double[] intersectHyperplanes(Hyperplane hyperplanes[])
        {
            int nHyperplanes = hyperplanes.length;
            if (nHyperplanes == 0)
                return new double[0];
            int iHyperplane;
            FOR (iHyperplane, nHyperplanes)
                if (hyperplanes[iHyperplane].spanningPoints == null)
                    break; // this hyperplane is not defined by spanning points
            if (iHyperplane == nHyperplanes)
            {
                //
                // All hyperplanes
                // are from spanning points.
                // We just need to find the one point
                // that is in the spanning set of all of them.
                //
                assert(nHyperplanes > 0); // we would have returned early above
                int iSpanningPoint, nSpanningPoints = hyperplanes[0].spanningPoints.length;
                FOR (iSpanningPoint, nSpanningPoints)
                {
                    double point[] = hyperplanes[0].spanningPoints[iSpanningPoint];
                    for (iHyperplane = 1; iHyperplane < nHyperplanes; ++iHyperplane)
                        if (Arrays.indexOfUsingEqualsSymbol(hyperplanes[iHyperplane].spanningPoints, point) == -1)
                            break; // it's not in this one
                    if (iHyperplane == nHyperplanes)
                    {
                        // It's in all of them!
                        return point;
                    }
                }
                assert(false); // XXX not sure if this can happen or not, so flag it for now and think about it if it goes off
            }

            //
            // Calculate explicit coords of the vertex.
            // We want column vector c
            // such that
            //    normal0 dot c == offset0
            //    normal1 dot c == offset1
            //    normal2 dot c == offset2
            //    ...
            // so c = inv(normalsMatrix) * offsetsColumnVector.
            //

#ifdef DEFUNCT
            int nRows = hyperplanes.length;
            double normalsMatrix[][] = new double[nRows][nRows];
            double offsetsColumnVector[][] = new double[nRows][1];

            double c[] = new double[nRows];
            FORI (iRow, nRows)
            {
                VecMath.copyvec(normalsMatrix[iRow], hyperplanes[iRow].normal);
                offsetsColumnVector[iRow][0] = hyperplanes[iRow].offset;
            }
            // replace normalsMatrix by its inverse,
            // replace offsetsColumnVector by the solution
            try
            {
                VecMath.gaussj(normalsMatrix, nRows,
                               offsetsColumnVector, 1);
            }
            catch (Exception e) // XXX singular matrix-- should figure out a cleaner way to do this
            {
                return null;
            }
            return VecMath.getcolumn(offsetsColumnVector, 0);
#endif // DEFUNCT

            int nRows = hyperplanes.length;
            double normalsMatrix[][] = new double[nRows][nRows];
            double offsetsColumnVector[] = new double[nRows];
            FORI (iRow, nRows)
            {
                VecMath.copyvec(normalsMatrix[iRow], hyperplanes[iRow].normal);
                offsetsColumnVector[iRow] = hyperplanes[iRow].offset;
            }
            double c[] = VecMath.invmxv(normalsMatrix, offsetsColumnVector);

            // XXX not an adequate test, I don't think
            if (c.length > 0
             && (Double.isInfinite(c[0])
              || Double.isNaN(c[0])))
                return null;

            return c;
        } // intersectHyperplanes



        //
        // Wrapper for a sorted array,
        // allowing it to be used as a hash key and value.
        // Equality is based on equality of the component items.
        // The hash code is the xor of all the component items' hash codes.
        // XXX should use sum, like some java structures do? think about it
        //
        private static class HashableSortedArray
        {
            private Object array[];
            public HashableSortedArray(Object array[])
            {
                this.array = array;
            }
            public int hashCode()
            {
                int hashCode = 0;
                int n = array.length;
                FORI (i, n)
                    hashCode ^= array[i].hashCode();
                return hashCode;
            } // equals
            public boolean equals(Object _that)
            {
                HashableSortedArray that = (HashableSortedArray)_that;
                Object[] these = this.array;
                Object[] those = that.array;
                int nThese = these.length, nThose = those.length;
                if (nThese != nThose)
                    return false;
                FORI (i, nThese)
                    if (!these[i].equals(those[i]))
                        return false;
                return true;
            } // equals
        } // class HashableSortedArray

        private static class HashablePair
        {
            private Object first, second;
            public HashablePair(Object first, Object second)
            {
                this.first = first;
                this.second = second;
            }
            public int hashCode()
            {
                return 3*first.hashCode() + second.hashCode();
            }
            public boolean equals(Object _that)
            {
                HashablePair that = (HashablePair)_that;
                return this.first.equals(that.first)
                    && this.second.equals(that.second);
            }
        } // class HashablePair


        private static int factorial(int n)
        {
            return n==0 ? 1 : n*factorial(n-1);
        }
        private static int intpow(int a, int b)
        {
            return b==0 ? 1 : intpow(a, b-1) * a;
        }
        private static int digit(int x, int i, int base)
        {
            return x / intpow(base,i) % base;
        }
        private static String intToString(int x, int base)
        {
            return (x>base ? intToString(x/base,base) : "") + x%base;
        }

        private static int numOccurancesOf(String str, String substr)
        {
            int numOccurances = 0;
            int i = -1;
            while ((i = str.indexOf(substr, i+1)) != -1)
                numOccurances++;
            return numOccurances;
        } // numOccurancesOf


    private static final boolean evalVerbose = false;
    /**
    *  Evaluate an expression such as "<code>(-((A-B) i (A i D))) u C</code>"
    *  from the beginning of a string,
    *  leaving the unparsed remainder of the string in the "rest" parameter.
    */
    public static SPolytope eval(
                String expr,     // XXX term, really... sorry for the confusion
                int dim,
                int fullDim,
                String varNames[/*1*/][], // array is passed by ref so can be resized
                SPolytope varValues[/*1*/][], // array is passed by ref so can be resized
                String rest[/*1*/]) // unparsed remainder of string is returned here
        throws java.text.ParseException
    {
        SPolytope result = null;
        String orig_expr = expr; // for error messages

        expr = expr.trim();
        if (expr.length() == 0)
            throw new java.text.ParseException("Empty expression \""+expr+"\"", orig_expr.length()-expr.length());
        char firstChar = expr.charAt(0);
        expr = expr.substring(1);

        if (firstChar == '0')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> 0");
            result = new SPolytope(0,1,
                                   new Polytope(dim,
                                                fullDim,
                                                new SPolytope[0], // no facets
                                                new Hyperplane[0], // no hyperplanes
                                                null)); // no aux // XXX use substring?
        }
        else if (firstChar == '1')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> 1");
            result = new SPolytope(1,1,
                                   new Polytope(dim,
                                                fullDim,
                                                new SPolytope[0], // no facets
                                                new Hyperplane[0], // no hyperplanes
                                                null)); // no aux // XXX use substring?
        }
        else if ("-~".indexOf(firstChar) != -1)
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> -expr");
            SPolytope operand = eval(expr,
                                     dim,
                                     fullDim,
                                     varNames,
                                     varValues,
                                     rest);
            expr = rest[0];
            result = complement(operand);
        }
        else if (firstChar == 's'
              && expr.startsWith("can(\""))
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> scan(\"quoted_string\")");
            int endQuoteIndex = expr.indexOf("\"", 5);
            if (endQuoteIndex < 0)
                throw new java.text.ParseException("bad bad bad expression \""+orig_expr+"\"", orig_expr.length()-expr.length());
            String fileName = expr.substring(5, endQuoteIndex);

            expr = expr.substring(endQuoteIndex+1);
            if (!expr.startsWith(")"))
                throw new java.text.ParseException("bad bad bad expression \""+orig_expr+"\"", orig_expr.length()-expr.length());
            expr = expr.substring(1);

            try {
                java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader(fileName));
                StringBuffer sb = new StringBuffer();
                char buf[] = new char[1024];
                int numRead = 0;
                while ((numRead = reader.read(buf)) > -1)
                    sb.append(String.valueOf(buf, 0, numRead));
                reader.close();
                String fileContents = sb.toString();
                result = SPolytope.fromStringInPcalcFormat(fileContents);
                // XXX LAME!  should be a method that reads from a Reader instead of having to slurp the whole file!
            }
            catch (java.io.IOException e)
            {
                throw new java.text.ParseException("Fooey, something went wrong reading file \""+fileName+"\": "+e, orig_expr.length()-expr.length());
            }
        }
        else if (firstChar == '(')
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (something)  (not sure))");
            SPolytope LHS = eval(expr,
                                 dim,
                                 fullDim,
                                 varNames,
                                 varValues,
                                 rest);
            expr = rest[0];
            expr = expr.trim(); // XXX actually only need to trim at beginning
            if (expr.length() == 0)
                throw new java.text.ParseException("Premature end of expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
            char operatorChar = expr.charAt(0);
            expr = expr.substring(1);

            if (operatorChar == ')')
            {
                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr)  (now I'm sure)");
                result = LHS;
            }
            else
            {
                SPolytope RHS = eval(expr,
                                     dim,
                                     fullDim,
                                     varNames,
                                     varValues,
                                     rest);
                expr = rest[0];
                if (expr.length() == 0)
                    throw new java.text.ParseException("Unmatched left paren in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                char shouldBeCloseParen = expr.charAt(0);
                expr = expr.substring(1);
                if (shouldBeCloseParen != ')')
                    throw new java.text.ParseException("Expected ')', got '"+shouldBeCloseParen+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());

                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr binop expr)  (now I'm sure)");

                if ("i&".indexOf(operatorChar) != -1)
                    result = intersect(LHS, RHS);
                else if ("u|".indexOf(operatorChar) != -1)
                    result = union(LHS, RHS);
                else if ("dm-\\".indexOf(operatorChar) != -1)
                    result = diff(LHS, RHS);
                else if ("*x".indexOf(operatorChar) != -1)
                    result = cross(LHS, RHS);
                else
                    throw new java.text.ParseException("Unknown binary operation '"+operatorChar+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> (expr "+operatorChar+" expr)");
            }
        }
        else if (Character.isJavaIdentifierStart(firstChar))
        {
            if (evalVerbose) System.out.println("\""+orig_expr+"\": expr -> varName and maybe assignment, not sure");
            String varName = ""+firstChar;
            while (expr.length() > 0
                && Character.isJavaIdentifierPart(firstChar = expr.charAt(0)))
            {
                varName += firstChar;
                expr = expr.substring(1);
            }

            int iVar, nVars = varNames[0].length;
            FOR (iVar, nVars)
                if (varName.equals(varNames[0][iVar]))
                    break;

            // XXX grammar is violated here... we are making varName=value
            // XXX into a term when it should be an expression;
            // XXX e.g.  A - B = C  is legal
            // XXX and is equivalent to A - (B = C),
            // XXX when it shouldn't be legal :-(
            // XXX also A=B-C gets evaluated as (A=B)-C :-( :-(
            // XXX really need to fix this
            expr = expr.trim();
            if (expr.length() >= 1
             && expr.charAt(0) == '=')
            {
                expr = expr.substring(1);

                expr = expr.trim(); // XXX should be only at beginning
                if (expr.length() == 0
                 || expr.startsWith(")"))
                {
                    // unset the variable-- that is, crunch it out
                    // of both arrays, keeping the arrays in order.
                    if (iVar < nVars)
                    {
                        varNames[0] = (String[])Arrays.concat(
                            Arrays.subarray(varNames[0],0,iVar),
                            Arrays.subarray(varNames[0],iVar+1,nVars-(iVar+1)));
                        varValues[0] = (SPolytope[])Arrays.concat(
                            Arrays.subarray(varValues[0],0,iVar),
                            Arrays.subarray(varValues[0],iVar+1,nVars-(iVar+1)));
                    }

                    result = null;
                }
                else
                {
                    SPolytope RHS = eval(expr,
                                         dim,
                                         fullDim,
                                         varNames,
                                         varValues,
                                         rest);
                    expr = rest[0];

                    if (iVar == nVars)
                    {
                        // append the new name,value pair
                        varNames[0] = (String[])Arrays.append(varNames[0], varName);
                        varValues[0] = (SPolytope[])Arrays.append(varValues[0], RHS);
                    }
                    else
                    {
                        // replace old value
                        varValues[0][iVar] = RHS;
                    }

                    result = RHS;
                }
            }
            else
            {
                if (iVar == nVars)
                    throw new java.text.ParseException("Undefined variable \""+varName+"\" in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
                result = varValues[0][iVar];
            }
        }
        else
        {
            throw new java.text.ParseException("Unexpected first char '"+firstChar+"' in expression \""+orig_expr+"\"",orig_expr.length()-expr.length());
        }

        rest[0] = expr;
        return result;
    } // eval

    /**
    *  Evaluate an expression such as "<code>(-((A-B) i (A i D))) u C</code>".
    *  The grammar is:
    *  <pre>
    * 
    *           expr -&gt; term
    *           expr -&gt; term [i&amp;^*] term // intersect(LHS,RHS)
    *           expr -&gt; term [u|+] term  // union(LHS,RHS)
    *           expr -&gt; term [-\dm] term // diff(LHS,RHS)
    *           expr -&gt; varName = expr   // sets varName's value to value of expr
    *           term -&gt; "0"              // empty set
    *           term -&gt; "1"              // all of space
    *           term -&gt; varName          // corresponding varValue
    *           term -&gt; [~-] term        // complement(RHS)
    *           term -&gt; "(" expr ")"
    *           term -&gt; scan "(" quoted_string ")"
    *  </pre>
    * 
    *  Note all the alternative operator chars; I'm wishy washy.
    *  The ones that are letters must be separated from adjacent variable names
    *  by spaces.
    * 
    *  XXX need a way to unset a variable
    */
    public static SPolytope eval(
                String expr,
                int dim,
                int fullDim,
                String varNames[/*1*/][], // array is passed by ref so can be resized
                SPolytope varValues[/*1*/][]) // array is passed by ref so can be resized
        throws java.text.ParseException
    {
        String rest[] = new String[1];
        String term = "("+expr+")";


        // XXX hack that my little brain seems to want...
        // XXX add as many parens at beginning as necessary
        while (numOccurancesOf(term, "(")
             < numOccurancesOf(term, ")"))
        {
            term = "(" + term;
        }


        SPolytope result = eval(term,
                                dim,
                                fullDim,
                                varNames,
                                varValues,
                                rest);
        if (rest[0].length() != 0)
        {
            int errorOffsetInTerm = term.length() - rest[0].length();
            throw new java.text.ParseException("Trailing garbage \""+rest[0]+"\" in expression \""+term+"\"",errorOffsetInTerm);
        }

        if (!isOrientedDeep(result.p))
        {
            System.out.println("WARNING: top-level eval returning a badly oriented polytope!");
        }
        return result;
    } // eval



    /**
    *  A little test program...
    *  Take two hypercubes, and do union, intersection, and difference.
    */
    public static void main(String args[])
        throws java.io.IOException
    {
        System.out.println("in main");

        if (args.length < 1)
        {
            System.err.println("Usage: CSG <dim> [<expr>]");
            System.exit(1);
        }

        if (false)
        {
            // just test make regular polytope
            SPolytope sp = makeRegularStarPolytopeProductFromString(args[0]);

            PRINTVEC(counts(sp.p));
            //PRINT(sp);
            return;
        }

        int fullDim = Integer.parseInt(args[0]);
        int dim = fullDim;

        if (false)
        {
            // just test simplex
            PRINT(makeSimplex(dim));
            return;
        }

        SPolytope A = makeHypercube(VecMath.fillvec(dim, -1.), 2.);
        SPolytope B = makeHypercube(VecMath.fillvec(dim,  1.), 2.);
        SPolytope C = makeHypercube(VecMath.fillvec(dim,  0.), 2.);
        //SPolytope simplex = makeSimplex(dim);
        SPolytope simplex = A; // XXX not ready yet

#ifdef DEFUNCT_BUT_NOTE // XXX can probably get rid of this now... but need to transfer the isOriented stuff somewhere in the shell!
        PRINT(A);
        PRINT(B);
        PRINT(C);

        if (false)
        {
            SPolytope AiB = intersect(A,B);
            PRINT(A);
            PRINT(B);
            PRINT(AiB);
            assert(isOrientedDeep(AiB.p));
        }
        if (false)
        {
            SPolytope AuB = union(A,B);
            PRINT(A);
            PRINT(B);
            PRINT(AuB);
            assert(isOrientedDeep(AuB.p));
        }
        if (false)
        {
            SPolytope AmB = diff(A,B);
            PRINT(A);
            PRINT(B);
            PRINT(AmB);
            assert(isOrientedDeep(AmB.p));
        }

        // Make a polytope with a cavity
        if (false)
        {
            SPolytope AiB = intersect(A,B);
            SPolytope Cm_AiB = diff(C, AiB);
            PRINT(A);
            PRINT(B);
            PRINT(C);
            PRINT(AiB);
            PRINT(Cm_AiB);
            assert(isOrientedDeep(Cm_AiB.p));
        }
#endif // DEFUNCT_BUT_NOTE

        if (args.length >= 2)
        {
            //
            // Evaluate given input expression
            //
            String expr = args[1];
            String varNames[][]     = {{"A","B","C","simplex"}};
            SPolytope varValues[][] = {{ A,  B,  C,  simplex }};
            SPolytope result = null;
            try
            {
                result = eval(expr,
                              dim,
                              fullDim,
                              varNames,
                              varValues);
            }
            catch (java.text.ParseException e)
            {
                System.err.println("Exception parsing expression \""+expr+"\": "+e);
            }
            PRINT(expr);
            PRINT(result);
        }
        else
        {
            //
            // Do a command shell.  Woohoo!
            //
            java.io.BufferedReader reader =
                new java.io.BufferedReader(
                    new java.io.InputStreamReader(System.in));

            // XXX hellacious hack for one-time-only pushback.
            // XXX it doesn't work anyway; the newline doesn't seem to make it.
            // XXX why not???
            if (false)
            {
                String nl = System.getProperty("line.separator");
                java.io.PushbackReader pushbackReader = new java.io.PushbackReader(new java.io.InputStreamReader(System.in), 100);
                pushbackReader.unread(("help"+nl).toCharArray());
                reader = new java.io.BufferedReader(pushbackReader);
            }

            String prompt = "yeah? ";

            String varNames[][]     = {{"A","B","C","simplex"}};
            SPolytope varValues[][] = {{ A,  B,  C,  simplex }};

            {
                System.out.println("Current variables:");
                FORI (iVar, varNames[0].length)
                {
                    System.out.print("    " + varNames[0][iVar] + " = ");
                    System.out.println(varValues[0][iVar].toString("        "));
                }
            }

            while (true)
            {
                System.out.print(prompt);
                String line = reader.readLine();
                if (line == null)
                    break;
                line = line.trim();
                if (line.equals(""))
                    continue;

                //
                // Special variables...
                //
                if (line.startsWith("v=")
                 || line.startsWith("v ="))
                {
                    verboseLevel = Integer.parseInt(line.substring(line.indexOf('=')+1));
                    PRINT(verboseLevel);
                    continue;
                }
                if (line.startsWith("d=")
                 || line.startsWith("d =")
                 || line.startsWith("dim=")
                 || line.startsWith("dim ="))
                {
                    fullDim = Integer.parseInt(line.substring(line.indexOf('=')+1));
                    dim = fullDim;
                    PRINT(dim);
                    System.out.println("WARNING: polytopes of different dimensions will act strangely when mixed");
                    continue;
                }
                if (line.equals("q")
                 || line.equals("quit")
                 || line.equals("exit"))
                {
                    break;
                }
                if (line.equals("help"))
                {
                    {
                        System.out.println("Current variables:");
                        FORI (iVar, varNames[0].length)
                        {
                            System.out.print("    " + varNames[0][iVar] + " = ");
                            System.out.println(varValues[0][iVar].toString("        "));
                        }
                    }
                    continue;
                }

                SPolytope result = null;
                try
                {
                    result = eval(
                                 line,
                                 dim,
                                 fullDim,
                                 varNames,
                                 varValues);
                }
                catch (java.text.ParseException pe)
                {
                    System.err.println("Parse error in expression \""+line+"\": ");
                    System.err.println("    "+pe.getLocalizedMessage()+", position "+pe.getErrorOffset());
                }
                if (result != null)
                {
                    System.out.println(result);
                    PRINTVEC(counts(result.p));
                    PRINT(volume(result));

                    FORI (iFacet, result.p.facets.length)
                    {
                        double areaNormalOfFacet[] = new double[dim];
                        areaNormal(areaNormalOfFacet, result.p.facets[iFacet]);
                        System.out.println("areaNormal(facets["+iFacet+"]) = "+ VecMath.toString(areaNormalOfFacet));
                        System.out.println("volume(facets["+iFacet+"]) = "+ volume(result.p.facets[iFacet]));
                    }

                    if (!isOrientedDeep(result.p))
                        System.out.println("WARNING: that was badly oriented!");
                    if (!isBinaryDensityDeep(result))
                        System.out.println("WARNING: that didn't have binary density!  Or something!");
                }
            }
        }

        System.out.println("out main");
    } // main


    //
    // Not used anywhere, but this is an example
    // of pcalc format...
    // Generated using the commans:
    //    pcalc "{3,3}"
    //    pcalc "{5,3}"
    //    pcalc "{3,3,3}"
    //    pcalc "{5,3,3}"
    private static String pcalcString33 = ""
        +"4 0-cells:\n"
        +" 0:     0.5 0.28867513459481287 0.20412414523193151\n"
        +" 1:     0 0 -0.61237243569579447\n"
        +" 2:     0 -0.57735026918962573 0.20412414523193151\n"
        +" 3:     -0.5 0.28867513459481287 0.20412414523193151\n"
        +"6 1-cells:\n"
        +" 0:    -0 +1\n"
        +" 1:    -2 +1\n"
        +" 2:    -0 +2\n"
        +" 3:    -3 +1\n"
        +" 4:    -3 +2\n"
        +" 5:    -0 +3\n"
        +"4 2-cells:\n"
        +" 0:    +0 -1 -2\n"
        +" 1:    +1 -3 +4\n"
        +" 2:    -0 +5 +3\n"
        +" 3:    +2 -4 -5\n"
        +"1 3-cell:\n"
        +" 0:    +0 +1 +2 +3\n"
        ;

} // CSG
