package com.donhatchsw.util;
#include "macros.h"

/**
* Wrappers for boolean, int, float, double, java.awt.Color
* that notify interested listeners when the value changes.
* This is useful for keeping multiple user
* interfaces that control the same variable
* in sync.
*/
public abstract class Listenable
{
    public interface Listener
    {
        public void valueChanged();
    }

    // XXX need to use weak refs.
    // See Java Tip 79:
    //     http://www.javaworld.com/javaworld/javatips/jw-javatip79.html
    public void addListener(Listener listener)
    {
        synchronized(listeners)
        {
            // XXX should make sure it's not already there? maybe
            java.lang.ref.WeakReference wr = new java.lang.ref.WeakReference(listener);
            listeners.add(wr);
        }
    }
    public void removeListener(Listener listener)
    {
        synchronized(listeners)
        {
            int n = listeners.size();
            for (int i = 0; i < n; ++i)
            {
                java.lang.ref.WeakReference wr = (java.lang.ref.WeakReference)listeners.get(i);
                if (wr.get() == listener)
                {
                    listeners.remove(i);
                    return;
                }
            }
        }
        throw new IllegalArgumentException("Listener.removeListener tried to remove a listener that wasn't attached");
    }
    public abstract void resetToDefault();
    public abstract boolean isDefault();

    private com.donhatchsw.compat.ArrayList listeners =
        new com.donhatchsw.compat.ArrayList();

    protected void notifyListenersThatValueChanged()
    {
        synchronized(listeners) // XXX this should be a read-only synchronization that allows multiple readers to run simultaneously, if I can figure out how to do that
        {
            int n = listeners.size();
            int nLapsedListeners = 0;
            for (int i = 0; i < n; ++i)
            {
                java.lang.ref.WeakReference wr = (java.lang.ref.WeakReference)listeners.get(i);
                Listener listener = (Listener)wr.get();
                if (listener != null)
                    listener.valueChanged();
                else
                    nLapsedListeners++;
            }
            if (nLapsedListeners > 0)
            {
                //System.out.println("CLEARING "+nLapsedListeners+" LAPSED LISTENER"+(nLapsedListeners==1?"":"S")+"!");
                synchronized(listeners) // XXX this is the part that needs a real synchronize
                {
                    int nOut = 0;
                    for (int i = 0; i < n; ++i)
                    {
                        java.lang.ref.WeakReference wr = (java.lang.ref.WeakReference)listeners.get(i);
                        if (wr.get() != null)
                            listeners.set(nOut++, wr);
                    }
                    // listeners.removeRange(nOut, n); // ARGH! removeRange is protected, see http://forum.java.sun.com/thread.jspa?threadID=5121683&messageID=9425625 for a laugh
                    while (n > nOut)
                        listeners.remove(--n);
                }
            }
        }
    }

    public static class Boolean extends Listenable
    {
        private boolean value, defaultValue;
        public Boolean(boolean defaultValue)
        {
            this.defaultValue = defaultValue;
            this.value = this.defaultValue;
        }
        public boolean getDefaultValue() { return defaultValue; }
        public boolean get() { return value; }
        public void set(boolean newValue)
        {
            if (newValue != value)
            {
                value = newValue;
                notifyListenersThatValueChanged();
            }
        }
        public void resetToDefault() { set(getDefaultValue()); }
        public boolean isDefault() { return get() == getDefaultValue(); }
    }

    public static abstract class Number extends Listenable
    {
        public abstract double getDouble();
        public abstract void setDouble(double newValue);
        public abstract double minDouble();
        public abstract double maxDouble();
        public abstract double defaultDouble();
    }

    public static class Int extends Number
    {
        private int value, minValue, maxValue, defaultValue;
        public Int(int minValue, int maxValue, int defaultValue)
        {
            this.minValue = minValue;
            this.maxValue = maxValue;
            this.defaultValue = defaultValue;
            this.value = defaultValue;
        }
        public int min() { return minValue; }
        public int max() { return maxValue; }
        public int getDefaultValue() { return defaultValue; }
        public int get() { return value; }
        public void set(int newValue)
        {
            if (newValue != value)
            {
                value = newValue;
                notifyListenersThatValueChanged();
            }
        }
        public void resetToDefault() { set(getDefaultValue()); }
        public boolean isDefault() { return get() == getDefaultValue(); }

        // Number overrides
        public double getDouble() { return (double)value; }
        public void setDouble(double newValue) { set((int)newValue); }
        public double minDouble() { return (double)minValue; }
        public double maxDouble() { return (double)maxValue; }
        public double defaultDouble() { return (double)defaultValue; }
    }
    public static class Float extends Number
    {
        private float value, minValue, maxValue, defaultValue;
        public Float(float minValue, float maxValue, float defaultValue)
        {
            this.minValue = minValue;
            this.maxValue = maxValue;
            this.defaultValue = defaultValue;
            this.value = this.defaultValue;
        }
        public float min() { return minValue; }
        public float max() { return maxValue; }
        public float getDefaultValue() { return defaultValue; }
        public float get() { return value; }
        public void set(float newValue)
        {
            if (newValue != value)
            {
                value = newValue;
                notifyListenersThatValueChanged();
            }
        }
        public void resetToDefault() { set(getDefaultValue()); }
        public boolean isDefault() { return get() == getDefaultValue(); }

        // Number overrides
        public double getDouble() { return (double)value; }
        public void setDouble(double newValue) { set((float)newValue); }
        public double minDouble() { return (double)minValue; }
        public double maxDouble() { return (double)maxValue; }
        public double defaultDouble() { return (double)defaultValue; }
    }
    public static class Double extends Number
    {
        private double value, minValue, maxValue, defaultValue;
        public Double(double minValue, double maxValue, double defaultValue)
        {
            this.minValue = minValue;
            this.maxValue = maxValue;
            this.defaultValue = defaultValue;
            this.value = this.defaultValue;
        }
        public double min() { return minValue; }
        public double max() { return maxValue; }
        public double getDefaultValue() { return defaultValue; }
        public double get() { return value; }
        public void set(double newValue)
        {
            if (newValue != value)
            {
                value = newValue;
                notifyListenersThatValueChanged();
            }
        }
        public void resetToDefault() { set(getDefaultValue()); }
        public boolean isDefault() { return get() == getDefaultValue(); }

        // Number overrides
        public double getDouble() { return (double)value; }
        public void setDouble(double newValue) { set((double)newValue); }
        public double minDouble() { return (double)minValue; }
        public double maxDouble() { return (double)maxValue; }
        public double defaultDouble() { return (double)defaultValue; }
    }
    public static class Color extends Listenable
    {
        private java.awt.Color value, defaultValue;
        public Color(java.awt.Color defaultValue)
        {
            this.defaultValue = defaultValue;
            this.value = this.defaultValue; // immutable so can share
        }
        public java.awt.Color getDefaultValue() { return defaultValue; }
        public java.awt.Color get() { return value; }
        public void set(java.awt.Color newValue)
        {
            if (!newValue.equals(value))
            {
                value = newValue;
                notifyListenersThatValueChanged();
            }
        }
        public void resetToDefault() { set(getDefaultValue()); }
        public boolean isDefault() { return get().equals(getDefaultValue()); }
    }
    public static class FloatVector extends Listenable
    {
        private float value[], defaultValue[];
        public FloatVector(float defaultValue[])
        {
            this.defaultValue = VecMath.copyvec(defaultValue);
            this.value = VecMath.copyvec(this.defaultValue); // don't share
        }
        public float[] getDefaultValue() { return defaultValue; }
        public float[] get() { return value; }
        public void set(float newValue[])
        {
            if (!VecMath.equalsExactly(newValue, value))
            {
                // assumes all vectors will have the same dimension, and never null
                VecMath.copyvec(value, newValue);
                notifyListenersThatValueChanged();
            }
        }
        public void resetToDefault() { set(getDefaultValue()); }
        public boolean isDefault() { return VecMath.equalsExactly(get(),getDefaultValue()); }
    }
    public static class FloatMatrix extends Listenable
    {
        private float value[][], defaultValue[][];
        public FloatMatrix(float defaultValue[][])
        {
            this.defaultValue = VecMath.copymat(defaultValue);
            this.value = VecMath.copymat(this.defaultValue); // don't share
        }
        public float[][] getDefaultValue() { return defaultValue; }
        public float[][] get() { return value; }
        public void set(float newValue[][])
        {
            if (!VecMath.equalsExactly(newValue, value))
            {
                // assumes all matrices will have the same dimensions, and never null
                VecMath.copymat(value, newValue);
                notifyListenersThatValueChanged();
            }
        }
        public void resetToDefault() { set(getDefaultValue()); }
        public boolean isDefault() { return VecMath.equalsExactly(get(),getDefaultValue()); }
    }


    /**
    * Return an array consisting of all Listenables
    * in all public Listenable and Listenable[] members
    * in the given object.
    */
    public static Listenable[] allListenablesInObject(Object obj)
    {
        com.donhatchsw.compat.ArrayList list = new com.donhatchsw.compat.ArrayList();

        Class objClass = obj.getClass();
        java.lang.reflect.Field[] fields = objClass.getFields();
        for (int iField = 0; iField < fields.length; iField++)
        {
            java.lang.reflect.Field field = fields[iField];
            Class fieldType = field.getType();
            try {
                if (Listenable.class.isAssignableFrom(fieldType)) // if Listenable is a superclass of fieldType
                {
                    //System.out.println("    found Listenable field "+field);
                    list.add(field.get(obj));
                }
                else if (Listenable[].class.isAssignableFrom(fieldType)) // if Listenable[] is a superclass of fieldType
                {
                    //System.out.println("    found Listenable[] field "+field);
                    Listenable array[] = (Listenable[])field.get(obj);
                    for (int i = 0; i < array.length; ++i)
                        list.add(array[i]);
                }
            } catch (IllegalAccessException e) {}
        }
        Listenable array[] = new Listenable[list.size()];
        list.toArray(array);
        return array;
    } // allListenablesInObject

} // class Listenable
