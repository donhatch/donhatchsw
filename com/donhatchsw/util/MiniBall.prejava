package com.donhatchsw.util;

#include "macros.h"

/*
TODO: retain record of which support points were used to compute the ball
TODO: do it using indices
TODO: uncomment identical-points examples and fix it

*/

/**
* Smallest enclosing ball.
* Roughly follows Emo Welz's move-to-front method
* described in Bernd Gartner's paper "Fast and Robust Smallest Enclosing Balls".
* Not really optimized or robustified.
*/

public class MiniBall
{
    private MiniBall() {} // uninstantiatable

    public static int verboseLevel = 0; // 2 gives nice recursion picture
    private static boolean checkEveryMiniBall = false; // only set this to true if you know the points are in general position


    private static double debugPoints[][];
    private static int getDebugInd(double point[])
    {
        FORI (iDebugPoint, debugPoints.length)
            if (point == debugPoints[iDebugPoint])
                return iDebugPoint;
        assert(false);
        return -1;
    }
    private static int[] getDebugInds(double points[][])
    {
        int inds[] = new int[points.length];
        FORI (iPoint, points.length)
            inds[iPoint] = getDebugInd(points[iPoint]);
        return inds;
    }
    private static String toDebugIndsString(int nPoints, double points[][])
    {
        return Arrays.toStringCompact(getDebugInds((double[][])Arrays.subarray(points,0,nPoints)));
    }



    /**
    * verify that the given ball is in fact the smallest enclosing ball
    * of the points.
    */
    public static boolean IsMiniBall(double center[], double radiusSquared,
                                     int nPoints,
                                     double points[][])
    {
        if (verboseLevel >= 1)
        {
            System.out.println("in IsMiniBall(nPoints="+nPoints+")");
            if (verboseLevel >= 2)
            {
                PRINTARRAY(points);
                PRINTARRAY(center);
                PRINT(radiusSquared);
                double radius = Math.sqrt(radiusSquared);
                PRINT(radius);
            }
        }

        if (radiusSquared < 0.
         || nPoints == 0)
        {
            if (verboseLevel >= 1)
                System.out.println("out IsMiniBall(nPoints="+nPoints+"), returning "+(radiusSquared < 0. && nPoints == 0)+" trivially because no points or empty ball");
            return radiusSquared < 0. && nPoints == 0;
        }


        int dim = center.length;
        double radius = Math.sqrt(radiusSquared);
        int nIn = 0;
        int nOn = 0;
        int nOut = 0;
        double on[][] = new double[nPoints][];
        FORI (iPoint, nPoints)
        {
            double dist = VecMath.dist(points[iPoint], center);
            //PRINT(dist);
            if (GT(dist, radius, radius*1e-12))
                nOut++;
            else if (LT(dist, radius, radius*1e-12))
                nIn++;
            else
                on[nOn++] = points[iPoint];
        }
        if (verboseLevel >= 1)
        {
            System.out.print("    "+nOn+" on: "+Arrays.toStringCompact(getDebugInds((double[][])Arrays.subarray(on,0,nOn))));
            System.out.print(", ");
            System.out.print(nIn+" in");
            System.out.print(", ");
            System.out.print(nOut+" out");
            System.out.println();
        }
        if (nOut != 0)
            return false;
        if (dim == 0)
        {
            assert(nOn == nPoints);
            if (verboseLevel >= 1)
                System.out.println("out IsMiniBall(nPoints="+nPoints+"), returning true trivially because dim==0");
            // XXX wait a minute, should make sure radiusSquared is 0!
            return true;
        }
        else
        {
            assert(nOn > 0);

            if (nOn > dim+1)
            {
                // reduce nOn to a set of dim+1 support points
                // (or fewer, if dimension spanned by the support points is less than that)
                double supportPoints[][] = new double[dim+1][];
                double M[][] = new double[dim+1][dim];
                // maybe a bit silly to go through the loop for the first support point when we know it's going to be on[0], but it doesn't hurt and exercises some functions which need to be exercised
                int i;
                FOR (i, dim+1)
                {
                    int bestJ = -1;
                    double bestContent = -1.;
                    FORI (j, nOn)
                    {
                        supportPoints[i] = on[j];
                        double thisContent = VecMath.relativeOrthotopeContent(i+1, dim, supportPoints, false);
                        thisContent = ABS(thisContent);
                        //PRINT(thisContent);
                        if (thisContent > bestContent)
                        {
                            bestJ = j;
                            bestContent = thisContent;
                        }
                    }
                    if (bestContent <= 1e-12*radius)
                        break;

                    assert(bestJ != -1);
                    supportPoints[i] = on[bestJ];
                    //PRINT(i);
                    PRINT(bestContent);
                    // TODO: if zero, need to truncate to what we've seen so far...
                }
                // i is now the number of independent points we've seen, at most dim+1
                assert(i > 0);
                nOn = i;
                on = supportPoints;
            }

            assert(nOn <= dim+1);

            // make sure center is in the interior or boundary
            // of the simplex formed by the "on" points,
            // i.e. that its barycentrics are all non-negative.
            // we don't have a general method of computing
            // barycentrics (we can only compute their absolute values),
            // so what we do is, we compute their absolute values
            // and verify that they add up to 1
            // (if any actual barycentrics are negative, they won't).
            double M[][] = VecMath.copymat(nOn, dim, on);
            double m[][] = new double[nOn-1][dim]; // scratch
            FORI (iRow, nOn-1)
                VecMath.vmv(m[iRow], M[iRow], M[nOn-1]);
            double fulldet = VecMath.relativeOrthotopeContent(nOn, dim, M, true); // fine to destroy contents of M
            fulldet = ABS(fulldet);
            double absBarys[] = new double[nOn];
            FORI (iOn, nOn)
            {
                VecMath.copymat(nOn, dim, M, on);
                VecMath.copyvec(M[iOn], center); // substitute center for iOn'th vertex
                double det = VecMath.relativeOrthotopeContent(nOn, dim, M, true); // fine to destroy contents of M
                det = ABS(det);

                //PRINT(det);
                //PRINT(det/fulldet);
                absBarys[iOn] = det/fulldet;
            }
            //PRINTVEC(absBarys);
            PRINT(VecMath.sum(absBarys));
            if (!EQ(VecMath.sum(absBarys), 1., 1e-6))
            {
                PRINTARRAY(absBarys);
                if (verboseLevel >= 1)
                    System.out.println("out IsMiniBall(nPoints="+nPoints+"), returning false");
                return false;
            }
            if (verboseLevel >= 1)
                System.out.println("out IsMiniBall(nPoints="+nPoints+"), returning true");
            return true;
        }
    } // IsMiniBall

    /**
    * returns the center and radius-squared of the smallest ball
    * enclosing the given points.
    */
    public static double MiniBall(double resultCenter[],
                                  double points[][])
    {
        int dim = resultCenter.length;
        if (verboseLevel >= 1)
        {
            System.out.println("                in MiniBall("+dim+" dims, "+points.length+" points)");
            System.out.println("                    points = "+Arrays.toStringCompact(points));
        }

        debugPoints = points;
        double radiusSquared = MiniBallHelper(resultCenter,
                                              points,
                                              points.length, VecMath.identityperm(points.length), // it gets reordered, that's okay
                                              0, new int[MIN(points.length, dim+1)],
                                              0);
        if (checkEveryMiniBall)
        {
            assert(IsMiniBall(resultCenter, radiusSquared, points.length, points));
        }
        if (verboseLevel >= 1)
            System.out.println("                out MiniBall("+dim+" dims, "+points.length+" points)");
        return radiusSquared;
    } // MiniBall


    private static double MiniBallHelper(double resultCenter[],
                                         double points[][],
                                         int nL, int L[], // not-necessarily-boundary point indices
                                         int nB, int B[], // boundary point indices
                                         int recursionLevel)
    {
        if (verboseLevel >= 2)
        {
            FORI (iIndent, recursionLevel) System.out.print("    ");
            System.out.println("                    in MiniBallHelper(nL="+nL+", nB="+nB+")");

            FORI (iIndent, recursionLevel) System.out.print("    ");
            System.out.println("                        L = "+Arrays.toStringCompact(Arrays.subarray(L,0,nL)));

            FORI (iIndent, recursionLevel) System.out.print("    ");
            System.out.println("                        B = "+Arrays.toStringCompact(Arrays.subarray(B,0,nB)));

            FORI (iIndent, recursionLevel) System.out.print("    ");
            System.out.println("                      O computing circumball of B="+Arrays.toStringCompact(Arrays.subarray(B,0,nB)));
        }


        int dim = resultCenter.length;
        double radiusSquared = CircumBall(resultCenter, points, nB, B);
        if (nB == dim+1)
        {
            if (verboseLevel >= 2)
            {
                FORI (iIndent, recursionLevel) System.out.print("    ");
                System.out.println("                  +---+");
                FORI (iIndent, recursionLevel) System.out.print("    ");
                System.out.println("                  | out MiniBallHelper(nL="+nL+", nB="+nB+")");
            }
            return radiusSquared;
        }
        FORI (i, nL)
        {
            int Li = L[i];
            if (verboseLevel >= 3)
            {
                PRINTVEC(resultCenter);
                PRINT(radiusSquared);
                PRINT(VecMath.distsqrd(points[Li], resultCenter))
                PRINT(Math.sqrt(radiusSquared));
            }
            if (radiusSquared < 0
             || VecMath.distsqrd(points[Li], resultCenter) > radiusSquared)
            {
                if (verboseLevel >= 2)
                {
                    FORI (iIndent, recursionLevel) System.out.print("    ");
                    System.out.println("                      X ("+Li+" is outside ball, recursing and replacing ball)");
                }
                B[nB] = Li;
                radiusSquared = MiniBallHelper(resultCenter,
                                               points,
                                               i, L,
                                               nB+1, B, // B with Li appended
                                               recursionLevel+1);

                // move L[i] to front
                FORIDOWN(j, i)
                    L[j+1] = L[j];
                L[0] = Li;


                /*
                how to implement linked list with a nexts array?

                int nexts[nPoints];
                FORI (iPoint, nPoints-1)
                    nexts[i] = i+1;
                if (nPoints == 0)
                {
                    first = -1;
                }
                else
                {
                    first = 0;
                    nexts[nPoints-1] = -1;
                }

                int iLprev = -1;
                int iL = firstInOrder;
                for (int iiL = 0; iiL < nL; ++iiL)
                {
                    if we want to move iL to front:
                    {
                        if (firstInOrder == iL)
                        {
                            // it's already in front
                            assert(iLprev == -1);
                        }
                        else
                        {
                            assert(nextInOrder[iLprev] == iL);
                            nextInOrder[iLprev] = nextInOrder[iL];
                            nextInOrder[iL] = firstInOrder;
                            firstInOrder = iL;
                            iL = ilPrev; // so that nextInOrder[iL] will be what used to be nextInOrder[iL], so the increment below will come out right (iL will get what used to be nextInOrder[iL], and ilPrev will stay the same)
                        }
                    }
                    ilPrev = iL;
                    iL = nextInOrder[iL];
                }
                */
            }
            else
            {
                if (verboseLevel >= 2)
                {
                    FORI (iIndent, recursionLevel) System.out.print("    ");
                    System.out.println("                      | ("+Li+" is in interior of ball, ignoring new point)");
                }
            }
        }
        if (verboseLevel >= 2)
        {
            FORI (iIndent, recursionLevel) System.out.print("    ");
            System.out.println("                  +---+");
            FORI (iIndent, recursionLevel) System.out.print("    ");
            System.out.println("                  | out MiniBallHelper(nL="+nL+", nB="+nB+")");
        }
        return radiusSquared;
    } // MiniBallHelper

    // (v1-v0) dot (v2-v0)
    private static double relativeDot(double v0[],
                                      double v1[],
                                      double v2[])
    {
        double answer = 0;
        FORI (i, v0.length)
            answer += (v1[i]-v0[i])*(v2[i]-v0[i]);
        return answer;
    }

    // circum-ball of up to dim+1 points,
    // assuming answer is inside the simplex.
    private static double CircumBall(double resultCenter[],
                                     double points[][],
                                     int nInds,
                                     int inds[])
    {
        if (verboseLevel >= 3) System.out.println("    in CircumBall ("+nInds+" points)");
        int dim = resultCenter.length;
        assert(nInds <= dim+1);
        if (nInds == 0)
        {
            VecMath.zerovec(resultCenter);
            if (verboseLevel >= 3) System.out.println("    out CircumBall (empty)");
            return Double.NEGATIVE_INFINITY;
        }
        else if (nInds == 1)
        {
            if (verboseLevel >= 3) System.out.println("    out CircumBall (1 point)");
            // can't use general method even if we want to, since the code gets confused about dimensions since Q would have no rows and so vxinvm can't deduce dimension and so would produce a twice_lambdas with length 0 instead of dim
            VecMath.copyvec(resultCenter, points[inds[0]]);
            if (verboseLevel >= 3) System.out.println("    out CircumBall (trivial nPoints=1)");
            return 0.;
        }
#if 0 // 0 to test general method
        else if (nInds == 2)
        {
            if (verboseLevel >= 3) System.out.println("    out CircumBall (2 points)");
            VecMath.lerp(resultCenter, points[inds[0]], points[inds[1]], .5);
            if (verboseLevel >= 3) System.out.println("    out CircumBall (trivial nPoints=2)");
            return VecMath.distsqrd(resultCenter, points[inds[0]]);
        }
        else if (nInds == 3) // XXX think about whether this is more robust than the general method?
        {

            // http://en.wikipedia.org/wiki/Circumscribed_circle#Barycentric_coordinates_from_cross-_and_dot-products
            double l12 = VecMath.distsqrd(points[inds[1]],points[inds[2]]);
            double l20 = VecMath.distsqrd(points[inds[2]],points[inds[0]]);
            double l01 = VecMath.distsqrd(points[inds[0]],points[inds[1]]);
            double c0 = l12 * relativeDot(points[inds[0]], points[inds[1]], points[inds[2]]);
            double c1 = l20 * relativeDot(points[inds[1]], points[inds[2]], points[inds[0]]);
            double c2 = l01 * relativeDot(points[inds[2]], points[inds[0]], points[inds[1]]);
            double sum = c0 + c1 + c2;
            VecMath.bary(resultCenter,
                         points[inds[0]],
                         points[inds[1]], c1/sum,
                         points[inds[2]], c2/sum);
            if (verboseLevel >= 3) System.out.println("    out CircumBall (3 points)");
            return VecMath.distsqrd(resultCenter, points[inds[0]]);
        }
#endif
        else if (true)
        {
            // Try the method in Bernd Gartner's paper "Fast and Robust Smallest Enclosing Balls"
            double Q[][] = new double[nInds-1][dim];
            FORI (i, Q.length)
                VecMath.vmv(Q[i], points[inds[i+1]], points[inds[0]]);
            //PRINTMAT(Q);
            double half_A_B[][] = VecMath.mxtransposem(Q,Q); // don't bother multiplying by 2
            //PRINTMAT(half_A_B);
            double Qlength2s[] = new double[Q.length];
            FORI (i, Qlength2s.length)
                Qlength2s[i] = VecMath.normsqrd(Q[i]);
            double[] twice_lambdas = VecMath.invmxv(half_A_B, Qlength2s); // matrix is symmetric, so doesn't matter whether we use vxinvm or invmxv... invmxv is more direct, I believe
            // XXX should there be a adjmxv and vxadjm?? that would be kinda cool I think maybe...

            boolean assertBarysNonNegative = false;
            if (assertBarysNonNegative)
            {
                double lambdas[] = VecMath.vxs(twice_lambdas, .5);
                double barys[] = new double[nInds];
                barys[0] = 1.-VecMath.sum(lambdas);
                FORI (i, twice_lambdas.length)
                    barys[i+1] = lambdas[i];

                if (LT(VecMath.min(barys), 0., 1e-12))
                {
                    /*
                       blech! I think this is problematic...
                       if we do this, we may end up with a smaller ball,
                       and then end up asking to do something impossible,
                       like L=0,2 B=1,3 with:
                               1
                          2         0
                               3
                       doesn't it suffice to simply say, if the matrix is degerate enough,
                       then it must contain *all* the other points? hmm no,
                       this could never happen, I don't think... there must be some point outside ball(0,2; 1)
                       that created this situation in the first place, such that
                       1 is outside the ball...
                       There must be a more robust way of asking this question,
                       without actually computing/using an untrustworthy ball!
                       I think, store the ball symbolically somehow,
                       in such a way that is-another-point-inside-it queries
                       can be done robustly.
                       OH! don't store the center, store a point and normal, or something? hmm!
                       Yes! suffices to store one of the points, and an inward normal towards the center...
                       and the *inverse* of the squared radius!

                       so let's see, how does that relate to the current problem...
                       instead of computing C, we'll compute C' = C / radius^2,
                       so the bigger radius is, the smaller C' will be.
                       actually that doesn't quite suffice, since if radius is literally infinite,
                       we still want a direction vector... namely the unit vector C/radius, I think.
                       so the representation of a ball is:
                           P0
                           inward unit normal N
                           invRadius (or invRadius^2?)
                       then the center is (possibly unstable or infinite, so we never compute it explicitly):
                           C = P0 + N/invRadius
                       and another point P1 is inside the circle iff:
                           ||P1-C|| < 1/invRadius
                           ||P1-P0-N/invRadius|| < 1/invRadius
                       i.e. ||P-N/invRadius|| < 1/invRadius  where P = P1-P0
                       assuming invRadius >=0 (I'll think about the other case later,
                       I bet it will just fall out naturally),
                       this is the same as  saying:
                           ||P*invRadius-N|| < 1
                       which is the same as:
                           ||P*invRadius-N||^2 < 1
                           (P*invRadius-N) dot (P*invRadius-N) < 1
                           ||P||^2*invRadius^2 + ||N||^2 - 2*invRadius*(P dot N) < 1
                           ||P||^2*invRadius^2 + 1 - 2*invRadius*(P dot N) < 1        since ||N|| == 1
                           ||P||^2*invRadius^2 - 2*invRadius*(P dot N) < 0
                           ||P||^2*invRadius^2 < 2*invRadius*(P dot N)
                           ||P||^2*invRadius < 2*(P dot N)
                       or, if we never want to take a square root,
                           ||P||^4*invRadius^2 < 4*(P dot N)^2
                       [
                           possible alternative to avoid the square root... N could have length 1+invRadius or something?
                           or...
                                r=0 -> ||N||=0  (so direction undefined)
                                r=infinitity -> ||N||=1    hmm?
                                ||N|| = 1 - 1/(r+1)  ?
                           or maybe
                                ||N|| = 1 - 1/(r^2+1)  ?
                           or
                                ||N||^2 = 1 - 1/(r^2+1)  ?
                       ]
                       Anyway...
                           if C is lambdas*Q
                           then invRadius will be 1/||
                       argh, this might not work out nicely,
                       since there are cases where the volume of the simplex
                       is tiny and yet the center is finite.

                       perhaps the whole thing needs another constant,
                       namely the simplex volume...
                       solve the equation using the adjoint instead of the inverse,
                       knowing that the real answer is that divided by the determinant.

                           inv(M) = adj(M)/det(M)
                           adj(M) = inv(M)*det(M)

                       AH! maybe that's it.
                       Solve for C' = C * determinant
                                 radius = ||C'/det||
                                 invRadius = det/||C'||
                       Then P is inside the circle iff:
                           ||P-C|| < radius
                           ||P-C'/det|| < ||C'/det||
                           ||P*det-C'|| < ||C'||
                       is that it? the final straw?
                       not quite, I think this all falls apart if det is close to 0 even when radius isn't huge. hmm.


                       Articulating my concerns:
                           (1) even if all points in completely general position
                               with no degeneracies or near-degeneracies,
                               we are sometimes asked to compute intermediate disks
                               that can't possibly be the final disk,
                               since one or more of their barycentrics are significantly negative.
                               That seems worrisome.
                               (example)
                                            0 .7




                                     -.2 0        .2 0
                                            0 -.1
                           (2) In the case of 4 points cocircular (with roundoff error),
                               an intermediate disk with significantly negative coeffs
                               (as described in the previous)
                               might actually be returned as the final disk.
                               If the checking afterwards remembers the points
                               it was computed from and considers them to be the support points,
                               it will wrongly say the disk is invalid.
                               (example)
                                             0  1

                                      -.8 -.6     .8 -.6
                                             0 -1

                           (3) The computation of the center of a given circle isn't as accurate
                               when the coeffs are significantly negative...
                               getting worse and worse if two or three of them are very close together.
                               the two-close-together issue is unavoidable (maybe-- but it's a separate
                               issue) if the two-close-together really are necessary supports
                               of the final hull, but it seems strange to suffer from it
                               when that's not the case.
                               In other words, it seems like bad practice to *ever* compute
                               a circle from support points for which some barys of the
                               center are negative.
                               Can't we do it while only computing balls which are actual
                               smallest enclosing balls of the support points they are being computed from?
                               (example)


                    */
                      
                    PRINTVEC(barys);
                    System.out.println("=================================");
                    System.out.println("throwing out the worst one and starting over!");
                    int worstIndex = VecMath.mini(barys);
                    int savedWorst = inds[worstIndex];
                    inds[worstIndex] = nInds-1;
                    double resultRadiusSquared = CircumBall(resultCenter, points, nInds-1, inds);
                    inds[worstIndex] = savedWorst;
                    System.out.println("done throwing out the worst one and starting over!");
                    System.out.println("=================================");
                    if (verboseLevel >= 3) System.out.println("    out CircumBall (tricky)");
                    return resultRadiusSquared;
                }
            }


            double twice_relativeCenter[] = resultCenter; // use resultCenter for scratch
            VecMath.vxm(twice_relativeCenter, twice_lambdas, Q);
            double resultRadiusSquared = .25 * VecMath.normsqrd(twice_relativeCenter); // compute it before we clobber the array
            VecMath.vpsxv(resultCenter, points[inds[0]], .5, twice_relativeCenter);
            if (verboseLevel >= 3) System.out.println("    out CircumBall (general)");
            return resultRadiusSquared;

            // well that was easy.
            // Note that it's not robust though, in the case that two or more points are very close together
        }
        else // we don't have a case for this number of points.
        {
            assert(false);
            return 0.;
        }
    } // CircumBall


    /** Little test program. */
    public static void main(String args[])
    {
        System.out.println("in MiniBall.main()");

        if (args.length != 1)
        {
            System.err.println("Usage: MiniBall <verboseLevel>     # 1 shows progress, 2 gives nice pictures but takes forever");
            System.exit(1);
        }
        verboseLevel = Integer.parseInt(args[0]);

        checkEveryMiniBall = true;


        if (false)
        {
            double points[][];
            String cacheFileName = "6144cache"; // created manually
            if (!new java.io.File(cacheFileName).exists())
            {
                System.out.println("WARNING: cache file "+cacheFileName+" doesn't exist, computing the 6144 points");
                // as suggested in the paper...
                // find the set of 6144 integer points on the circle
                // around the origin with squared radius r^2 = 3728702916375125.
                long l2 = 3728702916375125L;
                int nExpected = 6144;
                int nFound = 0;
                points = new double[nExpected][];
                for (long a = 0; a*a + a*a <= l2; ++a)
                {
                    long b = Math.round(Math.sqrt(l2 - a*a));
                    if (a*a + b*b == l2)
                    {
                        assert(0 < a);
                        assert(a < b);
                        System.out.println("    "+a+" "+b+"");
                        points[nFound++] = new double[] {a,b};
                        points[nFound++] = new double[] {a,-b};
                        points[nFound++] = new double[] {-a,b};
                        points[nFound++] = new double[] {-a,-b};
                        points[nFound++] = new double[] {b,a};
                        points[nFound++] = new double[] {b,-a};
                        points[nFound++] = new double[] {-b,a};
                        points[nFound++] = new double[] {-b,-a};
                    }
                }
                PRINT(nFound);
                assert(nFound == nExpected);
                assert(nFound == points.length);


                int intPoints[][] = new int[points.length][points[0].length];
                {
                    FORI (iPoint, points.length)
                    {
                        int x = (int)points[iPoint][0];
                        int y = (int)points[iPoint][1];
                        assert((double)x == points[iPoint][0]);
                        assert((double)y == points[iPoint][1]);
                        intPoints[iPoint][0] = x;
                        intPoints[iPoint][1] = y;
                    }
                }
                PRINTARRAY(intPoints);
                return;
            }
            else // read it from cache
            {
                String fileContents = null;
                PRINT(__LINE__);
                try {
                    java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader(cacheFileName));
                    StringBuffer sb = new StringBuffer();
                    char buf[] = new char[1024];
                    int numRead = 0;
                    while ((numRead = reader.read(buf)) > -1)
                        sb.append(String.valueOf(buf, 0, numRead));
                    reader.close();
                    fileContents = sb.toString();
                }
                catch (java.io.IOException e)
                {
                    System.err.println("Fooey, something went wrong reading file \""+cacheFileName+"\": "+e);
                    assert(false);
                }
                PRINT(__LINE__);
                if (false)
                {
                    try {
                        points = (double[][])Arrays.fromString(fileContents);
                    }
                    catch (java.text.ParseException e)
                    {
                        System.err.println("Fooey, something went wrong parsing file \""+cacheFileName+"\": "+e);
                        assert(false);
                    }
                }
                else
                {
                    // holy moly, I didn't realize Arrays.fromString was so slow!
                    // just read numbers, delimited by: "{},"
                    String tokens[] = com.donhatchsw.compat.regex.split(fileContents, "[{}, \t\r\n]+");
                    // XXX huh? how come there's an empty string at the beginning but not at the end??
                    PRINTARRAY(tokens[0]);
                    PRINTARRAY(tokens[tokens.length-1]);
                    assert(tokens.length % 2 == 1);
                    assert(tokens[0].equals(""));
                    assert(tokens[tokens.length-1] != "");
                    int nPoints = (tokens.length-1)/2;
                    points = new double[nPoints][2];
                    FORI (iPoint, nPoints)
                    {
                        points[iPoint][0] = Integer.parseInt(tokens[1+iPoint*2+0]);
                        points[iPoint][1] = Integer.parseInt(tokens[1+iPoint*2+1]);
                    }
                }
                PRINT(__LINE__);
            }

            if (true)
                points = (double[][])Arrays.subarray(points, 0, 10);

            if (true)
            {
                long seed = 0L;
                java.util.Random generator = new java.util.Random(seed);
                points = (double[][])Arrays.getMany(points, VecMath.randomperm(points.length, generator));
            }

            if (true)
            {
                // embed in higher-dimensional space
                int dim = 3;
                double Points[][] = new double[points.length][dim]; // zeros
                VecMath.copymat(Points, points);
                points = Points;
            }
            if (true)
            {
                // randomly rotate
                int dim = points[0].length;
                double M[][] = new double[dim][dim];
                FORI (i, M.length)
                    VecMath.random(M[i]);
                VecMath.extendAndOrthogonalize(dim, dim, M, M);
                points = VecMath.mxm(points, M);
            }

            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
            PRINT(VecMath.dist(points[0],points[1]));
            PRINT(VecMath.dist(points[1],points[2]));
            PRINT(VecMath.dist(points[2],points[0]));

            return;
        }

        if (false)
        {
            double examples[][][] = {
                {
                    // no points
                },
                {
                    // one point in zero dimensions
                    {},
                },
                {
                    // one point in one dimension
                    {-.1},
                },
                {
                    // one point in two dimensions
                    {-.1, -.2},
                },
                {
                    // two (identical) points in zero dims
                    {}, {},
                },
#ifdef NOTYET
                {
                    // 2 identical points in 1d
                    {-.1}, {-.1},
                },
#endif
                {
                    // 2 diff points in 1d
                    {-.1}, {-.2},
                },
#ifdef NOTYET
                {
                    // 2 identical points in 2d
                    {-.1,-.2}, {-.1,-.2},
                },
#endif
                {
                    // 2 diff points in 2d
                    {-.1,-.2}, {-.3,-.4},
                },
            };
            FORI (iExample, examples.length)
            {
                double points[][] = examples[iExample];
                PRINTARRAY(points);
                double center[] = new double[points.length == 0 ? 0 : points[0].length];
                double radiusSquared = MiniBall(center, points); // with internal assertion check
                double radius = Math.sqrt(radiusSquared);
                PRINTARRAY(center);
                PRINT(radiusSquared);
                PRINT(radius);
                FORI (iPoint, points.length)
                    PRINT(VecMath.dist(center, points[iPoint]));
            }
            return;
        }
        if (true)
        {
            // possibly problematic case?
            // can tweak this smaller and smaller... however IsMiniBall will fail since it has a pretty coarse tolerance.
            double points[][] = {
                {0,0},
                {1, 0},
                {1-1e-10/2, 1e-5},
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
            PRINT(VecMath.dist(points[0],points[1]));
            PRINT(VecMath.dist(points[1],points[2]));
            PRINT(VecMath.dist(points[2],points[0]));
        }
        if (true)
        {
            // possibly problematic case?
            // can tweak this smaller and smaller... however IsMiniBall will fail since it has a pretty coarse tolerance.
            double points[][] = {
                {1, 1e-7},
                {1, -1e-7},
                {0,0},
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
        }
        if (true)
        {
            // Example where assertions fail, if I assert all barycentrics are >= 0...
            // the last point p3 *is* a support point of the whole thing,
            // but it's not a support point of p0,p2,p3.
            // Hmm, need to read the paper again.
            double points[][] = {
                {-2,0}, // p0
                {0,-7}, // p1
                {2,0}, // p2
                {0,1}, // p3
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
        }
        if (true)
        {
            double points[][] = {
                {-0.11292382674794688,-0.5490194743891945,-0.7006793007314693,0.41519901300639384},
                {0.21265634387622745,-0.5070372969733454,-0.6619991057234174,0.08164861982970861},
                {0.49196102625524807,0.32753899159963584,0.45741214968436394,0.05055895411919131},
                {-0.7144045965733132,0.25535861602413124,0.4434164700345846,0.19871485790432208},
                {0.1357892945837358,0.9354574730083602,0.0871307080148207,0.24758074701688848},
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
        }
        if (true)
        {
            double points[][] = {
                {-0.4,-0.1},
                {-0.4,0.8},
                {0.6,0.6},
                {0.5,-0.1},
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
        }
        if (true)
        {
            // This one is actually fine...
            // it computes the real circumball,
            // however it's not the miniball
            double points[][] = {
                {-0.4,0.0,0.45},
                {-0.3,-0.8,-0.2},
                {0.2,0.2,0.7},
                {0.8,-0.4,0.3},
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = CircumBall(center, points, points.length, VecMath.identityperm(points.length));
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]) - radius);
            //return;
        }
        if (true)
        {
            double points[][] = {
                {0.8,-0.4,0.3},
                {0.2,0.2,0.7},
                {-0.3,-0.76,-0.2},
                {0.7,0.0,-0.7},
                {-0.42,0.0,0.45},
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
            //return;
        }
        if (true)
        {
            double points[][] = {
                {0.783054129878817,-0.39704014132044185,0.2610348388547796},
                //{-0.441428549933816,-0.20525760195521747,0.26368862850827557},
                {0.21551983726110668,0.24075572618081575,0.6831683632188075},
                {-0.29571147545557785,-0.7617919556006791,-0.14356164667067084},
                //{0.5646952259894502,-0.42967154646767525,0.08677141695053248},
                {0.7043065708560627,0.041341213403628396,-0.6451742599610941},
                {-0.42182573721816885,0.025564719827857685,0.46485070752947677},
                //{0.3128129116796552,0.3020331420759117,-0.5888859431223612},
            };
            PRINTARRAY(points);
            double center[] = new double[points[0].length];
            double radiusSquared = MiniBall(center, points); // with internal assertion check
            double radius = Math.sqrt(radiusSquared);
            PRINTARRAY(center);
            PRINT(radiusSquared);
            PRINT(radius);
            FORI (iPoint, points.length)
                PRINT(VecMath.dist(center, points[iPoint]));
            //return;
        }

        long seed = 0L;
        java.util.Random generator = new java.util.Random(seed);

        int minDim = 0;
        int maxDim = 6;
        int minPoints = 1;
        int maxPoints = 10;
        int nTests = 100;


        if (false)
        {
            System.out.println("WARNING WARNING WARNING");
            minDim = 3;
            minPoints = 4;
        }
        if (false)
        {
            System.out.println("WARNING WARNING WARNING");
            minDim = 1;
            minPoints = 2;
        }
        if (false)
        {
            System.out.println("WARNING WARNING WARNING");
            minDim = 2;
            minPoints = 4;
        }
        if (false)
        {
            System.out.println("WARNING WARNING WARNING");
            minDim = 6;
            minPoints = 100;
            maxPoints = 100;
        }

        for (int dim = minDim; dim <= maxDim; dim++)
        {
            System.out.println("    dim = "+dim);
            for (int nPoints = minPoints; nPoints <= maxPoints; nPoints++)
            {
                //System.out.println("        nPoints = "+nPoints);
                System.out.println("        dim = "+dim+" nPoints = "+nPoints);
                double points[][] = new double[nPoints][dim];
                FORI (iTest, nTests)
                {
                    System.out.println("            iTest = "+iTest+"/"+nTests+"  (dim = "+dim+" nPoints = "+nPoints+")");

                    FORI (iPoint, nPoints)
                        VecMath.random(points[iPoint], generator);

                    double expectedRadiusSquared = Double.NaN; // shut up compiler
                    double expectedResultCenter[] = new double[dim];
                    double resultCenter[] = new double[dim]; // scratch for loop
                    int nPerms = 10;
                    FORI (iPerm, nPerms)
                    {
                        System.out.println("                iPerm = "+iPerm+"/"+nPerms);
                        int perm[] = VecMath.randomperm(nPoints, generator);
                        points = (double[][])Arrays.getMany(points, perm);

                        if (verboseLevel >= 1)
                        {
                            PRINTARRAY(nPoints);
                            PRINTARRAY(points);
                        }
                        double resultRadiusSquared = MiniBall(resultCenter, points);
                        double resultRadius = Math.sqrt(resultRadiusSquared);
                        if (verboseLevel >= 1)
                        {
                            PRINTARRAY(resultCenter);
                            PRINT(resultRadius);
                        }
                        if (iPerm == 0)
                        {
                            // subsequent permutations should get the same answer
                            VecMath.copyvec(expectedResultCenter, resultCenter);
                            expectedRadiusSquared = resultRadiusSquared;
                        }
                        else
                        {
                            assert(VecMath.equals(resultCenter, expectedResultCenter, 1e-6));
                            assert(EQ(Math.sqrt(resultRadiusSquared),
                                      Math.sqrt(expectedRadiusSquared), 1e-6));
                        }
                        assert(IsMiniBall(resultCenter, resultRadiusSquared, points.length, points));

                        if (false)
                        {
                            // just return after first
                            return;
                        }
                    }
                }
            }
        } // for each dim

        System.out.println("out MiniBall.main()");
    } // main
} // class MiniBall
