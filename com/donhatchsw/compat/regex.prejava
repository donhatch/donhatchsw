/* vim: set filetype=java: */

package com.donhatchsw.compat;

import com.donhatchsw.util.Arrays; // XXX get rid of this dependency... it's for toStringCompact and append

#include "macros.h" // XXX should try to get rid of this

/**
*  Stopgap implementation of some regex utilities
*  that don't exist in java pre-1.4.
*  Not everything is implemented but it's getting me by.
*  My god what a lot of CRAP in this interface.
*  XXX TODO: my split uses greedy matching, not longest matching like it should... need to think about how to do it right without being horribly inefficient if possible
*/
public class regex
{
    private regex() {} // uninstantiatable

    /** If set (which it is by default) and the standard java.util.regex library exists (i.e. if you're running a 1.4 or later vm) then the result of every operation will be checked against the result from the standard library, and an Error will be thrown if the results differ.*/
    public static boolean checkAgainstStandardVersion = true; // if available
    /** If set and the standard java.util.regex library exists (i.e. if you're running a 1.4 or later vm) then the standard library will be used instead of this one. */
    public static boolean useStandardVersion = false; // if available
    /**
    * <pre>
    *    0: nothing
    *    1: basic
    *    2: more detail, print out the FSM and execution trace and everything
    * </pre>
    */
    public static int verboseLevel = 0;

    /**
    * An IllegalArgumentException
    * whose message does the cool point-to-the-error-in-the-regex thing.
    * XXX probably it doesn't work right if the regex has newlines and stuff in it
    */
    public static class PatternSyntaxException extends IllegalArgumentException
    {
        public PatternSyntaxException(String description,
                                      String patString,
                                      int index)
        {
            super(description+" near index "+index
                             +System.getProperty("line.separator")
                             +patString
                             +System.getProperty("line.separator")
                             +spaces(index)
                             +"^");
        }

        // Could just do Format.sprintf("%*s", n, "") but
        // Format depends on regex so that would form
        // a cyclic compilation dependency, which I try to avoid
        private static String spaces(int n)
        {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < n; ++i)
                sb.append(' ');
            return sb.toString();
        }
    } // PatternSyntaxException

    public static boolean matches(String input, String patString)
    {
        //return input.matches(patString); // only exists in >=1.4
        return Pattern.compile(patString).matcher(input).matches();
    }
    public static String[] split(String input, String patString, int limit)
    {
        //return input.split(patString, limit); // only exists in >=1.4
        return Pattern.compile(patString).split(input, limit);
    }
    public static String[] split(String input, String patString)
    {
        //return input.split(patString); // only exists in >=1.4
        return split(input, patString, 0);
    }
    public static String replaceAll(String input, String patString, String replacement)
    {
        //return input.replaceAll(patString, replacement); // only exists in >=1.4
        return Pattern.compile(patString).matcher(input).replaceAll(replacement);
    }

    public static class Pattern
    {
        private java_util_regex.Pattern theirPattern;
        private My.Pattern myPattern;

        private Pattern(java_util_regex.Pattern theirPattern, My.Pattern myPattern)
        {
            this.theirPattern = theirPattern;
            this.myPattern = myPattern;
        }

        public static Pattern compile(String patString)
        {
            if (!java_util_regex.exists())
            {
                // We're on our own!
                useStandardVersion = false;
                checkAgainstStandardVersion = false;
            }

            java_util_regex.Pattern theirs = null;
            My.Pattern mine = null;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = java_util_regex.Pattern.compile(patString);
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = My.Pattern.compile(patString);
            return new Pattern(theirs, mine);
        }
        public Matcher matcher(String input)
        {
            java_util_regex.Matcher theirs = null;
            My.Matcher mine = null;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = theirPattern.matcher(input);
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = myPattern.matcher(input);
            return new Matcher(theirs, mine);
                               
        }
        public String[] split(String input, int limit)
        {
            String theirs[] = null, mine[] = null;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = theirPattern.split(input, limit);
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = myPattern.split(input, limit);
            if (checkAgainstStandardVersion)
            {
                if (verboseLevel >= 1) System.out.println("    theirs = "+Arrays.toStringCompact(theirs));
                if (verboseLevel >= 1) System.out.println("    mine = "+Arrays.toStringCompact(mine));
                CHECK(theirs != null && mine != null);
                CHECK_EQ(theirs.length, mine.length);
                for (int i = 0; i < theirs.length; ++i)
                    CHECK(theirs[i].equals(mine[i]));
            }
            return useStandardVersion ? theirs : mine;
        } // split
    } // class Pattern
    public static class Matcher
    {
        private java_util_regex.Matcher theirMatcher;
        private My.Matcher myMatcher;
        private Matcher(java_util_regex.Matcher theirMatcher, My.Matcher myMatcher)
        {
            this.theirMatcher = theirMatcher;
            this.myMatcher = myMatcher;
        }

        public Matcher reset(String input)
        {
            if (useStandardVersion || checkAgainstStandardVersion)
                theirMatcher.reset(input);
            if (!useStandardVersion || checkAgainstStandardVersion)
                myMatcher.reset(input);
            if (checkAgainstStandardVersion)
            {
                // nothing to check really, I don't think... maybe
            }
            return this;
        }

        private boolean _find_or_matches(boolean isFind, boolean isFindWithStart, int inputStartIfIsFindWithStart)
        {
            boolean theirs = false, mine = false;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = isFindWithStart ? theirMatcher.find(inputStartIfIsFindWithStart) : isFind ? theirMatcher.find() : theirMatcher.matches();
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = isFindWithStart ? myMatcher.find(inputStartIfIsFindWithStart) : isFind ? myMatcher.find() : myMatcher.matches();
            if (checkAgainstStandardVersion)
            {
                int theirGroups[][/*2*/] = null;
                if (theirs)
                {
                    theirGroups = new int[theirMatcher.groupCount()+1][2]; // note the +1
                    for (int iGroup = 0; iGroup < theirGroups.length; ++iGroup)
                    {
                        theirGroups[iGroup][0] = theirMatcher.start(iGroup);
                        theirGroups[iGroup][1] = theirMatcher.end(iGroup);
                    }
                }

                int myGroups[][/*2*/] = null;
                if (mine)
                {
                    myGroups = new int[theirMatcher.groupCount()+1][2]; // note the +1
                    for (int iGroup = 0; iGroup < myGroups.length; ++iGroup)
                    {
                        myGroups[iGroup][0] = myMatcher.start(iGroup);
                        myGroups[iGroup][1] = myMatcher.end(iGroup);
                    }
                }

                if (verboseLevel >= 2)
                {
                    PRINT(theirs);
                    PRINT(mine);
                    if (theirGroups != null) PRINT(theirGroups.length);
                    PRINTARRAY(theirGroups);
                    if (myGroups != null) PRINT(myGroups.length);
                    PRINTARRAY(myGroups);
                }
                CHECK_EQ(theirs, mine);
                if (theirs)
                {
                    CHECK(theirGroups != null && myGroups != null);
                    CHECK_EQ(theirGroups.length, myGroups.length);
                    for (int iGroup = 0; iGroup < theirGroups.length; ++iGroup)
                    {
                        CHECK_EQ(theirGroups[iGroup].length, 2);
                        CHECK_EQ(myGroups[iGroup].length, 2);
                        CHECK_EQ(theirGroups[iGroup][0], myGroups[iGroup][0]);
                        CHECK_EQ(theirGroups[iGroup][1], myGroups[iGroup][1]);
                    }
                }
            }
            return useStandardVersion ? theirs : mine;
        }
        public boolean find(int inputStart)
        {
            return _find_or_matches(true, true, inputStart);
        }
        public boolean find()
        {
            return _find_or_matches(true, false, 12345);
        }

        // Attempts to match the internally stored string
        // against the internally stored pattern.
        // If it succeeds, returns true and stores
        // the group starts and ends of the matched substrings.
        public boolean matches()
        {
            return _find_or_matches(false, false, 12345);
        }
        public int groupCount()
        {
            int theirs = -1, mine = -1;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = theirMatcher.groupCount();
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = myMatcher.groupCount();
            if (checkAgainstStandardVersion)
            {
                CHECK_EQ(theirs, mine);
            }
            return useStandardVersion ? theirs : mine;
        }
        public String group(int iGroup)
        {
            String theirs = null, mine = null;
            if (useStandardVersion || checkAgainstStandardVersion)
            {
                theirs = theirMatcher.group(iGroup);
                /* XXX argh, we didn't save input
                CHECK(theirs.equals(input.substring(theirMatcher.start(iGroup),
                                                    theirMatcher.end(iGroup))));
                */
            }
            if (!useStandardVersion || checkAgainstStandardVersion)
            {
                mine = myMatcher.group(iGroup);
                /* XXX argh, we didn't save input
                CHECK(mine.equals(input.substring(myMatcher.start(iGroup),
                                                  myMatcher.end(iGroup))));
                */
            }
            if (checkAgainstStandardVersion)
            {
                //PRINT(theirs);
                //PRINT(mine);
                CHECK_EQ((theirs != null), (mine != null));
                if (theirs != null)
                    CHECK(theirs.equals(mine));
            }
            return useStandardVersion ? theirs : mine;
        }
        public int start(int iGroup)
        {
            int theirs = -1, mine = -1;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = theirMatcher.start(iGroup);
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = myMatcher.start(iGroup);
            //PRINT(iGroup);
            //PRINT(theirs);
            //PRINT(mine);
            //PRINT(myMatcher.myGroups.length);
            //PRINTARRAY(myMatcher.myGroups);
            if (checkAgainstStandardVersion)
                CHECK_EQ(theirs, mine);
            return useStandardVersion ? theirs : mine;
        }
        public int end(int iGroup)
        {
            int theirs = -1, mine = -1;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = theirMatcher.end(iGroup);
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = myMatcher.end(iGroup);
            if (checkAgainstStandardVersion)
                CHECK_EQ(theirs, mine);
            return useStandardVersion ? theirs : mine;
        }
        public int end()
        {
            int theirs = -1, mine = -1;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = theirMatcher.end();
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = myMatcher.end();
            if (checkAgainstStandardVersion)
                CHECK_EQ(theirs, mine);
            return useStandardVersion ? theirs : mine;
        }
        public String replaceAll(String replacement)
        {
            String theirs = null, mine = null;
            if (useStandardVersion || checkAgainstStandardVersion)
                theirs = theirMatcher.replaceAll(replacement);
            if (!useStandardVersion || checkAgainstStandardVersion)
                mine = myMatcher.replaceAll(replacement);
            if (checkAgainstStandardVersion)
            {
                if (verboseLevel >= 1) System.out.println("    theirs = "+Arrays.toStringCompact(theirs));
                if (verboseLevel >= 1) System.out.println("    mine = "+Arrays.toStringCompact(mine));
                CHECK(theirs != null && mine != null);
                CHECK(theirs.equals(mine));
            }
            return useStandardVersion ? theirs : mine;
        }
    } // class Matcher



    // My implementation of Pattern and Matcher.
    private static class My
    {
        //
        // Nondeterministic finite state machine
        // representing a regular expression.
        //
        private static class FSM
        {
            public String patString; // for debugging so we can print where we are
            public State states[];
            public int nCaptureGroups;
            private int stack[] = new int[0]; // runtime stack.  note this makes it so only one thread can execute stuff at once.

            public static class State
            {
                public Transition transitions[] = new Transition[0];
                // XXX gee, a state doesn't have much... states could really just be a Transition[][]
            }
            public static class Transition
            {
                public String chars; // null means go right there without eating a char of input
                public boolean complement;
                public int nextState;
                public int captureGroupIndex; // -1 except for '(' or ')' transitions
                public Transition(String chars, boolean complement, int nextState, int captureGroupIndex)
                {
                    this.chars = chars;
                    this.complement = complement;
                    this.nextState = nextState;
                    this.captureGroupIndex = captureGroupIndex;
                }
            }
            public FSM(String patString)
            {
                this.patString = patString;
                int patStringLength = patString.length();

                this.states = new State[patStringLength];
                for (int iState = 0; iState < states.length; ++iState)
                    states[iState] = new State();

                this.nCaptureGroups = 0; // and counting

                int openParensStack[] = new int[patStringLength];
                int nOpenParens = 0;
                int otherParen[] = new int[patStringLength]; // from each paren to its opposite
                int patIndexToCaptureGroupIndex[] = new int[patStringLength];
                for (int i = 0; i < patStringLength; ++i)
                    otherParen[i] = -1;
                int thingStart = -1; // start of thing that ?,*,+ will be applied to if there is one following
                for (int i = 0; i < patStringLength; ++i)
                {
                    int iState = i;
                    Transition transition = null;

                    char c = patString.charAt(i);
                    if (c == '(')
                    {
                        if (i+1 < patStringLength && patString.charAt(i+1) == '?')
                        {
                            // Non-capturing special constructs
                            unimplemented();
                        }
                        openParensStack[nOpenParens++] = i; // push the open paren position on stack
                        patIndexToCaptureGroupIndex[i] = ++this.nCaptureGroups;
                        transition = new Transition(null, false, i+1, 2*patIndexToCaptureGroupIndex[i]+0);
                        thingStart = -1; // following ?,*,+ is illegal
                    }
                    else if (c == ')')
                    {
                        // Add a free transition from the end of
                        // each alternative to just before this close paren
                        // XXX somewhat duplicated code in the ')' case and end of pattern
                        while (nOpenParens > 0
                            && patString.charAt(openParensStack[nOpenParens-1]) == '|')
                        {
                            int j = openParensStack[--nOpenParens]; // actually position of the '|'
                            states[j].transitions = (Transition[])Arrays.append(states[j].transitions, new Transition(null, false, i, -1));
                        }

                        if (nOpenParens == 0)
                            throw new PatternSyntaxException("Unmatched '"+c+"'", patString, i); // XXX escapify!
                        int j = openParensStack[--nOpenParens]; // pop matching open paren off stack
                        otherParen[i] = j;
                        otherParen[j] = i; // XXX unused other than this? if so, can get rid
                        transition = new Transition(null, false, i+1, 2*patIndexToCaptureGroupIndex[j]+1);
                        thingStart = j; // before the matching '('
                    }
                    else if (c == '|')
                    {
                        // Append a free transition from the beginning of the most recently opened
                        // paren block (or the beginning of the pattern, if there was none) to here.
                        // Do NOT put any transitions from here yet... there will be
                        // a free transition from here to the end of the current paren block
                        // or end of string.

                        // look for the top *real* open paren, not bar
                        int iOpenParen = nOpenParens-1;
                        while (iOpenParen > 0 && openParensStack[iOpenParen] == '|')
                            iOpenParen--;
                        int fromState = (iOpenParen>=0 ? openParensStack[iOpenParen]+1 : 0);

                        // XXX do this into a Vector first
                        states[fromState].transitions = (Transition[])Arrays.append(states[fromState].transitions, new Transition(null, false, i+1, -1));
                        thingStart = -1; // following ?,*,+ is illegal
                        openParensStack[nOpenParens++] = i; // push the '|' paren position on stack
                    }
                    else if (c == '?')
                    {
                        // the previous thing, once or not at all
                        if (i > 0 && "?*+}".indexOf(patString.charAt(i-1)) != -1)
                            unimplemented(); // reluctant quantifier
                        if (thingStart == -1)
                            throw new PatternSyntaxException("Illegal '"+c+"'", patString, i);// XXX escapify!
                        // add free transition from thingStart to past the ?
                        states[thingStart].transitions = (Transition[])Arrays.append(states[thingStart].transitions, new Transition(null, false, i+1, -1));
                        transition = new Transition(null, false, i+1, -1);
                    }
                    else if (c == '*')
                    {
                        // the previous thing, zero or more times
                        if (thingStart == -1)
                            throw new PatternSyntaxException("Illegal '"+c+"'", patString, i);// XXX escapify!
                        // add free transition from the end of thing to beginning,
                        // and from beginning to past the * (making it optional)
                        states[i].transitions = (Transition[])Arrays.append(states[i].transitions, new Transition(null, false, thingStart, -1));
                        states[thingStart].transitions = (Transition[])Arrays.append(states[thingStart].transitions, new Transition(null, false, i+1, -1));

                    }
                    else if (c == '+')
                    {
                        // the previous thing, one or more times
                        if (i > 0 && "?*+}".indexOf(patString.charAt(i-1)) != -1)
                            unimplemented(); // possessive quantifier
                        // add free transition from the end of thing to beginning (preferred)
                        // and from the end to past the + (non-preferred)
                        states[i].transitions = (Transition[])Arrays.append(states[i].transitions, new Transition(null, false, thingStart, -1));
                        states[i].transitions = (Transition[])Arrays.append(states[i].transitions, new Transition(null, false, i+1, -1));
                    }
                    else if (c == '[')
                    {
                        // Get the character class beginning here
                        StringBuffer sb = new StringBuffer();
                        thingStart = i;
                        int j = i+1;
                        boolean complement = false;
                        while (j < patStringLength && patString.charAt(j) != ']')
                        {
                            if (j == i+1 && patString.charAt(j) == '^')
                            {
                                complement = true;
                                j++;
                            }
                            else if (j+2 < patStringLength
                                 && patString.charAt(j+1) == '-')
                            {
                                char rangeStart = patString.charAt(j);
                                char rangeEnd = patString.charAt(j+2);
                                if (rangeStart > rangeEnd)
                                    throw new PatternSyntaxException("Backwards character range", patString, j+2);
                                for (char k = rangeStart; k <= rangeEnd; ++k)
                                    sb.append(k);
                                j += 3;
                            }
                            else
                            {
                                sb.append(patString.charAt(j));
                                j++;
                            }
                        }
                        if (j == patStringLength)
                            throw new PatternSyntaxException("Unmatched '['", patString, i);
                        transition = new Transition(sb.toString(), complement, j+1, -1);
                        i = j; // the ']'
                    }
                    else if (c == '.')
                    {
                        // Any character (may or may not match line terminators)
                        // XXX currently never matches line terminators
                        thingStart = i;
                        transition = new Transition("\r\n", true, i+1, -1);
                    }
                    else if (c == '^')
                    {
                        // The beginning of a line
                        unimplemented(); // XXX what do do here?
                    }
                    else if (c == '$')
                    {
                        // The end of a line
                        unimplemented(); // XXX what do do here?
                    }
                    else if (c == '{')
                    {
                        // {n} means the previous thing, exactly n times
                        // {n,} means the previous thing, at least n times
                        // {n,m} means the previous thing, at least n but not more than m times
                        unimplemented();
                    }
                    else if (c == '\\')
                    {
                        thingStart = i;
                        if (i+1 == patStringLength)
                        {
                            // XXX need better msg
                            throw new PatternSyntaxException("pattern ends in a backslash!", patString, i);
                        }
                        char d = patString.charAt(++i); // advance and get next char from pat
                        if (d == '\\')
                            transition = new Transition("\\", false, i+1, -1);
                        else if (d == '0')
                            unimplemented();
                        else if (d == 'x')
                            unimplemented();
                        else if (d == 'u')
                            unimplemented();
                        else if (d == 't')
                            transition = new Transition("\t", false, i+1, -1);
                        else if (d == 'n')
                            transition = new Transition("\n", false, i+1, -1);
                        else if (d == 'r')
                            transition = new Transition("\r", false, i+1, -1);
                        else if (d == 'f')
                            transition = new Transition("\f", false, i+1, -1);
                        else if (d == 'a')
                            transition = new Transition("\007", false, i+1, -1);
                        else if (d == 'e')
                            transition = new Transition("\033", false, i+1, -1);
                        else if (d == 'c' && i+1 < patStringLength)
                        {
                            char e = patString.charAt(++i); // advance and get next char from pat
                            transition = new Transition(""+(e-'A'), false, i+1, -1); // XXX 'a' or 'A' or what???
                        }
                        else if (d == 'd')
                            transition = new Transition("0123456789", false, i+1, -1);
                        else if (d == 'D')
                            transition = new Transition("0123456789", true, i+1, -1);
                        else if (d == 's')
                            transition = new Transition(" \t\n\013\f\r", false, i+1, -1);
                        else if (d == 'S')
                            transition = new Transition(" \t\n\013\f\r", true, i+1, -1);
                        else if (d == 'w')
                            transition = new Transition("a-zA-Z_0-9", false, i+1, -1);
                        else if (d == 'W')
                            transition = new Transition("a-zA-Z_0-9", true, i+1, -1);
                        else if (d == 'p' || d == 'P')
                        {
                            // Posix character classes
                            unimplemented();
                        }
                        else if (d == 'b')
                        {
                            // A word boundary
                            unimplemented();
                        }
                        else if (d == 'B')
                        {
                            // A non-word boundary
                            unimplemented();
                        }
                        else if (d == 'A')
                        {
                            // The beginning of the input
                            unimplemented();
                        }
                        else if (d == 'G')
                        {
                            // The end of the previous match
                            unimplemented();
                        }
                        else if (d == 'Z')
                        {
                            // The end of the input but for the final terminator, if any
                            unimplemented();
                        }
                        else if (d == 'Z')
                        {
                            // The end of the input
                            unimplemented();
                        }
                        else if ("0123456789".indexOf(d) != -1)
                        {
                            // Whatever the n'th capturing group matched
                            // XXX only a single digit, or not?
                            unimplemented();
                        }
                        else if (d == 'Q')
                        {
                            // Nothing, but quotes all characters until \E
                            // XXX what the hell does this mean?
                            unimplemented();
                        }
                        else if (d == 'E')
                        {
                            // Nothing, but ends quoting started by \Q
                            // XXX what the hell does this mean?
                            unimplemented();
                        }
                        else
                        {
                            // quote a character that otherwise
                            // would be interpreted as unescaped constructs
                            transition = new Transition(""+d, false, i+1, -1);
                        }
                    } // c == '\\'
                    else
                    {
                        // Just a char literal.
                        thingStart = i;
                        transition = new Transition(""+c, false, i+1, -1);
                    }

                    if (transition != null)
                    {
                        CHECK_EQ(states[iState].transitions.length, 0);
                        states[iState].transitions = (Transition[])Arrays.append(states[iState].transitions, transition);
                    }
                }

                // Add a free transition from the end of
                // each alternative to the end of the pattern
                // XXX somewhat duplicated code in the ')' case and end of pattern
                while (nOpenParens > 0
                    && patString.charAt(openParensStack[nOpenParens-1]) == '|')
                {
                    int j = openParensStack[--nOpenParens]; // actually position of the '|'
                    states[j].transitions = (Transition[])Arrays.append(states[j].transitions, new Transition(null, false, patStringLength, -1));
                }
            } // FSM ctor

            public String toString()
            {
                StringBuffer sb = new StringBuffer();
                sb.append("    patString=\"").append(patString).append("\"\n");
                sb.append("    ").append(states.length).append(" states\n");
                for (int iState = 0; iState < states.length; ++iState)
                {
                    sb.append("        ").append(iState).append(":\n");
                    Transition transitions[] = states[iState].transitions;
                    for (int iTransition = 0; iTransition < transitions.length; ++iTransition)
                    {
                        Transition t = transitions[iTransition];
                        if (t.chars == null)
                            sb.append("            --> ").append(t.nextState).append("\n");
                        else
                            sb.append("            -").append((t.complement?"^":"")).append("\"").append(t.chars+"\"-> ").append(t.nextState).append("\n");

                    }
                }
                return sb.toString();
            } // FSM.toString

            // Return the end of the greedy match,
            // or -1 if no match.
            private int __match(String input, int inputStart, int inputEnd, int iState, int captureGroups[][/*2*/])
            {
                if (verboseLevel >= 2) System.out.println("    matching input \""+input.substring(inputStart, inputEnd)+"\" against pattern \""+patString.substring(iState)+"\""); // XXX stringify
                if (iState == states.length)
                    return inputStart;
                Transition transitions[] = states[iState].transitions;
                for (int iTransition = 0; iTransition < transitions.length; ++iTransition)
                {
                    Transition transition = transitions[iTransition];
                    int matchEnd = -1;
                    if (transition.chars == null)
                    {
                        // Free transition-- don't eat a char
                        if (verboseLevel >= 2) System.out.println("    "+iState+" -----> "+(transition.nextState==states.length?"[":"")+transition.nextState+(transition.nextState==states.length?"]":""));
                        matchEnd = __match(input, inputStart, inputEnd, transition.nextState, captureGroups);
                        if (matchEnd != -1)
                        {
                            if (captureGroups != null
                             && transition.captureGroupIndex != -1
                             && captureGroups[transition.captureGroupIndex/2]
                                             [transition.captureGroupIndex%2] == -1) // for a * or +, we want the last one, so don't clobber it
                                captureGroups[transition.captureGroupIndex/2]
                                             [transition.captureGroupIndex%2] = inputStart;
                            return matchEnd;
                        }
                    }
                    else
                    {
                        // Transition, and eat the char, if it matches
                        if (inputStart < inputEnd)
                        {
                            char c = input.charAt(inputStart);
                            if ((transition.chars.indexOf(c) == -1) == transition.complement)
                            {
                                if (verboseLevel >= 2) System.out.println("    "+iState+" -("+c+")-> "+(transition.nextState==states.length?"[":"")+transition.nextState+(transition.nextState==states.length?"]":""));
                                matchEnd = __match(input, inputStart+1, inputEnd, transition.nextState, captureGroups);
                                if (matchEnd != -1)
                                {
                                    if (captureGroups != null
                                     && transition.captureGroupIndex != -1
                                     && captureGroups[transition.captureGroupIndex/2]
                                                     [transition.captureGroupIndex%2] == -1) // for a * or +, we want the last one, so don't clobber it
                                        captureGroups[transition.captureGroupIndex/2]
                                                     [transition.captureGroupIndex%2] = inputStart;
                                    return matchEnd;
                                }
                            }
                        }
                    }
                }
                return -1; // no way out
            } // FSM.__match
            public int match(String input, int inputStart, int inputEnd, int captureGroups[][/*2*/])
            {
                boolean doItRecursively = false;
                if (doItRecursively)
                {
                    int matchEnd = __match(input, inputStart, inputEnd, 0, captureGroups);
                    if (matchEnd != -1
                     && captureGroups != null)
                    {
                        captureGroups[0][0] = inputStart;
                        captureGroups[0][1] = matchEnd;
                    }
                    return matchEnd;
                }
                else
                {
                    //
                    // Recursing on every char won't fly--
                    // it bombs after 20000 or so recursion levels, on my machine.
                    // So, need to simulate the runtime stack instead.
                    // Each stack frame contains:
                    //        inputStart
                    //        iState
                    //        iTransition
                    // This kinda sucks for small strings, or when doing a ton of finds, e.g. during a long split.
                    // since the recursive version was actually allocation-free, I think.
                    // In fact it was so bad that we had to move the ownership of this stack
                    // into a member of the FSM, making the FSM not thread-safe.  Which I guess is fine.

                    // XXX what is the right number?
                    // 2 states (.*):
                    //   0->1
                    //   1->3
                    //   2->5
                    // 4 states (.*.*):
                    //   0->2
                    //   1->4
                    //   2->6
                    //   3->8
                    int upperBound = (2*(inputEnd-inputStart) + 2*states.length)*3; // XXX what is the right upper bound??
                    if (upperBound > stack.length)
                        stack = new int[upperBound];
                    int iStack = 0;


        
                    {
                        int iTransition = 0;
           stateLoop:   for (int iState = 0; iState < states.length;)
                        {
                            if (verboseLevel >= 2) System.out.println("    matching input \""+input.substring(inputStart, inputEnd)+"\" against pattern \""+patString.substring(iState)+"\""); // XXX stringify
                            Transition transitions[] = states[iState].transitions;
                            for (; iTransition < transitions.length; ++iTransition)
                            {

                                // XXX get rid of the following when I get the right bound, above
                                if (iStack+3 >= stack.length)
                                {
                                    //int newStack[] = new int[stack.length*5/4]; // 11.68 secs for 10m if start small
                                    int newStack[] = new int[stack.length*3/2]; // 9.6 secs for 10m if start small
                                    //int newStack[] = new int[stack.length*2]; // 7.6 secs for 10m if start small
                                    // 3.9 secs for 10m if allocate it big up front
                                    System.arraycopy(stack, 0, newStack, 0, stack.length);
                                    stack = newStack;
                                }

                                Transition transition = transitions[iTransition];
                                if (transition.chars == null)
                                {
                                    // Free transition-- always succeeds, and don't eat a char
                                    if (verboseLevel >= 2) System.out.println("    "+iState+" -----> "+(transition.nextState==states.length?"[":"")+transition.nextState+(transition.nextState==states.length?"]":""));

                                    stack[iStack++] = inputStart;
                                    stack[iStack++] = iState;
                                    stack[iStack++] = iTransition;

                                    iState = transition.nextState;
                                    iTransition = 0;
                                    continue stateLoop; // recurse
                                }
                                else
                                {
                                    // Transition, and eat the char, only if it matches
                                    if (inputStart < inputEnd)
                                    {
                                        char c = input.charAt(inputStart);
                                        if ((transition.chars.indexOf(c) == -1) == transition.complement)
                                        {
                                            if (verboseLevel >= 2) System.out.println("    "+iState+" -("+c+")-> "+(transition.nextState==states.length?"[":"")+transition.nextState+(transition.nextState==states.length?"]":""));

                                            stack[iStack++] = inputStart;
                                            stack[iStack++] = iState;
                                            stack[iStack++] = iTransition;

                                            inputStart++;
                                            iState = transition.nextState;
                                            iTransition = 0;
                                            continue stateLoop; // recurse
                                        }
                                    }
                                    else
                                    {
                                        // This transition failed; on to next iTransition
                                    }
                                }
                            }
                            //
                            // No transitions worked from this state
                            // at this inputStart; pop to parent stack frame,
                            // and on to the next transition in the parent state.
                            // If we're at the beginning, fail.
                            // This is really returning from the recursion;
                            // we jump right into the middle of the caller's iTransition loop.
                            //
                            if (iStack == 0)
                                return -1;

                            iTransition = stack[--iStack];
                            iState = stack[--iStack];
                            inputStart = stack[--iStack];

                            iTransition++;
                        } // for iState
                    }

                    // Success!
                    // Unwind the stack information into captureGroups,
                    // and return the current value of inputStart,
                    // which is the end of the match.
                    int matchEnd = inputStart;
                    if (captureGroups != null)
                    {
                        while (iStack > 0)
                        {
                            int iTransition = stack[--iStack];
                            int iState = stack[--iStack];
                            inputStart = stack[--iStack];

                            Transition transition = states[iState].transitions[iTransition];

                            if (transition.captureGroupIndex != -1
                             && captureGroups[transition.captureGroupIndex/2]
                                             [transition.captureGroupIndex%2] == -1) // for a * or +, we want the last one, so don't clobber it
                                captureGroups[transition.captureGroupIndex/2]
                                             [transition.captureGroupIndex%2] = inputStart;
                        }
                        captureGroups[0][0] = inputStart;
                        captureGroups[0][1] = matchEnd;
                    }
                    return matchEnd;
                }
            } // FSM.match
        } // class My.FSM

        public static class Pattern // My.Pattern
        {
            private String patString;
            private FSM fsm;

            private Pattern(String patString)
            {
                this.patString = patString;
                this.fsm = new FSM(patString);
            }

            public static Pattern compile(String patString)
            {
                if (verboseLevel >= 1)
                {
                    System.out.println("    =================");
                    System.out.println("    in Pattern.compile(patString=\""+patString+"\")"); // XXX stringify
                }
                Pattern pattern = new Pattern(patString);
                if (verboseLevel >= 1)
                {
                    System.out.println("    fsm = ");
                    System.out.println("    "+pattern.fsm);
                    System.out.println("    =================");
                }
                return pattern;
            }
            public Matcher matcher(String input)
            {
                return new Matcher(this, input);
            }

            public String[] split(String input, int limit)
            {
                if (verboseLevel >= 1)
                {
                    System.out.println("=================");
                    System.out.println("in Pattern.split(patString=\""+patString+"\", input=\""+input+"\", limit="+limit+")"); // XXX stringify
                }

                ArrayList resultVector = new ArrayList();
                {
                    int inputLength = input.length();
                    Matcher matcher = matcher(input);
                    int prevSearchStart = -1;
                    int i = 0;
                    while (true)
                    {
                        if (resultVector.size()+1 == limit)
                            break;
                        int searchStart = i==prevSearchStart ? i+1 : i; // never do the same search twice, or we will endless loop
                        if (searchStart > inputLength)
                            break;
                        if (!matcher.find(searchStart))
                            break;
                        prevSearchStart = searchStart;
                        // Found a match; send everything up to it
                        // and then advance past it.
                        resultVector.add(input.substring(i, matcher.start(0)));
                        i = matcher.end(0);
                    }
                    // Send the rest of the input.
                    resultVector.add(input.substring(i));
                }
                if (limit == 0)
                {
                    // special case: trailing empty strings are discarded
                    while (resultVector.size() >= 1
                        && ((String)resultVector.get(resultVector.size()-1)).equals(""))
                        resultVector.remove(resultVector.size()-1);
                }
                String result[] = new String[resultVector.size()];
                resultVector.toArray(result);

                // Fudge to make mine match theirs, even though
                // I don't think I agree...
                if (input.equals(""))
                    result = new String[]{""};

                return result;
            } // split
        } // class My.Pattern
        public static class Matcher // My.Matcher
        {
            private Pattern pattern; // the My.Pattern who made me
            private String input;
            private int groups[][/*2*/];
            private Matcher(Pattern pattern, String input) // XXX huh? why is javap showing this?
            {
                this.pattern = pattern;
                this.groups = new int[pattern.fsm.nCaptureGroups+1][2]; // note the +1
                reset(input);
            }

            public boolean find()
            {
                return find(groups[0][1] == -1 ? 0 : groups[0][1]);
            }
            public boolean find(int inputStart)
            {
                if (verboseLevel >= 1)
                {
                    System.out.println("=================");
                    System.out.println("in Matcher.find(patString=\""+pattern.patString+"\", input tail=\""+input.substring(inputStart)+"\")"); // XXX stringify
                }

                reset();

                int inputLength = input.length();
                int matchEnd = -1;
                while (inputStart <= inputLength) // yes, test even at end
                {
                    matchEnd = pattern.fsm.match(input, inputStart, inputLength, groups);
                    if (matchEnd != -1)
                    {
                        if (verboseLevel >= 1)
                        {
                            System.out.println("mine DID match");
                            System.out.println("=================");
                        }
                        return true;
                    }
                    inputStart++;
                }
                if (verboseLevel >= 1)
                {
                    System.out.println("mine DID NOT match");
                    System.out.println("=================");
                }
                return false;
            } // My.Matcher.find


            // Attempts to match the internally stored string
            // against the internally stored pattern.
            // If it succeeds, returns true and stores
            // the group starts and ends of the matched substrings.
            public boolean matches()
            {
                if (verboseLevel >= 1)
                {
                    System.out.println("=================");
                    System.out.println("in Matcher.matches(patString=\""+pattern.patString+"\", input=\""+input+"\")"); // XXX stringify
                }

                reset();

                int matchEnd = pattern.fsm.match(input, 0, input.length(), groups);
                boolean matched = (matchEnd == input.length());
                if (verboseLevel >= 1)
                {
                    System.out.println("mine "+(matched ? "DID" : "DID NOT")+" match");
                    System.out.println("=================");
                }
                return matched;
            } // My.Matcher.matches
            public int groupCount()
            {
                return pattern.fsm.nCaptureGroups;
            }
            public String group(int iGroup)
            {
                //PRINT(iGroup);
                //PRINTARRAY(groups);
                // XXX need to throw if there was no match
                return groups[iGroup][0] == -1 ? null :
                            input.substring(groups[iGroup][0], groups[iGroup][1]);
            }
            public int start(int iGroup)
            {
                // XXX need to throw if there was no match
                return groups[iGroup][0];
            }
            public int end(int iGroup)
            {
                // XXX need to throw if there was no match
                return groups[iGroup][1];
            }
            public int end()
            {
                return end(0);
            }
            // Resets the matcher and then replaces all.
            // Doesn't need to reset afterwards.
            public String replaceAll(String replacement)
            {
                if (verboseLevel >= 1)
                {
                    System.out.println("=================");
                    System.out.println("in Matcher.replaceAll()");
                    System.out.println("    pattern.patString = "+pattern.patString); // XXX stringify
                    System.out.println("    input = "+input); // XXX stringify
                    System.out.println("    replacement = "+replacement); // XXX stringify
                }
                this.reset(); // so that we start at the beginning
                int replacementLength = replacement.length();
                StringBuffer sb = new StringBuffer();
                {
                    int inputLength = input.length();
                    int prevSearchStart = -1;
                    int i = 0;
                    while (true)
                    {
                        int searchStart = i==prevSearchStart ? i+1 : i; // never do the same search twice, or we will endless loop    XXX make sure we have a test case for this
                        if (searchStart > inputLength)
                            break;
                        if (!this.find(searchStart))
                            break;
                        prevSearchStart = searchStart;

                        // Found a match; send everything up to it...
                        sb.append(input.substring(i, this.start(0)));

                        // and send the replacement...
                        // dollar signs are backrefs, backslashes are
                        // escapes.
                        {
                            for (int iReplacement = 0; iReplacement < replacementLength; ++iReplacement)
                            {
                                char c = replacement.charAt(iReplacement);
                                if (c == '\\')
                                {
                                    if (iReplacement+1 == replacementLength)
                                        throw new IllegalArgumentException("replacement \""+replacement+"\" ends in a backslash!"); // XXX escapify   XXX don't need to check this every time, just sanity check once at start maybe
                                    sb.append(replacement.charAt(++iReplacement));
                                }
                                else if (c == '$')
                                {
                                    // XXX not clear on what happens if followed by more than one digit... we will just assume we should get a single digit.
                                    if (iReplacement+1 == replacementLength)
                                        throw new IllegalArgumentException("replacement \""+replacement+"\" ends in a dollar sign!"); // XXX escapify   XXX don't need to check this every time, just sanity check once at start maybe
                                    char d = replacement.charAt(++iReplacement);
                                    if (d < '0' || d > '9')
                                        throw new IllegalArgumentException("replacement \""+replacement+"\" has a dollar sign not followed by a digit!"); // XXX escapify   XXX don't need to check this every time, just sanity check once at start maybe
                                    int iGroup = d - '0';
                                    int iGroupMaybe;
                                    while (iReplacement+1 < replacementLength
                                        && (iGroupMaybe = iGroup*10 + (replacement.charAt(iReplacement+1)-'0')) < groups.length)
                                    {
                                        iGroup = iGroupMaybe;
                                        iReplacement++;
                                    }
                                    if (groups[iGroup][0] != -1)
                                        sb.append(input.substring(groups[iGroup][0], groups[iGroup][1]));
                                    else
                                    {
                                        // XXX am I doing the right thing here? need a test
                                    }
                                }
                                else
                                    sb.append(c);
                            }
                        }

                        // and advance past it.
                        i = this.end(0);
                    }
                    // Send the rest of the input.
                    sb.append(input.substring(i));
                }
                return sb.toString();
            } // replaceAll
            public Matcher reset(String input)
            {
                this.input = input;
                return reset();
            }
            public Matcher reset()
            {
                for (int iGroup = 0; iGroup < groups.length; ++iGroup)
                {
                    groups[iGroup][0] = -1;
                    groups[iGroup][1] = -1;
                }
                return this;
            }
        } // class My.Matcher
    } // class My



    //=========================================================================
    // Way to get at the native versions
    // using reflection, so it will compile on <1.4
    //
    private static class java_util_regex
    {
        // you MUST call this and make sure it returns true
        // before calling any of the other methods
        public static boolean exists()
        {
            init();
            return patternClass != null;
        }

        private static boolean inited;
        private static Class patternClass;
        private static Class matcherClass;
        private static Class charSequenceClass;
        private static java.lang.reflect.Method patternCompileMethod;
        private static java.lang.reflect.Method patternMatcherMethod;
        private static java.lang.reflect.Method patternSplitMethod;
        private static java.lang.reflect.Method matcherReset0Method;
        private static java.lang.reflect.Method matcherReset1Method;
        private static java.lang.reflect.Method matcherFind0Method;
        private static java.lang.reflect.Method matcherFind1Method;
        private static java.lang.reflect.Method matcherMatchesMethod;
        private static java.lang.reflect.Method matcherGroupCountMethod;
        private static java.lang.reflect.Method matcherStartMethod;
        private static java.lang.reflect.Method matcherEnd0Method;
        private static java.lang.reflect.Method matcherEnd1Method;
        private static java.lang.reflect.Method matcherGroupMethod;
        private static java.lang.reflect.Method matcherReplaceAllMethod;

        private static void init()
        {
            synchronized(Pattern.class) {
                if (inited)
                    return;
                inited = true;
            }
            try {
                patternClass = Class.forName("java.util.regex.Pattern");
                matcherClass = Class.forName("java.util.regex.Matcher");
                charSequenceClass = Class.forName("java.lang.CharSequence");
            } catch (ClassNotFoundException e) {
                // This is the <1.4 case.
                if (verboseLevel >= 1)
                {
                    System.out.println("I guess we don't have regex: "+e);
                }
                return;
            }

            try {
                patternCompileMethod = patternClass.getMethod("compile", new Class[]{String.class});
                patternMatcherMethod = patternClass.getMethod("matcher", new Class[]{charSequenceClass});
                patternSplitMethod = patternClass.getMethod("split", new Class[]{charSequenceClass, int.class});
                matcherReset0Method = matcherClass.getMethod("reset", new Class[]{});
                matcherReset1Method = matcherClass.getMethod("reset", new Class[]{charSequenceClass});
                matcherFind0Method = matcherClass.getMethod("find", new Class[]{});
                matcherFind1Method = matcherClass.getMethod("find", new Class[]{int.class});
                matcherMatchesMethod = matcherClass.getMethod("matches", new Class[]{});
                matcherGroupCountMethod = matcherClass.getMethod("groupCount", new Class[]{});
                matcherStartMethod = matcherClass.getMethod("start", new Class[]{int.class});
                matcherEnd0Method = matcherClass.getMethod("end", new Class[]{});
                matcherEnd1Method = matcherClass.getMethod("end", new Class[]{int.class});
                matcherGroupMethod = matcherClass.getMethod("group", new Class[]{int.class});
                matcherReplaceAllMethod = matcherClass.getMethod("replaceAll", new Class[]{String.class});

            } catch (NoSuchMethodException e) {
                System.err.println("java_util_regex.Pattern: something went dreadfully wrong: "+e);
                CHECK(false);
            }
        } // java_util_regex.getMethods


        private static class Pattern
        {
            //private java.util.regex.Pattern nativePattern;
            private Object nativePattern;


            private Pattern(Object nativePattern)
            {
                this.nativePattern = nativePattern;
            }

            public static Pattern compile(String patString)
            {
                if (patternCompileMethod == null)
                {
                    throw new Error("java_util_regex.Pattern.compile called without first verifying java_util_regex.exists()"); // should neve happen
                }
                //java.util.regex.Pattern nativePattern = java.util.regex.Pattern.compile(patString);
                try {
                    Object nativePattern = patternCompileMethod.invoke(null, new Object[]{patString});
                    return new Pattern(nativePattern);
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Pattern.compile!?");
                    CHECK(false); // XXX should rethrow? maybe not if only checking?  get straight on this
                    return null;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Pattern.compile: "+e.getTargetException());
                    CHECK(false); // XXX should rethrow? maybe not if only checking?  get straight on this
                    return null;
                }
            }
            public Matcher matcher(String input)
            {
                //return new Matcher(nativePattern.matcher(input));
                try {
                    Object nativeMatcher = patternMatcherMethod.invoke(nativePattern, new Object[]{input});
                    return new Matcher(nativeMatcher);
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Pattern.matcher!?");
                    CHECK(false);
                    return null;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Pattern.matcher: "+e.getTargetException());
                    CHECK(false);
                    return null;
                }
            }
            public String[] split(String input, int limit)
            {
                // return nativePattern.split(input, limit);
                try {
                    return (String[])patternSplitMethod.invoke(nativePattern, new Object[]{input, Integer.valueOf(limit)});
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Pattern.split!?");
                    CHECK(false);
                    return null;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Pattern.split: "+e.getTargetException());
                    CHECK(false);
                    return null;
                }
            }
        } // java_util_regex.Pattern

        private static class Matcher
        {
            //private java.util.regex.Matcher nativeMatcher;
            private Object nativeMatcher;

            private Matcher(Object nativeMatcher)
            {
                this.nativeMatcher = nativeMatcher;
            }

            public Matcher reset(String input)
            {
                //nativeMatcher.reset(input);
                try {
                    matcherReset1Method.invoke(nativeMatcher, new Object[]{input}); // XXX why can I look in Pattern's privates?  that's messed up
                    // XXX should make sure return value is expected type, maybe
                    return this;
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.reset!?");
                    CHECK(false);
                    return null;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.reset: "+e.getTargetException());
                    CHECK(false);
                    return null;
                }
            }

            public boolean find(int inputStart)
            {
                //return nativeMatcher.find();
                try {
                    return ((Boolean)matcherFind1Method.invoke(nativeMatcher, new Object[]{Integer.valueOf(inputStart)})).booleanValue(); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.find!?");
                    CHECK(false);
                    return false;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.find: "+e.getTargetException());
                    CHECK(false);
                    return false;
                }
            }
            public boolean find()
            {
                //return nativeMatcher.find();
                try {
                    return ((Boolean)matcherFind0Method.invoke(nativeMatcher, new Object[]{})).booleanValue(); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.find!?");
                    CHECK(false);
                    return false;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.find: "+e.getTargetException());
                    CHECK(false);
                    return false;
                }
            }
            public boolean matches()
            {
                //return nativeMatcher.matches();
                try {
                    return ((Boolean)matcherMatchesMethod.invoke(nativeMatcher, new Object[]{})).booleanValue(); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.matches!?");
                    CHECK(false);
                    return false;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.matches: "+e.getTargetException());
                    CHECK(false);
                    return false;
                }
            }
            public int groupCount() // XXX weird, why isn't this a method on the Pattern?
            {
                //return nativeMatcher.groupCount();
                try {
                    return ((Integer)matcherGroupCountMethod.invoke(nativeMatcher, new Object[]{})).intValue(); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.groupCount!?");
                    CHECK(false);
                    return -1;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.groupCount: "+e.getTargetException());
                    CHECK(false);
                    return -1;
                }
            }
            public int start(int iGroup)
            {
                //return nativeMatcher.start(iGroup);
                try {
                    return ((Integer)matcherStartMethod.invoke(nativeMatcher, new Object[]{Integer.valueOf(iGroup)})).intValue(); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.start!?");
                    CHECK(false);
                    return -1;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.start: "+e.getTargetException());
                    CHECK(false);
                    return -1;
                }
            }
            public int end(int iGroup)
            {
                //return nativeMatcher.end(iGroup);
                try {
                    return ((Integer)matcherEnd1Method.invoke(nativeMatcher, new Object[]{Integer.valueOf(iGroup)})).intValue(); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.end!?");
                    CHECK(false);
                    return -1;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.end: "+e.getTargetException());
                    CHECK(false);
                    return -1;
                }
            }
            public int end()
            {
                //return nativeMatcher.end(iGroup);
                try {
                    return ((Integer)matcherEnd0Method.invoke(nativeMatcher, new Object[]{})).intValue(); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.end!?");
                    CHECK(false);
                    return -1;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.end: "+e.getTargetException());
                    CHECK(false);
                    return -1;
                }
            }
            public String group(int iGroup)
            {
                //return nativeMatcher.group(iGroup);
                try {
                    return (String)matcherGroupMethod.invoke(nativeMatcher, new Object[]{Integer.valueOf(iGroup)}); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.group!?");
                    CHECK(false);
                    return null;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.group: "+e.getTargetException());
                    //CHECK(false);
                    return null;
                }
            }
            public String replaceAll(String replacement)
            {
                //return nativeMatcher.replaceAll(input);
                try {
                    return (String)matcherReplaceAllMethod.invoke(nativeMatcher, new Object[]{replacement}); // XXX why can I look in Pattern's privates?  that's messed up
                } catch (IllegalAccessException e) {
                    System.err.println("IllegalAccessException trying to invoke Matcher.replaceAll!?");
                    CHECK(false);
                    return null;
                } catch (java.lang.reflect.InvocationTargetException e) {
                    System.err.println("InvocationTargetException trying to invoke Matcher.replaceAll: "+e.getTargetException());
                    CHECK(false);
                    return null;
                }
            }
        } // java_util_regex.Matcher
    } // java_util_regex

    //
    //=========================================================================

    private static void testSplit(String inputs[], String patStrings[], int limits[])
    {
        FORI (iInput, inputs.length)
        FORI (iPatString, patStrings.length)
        FORI (iLimit, limits.length)
        {
            split(inputs[iInput], patStrings[iPatString], limits[iLimit]);
            replaceAll(inputs[iInput], patStrings[iPatString], "");
            replaceAll(inputs[iInput], patStrings[iPatString], "howdy");
        }
    }


    // Some examples from the doc,
    // and others that exercise stuff.
    public static void main(String args[])
    {
        if (args.length == 1)
        {
            verboseLevel = Integer.parseInt(args[0]);
        }

        if (true)
        {
            matches("", ".*.*");
            matches("a", ".*.*");
            matches("ab", ".*.*");
            matches("abc", ".*.*");
            matches("abcd", ".*.*");
            matches("abcde", ".*.*");
            matches("abcdef", ".*.*");
            matches("abcdefg", ".*.*");
            matches("abcdefgh", ".*.*");
            matches("abcdefghi", ".*.*");
        }
        if (true)
        {
            testSplit(new String[]{"","a"},
                      new String[]{"","a","a?","a*","a+","\\s","\\s?","\\s*","\\s+"},
                      new int[]{-1,0,1,2});

            split("boo:and:foo", ":");
            split("boo:and:foo", "o");

            split("boo:and:foo", ":", 2);
            split("boo:and:foo", ":", 5);
            split("boo:and:foo", ":", -2);
            split("boo:and:foo", "o", 5);
            split("boo:and:foo", "o", -2);
            split("boo:and:foo", "o", 0);

            split("boo:and:foo", "", 0);
            split("boo:and:foo", ".", 0);
            split("boo:and:foo", ".?", 0);
            split("boo:and:foo", ".*", 0);
            split("boo:and:foo", ".+", 0);

            split("b", "a", -1);
            split("b", "a?", -1);
            split("b", "a*", -1);
            split("b", "a+", -1);
            split("b", "[a]", -1);
            split("b", "[a]*", -1);
            split("b", "[a]+", -1);
            split("b", "[^a]", -1);
            split("b", "[^a]?", -1);
            split("b", "[^a]*", -1);
            split("b", "[^a]+", -1);
            split("bbabaabaaa", "a?", -1);
            split("bbabaabaaa", "a*", -1);
            split("bbabaabaaa", "a+", -1);
            split("bbabaabaaa", "[a]?", -1);
            split("bbabaabaaa", "[a]*", -1);
            split("bbabaabaaa", "[a]+", -1);
            split("bbabaabaaa", "[^a]?", -1);
            split("bbabaabaaa", "[^a]*", -1);
            split("bbabaabaaa", "[^a]+", -1);
            split("boo:and:foo", "o+", -1);
            split("boo:and:foo", "o?", -1);
            split("boo:and:foo", "o*", -1);
            split(" \n ", "\\s*\n\\s*", -1);
            split("(1)5/2(0)3(0)", "\\([^)]+\\)", -1);
            split("X144 13-cells:Y", "(\\d+) (\\d+)-cell[^:]*:", -1);
            split("X144 13-cell:Y", "(\\d+) (\\d+)-cell[^:]*:", -1);
            matches("X144 13-cells:Y", "(\\d+) (\\d+)-cell[^:]*:"); // no
            matches("X144 13-cell:Y", "(\\d+) (\\d+)-cell[^:]*:"); // no
            matches("X144 13-cells:", "(\\d+) (\\d+)-cell[^:]*:"); // no
            matches("X144 13-cell:", "(\\d+) (\\d+)-cell[^:]*:"); // no
            matches("144 13-cells:", "(\\d+) (\\d+)-cell[^:]*:"); // yes
            matches("144 13-cell:", "(\\d+) (\\d+)-cell[^:]*:"); // yes
            matches("a", "(a|b)");
            matches("a", "a|b");
            matches("%.2g", "%\\.((\\d+))g");
            matches("%.2g", "%\\.((\\d+)|(\\*))g");
            matches("%.2g", "%\\.((\\d+)|(\\*))?g");
            matches("abc%d%x%%%.17g", "(%|[^%])*");
            matches("abc%d%f%%%.17g", "((%(-)?((\\d+)|(\\*))?(\\.((\\d+)|(\\*)))?([gdf]))|(%%)|([^%]))*");
            matches("%%", "((%(-)?((\\d+)|(\\*))?(\\.((\\d+)|(\\*)))?([gdf]))|(%%)|([^%]))*");

            matches("b", "[a-z0-9]");
            matches("b", "[A-Z]");
            matches("b", "[A-Za-z]");
            matches("b", "[A-Za-z]");
            matches("B", "[A-Za-z]");
            matches("B", "[-Za-z]");
            matches("-", "[-Za-z]");
            matches("Z", "[-Za-z]");
            matches("z", "[a-z-]");
            matches("Z", "[a-z-]");
            matches("Z", "[----]");
            split("ab .abX 0cd dq.z hello(there)", "[._a-zA-Z][._a-zA-Z0-9]*");
            replaceAll("aabfooaabfooabfoob", "a*b", "-");
            String prepattern = " { genericPuzzleDescription = ([^\\n,]+) , \\n genericPuzzleState = ([^\\n,]+) , \\n history = ([^\\n,]+) , \\n undoPartSize = (\\d+) ";
            split(prepattern, " ");
            replaceAll(prepattern, " ", "\\\\s*");
            replaceAll(prepattern, " ", "\\s*");
            replaceAll("aaafoo", "(...)(...)", "$2bar");
            replaceAll("aaaaaaaaabbbbbbbbb", "(.)(.)(.)(.)(.)(.)(.)(.)(.)", "\\\\\\$$100"); // the back ref is $1 because $10 is illegal
            replaceAll("aaaaaaaaaabbbbbbbbbb", "(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)", "\\\\\\$$100"); // the back ref is $10
            matches("foo", "\\s*\\{\\s*genericPuzzleDescription\\s*=\\s*([^\\n,]+)\\s*,\\s*\\n\\s*genericPuzzleState\\s*=\\s*([^\\n,]+)\\s*,\\s*\\n\\s*history\\s*=\\s*([^\\n,]+)\\s*,\\s*\\n\\s*undoPartSize\\s*=\\s*(\\d+)\\s*\\}\\s*,?\\s*");
            replaceAll("abcdefghi", ".", "n\n\\n\\\n\\\\n\\\\\n");
        }
        if (false)
        {
            // These fail currently
            split("XababacY", "((ab)*|aba)c?", -1); // XXX Oh frickin heck, they got the non-greedy longest match.  How did they do that??  This sucks.
            matches("b", "[A-]"); // XXX I considered this illegal... I guess it's not? weird
            matches("new foo(\"bar\")", "\\s*new\\s+([a-zA-Z0-9.]+)\\s*\\(\"(([^\\]|\\\\.)*)\"\\s*\\)\\s*"); // XXX they say that char range is unmatched...  oh guess it is, I forgot to make the \ inside the [] be \\\\... and mine accepts it, wrongly, because it doesn't properly parse escapes inside char ranges
            replaceAll("f\\oo", "\\\\(.)", "\\1"); // XXX I can't handle backrefs yet

            matches("\n", "[^n,]");
            matches("\n", "[^\n,]");
            matches("\n", "[^\\n,]"); // XXX argh, looks like they are interpreting backslash n as newline inside the thing? need to do that
            matches("\n", "[^\\\n,]");
            matches("\n", "[^\\\\n,]");
        }
        if (false)
        {
            // Purposely try to throw exceptions to exercise that XXX should catch and verify these
            matches("b", "[z-b0-9]"); // Backwards range near index 3
            matches("%.2g", "%\\(.((\\d+)|(\\*  )  )  )?g"); // Unmatched closing ')' near index 22 (theirs says 21, I like mine better because it points to the ')')
        }
        if (true)
        {
            replaceAll("abc\r\n", ".", "!");
            matches("{\n    genericPuzzleDescription\n",
                    "\\s*\\{\\s*genericPuzzleDescription(.|\n|\r)*");
            matches(",abc\r\ndef\n\r", ",(.|\r|\n)*");

            // XXX this gives stack overflow in 1.6... sometimes
            matches(
"{\n"+
"    genericPuzzleDescription = new PolytopePuzzleDescription(\"{4,3,3} 3\"),\n"+
"    genericPuzzleState = {3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7},\n"+
"    history = [],\n"+
"    undoPartSize = 0,\n"+
"}",
            "\\s*\\{\\s*genericPuzzleDescription\\s*=\\s*([^\n,]+),(.|\r|\n)*"
            );
        }
        if (true)
        {
            // XXX gives a stack overflow in 1.6... sometimes
            matches(
"{\n"+
"    genericPuzzleDescription = new PolytopePuzzleDescription(\"{5,3}x{} 3\"),\n"+
"    genericPuzzleState = {12,13,12,13,12,12,13,13,12,12,13,13,12,12,12,12,12,12,12,13,13,13,13,13,13,13,12,12,12,12,12,12,12,13,13,13,13,13,13,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11},\n"+
"    history = { (you are here) }}",
"\\s*\\{\\s*genericPuzzleDescription\\s*=\\s*([^\n]+)\\s*,\\s*\n\\s*genericPuzzleState\\s*=\\s*([^\n]+)\\s*,\\s*\n\\s*history\\s*=\\s*([^\n]+)\\s*\\}\\s*");
        }
        if (true)
        {
            // Yeah, this is enough to do it...
            // needed to re-implement using a real stack instead
            // of the recursion stack.
            // With the resursive algorithm,
            // 10,000 or 20,000 was stack overflowing on all vms (1.6 got worse)...
            // but with non-recursive implementation, can handle 1000 times that much:
            // 30,000,000, maybe bigger with bigger machine
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < 10*1000*1000; ++i)
                sb.append('a');
            String input = sb.toString();
            sb = null;
            System.out.println("Trying to match input of length "+input.length());
            PRINT(matches(input, ".*"));
        }

        if (true)
        {
            // Oh hell, but then the non-recursive implementation takes forever
            // when trying to split the grand antiprism input string
            // (1646 lines of reasonable length, split by "\\s*\n\\s*".
            // This should be almost instantaneous.
            // Okay it is now that I moved the stack ownership
            // into the caller.
            StringBuffer sb = new StringBuffer();
            FORI (i, 1000)
            {
                FORI (j, 80)
                {
                    sb.append('a');
                }
                sb.append('\n');
            }
            String input = sb.toString();
            sb = null;
            System.out.println("Trying to split input of length "+input.length());
            String result[] = split(input, "\\s*\n\\s*");
            System.out.println("    result = "+result.length+" pieces");
        }

        System.out.println("All good!");
    } // main

} // class regex
